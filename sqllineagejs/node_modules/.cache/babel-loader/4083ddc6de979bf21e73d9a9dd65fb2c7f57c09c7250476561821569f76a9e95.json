{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../common/core/range.js';\nimport { isUpperAsciiLetter, isLowerAsciiLetter } from '../../../base/common/strings.js';\nexport class WordSelectionRangeProvider {\n  provideSelectionRanges(model, positions) {\n    const result = [];\n    for (const position of positions) {\n      const bucket = [];\n      result.push(bucket);\n      this._addInWordRanges(bucket, model, position);\n      this._addWordRanges(bucket, model, position);\n      this._addWhitespaceLine(bucket, model, position);\n      bucket.push({\n        range: model.getFullModelRange()\n      });\n    }\n    return result;\n  }\n  _addInWordRanges(bucket, model, pos) {\n    const obj = model.getWordAtPosition(pos);\n    if (!obj) {\n      return;\n    }\n    let {\n      word,\n      startColumn\n    } = obj;\n    let offset = pos.column - startColumn;\n    let start = offset;\n    let end = offset;\n    let lastCh = 0;\n    // LEFT anchor (start)\n    for (; start >= 0; start--) {\n      let ch = word.charCodeAt(start);\n      if (start !== offset && (ch === 95 /* Underline */ || ch === 45 /* Dash */)) {\n        // foo-bar OR foo_bar\n        break;\n      } else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {\n        // fooBar\n        break;\n      }\n      lastCh = ch;\n    }\n    start += 1;\n    // RIGHT anchor (end)\n    for (; end < word.length; end++) {\n      let ch = word.charCodeAt(end);\n      if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {\n        // fooBar\n        break;\n      } else if (ch === 95 /* Underline */ || ch === 45 /* Dash */) {\n        // foo-bar OR foo_bar\n        break;\n      }\n      lastCh = ch;\n    }\n    if (start < end) {\n      bucket.push({\n        range: new Range(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end)\n      });\n    }\n  }\n  _addWordRanges(bucket, model, pos) {\n    const word = model.getWordAtPosition(pos);\n    if (word) {\n      bucket.push({\n        range: new Range(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn)\n      });\n    }\n  }\n  _addWhitespaceLine(bucket, model, pos) {\n    if (model.getLineLength(pos.lineNumber) > 0 && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0 && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {\n      bucket.push({\n        range: new Range(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber))\n      });\n    }\n  }\n}","map":{"version":3,"names":["Range","isUpperAsciiLetter","isLowerAsciiLetter","WordSelectionRangeProvider","provideSelectionRanges","model","positions","result","position","bucket","push","_addInWordRanges","_addWordRanges","_addWhitespaceLine","range","getFullModelRange","pos","obj","getWordAtPosition","word","startColumn","offset","column","start","end","lastCh","ch","charCodeAt","length","lineNumber","endColumn","getLineLength","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","getLineMaxColumn"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/wordSelections.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Range } from '../../common/core/range.js';\r\nimport { isUpperAsciiLetter, isLowerAsciiLetter } from '../../../base/common/strings.js';\r\nexport class WordSelectionRangeProvider {\r\n    provideSelectionRanges(model, positions) {\r\n        const result = [];\r\n        for (const position of positions) {\r\n            const bucket = [];\r\n            result.push(bucket);\r\n            this._addInWordRanges(bucket, model, position);\r\n            this._addWordRanges(bucket, model, position);\r\n            this._addWhitespaceLine(bucket, model, position);\r\n            bucket.push({ range: model.getFullModelRange() });\r\n        }\r\n        return result;\r\n    }\r\n    _addInWordRanges(bucket, model, pos) {\r\n        const obj = model.getWordAtPosition(pos);\r\n        if (!obj) {\r\n            return;\r\n        }\r\n        let { word, startColumn } = obj;\r\n        let offset = pos.column - startColumn;\r\n        let start = offset;\r\n        let end = offset;\r\n        let lastCh = 0;\r\n        // LEFT anchor (start)\r\n        for (; start >= 0; start--) {\r\n            let ch = word.charCodeAt(start);\r\n            if ((start !== offset) && (ch === 95 /* Underline */ || ch === 45 /* Dash */)) {\r\n                // foo-bar OR foo_bar\r\n                break;\r\n            }\r\n            else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {\r\n                // fooBar\r\n                break;\r\n            }\r\n            lastCh = ch;\r\n        }\r\n        start += 1;\r\n        // RIGHT anchor (end)\r\n        for (; end < word.length; end++) {\r\n            let ch = word.charCodeAt(end);\r\n            if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {\r\n                // fooBar\r\n                break;\r\n            }\r\n            else if (ch === 95 /* Underline */ || ch === 45 /* Dash */) {\r\n                // foo-bar OR foo_bar\r\n                break;\r\n            }\r\n            lastCh = ch;\r\n        }\r\n        if (start < end) {\r\n            bucket.push({ range: new Range(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end) });\r\n        }\r\n    }\r\n    _addWordRanges(bucket, model, pos) {\r\n        const word = model.getWordAtPosition(pos);\r\n        if (word) {\r\n            bucket.push({ range: new Range(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn) });\r\n        }\r\n    }\r\n    _addWhitespaceLine(bucket, model, pos) {\r\n        if (model.getLineLength(pos.lineNumber) > 0\r\n            && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0\r\n            && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {\r\n            bucket.push({ range: new Range(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber)) });\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}