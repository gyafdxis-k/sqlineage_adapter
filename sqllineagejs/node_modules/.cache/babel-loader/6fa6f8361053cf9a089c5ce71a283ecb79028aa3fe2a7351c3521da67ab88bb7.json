{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport const MAX_FOLDING_REGIONS = 0xFFFF;\nexport const MAX_LINE_NUMBER = 0xFFFFFF;\nconst MASK_INDENT = 0xFF000000;\nexport class FoldingRegions {\n  constructor(startIndexes, endIndexes, types) {\n    if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {\n      throw new Error('invalid startIndexes or endIndexes size');\n    }\n    this._startIndexes = startIndexes;\n    this._endIndexes = endIndexes;\n    this._collapseStates = new Uint32Array(Math.ceil(startIndexes.length / 32));\n    this._types = types;\n    this._parentsComputed = false;\n  }\n  ensureParentIndices() {\n    if (!this._parentsComputed) {\n      this._parentsComputed = true;\n      let parentIndexes = [];\n      let isInsideLast = (startLineNumber, endLineNumber) => {\n        let index = parentIndexes[parentIndexes.length - 1];\n        return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;\n      };\n      for (let i = 0, len = this._startIndexes.length; i < len; i++) {\n        let startLineNumber = this._startIndexes[i];\n        let endLineNumber = this._endIndexes[i];\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n          throw new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);\n        }\n        while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n          parentIndexes.pop();\n        }\n        let parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\n        parentIndexes.push(i);\n        this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n        this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n      }\n    }\n  }\n  get length() {\n    return this._startIndexes.length;\n  }\n  getStartLineNumber(index) {\n    return this._startIndexes[index] & MAX_LINE_NUMBER;\n  }\n  getEndLineNumber(index) {\n    return this._endIndexes[index] & MAX_LINE_NUMBER;\n  }\n  getType(index) {\n    return this._types ? this._types[index] : undefined;\n  }\n  hasTypes() {\n    return !!this._types;\n  }\n  isCollapsed(index) {\n    let arrayIndex = index / 32 | 0;\n    let bit = index % 32;\n    return (this._collapseStates[arrayIndex] & 1 << bit) !== 0;\n  }\n  setCollapsed(index, newState) {\n    let arrayIndex = index / 32 | 0;\n    let bit = index % 32;\n    let value = this._collapseStates[arrayIndex];\n    if (newState) {\n      this._collapseStates[arrayIndex] = value | 1 << bit;\n    } else {\n      this._collapseStates[arrayIndex] = value & ~(1 << bit);\n    }\n  }\n  toRegion(index) {\n    return new FoldingRegion(this, index);\n  }\n  getParentIndex(index) {\n    this.ensureParentIndices();\n    let parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n    if (parent === MAX_FOLDING_REGIONS) {\n      return -1;\n    }\n    return parent;\n  }\n  contains(index, line) {\n    return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n  }\n  findIndex(line) {\n    let low = 0,\n      high = this._startIndexes.length;\n    if (high === 0) {\n      return -1; // no children\n    }\n\n    while (low < high) {\n      let mid = Math.floor((low + high) / 2);\n      if (line < this.getStartLineNumber(mid)) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    return low - 1;\n  }\n  findRange(line) {\n    let index = this.findIndex(line);\n    if (index >= 0) {\n      let endLineNumber = this.getEndLineNumber(index);\n      if (endLineNumber >= line) {\n        return index;\n      }\n      index = this.getParentIndex(index);\n      while (index !== -1) {\n        if (this.contains(index, line)) {\n          return index;\n        }\n        index = this.getParentIndex(index);\n      }\n    }\n    return -1;\n  }\n  toString() {\n    let res = [];\n    for (let i = 0; i < this.length; i++) {\n      res[i] = \"[\".concat(this.isCollapsed(i) ? '+' : '-', \"] \").concat(this.getStartLineNumber(i), \"/\").concat(this.getEndLineNumber(i));\n    }\n    return res.join(', ');\n  }\n}\nexport class FoldingRegion {\n  constructor(ranges, index) {\n    this.ranges = ranges;\n    this.index = index;\n  }\n  get startLineNumber() {\n    return this.ranges.getStartLineNumber(this.index);\n  }\n  get endLineNumber() {\n    return this.ranges.getEndLineNumber(this.index);\n  }\n  get regionIndex() {\n    return this.index;\n  }\n  get parentIndex() {\n    return this.ranges.getParentIndex(this.index);\n  }\n  get isCollapsed() {\n    return this.ranges.isCollapsed(this.index);\n  }\n  containedBy(range) {\n    return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n  }\n  containsLine(lineNumber) {\n    return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n  }\n}","map":{"version":3,"names":["MAX_FOLDING_REGIONS","MAX_LINE_NUMBER","MASK_INDENT","FoldingRegions","constructor","startIndexes","endIndexes","types","length","Error","_startIndexes","_endIndexes","_collapseStates","Uint32Array","Math","ceil","_types","_parentsComputed","ensureParentIndices","parentIndexes","isInsideLast","startLineNumber","endLineNumber","index","getStartLineNumber","getEndLineNumber","i","len","pop","parentIndex","push","getType","undefined","hasTypes","isCollapsed","arrayIndex","bit","setCollapsed","newState","value","toRegion","FoldingRegion","getParentIndex","parent","contains","line","findIndex","low","high","mid","floor","findRange","toString","res","concat","join","ranges","regionIndex","containedBy","range","containsLine","lineNumber"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingRanges.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport const MAX_FOLDING_REGIONS = 0xFFFF;\r\nexport const MAX_LINE_NUMBER = 0xFFFFFF;\r\nconst MASK_INDENT = 0xFF000000;\r\nexport class FoldingRegions {\r\n    constructor(startIndexes, endIndexes, types) {\r\n        if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {\r\n            throw new Error('invalid startIndexes or endIndexes size');\r\n        }\r\n        this._startIndexes = startIndexes;\r\n        this._endIndexes = endIndexes;\r\n        this._collapseStates = new Uint32Array(Math.ceil(startIndexes.length / 32));\r\n        this._types = types;\r\n        this._parentsComputed = false;\r\n    }\r\n    ensureParentIndices() {\r\n        if (!this._parentsComputed) {\r\n            this._parentsComputed = true;\r\n            let parentIndexes = [];\r\n            let isInsideLast = (startLineNumber, endLineNumber) => {\r\n                let index = parentIndexes[parentIndexes.length - 1];\r\n                return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;\r\n            };\r\n            for (let i = 0, len = this._startIndexes.length; i < len; i++) {\r\n                let startLineNumber = this._startIndexes[i];\r\n                let endLineNumber = this._endIndexes[i];\r\n                if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\r\n                    throw new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);\r\n                }\r\n                while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\r\n                    parentIndexes.pop();\r\n                }\r\n                let parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\r\n                parentIndexes.push(i);\r\n                this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\r\n                this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\r\n            }\r\n        }\r\n    }\r\n    get length() {\r\n        return this._startIndexes.length;\r\n    }\r\n    getStartLineNumber(index) {\r\n        return this._startIndexes[index] & MAX_LINE_NUMBER;\r\n    }\r\n    getEndLineNumber(index) {\r\n        return this._endIndexes[index] & MAX_LINE_NUMBER;\r\n    }\r\n    getType(index) {\r\n        return this._types ? this._types[index] : undefined;\r\n    }\r\n    hasTypes() {\r\n        return !!this._types;\r\n    }\r\n    isCollapsed(index) {\r\n        let arrayIndex = (index / 32) | 0;\r\n        let bit = index % 32;\r\n        return (this._collapseStates[arrayIndex] & (1 << bit)) !== 0;\r\n    }\r\n    setCollapsed(index, newState) {\r\n        let arrayIndex = (index / 32) | 0;\r\n        let bit = index % 32;\r\n        let value = this._collapseStates[arrayIndex];\r\n        if (newState) {\r\n            this._collapseStates[arrayIndex] = value | (1 << bit);\r\n        }\r\n        else {\r\n            this._collapseStates[arrayIndex] = value & ~(1 << bit);\r\n        }\r\n    }\r\n    toRegion(index) {\r\n        return new FoldingRegion(this, index);\r\n    }\r\n    getParentIndex(index) {\r\n        this.ensureParentIndices();\r\n        let parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\r\n        if (parent === MAX_FOLDING_REGIONS) {\r\n            return -1;\r\n        }\r\n        return parent;\r\n    }\r\n    contains(index, line) {\r\n        return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\r\n    }\r\n    findIndex(line) {\r\n        let low = 0, high = this._startIndexes.length;\r\n        if (high === 0) {\r\n            return -1; // no children\r\n        }\r\n        while (low < high) {\r\n            let mid = Math.floor((low + high) / 2);\r\n            if (line < this.getStartLineNumber(mid)) {\r\n                high = mid;\r\n            }\r\n            else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        return low - 1;\r\n    }\r\n    findRange(line) {\r\n        let index = this.findIndex(line);\r\n        if (index >= 0) {\r\n            let endLineNumber = this.getEndLineNumber(index);\r\n            if (endLineNumber >= line) {\r\n                return index;\r\n            }\r\n            index = this.getParentIndex(index);\r\n            while (index !== -1) {\r\n                if (this.contains(index, line)) {\r\n                    return index;\r\n                }\r\n                index = this.getParentIndex(index);\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    toString() {\r\n        let res = [];\r\n        for (let i = 0; i < this.length; i++) {\r\n            res[i] = `[${this.isCollapsed(i) ? '+' : '-'}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;\r\n        }\r\n        return res.join(', ');\r\n    }\r\n}\r\nexport class FoldingRegion {\r\n    constructor(ranges, index) {\r\n        this.ranges = ranges;\r\n        this.index = index;\r\n    }\r\n    get startLineNumber() {\r\n        return this.ranges.getStartLineNumber(this.index);\r\n    }\r\n    get endLineNumber() {\r\n        return this.ranges.getEndLineNumber(this.index);\r\n    }\r\n    get regionIndex() {\r\n        return this.index;\r\n    }\r\n    get parentIndex() {\r\n        return this.ranges.getParentIndex(this.index);\r\n    }\r\n    get isCollapsed() {\r\n        return this.ranges.isCollapsed(this.index);\r\n    }\r\n    containedBy(range) {\r\n        return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\r\n    }\r\n    containsLine(lineNumber) {\r\n        return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}