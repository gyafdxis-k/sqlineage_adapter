{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TokenMetadata } from '../modes.js';\nexport function countEOL(text) {\n  let eolCount = 0;\n  let firstLineLength = 0;\n  let lastLineStart = 0;\n  let eol = 0 /* Unknown */;\n  for (let i = 0, len = text.length; i < len; i++) {\n    const chr = text.charCodeAt(i);\n    if (chr === 13 /* CarriageReturn */) {\n      if (eolCount === 0) {\n        firstLineLength = i;\n      }\n      eolCount++;\n      if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\n        // \\r\\n... case\n        eol |= 2 /* CRLF */;\n        i++; // skip \\n\n      } else {\n        // \\r... case\n        eol |= 3 /* Invalid */;\n      }\n\n      lastLineStart = i + 1;\n    } else if (chr === 10 /* LineFeed */) {\n      // \\n... case\n      eol |= 1 /* LF */;\n      if (eolCount === 0) {\n        firstLineLength = i;\n      }\n      eolCount++;\n      lastLineStart = i + 1;\n    }\n  }\n  if (eolCount === 0) {\n    firstLineLength = text.length;\n  }\n  return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n  return (topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */ | 0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */ | 0 /* None */ << 11 /* FONT_STYLE_OFFSET */ | 1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */ | 2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */) >>> 0;\n}\nconst EMPTY_LINE_TOKENS = new Uint32Array(0).buffer;\nexport class MultilineTokensBuilder {\n  constructor() {\n    this.tokens = [];\n  }\n  add(lineNumber, lineTokens) {\n    if (this.tokens.length > 0) {\n      const last = this.tokens[this.tokens.length - 1];\n      const lastLineNumber = last.startLineNumber + last.tokens.length - 1;\n      if (lastLineNumber + 1 === lineNumber) {\n        // append\n        last.tokens.push(lineTokens);\n        return;\n      }\n    }\n    this.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));\n  }\n}\nexport class SparseEncodedTokens {\n  constructor(tokens) {\n    this._tokens = tokens;\n    this._tokenCount = tokens.length / 4;\n  }\n  toString(startLineNumber) {\n    let pieces = [];\n    for (let i = 0; i < this._tokenCount; i++) {\n      pieces.push(\"(\".concat(this._getDeltaLine(i) + startLineNumber, \",\").concat(this._getStartCharacter(i), \"-\").concat(this._getEndCharacter(i), \")\"));\n    }\n    return \"[\".concat(pieces.join(','), \"]\");\n  }\n  getMaxDeltaLine() {\n    const tokenCount = this._getTokenCount();\n    if (tokenCount === 0) {\n      return -1;\n    }\n    return this._getDeltaLine(tokenCount - 1);\n  }\n  getRange() {\n    const tokenCount = this._getTokenCount();\n    if (tokenCount === 0) {\n      return null;\n    }\n    const startChar = this._getStartCharacter(0);\n    const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n    const endChar = this._getEndCharacter(tokenCount - 1);\n    return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n  }\n  _getTokenCount() {\n    return this._tokenCount;\n  }\n  _getDeltaLine(tokenIndex) {\n    return this._tokens[4 * tokenIndex];\n  }\n  _getStartCharacter(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 1];\n  }\n  _getEndCharacter(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 2];\n  }\n  isEmpty() {\n    return this._getTokenCount() === 0;\n  }\n  getLineTokens(deltaLine) {\n    let low = 0;\n    let high = this._getTokenCount() - 1;\n    while (low < high) {\n      const mid = low + Math.floor((high - low) / 2);\n      const midDeltaLine = this._getDeltaLine(mid);\n      if (midDeltaLine < deltaLine) {\n        low = mid + 1;\n      } else if (midDeltaLine > deltaLine) {\n        high = mid - 1;\n      } else {\n        let min = mid;\n        while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n          min--;\n        }\n        let max = mid;\n        while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n          max++;\n        }\n        return new LineTokens2(this._tokens.subarray(4 * min, 4 * max + 4));\n      }\n    }\n    if (this._getDeltaLine(low) === deltaLine) {\n      return new LineTokens2(this._tokens.subarray(4 * low, 4 * low + 4));\n    }\n    return null;\n  }\n  clear() {\n    this._tokenCount = 0;\n  }\n  removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n    const tokens = this._tokens;\n    const tokenCount = this._tokenCount;\n    let newTokenCount = 0;\n    let hasDeletedTokens = false;\n    let firstDeltaLine = 0;\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 4 * i;\n      const tokenDeltaLine = tokens[srcOffset];\n      const tokenStartCharacter = tokens[srcOffset + 1];\n      const tokenEndCharacter = tokens[srcOffset + 2];\n      const tokenMetadata = tokens[srcOffset + 3];\n      if ((tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) && (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar)) {\n        hasDeletedTokens = true;\n      } else {\n        if (newTokenCount === 0) {\n          firstDeltaLine = tokenDeltaLine;\n        }\n        if (hasDeletedTokens) {\n          // must move the token to the left\n          const destOffset = 4 * newTokenCount;\n          tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n          tokens[destOffset + 1] = tokenStartCharacter;\n          tokens[destOffset + 2] = tokenEndCharacter;\n          tokens[destOffset + 3] = tokenMetadata;\n        }\n        newTokenCount++;\n      }\n    }\n    this._tokenCount = newTokenCount;\n    return firstDeltaLine;\n  }\n  split(startDeltaLine, startChar, endDeltaLine, endChar) {\n    const tokens = this._tokens;\n    const tokenCount = this._tokenCount;\n    let aTokens = [];\n    let bTokens = [];\n    let destTokens = aTokens;\n    let destOffset = 0;\n    let destFirstDeltaLine = 0;\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 4 * i;\n      const tokenDeltaLine = tokens[srcOffset];\n      const tokenStartCharacter = tokens[srcOffset + 1];\n      const tokenEndCharacter = tokens[srcOffset + 2];\n      const tokenMetadata = tokens[srcOffset + 3];\n      if (tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) {\n        if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar) {\n          // this token is touching the range\n          continue;\n        } else {\n          // this token is after the range\n          if (destTokens !== bTokens) {\n            // this token is the first token after the range\n            destTokens = bTokens;\n            destOffset = 0;\n            destFirstDeltaLine = tokenDeltaLine;\n          }\n        }\n      }\n      destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n      destTokens[destOffset++] = tokenStartCharacter;\n      destTokens[destOffset++] = tokenEndCharacter;\n      destTokens[destOffset++] = tokenMetadata;\n    }\n    return [new SparseEncodedTokens(new Uint32Array(aTokens)), new SparseEncodedTokens(new Uint32Array(bTokens)), destFirstDeltaLine];\n  }\n  acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n    // This is a bit complex, here are the cases I used to think about this:\n    //\n    // 1. The token starts before the deletion range\n    // 1a. The token is completely before the deletion range\n    //               -----------\n    //                          xxxxxxxxxxx\n    // 1b. The token starts before, the deletion range ends after the token\n    //               -----------\n    //                      xxxxxxxxxxx\n    // 1c. The token starts before, the deletion range ends precisely with the token\n    //               ---------------\n    //                      xxxxxxxx\n    // 1d. The token starts before, the deletion range is inside the token\n    //               ---------------\n    //                    xxxxx\n    //\n    // 2. The token starts at the same position with the deletion range\n    // 2a. The token starts at the same position, and ends inside the deletion range\n    //               -------\n    //               xxxxxxxxxxx\n    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n    //               ----------\n    //               xxxxxxxxxx\n    // 2c. The token starts at the same position, and ends after the deletion range\n    //               -------------\n    //               xxxxxxx\n    //\n    // 3. The token starts inside the deletion range\n    // 3a. The token is inside the deletion range\n    //                -------\n    //             xxxxxxxxxxxxx\n    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n    //                ----------\n    //             xxxxxxxxxxxxx\n    // 3c. The token starts inside the deletion range, and ends after the deletion range\n    //                ------------\n    //             xxxxxxxxxxx\n    //\n    // 4. The token starts after the deletion range\n    //                  -----------\n    //          xxxxxxxx\n    //\n    const tokens = this._tokens;\n    const tokenCount = this._tokenCount;\n    const deletedLineCount = endDeltaLine - startDeltaLine;\n    let newTokenCount = 0;\n    let hasDeletedTokens = false;\n    for (let i = 0; i < tokenCount; i++) {\n      const srcOffset = 4 * i;\n      let tokenDeltaLine = tokens[srcOffset];\n      let tokenStartCharacter = tokens[srcOffset + 1];\n      let tokenEndCharacter = tokens[srcOffset + 2];\n      const tokenMetadata = tokens[srcOffset + 3];\n      if (tokenDeltaLine < startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter) {\n        // 1a. The token is completely before the deletion range\n        // => nothing to do\n        newTokenCount++;\n        continue;\n      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n        // 1b, 1c, 1d\n        // => the token survives, but it needs to shrink\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          // 1d. The token starts before, the deletion range is inside the token\n          // => the token shrinks by the deletion character count\n          tokenEndCharacter -= endCharacter - startCharacter;\n        } else {\n          // 1b. The token starts before, the deletion range ends after the token\n          // 1c. The token starts before, the deletion range ends precisely with the token\n          // => the token shrinks its ending to the deletion start\n          tokenEndCharacter = startCharacter;\n        }\n      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n        // 2a, 2b, 2c\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          // 2c. The token starts at the same position, and ends after the deletion range\n          // => the token shrinks by the deletion character count\n          tokenEndCharacter -= endCharacter - startCharacter;\n        } else {\n          // 2a. The token starts at the same position, and ends inside the deletion range\n          // 2b. The token starts at the same position, and ends at the same position as the deletion range\n          // => the token is deleted\n          hasDeletedTokens = true;\n          continue;\n        }\n      } else if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter) {\n        // 3a, 3b, 3c\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          // 3c. The token starts inside the deletion range, and ends after the deletion range\n          // => the token moves left and shrinks\n          if (tokenDeltaLine === startDeltaLine) {\n            // the deletion started on the same line as the token\n            // => the token moves left and shrinks\n            tokenStartCharacter = startCharacter;\n            tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n          } else {\n            // the deletion started on a line above the token\n            // => the token moves to the beginning of the line\n            tokenStartCharacter = 0;\n            tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n          }\n        } else {\n          // 3a. The token is inside the deletion range\n          // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n          // => the token is deleted\n          hasDeletedTokens = true;\n          continue;\n        }\n      } else if (tokenDeltaLine > endDeltaLine) {\n        // 4. (partial) The token starts after the deletion range, on a line below...\n        if (deletedLineCount === 0 && !hasDeletedTokens) {\n          // early stop, there is no need to walk all the tokens and do nothing...\n          newTokenCount = tokenCount;\n          break;\n        }\n        tokenDeltaLine -= deletedLineCount;\n      } else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n        // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n        if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n          tokenStartCharacter += horizontalShiftForFirstLineTokens;\n          tokenEndCharacter += horizontalShiftForFirstLineTokens;\n        }\n        tokenDeltaLine -= deletedLineCount;\n        tokenStartCharacter -= endCharacter - startCharacter;\n        tokenEndCharacter -= endCharacter - startCharacter;\n      } else {\n        throw new Error(\"Not possible!\");\n      }\n      const destOffset = 4 * newTokenCount;\n      tokens[destOffset] = tokenDeltaLine;\n      tokens[destOffset + 1] = tokenStartCharacter;\n      tokens[destOffset + 2] = tokenEndCharacter;\n      tokens[destOffset + 3] = tokenMetadata;\n      newTokenCount++;\n    }\n    this._tokenCount = newTokenCount;\n  }\n  acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    // Here are the cases I used to think about this:\n    //\n    // 1. The token is completely before the insertion point\n    //            -----------   |\n    // 2. The token ends precisely at the insertion point\n    //            -----------|\n    // 3. The token contains the insertion point\n    //            -----|------\n    // 4. The token starts precisely at the insertion point\n    //            |-----------\n    // 5. The token is completely after the insertion point\n    //            |   -----------\n    //\n    const isInsertingPreciselyOneWordCharacter = eolCount === 0 && firstLineLength === 1 && (firstCharCode >= 48 /* Digit0 */ && firstCharCode <= 57 /* Digit9 */ || firstCharCode >= 65 /* A */ && firstCharCode <= 90 /* Z */ || firstCharCode >= 97 /* a */ && firstCharCode <= 122 /* z */);\n    const tokens = this._tokens;\n    const tokenCount = this._tokenCount;\n    for (let i = 0; i < tokenCount; i++) {\n      const offset = 4 * i;\n      let tokenDeltaLine = tokens[offset];\n      let tokenStartCharacter = tokens[offset + 1];\n      let tokenEndCharacter = tokens[offset + 2];\n      if (tokenDeltaLine < deltaLine || tokenDeltaLine === deltaLine && tokenEndCharacter < character) {\n        // 1. The token is completely before the insertion point\n        // => nothing to do\n        continue;\n      } else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n        // 2. The token ends precisely at the insertion point\n        // => expand the end character only if inserting precisely one character that is a word character\n        if (isInsertingPreciselyOneWordCharacter) {\n          tokenEndCharacter += 1;\n        } else {\n          continue;\n        }\n      } else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n        // 3. The token contains the insertion point\n        if (eolCount === 0) {\n          // => just expand the end character\n          tokenEndCharacter += firstLineLength;\n        } else {\n          // => cut off the token\n          tokenEndCharacter = character;\n        }\n      } else {\n        // 4. or 5.\n        if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n          // 4. The token starts precisely at the insertion point\n          // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n          // => otherwise behave as in case 5.\n          if (isInsertingPreciselyOneWordCharacter) {\n            continue;\n          }\n        }\n        // => the token must move and keep its size constant\n        if (tokenDeltaLine === deltaLine) {\n          tokenDeltaLine += eolCount;\n          // this token is on the line where the insertion is taking place\n          if (eolCount === 0) {\n            tokenStartCharacter += firstLineLength;\n            tokenEndCharacter += firstLineLength;\n          } else {\n            const tokenLength = tokenEndCharacter - tokenStartCharacter;\n            tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n            tokenEndCharacter = tokenStartCharacter + tokenLength;\n          }\n        } else {\n          tokenDeltaLine += eolCount;\n        }\n      }\n      tokens[offset] = tokenDeltaLine;\n      tokens[offset + 1] = tokenStartCharacter;\n      tokens[offset + 2] = tokenEndCharacter;\n    }\n  }\n}\nexport class LineTokens2 {\n  constructor(tokens) {\n    this._tokens = tokens;\n  }\n  getCount() {\n    return this._tokens.length / 4;\n  }\n  getStartCharacter(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 1];\n  }\n  getEndCharacter(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 2];\n  }\n  getMetadata(tokenIndex) {\n    return this._tokens[4 * tokenIndex + 3];\n  }\n}\nexport class MultilineTokens2 {\n  constructor(startLineNumber, tokens) {\n    this.startLineNumber = startLineNumber;\n    this.tokens = tokens;\n    this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\n  }\n  toString() {\n    return this.tokens.toString(this.startLineNumber);\n  }\n  _updateEndLineNumber() {\n    this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\n  }\n  isEmpty() {\n    return this.tokens.isEmpty();\n  }\n  getLineTokens(lineNumber) {\n    if (this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber) {\n      return this.tokens.getLineTokens(lineNumber - this.startLineNumber);\n    }\n    return null;\n  }\n  getRange() {\n    const deltaRange = this.tokens.getRange();\n    if (!deltaRange) {\n      return deltaRange;\n    }\n    return new Range(this.startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this.startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n  }\n  removeTokens(range) {\n    const startLineIndex = range.startLineNumber - this.startLineNumber;\n    const endLineIndex = range.endLineNumber - this.startLineNumber;\n    this.startLineNumber += this.tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n    this._updateEndLineNumber();\n  }\n  split(range) {\n    // split tokens to two:\n    // a) all the tokens before `range`\n    // b) all the tokens after `range`\n    const startLineIndex = range.startLineNumber - this.startLineNumber;\n    const endLineIndex = range.endLineNumber - this.startLineNumber;\n    const [a, b, bDeltaLine] = this.tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n    return [new MultilineTokens2(this.startLineNumber, a), new MultilineTokens2(this.startLineNumber + bDeltaLine, b)];\n  }\n  applyEdit(range, text) {\n    const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n    this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* Null */);\n  }\n\n  acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    this._acceptDeleteRange(range);\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n    this._updateEndLineNumber();\n  }\n  _acceptDeleteRange(range) {\n    if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n      // Nothing to delete\n      return;\n    }\n    const firstLineIndex = range.startLineNumber - this.startLineNumber;\n    const lastLineIndex = range.endLineNumber - this.startLineNumber;\n    if (lastLineIndex < 0) {\n      // this deletion occurs entirely before this block, so we only need to adjust line numbers\n      const deletedLinesCount = lastLineIndex - firstLineIndex;\n      this.startLineNumber -= deletedLinesCount;\n      return;\n    }\n    const tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\n    if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n      // this deletion occurs entirely after this block, so there is nothing to do\n      return;\n    }\n    if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n      // this deletion completely encompasses this block\n      this.startLineNumber = 0;\n      this.tokens.clear();\n      return;\n    }\n    if (firstLineIndex < 0) {\n      const deletedBefore = -firstLineIndex;\n      this.startLineNumber -= deletedBefore;\n      this.tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n    } else {\n      this.tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n    }\n  }\n  _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    if (eolCount === 0 && firstLineLength === 0) {\n      // Nothing to insert\n      return;\n    }\n    const lineIndex = position.lineNumber - this.startLineNumber;\n    if (lineIndex < 0) {\n      // this insertion occurs before this block, so we only need to adjust line numbers\n      this.startLineNumber += eolCount;\n      return;\n    }\n    const tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\n    if (lineIndex >= tokenMaxDeltaLine + 1) {\n      // this insertion occurs after this block, so there is nothing to do\n      return;\n    }\n    this.tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n  }\n}\nexport class MultilineTokens {\n  constructor(startLineNumber, tokens) {\n    this.startLineNumber = startLineNumber;\n    this.tokens = tokens;\n  }\n}\nfunction toUint32Array(arr) {\n  if (arr instanceof Uint32Array) {\n    return arr;\n  } else {\n    return new Uint32Array(arr);\n  }\n}\nexport class TokensStore2 {\n  constructor() {\n    this._pieces = [];\n    this._isComplete = false;\n  }\n  flush() {\n    this._pieces = [];\n    this._isComplete = false;\n  }\n  isEmpty() {\n    return this._pieces.length === 0;\n  }\n  set(pieces, isComplete) {\n    this._pieces = pieces || [];\n    this._isComplete = isComplete;\n  }\n  setPartial(_range, pieces) {\n    // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n    let range = _range;\n    if (pieces.length > 0) {\n      const _firstRange = pieces[0].getRange();\n      const _lastRange = pieces[pieces.length - 1].getRange();\n      if (!_firstRange || !_lastRange) {\n        return _range;\n      }\n      range = _range.plusRange(_firstRange).plusRange(_lastRange);\n    }\n    let insertPosition = null;\n    for (let i = 0, len = this._pieces.length; i < len; i++) {\n      const piece = this._pieces[i];\n      if (piece.endLineNumber < range.startLineNumber) {\n        // this piece is before the range\n        continue;\n      }\n      if (piece.startLineNumber > range.endLineNumber) {\n        // this piece is after the range, so mark the spot before this piece\n        // as a good insertion position and stop looping\n        insertPosition = insertPosition || {\n          index: i\n        };\n        break;\n      }\n      // this piece might intersect with the range\n      piece.removeTokens(range);\n      if (piece.isEmpty()) {\n        // remove the piece if it became empty\n        this._pieces.splice(i, 1);\n        i--;\n        len--;\n        continue;\n      }\n      if (piece.endLineNumber < range.startLineNumber) {\n        // after removal, this piece is before the range\n        continue;\n      }\n      if (piece.startLineNumber > range.endLineNumber) {\n        // after removal, this piece is after the range\n        insertPosition = insertPosition || {\n          index: i\n        };\n        continue;\n      }\n      // after removal, this piece contains the range\n      const [a, b] = piece.split(range);\n      if (a.isEmpty()) {\n        // this piece is actually after the range\n        insertPosition = insertPosition || {\n          index: i\n        };\n        continue;\n      }\n      if (b.isEmpty()) {\n        // this piece is actually before the range\n        continue;\n      }\n      this._pieces.splice(i, 1, a, b);\n      i++;\n      len++;\n      insertPosition = insertPosition || {\n        index: i\n      };\n    }\n    insertPosition = insertPosition || {\n      index: this._pieces.length\n    };\n    if (pieces.length > 0) {\n      this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n    }\n    // console.log(`I HAVE ${this._pieces.length} pieces`);\n    // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n    return range;\n  }\n  isComplete() {\n    return this._isComplete;\n  }\n  addSemanticTokens(lineNumber, aTokens) {\n    const pieces = this._pieces;\n    if (pieces.length === 0) {\n      return aTokens;\n    }\n    const pieceIndex = TokensStore2._findFirstPieceWithLine(pieces, lineNumber);\n    const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n    if (!bTokens) {\n      return aTokens;\n    }\n    const aLen = aTokens.getCount();\n    const bLen = bTokens.getCount();\n    let aIndex = 0;\n    let result = [],\n      resultLen = 0;\n    let lastEndOffset = 0;\n    const emitToken = (endOffset, metadata) => {\n      if (endOffset === lastEndOffset) {\n        return;\n      }\n      lastEndOffset = endOffset;\n      result[resultLen++] = endOffset;\n      result[resultLen++] = metadata;\n    };\n    for (let bIndex = 0; bIndex < bLen; bIndex++) {\n      const bStartCharacter = bTokens.getStartCharacter(bIndex);\n      const bEndCharacter = bTokens.getEndCharacter(bIndex);\n      const bMetadata = bTokens.getMetadata(bIndex);\n      const bMask = ((bMetadata & 1 /* SEMANTIC_USE_ITALIC */ ? 2048 /* ITALIC_MASK */ : 0) | (bMetadata & 2 /* SEMANTIC_USE_BOLD */ ? 4096 /* BOLD_MASK */ : 0) | (bMetadata & 4 /* SEMANTIC_USE_UNDERLINE */ ? 8192 /* UNDERLINE_MASK */ : 0) | (bMetadata & 8 /* SEMANTIC_USE_FOREGROUND */ ? 8372224 /* FOREGROUND_MASK */ : 0) | (bMetadata & 16 /* SEMANTIC_USE_BACKGROUND */ ? 4286578688 /* BACKGROUND_MASK */ : 0)) >>> 0;\n      const aMask = ~bMask >>> 0;\n      // push any token from `a` that is before `b`\n      while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n        emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n        aIndex++;\n      }\n      // push the token from `a` if it intersects the token from `b`\n      if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n        emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n      }\n      // skip any tokens from `a` that are contained inside `b`\n      while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n        emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);\n        aIndex++;\n      }\n      if (aIndex < aLen) {\n        emitToken(bEndCharacter, aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);\n        if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n          // `a` ends exactly at the same spot as `b`!\n          aIndex++;\n        }\n      } else {\n        const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n        // push the token from `b`\n        emitToken(bEndCharacter, aTokens.getMetadata(aMergeIndex) & aMask | bMetadata & bMask);\n      }\n    }\n    // push the remaining tokens from `a`\n    while (aIndex < aLen) {\n      emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n      aIndex++;\n    }\n    return new LineTokens(new Uint32Array(result), aTokens.getLineContent());\n  }\n  static _findFirstPieceWithLine(pieces, lineNumber) {\n    let low = 0;\n    let high = pieces.length - 1;\n    while (low < high) {\n      let mid = low + Math.floor((high - low) / 2);\n      if (pieces[mid].endLineNumber < lineNumber) {\n        low = mid + 1;\n      } else if (pieces[mid].startLineNumber > lineNumber) {\n        high = mid - 1;\n      } else {\n        while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n          mid--;\n        }\n        return mid;\n      }\n    }\n    return low;\n  }\n  //#region Editing\n  acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    for (const piece of this._pieces) {\n      piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n  }\n}\nexport class TokensStore {\n  constructor() {\n    this._lineTokens = [];\n    this._len = 0;\n  }\n  flush() {\n    this._lineTokens = [];\n    this._len = 0;\n  }\n  getTokens(topLevelLanguageId, lineIndex, lineText) {\n    let rawLineTokens = null;\n    if (lineIndex < this._len) {\n      rawLineTokens = this._lineTokens[lineIndex];\n    }\n    if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n      return new LineTokens(toUint32Array(rawLineTokens), lineText);\n    }\n    let lineTokens = new Uint32Array(2);\n    lineTokens[0] = lineText.length;\n    lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\n    return new LineTokens(lineTokens, lineText);\n  }\n  static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n    const tokens = _tokens ? toUint32Array(_tokens) : null;\n    if (lineTextLength === 0) {\n      let hasDifferentLanguageId = false;\n      if (tokens && tokens.length > 1) {\n        hasDifferentLanguageId = TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId;\n      }\n      if (!hasDifferentLanguageId) {\n        return EMPTY_LINE_TOKENS;\n      }\n    }\n    if (!tokens || tokens.length === 0) {\n      const tokens = new Uint32Array(2);\n      tokens[0] = lineTextLength;\n      tokens[1] = getDefaultMetadata(topLevelLanguageId);\n      return tokens.buffer;\n    }\n    // Ensure the last token covers the end of the text\n    tokens[tokens.length - 2] = lineTextLength;\n    if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n      // Store directly the ArrayBuffer pointer to save an object\n      return tokens.buffer;\n    }\n    return tokens;\n  }\n  _ensureLine(lineIndex) {\n    while (lineIndex >= this._len) {\n      this._lineTokens[this._len] = null;\n      this._len++;\n    }\n  }\n  _deleteLines(start, deleteCount) {\n    if (deleteCount === 0) {\n      return;\n    }\n    if (start + deleteCount > this._len) {\n      deleteCount = this._len - start;\n    }\n    this._lineTokens.splice(start, deleteCount);\n    this._len -= deleteCount;\n  }\n  _insertLines(insertIndex, insertCount) {\n    if (insertCount === 0) {\n      return;\n    }\n    let lineTokens = [];\n    for (let i = 0; i < insertCount; i++) {\n      lineTokens[i] = null;\n    }\n    this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n    this._len += insertCount;\n  }\n  setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n    const tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);\n    this._ensureLine(lineIndex);\n    const oldTokens = this._lineTokens[lineIndex];\n    this._lineTokens[lineIndex] = tokens;\n    if (checkEquality) {\n      return !TokensStore._equals(oldTokens, tokens);\n    }\n    return false;\n  }\n  static _equals(_a, _b) {\n    if (!_a || !_b) {\n      return !_a && !_b;\n    }\n    const a = toUint32Array(_a);\n    const b = toUint32Array(_b);\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0, len = a.length; i < len; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  //#region Editing\n  acceptEdit(range, eolCount, firstLineLength) {\n    this._acceptDeleteRange(range);\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n  }\n  _acceptDeleteRange(range) {\n    const firstLineIndex = range.startLineNumber - 1;\n    if (firstLineIndex >= this._len) {\n      return;\n    }\n    if (range.startLineNumber === range.endLineNumber) {\n      if (range.startColumn === range.endColumn) {\n        // Nothing to delete\n        return;\n      }\n      this._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n      return;\n    }\n    this._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n    const lastLineIndex = range.endLineNumber - 1;\n    let lastLineTokens = null;\n    if (lastLineIndex < this._len) {\n      lastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n    }\n    // Take remaining text on last line and append it to remaining text on first line\n    this._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens);\n    // Delete middle lines\n    this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n  }\n  _acceptInsertText(position, eolCount, firstLineLength) {\n    if (eolCount === 0 && firstLineLength === 0) {\n      // Nothing to insert\n      return;\n    }\n    const lineIndex = position.lineNumber - 1;\n    if (lineIndex >= this._len) {\n      return;\n    }\n    if (eolCount === 0) {\n      // Inserting text on one line\n      this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n      return;\n    }\n    this._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n    this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n    this._insertLines(position.lineNumber, eolCount);\n  }\n  static _deleteBeginning(lineTokens, toChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n    return TokensStore._delete(lineTokens, 0, toChIndex);\n  }\n  static _deleteEnding(lineTokens, fromChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n    const tokens = toUint32Array(lineTokens);\n    const lineTextLength = tokens[tokens.length - 2];\n    return TokensStore._delete(lineTokens, fromChIndex, lineTextLength);\n  }\n  static _delete(lineTokens, fromChIndex, toChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n      return lineTokens;\n    }\n    const tokens = toUint32Array(lineTokens);\n    const tokensCount = tokens.length >>> 1;\n    // special case: deleting everything\n    if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n      return EMPTY_LINE_TOKENS;\n    }\n    const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n    const fromTokenStartOffset = fromTokenIndex > 0 ? tokens[fromTokenIndex - 1 << 1] : 0;\n    const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n    if (toChIndex < fromTokenEndOffset) {\n      // the delete range is inside a single token\n      const delta = toChIndex - fromChIndex;\n      for (let i = fromTokenIndex; i < tokensCount; i++) {\n        tokens[i << 1] -= delta;\n      }\n      return lineTokens;\n    }\n    let dest;\n    let lastEnd;\n    if (fromTokenStartOffset !== fromChIndex) {\n      tokens[fromTokenIndex << 1] = fromChIndex;\n      dest = fromTokenIndex + 1 << 1;\n      lastEnd = fromChIndex;\n    } else {\n      dest = fromTokenIndex << 1;\n      lastEnd = fromTokenStartOffset;\n    }\n    const delta = toChIndex - fromChIndex;\n    for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n      const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n      if (tokenEndOffset > lastEnd) {\n        tokens[dest++] = tokenEndOffset;\n        tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n        lastEnd = tokenEndOffset;\n      }\n    }\n    if (dest === tokens.length) {\n      // nothing to trim\n      return lineTokens;\n    }\n    let tmp = new Uint32Array(dest);\n    tmp.set(tokens.subarray(0, dest), 0);\n    return tmp.buffer;\n  }\n  static _append(lineTokens, _otherTokens) {\n    if (_otherTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n    if (lineTokens === EMPTY_LINE_TOKENS) {\n      return _otherTokens;\n    }\n    if (lineTokens === null) {\n      return lineTokens;\n    }\n    if (_otherTokens === null) {\n      // cannot determine combined line length...\n      return null;\n    }\n    const myTokens = toUint32Array(lineTokens);\n    const otherTokens = toUint32Array(_otherTokens);\n    const otherTokensCount = otherTokens.length >>> 1;\n    let result = new Uint32Array(myTokens.length + otherTokens.length);\n    result.set(myTokens, 0);\n    let dest = myTokens.length;\n    const delta = myTokens[myTokens.length - 2];\n    for (let i = 0; i < otherTokensCount; i++) {\n      result[dest++] = otherTokens[i << 1] + delta;\n      result[dest++] = otherTokens[(i << 1) + 1];\n    }\n    return result.buffer;\n  }\n  static _insert(lineTokens, chIndex, textLength) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      // nothing to do\n      return lineTokens;\n    }\n    const tokens = toUint32Array(lineTokens);\n    const tokensCount = tokens.length >>> 1;\n    let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n    if (fromTokenIndex > 0) {\n      const fromTokenStartOffset = tokens[fromTokenIndex - 1 << 1];\n      if (fromTokenStartOffset === chIndex) {\n        fromTokenIndex--;\n      }\n    }\n    for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n      tokens[tokenIndex << 1] += textLength;\n    }\n    return lineTokens;\n  }\n}","map":{"version":3,"names":["arrays","LineTokens","Position","Range","TokenMetadata","countEOL","text","eolCount","firstLineLength","lastLineStart","eol","i","len","length","chr","charCodeAt","getDefaultMetadata","topLevelLanguageId","EMPTY_LINE_TOKENS","Uint32Array","buffer","MultilineTokensBuilder","constructor","tokens","add","lineNumber","lineTokens","last","lastLineNumber","startLineNumber","push","MultilineTokens","SparseEncodedTokens","_tokens","_tokenCount","toString","pieces","concat","_getDeltaLine","_getStartCharacter","_getEndCharacter","join","getMaxDeltaLine","tokenCount","_getTokenCount","getRange","startChar","maxDeltaLine","endChar","tokenIndex","isEmpty","getLineTokens","deltaLine","low","high","mid","Math","floor","midDeltaLine","min","max","LineTokens2","subarray","clear","removeTokens","startDeltaLine","endDeltaLine","newTokenCount","hasDeletedTokens","firstDeltaLine","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","tokenMetadata","destOffset","split","aTokens","bTokens","destTokens","destFirstDeltaLine","acceptDeleteRange","horizontalShiftForFirstLineTokens","startCharacter","endCharacter","deletedLineCount","Error","acceptInsertText","character","lastLineLength","firstCharCode","isInsertingPreciselyOneWordCharacter","offset","tokenLength","getCount","getStartCharacter","getEndCharacter","getMetadata","MultilineTokens2","endLineNumber","_updateEndLineNumber","deltaRange","startColumn","endColumn","range","startLineIndex","endLineIndex","a","b","bDeltaLine","applyEdit","acceptEdit","_acceptDeleteRange","_acceptInsertText","firstLineIndex","lastLineIndex","deletedLinesCount","tokenMaxDeltaLine","deletedBefore","position","lineIndex","column","toUint32Array","arr","TokensStore2","_pieces","_isComplete","flush","set","isComplete","setPartial","_range","_firstRange","_lastRange","plusRange","insertPosition","piece","index","splice","arrayInsert","addSemanticTokens","pieceIndex","_findFirstPieceWithLine","aLen","bLen","aIndex","result","resultLen","lastEndOffset","emitToken","endOffset","metadata","bIndex","bStartCharacter","bEndCharacter","bMetadata","bMask","aMask","getEndOffset","getStartOffset","aMergeIndex","getLineContent","TokensStore","_lineTokens","_len","getTokens","lineText","rawLineTokens","_massageTokens","lineTextLength","hasDifferentLanguageId","getLanguageId","byteOffset","byteLength","_ensureLine","_deleteLines","start","deleteCount","_insertLines","insertIndex","insertCount","setTokens","checkEquality","oldTokens","_equals","_a","_b","_delete","_deleteEnding","lastLineTokens","_deleteBeginning","_append","_insert","toChIndex","fromChIndex","tokensCount","fromTokenIndex","findIndexInTokensArray","fromTokenStartOffset","fromTokenEndOffset","delta","dest","lastEnd","tokenEndOffset","tmp","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/model/tokensStore.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as arrays from '../../../base/common/arrays.js';\r\nimport { LineTokens } from '../core/lineTokens.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { TokenMetadata } from '../modes.js';\r\nexport function countEOL(text) {\r\n    let eolCount = 0;\r\n    let firstLineLength = 0;\r\n    let lastLineStart = 0;\r\n    let eol = 0 /* Unknown */;\r\n    for (let i = 0, len = text.length; i < len; i++) {\r\n        const chr = text.charCodeAt(i);\r\n        if (chr === 13 /* CarriageReturn */) {\r\n            if (eolCount === 0) {\r\n                firstLineLength = i;\r\n            }\r\n            eolCount++;\r\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                // \\r\\n... case\r\n                eol |= 2 /* CRLF */;\r\n                i++; // skip \\n\r\n            }\r\n            else {\r\n                // \\r... case\r\n                eol |= 3 /* Invalid */;\r\n            }\r\n            lastLineStart = i + 1;\r\n        }\r\n        else if (chr === 10 /* LineFeed */) {\r\n            // \\n... case\r\n            eol |= 1 /* LF */;\r\n            if (eolCount === 0) {\r\n                firstLineLength = i;\r\n            }\r\n            eolCount++;\r\n            lastLineStart = i + 1;\r\n        }\r\n    }\r\n    if (eolCount === 0) {\r\n        firstLineLength = text.length;\r\n    }\r\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\r\n}\r\nfunction getDefaultMetadata(topLevelLanguageId) {\r\n    return ((topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */)\r\n        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)\r\n        | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)\r\n        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\r\n        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\r\n}\r\nconst EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\r\nexport class MultilineTokensBuilder {\r\n    constructor() {\r\n        this.tokens = [];\r\n    }\r\n    add(lineNumber, lineTokens) {\r\n        if (this.tokens.length > 0) {\r\n            const last = this.tokens[this.tokens.length - 1];\r\n            const lastLineNumber = last.startLineNumber + last.tokens.length - 1;\r\n            if (lastLineNumber + 1 === lineNumber) {\r\n                // append\r\n                last.tokens.push(lineTokens);\r\n                return;\r\n            }\r\n        }\r\n        this.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));\r\n    }\r\n}\r\nexport class SparseEncodedTokens {\r\n    constructor(tokens) {\r\n        this._tokens = tokens;\r\n        this._tokenCount = tokens.length / 4;\r\n    }\r\n    toString(startLineNumber) {\r\n        let pieces = [];\r\n        for (let i = 0; i < this._tokenCount; i++) {\r\n            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\r\n        }\r\n        return `[${pieces.join(',')}]`;\r\n    }\r\n    getMaxDeltaLine() {\r\n        const tokenCount = this._getTokenCount();\r\n        if (tokenCount === 0) {\r\n            return -1;\r\n        }\r\n        return this._getDeltaLine(tokenCount - 1);\r\n    }\r\n    getRange() {\r\n        const tokenCount = this._getTokenCount();\r\n        if (tokenCount === 0) {\r\n            return null;\r\n        }\r\n        const startChar = this._getStartCharacter(0);\r\n        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\r\n        const endChar = this._getEndCharacter(tokenCount - 1);\r\n        return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\r\n    }\r\n    _getTokenCount() {\r\n        return this._tokenCount;\r\n    }\r\n    _getDeltaLine(tokenIndex) {\r\n        return this._tokens[4 * tokenIndex];\r\n    }\r\n    _getStartCharacter(tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 1];\r\n    }\r\n    _getEndCharacter(tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 2];\r\n    }\r\n    isEmpty() {\r\n        return (this._getTokenCount() === 0);\r\n    }\r\n    getLineTokens(deltaLine) {\r\n        let low = 0;\r\n        let high = this._getTokenCount() - 1;\r\n        while (low < high) {\r\n            const mid = low + Math.floor((high - low) / 2);\r\n            const midDeltaLine = this._getDeltaLine(mid);\r\n            if (midDeltaLine < deltaLine) {\r\n                low = mid + 1;\r\n            }\r\n            else if (midDeltaLine > deltaLine) {\r\n                high = mid - 1;\r\n            }\r\n            else {\r\n                let min = mid;\r\n                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\r\n                    min--;\r\n                }\r\n                let max = mid;\r\n                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\r\n                    max++;\r\n                }\r\n                return new LineTokens2(this._tokens.subarray(4 * min, 4 * max + 4));\r\n            }\r\n        }\r\n        if (this._getDeltaLine(low) === deltaLine) {\r\n            return new LineTokens2(this._tokens.subarray(4 * low, 4 * low + 4));\r\n        }\r\n        return null;\r\n    }\r\n    clear() {\r\n        this._tokenCount = 0;\r\n    }\r\n    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\r\n        const tokens = this._tokens;\r\n        const tokenCount = this._tokenCount;\r\n        let newTokenCount = 0;\r\n        let hasDeletedTokens = false;\r\n        let firstDeltaLine = 0;\r\n        for (let i = 0; i < tokenCount; i++) {\r\n            const srcOffset = 4 * i;\r\n            const tokenDeltaLine = tokens[srcOffset];\r\n            const tokenStartCharacter = tokens[srcOffset + 1];\r\n            const tokenEndCharacter = tokens[srcOffset + 2];\r\n            const tokenMetadata = tokens[srcOffset + 3];\r\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\r\n                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\r\n                hasDeletedTokens = true;\r\n            }\r\n            else {\r\n                if (newTokenCount === 0) {\r\n                    firstDeltaLine = tokenDeltaLine;\r\n                }\r\n                if (hasDeletedTokens) {\r\n                    // must move the token to the left\r\n                    const destOffset = 4 * newTokenCount;\r\n                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\r\n                    tokens[destOffset + 1] = tokenStartCharacter;\r\n                    tokens[destOffset + 2] = tokenEndCharacter;\r\n                    tokens[destOffset + 3] = tokenMetadata;\r\n                }\r\n                newTokenCount++;\r\n            }\r\n        }\r\n        this._tokenCount = newTokenCount;\r\n        return firstDeltaLine;\r\n    }\r\n    split(startDeltaLine, startChar, endDeltaLine, endChar) {\r\n        const tokens = this._tokens;\r\n        const tokenCount = this._tokenCount;\r\n        let aTokens = [];\r\n        let bTokens = [];\r\n        let destTokens = aTokens;\r\n        let destOffset = 0;\r\n        let destFirstDeltaLine = 0;\r\n        for (let i = 0; i < tokenCount; i++) {\r\n            const srcOffset = 4 * i;\r\n            const tokenDeltaLine = tokens[srcOffset];\r\n            const tokenStartCharacter = tokens[srcOffset + 1];\r\n            const tokenEndCharacter = tokens[srcOffset + 2];\r\n            const tokenMetadata = tokens[srcOffset + 3];\r\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\r\n                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\r\n                    // this token is touching the range\r\n                    continue;\r\n                }\r\n                else {\r\n                    // this token is after the range\r\n                    if (destTokens !== bTokens) {\r\n                        // this token is the first token after the range\r\n                        destTokens = bTokens;\r\n                        destOffset = 0;\r\n                        destFirstDeltaLine = tokenDeltaLine;\r\n                    }\r\n                }\r\n            }\r\n            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\r\n            destTokens[destOffset++] = tokenStartCharacter;\r\n            destTokens[destOffset++] = tokenEndCharacter;\r\n            destTokens[destOffset++] = tokenMetadata;\r\n        }\r\n        return [new SparseEncodedTokens(new Uint32Array(aTokens)), new SparseEncodedTokens(new Uint32Array(bTokens)), destFirstDeltaLine];\r\n    }\r\n    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\r\n        // This is a bit complex, here are the cases I used to think about this:\r\n        //\r\n        // 1. The token starts before the deletion range\r\n        // 1a. The token is completely before the deletion range\r\n        //               -----------\r\n        //                          xxxxxxxxxxx\r\n        // 1b. The token starts before, the deletion range ends after the token\r\n        //               -----------\r\n        //                      xxxxxxxxxxx\r\n        // 1c. The token starts before, the deletion range ends precisely with the token\r\n        //               ---------------\r\n        //                      xxxxxxxx\r\n        // 1d. The token starts before, the deletion range is inside the token\r\n        //               ---------------\r\n        //                    xxxxx\r\n        //\r\n        // 2. The token starts at the same position with the deletion range\r\n        // 2a. The token starts at the same position, and ends inside the deletion range\r\n        //               -------\r\n        //               xxxxxxxxxxx\r\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\r\n        //               ----------\r\n        //               xxxxxxxxxx\r\n        // 2c. The token starts at the same position, and ends after the deletion range\r\n        //               -------------\r\n        //               xxxxxxx\r\n        //\r\n        // 3. The token starts inside the deletion range\r\n        // 3a. The token is inside the deletion range\r\n        //                -------\r\n        //             xxxxxxxxxxxxx\r\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\r\n        //                ----------\r\n        //             xxxxxxxxxxxxx\r\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\r\n        //                ------------\r\n        //             xxxxxxxxxxx\r\n        //\r\n        // 4. The token starts after the deletion range\r\n        //                  -----------\r\n        //          xxxxxxxx\r\n        //\r\n        const tokens = this._tokens;\r\n        const tokenCount = this._tokenCount;\r\n        const deletedLineCount = (endDeltaLine - startDeltaLine);\r\n        let newTokenCount = 0;\r\n        let hasDeletedTokens = false;\r\n        for (let i = 0; i < tokenCount; i++) {\r\n            const srcOffset = 4 * i;\r\n            let tokenDeltaLine = tokens[srcOffset];\r\n            let tokenStartCharacter = tokens[srcOffset + 1];\r\n            let tokenEndCharacter = tokens[srcOffset + 2];\r\n            const tokenMetadata = tokens[srcOffset + 3];\r\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\r\n                // 1a. The token is completely before the deletion range\r\n                // => nothing to do\r\n                newTokenCount++;\r\n                continue;\r\n            }\r\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\r\n                // 1b, 1c, 1d\r\n                // => the token survives, but it needs to shrink\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 1d. The token starts before, the deletion range is inside the token\r\n                    // => the token shrinks by the deletion character count\r\n                    tokenEndCharacter -= (endCharacter - startCharacter);\r\n                }\r\n                else {\r\n                    // 1b. The token starts before, the deletion range ends after the token\r\n                    // 1c. The token starts before, the deletion range ends precisely with the token\r\n                    // => the token shrinks its ending to the deletion start\r\n                    tokenEndCharacter = startCharacter;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\r\n                // 2a, 2b, 2c\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 2c. The token starts at the same position, and ends after the deletion range\r\n                    // => the token shrinks by the deletion character count\r\n                    tokenEndCharacter -= (endCharacter - startCharacter);\r\n                }\r\n                else {\r\n                    // 2a. The token starts at the same position, and ends inside the deletion range\r\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\r\n                    // => the token is deleted\r\n                    hasDeletedTokens = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\r\n                // 3a, 3b, 3c\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\r\n                    // => the token moves left and shrinks\r\n                    if (tokenDeltaLine === startDeltaLine) {\r\n                        // the deletion started on the same line as the token\r\n                        // => the token moves left and shrinks\r\n                        tokenStartCharacter = startCharacter;\r\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\r\n                    }\r\n                    else {\r\n                        // the deletion started on a line above the token\r\n                        // => the token moves to the beginning of the line\r\n                        tokenStartCharacter = 0;\r\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\r\n                    }\r\n                }\r\n                else {\r\n                    // 3a. The token is inside the deletion range\r\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\r\n                    // => the token is deleted\r\n                    hasDeletedTokens = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine > endDeltaLine) {\r\n                // 4. (partial) The token starts after the deletion range, on a line below...\r\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\r\n                    // early stop, there is no need to walk all the tokens and do nothing...\r\n                    newTokenCount = tokenCount;\r\n                    break;\r\n                }\r\n                tokenDeltaLine -= deletedLineCount;\r\n            }\r\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\r\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\r\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\r\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\r\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\r\n                }\r\n                tokenDeltaLine -= deletedLineCount;\r\n                tokenStartCharacter -= (endCharacter - startCharacter);\r\n                tokenEndCharacter -= (endCharacter - startCharacter);\r\n            }\r\n            else {\r\n                throw new Error(`Not possible!`);\r\n            }\r\n            const destOffset = 4 * newTokenCount;\r\n            tokens[destOffset] = tokenDeltaLine;\r\n            tokens[destOffset + 1] = tokenStartCharacter;\r\n            tokens[destOffset + 2] = tokenEndCharacter;\r\n            tokens[destOffset + 3] = tokenMetadata;\r\n            newTokenCount++;\r\n        }\r\n        this._tokenCount = newTokenCount;\r\n    }\r\n    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        // Here are the cases I used to think about this:\r\n        //\r\n        // 1. The token is completely before the insertion point\r\n        //            -----------   |\r\n        // 2. The token ends precisely at the insertion point\r\n        //            -----------|\r\n        // 3. The token contains the insertion point\r\n        //            -----|------\r\n        // 4. The token starts precisely at the insertion point\r\n        //            |-----------\r\n        // 5. The token is completely after the insertion point\r\n        //            |   -----------\r\n        //\r\n        const isInsertingPreciselyOneWordCharacter = (eolCount === 0\r\n            && firstLineLength === 1\r\n            && ((firstCharCode >= 48 /* Digit0 */ && firstCharCode <= 57 /* Digit9 */)\r\n                || (firstCharCode >= 65 /* A */ && firstCharCode <= 90 /* Z */)\r\n                || (firstCharCode >= 97 /* a */ && firstCharCode <= 122 /* z */)));\r\n        const tokens = this._tokens;\r\n        const tokenCount = this._tokenCount;\r\n        for (let i = 0; i < tokenCount; i++) {\r\n            const offset = 4 * i;\r\n            let tokenDeltaLine = tokens[offset];\r\n            let tokenStartCharacter = tokens[offset + 1];\r\n            let tokenEndCharacter = tokens[offset + 2];\r\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\r\n                // 1. The token is completely before the insertion point\r\n                // => nothing to do\r\n                continue;\r\n            }\r\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\r\n                // 2. The token ends precisely at the insertion point\r\n                // => expand the end character only if inserting precisely one character that is a word character\r\n                if (isInsertingPreciselyOneWordCharacter) {\r\n                    tokenEndCharacter += 1;\r\n                }\r\n                else {\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\r\n                // 3. The token contains the insertion point\r\n                if (eolCount === 0) {\r\n                    // => just expand the end character\r\n                    tokenEndCharacter += firstLineLength;\r\n                }\r\n                else {\r\n                    // => cut off the token\r\n                    tokenEndCharacter = character;\r\n                }\r\n            }\r\n            else {\r\n                // 4. or 5.\r\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\r\n                    // 4. The token starts precisely at the insertion point\r\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\r\n                    // => otherwise behave as in case 5.\r\n                    if (isInsertingPreciselyOneWordCharacter) {\r\n                        continue;\r\n                    }\r\n                }\r\n                // => the token must move and keep its size constant\r\n                if (tokenDeltaLine === deltaLine) {\r\n                    tokenDeltaLine += eolCount;\r\n                    // this token is on the line where the insertion is taking place\r\n                    if (eolCount === 0) {\r\n                        tokenStartCharacter += firstLineLength;\r\n                        tokenEndCharacter += firstLineLength;\r\n                    }\r\n                    else {\r\n                        const tokenLength = tokenEndCharacter - tokenStartCharacter;\r\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\r\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\r\n                    }\r\n                }\r\n                else {\r\n                    tokenDeltaLine += eolCount;\r\n                }\r\n            }\r\n            tokens[offset] = tokenDeltaLine;\r\n            tokens[offset + 1] = tokenStartCharacter;\r\n            tokens[offset + 2] = tokenEndCharacter;\r\n        }\r\n    }\r\n}\r\nexport class LineTokens2 {\r\n    constructor(tokens) {\r\n        this._tokens = tokens;\r\n    }\r\n    getCount() {\r\n        return this._tokens.length / 4;\r\n    }\r\n    getStartCharacter(tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 1];\r\n    }\r\n    getEndCharacter(tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 2];\r\n    }\r\n    getMetadata(tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 3];\r\n    }\r\n}\r\nexport class MultilineTokens2 {\r\n    constructor(startLineNumber, tokens) {\r\n        this.startLineNumber = startLineNumber;\r\n        this.tokens = tokens;\r\n        this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\r\n    }\r\n    toString() {\r\n        return this.tokens.toString(this.startLineNumber);\r\n    }\r\n    _updateEndLineNumber() {\r\n        this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\r\n    }\r\n    isEmpty() {\r\n        return this.tokens.isEmpty();\r\n    }\r\n    getLineTokens(lineNumber) {\r\n        if (this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber) {\r\n            return this.tokens.getLineTokens(lineNumber - this.startLineNumber);\r\n        }\r\n        return null;\r\n    }\r\n    getRange() {\r\n        const deltaRange = this.tokens.getRange();\r\n        if (!deltaRange) {\r\n            return deltaRange;\r\n        }\r\n        return new Range(this.startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this.startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\r\n    }\r\n    removeTokens(range) {\r\n        const startLineIndex = range.startLineNumber - this.startLineNumber;\r\n        const endLineIndex = range.endLineNumber - this.startLineNumber;\r\n        this.startLineNumber += this.tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\r\n        this._updateEndLineNumber();\r\n    }\r\n    split(range) {\r\n        // split tokens to two:\r\n        // a) all the tokens before `range`\r\n        // b) all the tokens after `range`\r\n        const startLineIndex = range.startLineNumber - this.startLineNumber;\r\n        const endLineIndex = range.endLineNumber - this.startLineNumber;\r\n        const [a, b, bDeltaLine] = this.tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\r\n        return [new MultilineTokens2(this.startLineNumber, a), new MultilineTokens2(this.startLineNumber + bDeltaLine, b)];\r\n    }\r\n    applyEdit(range, text) {\r\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\r\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* Null */);\r\n    }\r\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n        this._updateEndLineNumber();\r\n    }\r\n    _acceptDeleteRange(range) {\r\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\r\n            // Nothing to delete\r\n            return;\r\n        }\r\n        const firstLineIndex = range.startLineNumber - this.startLineNumber;\r\n        const lastLineIndex = range.endLineNumber - this.startLineNumber;\r\n        if (lastLineIndex < 0) {\r\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\r\n            const deletedLinesCount = lastLineIndex - firstLineIndex;\r\n            this.startLineNumber -= deletedLinesCount;\r\n            return;\r\n        }\r\n        const tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\r\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this deletion occurs entirely after this block, so there is nothing to do\r\n            return;\r\n        }\r\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this deletion completely encompasses this block\r\n            this.startLineNumber = 0;\r\n            this.tokens.clear();\r\n            return;\r\n        }\r\n        if (firstLineIndex < 0) {\r\n            const deletedBefore = -firstLineIndex;\r\n            this.startLineNumber -= deletedBefore;\r\n            this.tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\r\n        }\r\n        else {\r\n            this.tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\r\n        }\r\n    }\r\n    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        if (eolCount === 0 && firstLineLength === 0) {\r\n            // Nothing to insert\r\n            return;\r\n        }\r\n        const lineIndex = position.lineNumber - this.startLineNumber;\r\n        if (lineIndex < 0) {\r\n            // this insertion occurs before this block, so we only need to adjust line numbers\r\n            this.startLineNumber += eolCount;\r\n            return;\r\n        }\r\n        const tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\r\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this insertion occurs after this block, so there is nothing to do\r\n            return;\r\n        }\r\n        this.tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n    }\r\n}\r\nexport class MultilineTokens {\r\n    constructor(startLineNumber, tokens) {\r\n        this.startLineNumber = startLineNumber;\r\n        this.tokens = tokens;\r\n    }\r\n}\r\nfunction toUint32Array(arr) {\r\n    if (arr instanceof Uint32Array) {\r\n        return arr;\r\n    }\r\n    else {\r\n        return new Uint32Array(arr);\r\n    }\r\n}\r\nexport class TokensStore2 {\r\n    constructor() {\r\n        this._pieces = [];\r\n        this._isComplete = false;\r\n    }\r\n    flush() {\r\n        this._pieces = [];\r\n        this._isComplete = false;\r\n    }\r\n    isEmpty() {\r\n        return (this._pieces.length === 0);\r\n    }\r\n    set(pieces, isComplete) {\r\n        this._pieces = pieces || [];\r\n        this._isComplete = isComplete;\r\n    }\r\n    setPartial(_range, pieces) {\r\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\r\n        let range = _range;\r\n        if (pieces.length > 0) {\r\n            const _firstRange = pieces[0].getRange();\r\n            const _lastRange = pieces[pieces.length - 1].getRange();\r\n            if (!_firstRange || !_lastRange) {\r\n                return _range;\r\n            }\r\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\r\n        }\r\n        let insertPosition = null;\r\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\r\n            const piece = this._pieces[i];\r\n            if (piece.endLineNumber < range.startLineNumber) {\r\n                // this piece is before the range\r\n                continue;\r\n            }\r\n            if (piece.startLineNumber > range.endLineNumber) {\r\n                // this piece is after the range, so mark the spot before this piece\r\n                // as a good insertion position and stop looping\r\n                insertPosition = insertPosition || { index: i };\r\n                break;\r\n            }\r\n            // this piece might intersect with the range\r\n            piece.removeTokens(range);\r\n            if (piece.isEmpty()) {\r\n                // remove the piece if it became empty\r\n                this._pieces.splice(i, 1);\r\n                i--;\r\n                len--;\r\n                continue;\r\n            }\r\n            if (piece.endLineNumber < range.startLineNumber) {\r\n                // after removal, this piece is before the range\r\n                continue;\r\n            }\r\n            if (piece.startLineNumber > range.endLineNumber) {\r\n                // after removal, this piece is after the range\r\n                insertPosition = insertPosition || { index: i };\r\n                continue;\r\n            }\r\n            // after removal, this piece contains the range\r\n            const [a, b] = piece.split(range);\r\n            if (a.isEmpty()) {\r\n                // this piece is actually after the range\r\n                insertPosition = insertPosition || { index: i };\r\n                continue;\r\n            }\r\n            if (b.isEmpty()) {\r\n                // this piece is actually before the range\r\n                continue;\r\n            }\r\n            this._pieces.splice(i, 1, a, b);\r\n            i++;\r\n            len++;\r\n            insertPosition = insertPosition || { index: i };\r\n        }\r\n        insertPosition = insertPosition || { index: this._pieces.length };\r\n        if (pieces.length > 0) {\r\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\r\n        }\r\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\r\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\r\n        return range;\r\n    }\r\n    isComplete() {\r\n        return this._isComplete;\r\n    }\r\n    addSemanticTokens(lineNumber, aTokens) {\r\n        const pieces = this._pieces;\r\n        if (pieces.length === 0) {\r\n            return aTokens;\r\n        }\r\n        const pieceIndex = TokensStore2._findFirstPieceWithLine(pieces, lineNumber);\r\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\r\n        if (!bTokens) {\r\n            return aTokens;\r\n        }\r\n        const aLen = aTokens.getCount();\r\n        const bLen = bTokens.getCount();\r\n        let aIndex = 0;\r\n        let result = [], resultLen = 0;\r\n        let lastEndOffset = 0;\r\n        const emitToken = (endOffset, metadata) => {\r\n            if (endOffset === lastEndOffset) {\r\n                return;\r\n            }\r\n            lastEndOffset = endOffset;\r\n            result[resultLen++] = endOffset;\r\n            result[resultLen++] = metadata;\r\n        };\r\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\r\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\r\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\r\n            const bMetadata = bTokens.getMetadata(bIndex);\r\n            const bMask = (((bMetadata & 1 /* SEMANTIC_USE_ITALIC */) ? 2048 /* ITALIC_MASK */ : 0)\r\n                | ((bMetadata & 2 /* SEMANTIC_USE_BOLD */) ? 4096 /* BOLD_MASK */ : 0)\r\n                | ((bMetadata & 4 /* SEMANTIC_USE_UNDERLINE */) ? 8192 /* UNDERLINE_MASK */ : 0)\r\n                | ((bMetadata & 8 /* SEMANTIC_USE_FOREGROUND */) ? 8372224 /* FOREGROUND_MASK */ : 0)\r\n                | ((bMetadata & 16 /* SEMANTIC_USE_BACKGROUND */) ? 4286578688 /* BACKGROUND_MASK */ : 0)) >>> 0;\r\n            const aMask = (~bMask) >>> 0;\r\n            // push any token from `a` that is before `b`\r\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\r\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\r\n                aIndex++;\r\n            }\r\n            // push the token from `a` if it intersects the token from `b`\r\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\r\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\r\n            }\r\n            // skip any tokens from `a` that are contained inside `b`\r\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\r\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\r\n                aIndex++;\r\n            }\r\n            if (aIndex < aLen) {\r\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\r\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\r\n                    // `a` ends exactly at the same spot as `b`!\r\n                    aIndex++;\r\n                }\r\n            }\r\n            else {\r\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\r\n                // push the token from `b`\r\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\r\n            }\r\n        }\r\n        // push the remaining tokens from `a`\r\n        while (aIndex < aLen) {\r\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\r\n            aIndex++;\r\n        }\r\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent());\r\n    }\r\n    static _findFirstPieceWithLine(pieces, lineNumber) {\r\n        let low = 0;\r\n        let high = pieces.length - 1;\r\n        while (low < high) {\r\n            let mid = low + Math.floor((high - low) / 2);\r\n            if (pieces[mid].endLineNumber < lineNumber) {\r\n                low = mid + 1;\r\n            }\r\n            else if (pieces[mid].startLineNumber > lineNumber) {\r\n                high = mid - 1;\r\n            }\r\n            else {\r\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\r\n                    mid--;\r\n                }\r\n                return mid;\r\n            }\r\n        }\r\n        return low;\r\n    }\r\n    //#region Editing\r\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        for (const piece of this._pieces) {\r\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n        }\r\n    }\r\n}\r\nexport class TokensStore {\r\n    constructor() {\r\n        this._lineTokens = [];\r\n        this._len = 0;\r\n    }\r\n    flush() {\r\n        this._lineTokens = [];\r\n        this._len = 0;\r\n    }\r\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\r\n        let rawLineTokens = null;\r\n        if (lineIndex < this._len) {\r\n            rawLineTokens = this._lineTokens[lineIndex];\r\n        }\r\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\r\n            return new LineTokens(toUint32Array(rawLineTokens), lineText);\r\n        }\r\n        let lineTokens = new Uint32Array(2);\r\n        lineTokens[0] = lineText.length;\r\n        lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\r\n        return new LineTokens(lineTokens, lineText);\r\n    }\r\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\r\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\r\n        if (lineTextLength === 0) {\r\n            let hasDifferentLanguageId = false;\r\n            if (tokens && tokens.length > 1) {\r\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\r\n            }\r\n            if (!hasDifferentLanguageId) {\r\n                return EMPTY_LINE_TOKENS;\r\n            }\r\n        }\r\n        if (!tokens || tokens.length === 0) {\r\n            const tokens = new Uint32Array(2);\r\n            tokens[0] = lineTextLength;\r\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\r\n            return tokens.buffer;\r\n        }\r\n        // Ensure the last token covers the end of the text\r\n        tokens[tokens.length - 2] = lineTextLength;\r\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\r\n            // Store directly the ArrayBuffer pointer to save an object\r\n            return tokens.buffer;\r\n        }\r\n        return tokens;\r\n    }\r\n    _ensureLine(lineIndex) {\r\n        while (lineIndex >= this._len) {\r\n            this._lineTokens[this._len] = null;\r\n            this._len++;\r\n        }\r\n    }\r\n    _deleteLines(start, deleteCount) {\r\n        if (deleteCount === 0) {\r\n            return;\r\n        }\r\n        if (start + deleteCount > this._len) {\r\n            deleteCount = this._len - start;\r\n        }\r\n        this._lineTokens.splice(start, deleteCount);\r\n        this._len -= deleteCount;\r\n    }\r\n    _insertLines(insertIndex, insertCount) {\r\n        if (insertCount === 0) {\r\n            return;\r\n        }\r\n        let lineTokens = [];\r\n        for (let i = 0; i < insertCount; i++) {\r\n            lineTokens[i] = null;\r\n        }\r\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\r\n        this._len += insertCount;\r\n    }\r\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\r\n        const tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);\r\n        this._ensureLine(lineIndex);\r\n        const oldTokens = this._lineTokens[lineIndex];\r\n        this._lineTokens[lineIndex] = tokens;\r\n        if (checkEquality) {\r\n            return !TokensStore._equals(oldTokens, tokens);\r\n        }\r\n        return false;\r\n    }\r\n    static _equals(_a, _b) {\r\n        if (!_a || !_b) {\r\n            return !_a && !_b;\r\n        }\r\n        const a = toUint32Array(_a);\r\n        const b = toUint32Array(_b);\r\n        if (a.length !== b.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0, len = a.length; i < len; i++) {\r\n            if (a[i] !== b[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    //#region Editing\r\n    acceptEdit(range, eolCount, firstLineLength) {\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\r\n    }\r\n    _acceptDeleteRange(range) {\r\n        const firstLineIndex = range.startLineNumber - 1;\r\n        if (firstLineIndex >= this._len) {\r\n            return;\r\n        }\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            if (range.startColumn === range.endColumn) {\r\n                // Nothing to delete\r\n                return;\r\n            }\r\n            this._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\r\n            return;\r\n        }\r\n        this._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\r\n        const lastLineIndex = range.endLineNumber - 1;\r\n        let lastLineTokens = null;\r\n        if (lastLineIndex < this._len) {\r\n            lastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\r\n        }\r\n        // Take remaining text on last line and append it to remaining text on first line\r\n        this._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens);\r\n        // Delete middle lines\r\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n    }\r\n    _acceptInsertText(position, eolCount, firstLineLength) {\r\n        if (eolCount === 0 && firstLineLength === 0) {\r\n            // Nothing to insert\r\n            return;\r\n        }\r\n        const lineIndex = position.lineNumber - 1;\r\n        if (lineIndex >= this._len) {\r\n            return;\r\n        }\r\n        if (eolCount === 0) {\r\n            // Inserting text on one line\r\n            this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\r\n            return;\r\n        }\r\n        this._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);\r\n        this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\r\n        this._insertLines(position.lineNumber, eolCount);\r\n    }\r\n    static _deleteBeginning(lineTokens, toChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        return TokensStore._delete(lineTokens, 0, toChIndex);\r\n    }\r\n    static _deleteEnding(lineTokens, fromChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        const tokens = toUint32Array(lineTokens);\r\n        const lineTextLength = tokens[tokens.length - 2];\r\n        return TokensStore._delete(lineTokens, fromChIndex, lineTextLength);\r\n    }\r\n    static _delete(lineTokens, fromChIndex, toChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\r\n            return lineTokens;\r\n        }\r\n        const tokens = toUint32Array(lineTokens);\r\n        const tokensCount = (tokens.length >>> 1);\r\n        // special case: deleting everything\r\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\r\n            return EMPTY_LINE_TOKENS;\r\n        }\r\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\r\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\r\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\r\n        if (toChIndex < fromTokenEndOffset) {\r\n            // the delete range is inside a single token\r\n            const delta = (toChIndex - fromChIndex);\r\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\r\n                tokens[i << 1] -= delta;\r\n            }\r\n            return lineTokens;\r\n        }\r\n        let dest;\r\n        let lastEnd;\r\n        if (fromTokenStartOffset !== fromChIndex) {\r\n            tokens[fromTokenIndex << 1] = fromChIndex;\r\n            dest = ((fromTokenIndex + 1) << 1);\r\n            lastEnd = fromChIndex;\r\n        }\r\n        else {\r\n            dest = (fromTokenIndex << 1);\r\n            lastEnd = fromTokenStartOffset;\r\n        }\r\n        const delta = (toChIndex - fromChIndex);\r\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\r\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\r\n            if (tokenEndOffset > lastEnd) {\r\n                tokens[dest++] = tokenEndOffset;\r\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\r\n                lastEnd = tokenEndOffset;\r\n            }\r\n        }\r\n        if (dest === tokens.length) {\r\n            // nothing to trim\r\n            return lineTokens;\r\n        }\r\n        let tmp = new Uint32Array(dest);\r\n        tmp.set(tokens.subarray(0, dest), 0);\r\n        return tmp.buffer;\r\n    }\r\n    static _append(lineTokens, _otherTokens) {\r\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        if (lineTokens === EMPTY_LINE_TOKENS) {\r\n            return _otherTokens;\r\n        }\r\n        if (lineTokens === null) {\r\n            return lineTokens;\r\n        }\r\n        if (_otherTokens === null) {\r\n            // cannot determine combined line length...\r\n            return null;\r\n        }\r\n        const myTokens = toUint32Array(lineTokens);\r\n        const otherTokens = toUint32Array(_otherTokens);\r\n        const otherTokensCount = (otherTokens.length >>> 1);\r\n        let result = new Uint32Array(myTokens.length + otherTokens.length);\r\n        result.set(myTokens, 0);\r\n        let dest = myTokens.length;\r\n        const delta = myTokens[myTokens.length - 2];\r\n        for (let i = 0; i < otherTokensCount; i++) {\r\n            result[dest++] = otherTokens[(i << 1)] + delta;\r\n            result[dest++] = otherTokens[(i << 1) + 1];\r\n        }\r\n        return result.buffer;\r\n    }\r\n    static _insert(lineTokens, chIndex, textLength) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            // nothing to do\r\n            return lineTokens;\r\n        }\r\n        const tokens = toUint32Array(lineTokens);\r\n        const tokensCount = (tokens.length >>> 1);\r\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\r\n        if (fromTokenIndex > 0) {\r\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\r\n            if (fromTokenStartOffset === chIndex) {\r\n                fromTokenIndex--;\r\n            }\r\n        }\r\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\r\n            tokens[tokenIndex << 1] += textLength;\r\n        }\r\n        return lineTokens;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}