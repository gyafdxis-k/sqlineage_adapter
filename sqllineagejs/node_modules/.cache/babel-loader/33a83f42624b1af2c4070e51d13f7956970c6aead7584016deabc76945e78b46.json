{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../controller/cursorCommon.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nconst repeatCache = Object.create(null);\nexport function cachedStringRepeat(str, count) {\n  if (!repeatCache[str]) {\n    repeatCache[str] = ['', str];\n  }\n  const cache = repeatCache[str];\n  for (let i = cache.length; i <= count; i++) {\n    cache[i] = cache[i - 1] + str;\n  }\n  return cache[count];\n}\nexport class ShiftCommand {\n  constructor(range, opts) {\n    this._opts = opts;\n    this._selection = range;\n    this._selectionId = null;\n    this._useLastEditRangeForCursorEndPosition = false;\n    this._selectionStartColumnStaysPut = false;\n  }\n  static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n    // Determine the visible column where the content starts\n    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n    if (insertSpaces) {\n      const indent = cachedStringRepeat(' ', indentSize);\n      const desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n      const indentCount = desiredTabStop / indentSize; // will be an integer\n      return cachedStringRepeat(indent, indentCount);\n    } else {\n      const indent = '\\t';\n      const desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n      const indentCount = desiredTabStop / tabSize; // will be an integer\n      return cachedStringRepeat(indent, indentCount);\n    }\n  }\n  static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n    // Determine the visible column where the content starts\n    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n    if (insertSpaces) {\n      const indent = cachedStringRepeat(' ', indentSize);\n      const desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n      const indentCount = desiredTabStop / indentSize; // will be an integer\n      return cachedStringRepeat(indent, indentCount);\n    } else {\n      const indent = '\\t';\n      const desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n      const indentCount = desiredTabStop / tabSize; // will be an integer\n      return cachedStringRepeat(indent, indentCount);\n    }\n  }\n  _addEditOperation(builder, range, text) {\n    if (this._useLastEditRangeForCursorEndPosition) {\n      builder.addTrackedEditOperation(range, text);\n    } else {\n      builder.addEditOperation(range, text);\n    }\n  }\n  getEditOperations(model, builder) {\n    const startLine = this._selection.startLineNumber;\n    let endLine = this._selection.endLineNumber;\n    if (this._selection.endColumn === 1 && startLine !== endLine) {\n      endLine = endLine - 1;\n    }\n    const {\n      tabSize,\n      indentSize,\n      insertSpaces\n    } = this._opts;\n    const shouldIndentEmptyLines = startLine === endLine;\n    if (this._opts.useTabStops) {\n      // if indenting or outdenting on a whitespace only line\n      if (this._selection.isEmpty()) {\n        if (/^\\s*$/.test(model.getLineContent(startLine))) {\n          this._useLastEditRangeForCursorEndPosition = true;\n        }\n      }\n      // keep track of previous line's \"miss-alignment\"\n      let previousLineExtraSpaces = 0,\n        extraSpaces = 0;\n      for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n        extraSpaces = 0;\n        let lineText = model.getLineContent(lineNumber);\n        let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n          // empty line or line with no leading whitespace => nothing to do\n          continue;\n        }\n        if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n          // do not indent empty lines => nothing to do\n          continue;\n        }\n        if (indentationEndIndex === -1) {\n          // the entire line is whitespace\n          indentationEndIndex = lineText.length;\n        }\n        if (lineNumber > 1) {\n          let contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n          if (contentStartVisibleColumn % indentSize !== 0) {\n            // The current line is \"miss-aligned\", so let's see if this is expected...\n            // This can only happen when it has trailing commas in the indent\n            if (model.isCheapToTokenize(lineNumber - 1)) {\n              let enterAction = LanguageConfigurationRegistry.getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)));\n              if (enterAction) {\n                extraSpaces = previousLineExtraSpaces;\n                if (enterAction.appendText) {\n                  for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                    if (enterAction.appendText.charCodeAt(j) === 32 /* Space */) {\n                      extraSpaces++;\n                    } else {\n                      break;\n                    }\n                  }\n                }\n                if (enterAction.removeText) {\n                  extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                }\n                // Act as if `prefixSpaces` is not part of the indentation\n                for (let j = 0; j < extraSpaces; j++) {\n                  if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* Space */) {\n                    break;\n                  }\n                  indentationEndIndex--;\n                }\n              }\n            }\n          }\n        }\n        if (this._opts.isUnshift && indentationEndIndex === 0) {\n          // line with no leading whitespace => nothing to do\n          continue;\n        }\n        let desiredIndent;\n        if (this._opts.isUnshift) {\n          desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n        } else {\n          desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n        }\n        this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n        if (lineNumber === startLine && !this._selection.isEmpty()) {\n          // Force the startColumn to stay put because we're inserting after it\n          this._selectionStartColumnStaysPut = this._selection.startColumn <= indentationEndIndex + 1;\n        }\n      }\n    } else {\n      // if indenting or outdenting on a whitespace only line\n      if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\n        this._useLastEditRangeForCursorEndPosition = true;\n      }\n      const oneIndent = insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t';\n      for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n        const lineText = model.getLineContent(lineNumber);\n        let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n          // empty line or line with no leading whitespace => nothing to do\n          continue;\n        }\n        if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n          // do not indent empty lines => nothing to do\n          continue;\n        }\n        if (indentationEndIndex === -1) {\n          // the entire line is whitespace\n          indentationEndIndex = lineText.length;\n        }\n        if (this._opts.isUnshift && indentationEndIndex === 0) {\n          // line with no leading whitespace => nothing to do\n          continue;\n        }\n        if (this._opts.isUnshift) {\n          indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n          for (let i = 0; i < indentationEndIndex; i++) {\n            const chr = lineText.charCodeAt(i);\n            if (chr === 9 /* Tab */) {\n              indentationEndIndex = i + 1;\n              break;\n            }\n          }\n          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n        } else {\n          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n          if (lineNumber === startLine && !this._selection.isEmpty()) {\n            // Force the startColumn to stay put because we're inserting after it\n            this._selectionStartColumnStaysPut = this._selection.startColumn === 1;\n          }\n        }\n      }\n    }\n    this._selectionId = builder.trackSelection(this._selection);\n  }\n  computeCursorState(model, helper) {\n    if (this._useLastEditRangeForCursorEndPosition) {\n      let lastOp = helper.getInverseEditOperations()[0];\n      return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n    }\n    const result = helper.getTrackedSelection(this._selectionId);\n    if (this._selectionStartColumnStaysPut) {\n      // The selection start should not move\n      let initialStartColumn = this._selection.startColumn;\n      let resultStartColumn = result.startColumn;\n      if (resultStartColumn <= initialStartColumn) {\n        return result;\n      }\n      if (result.getDirection() === 0 /* LTR */) {\n        return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n      }\n      return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["strings","CursorColumns","Range","Selection","LanguageConfigurationRegistry","repeatCache","Object","create","cachedStringRepeat","str","count","cache","i","length","ShiftCommand","constructor","range","opts","_opts","_selection","_selectionId","_useLastEditRangeForCursorEndPosition","_selectionStartColumnStaysPut","unshiftIndent","line","column","tabSize","indentSize","insertSpaces","contentStartVisibleColumn","visibleColumnFromColumn","indent","desiredTabStop","prevIndentTabStop","indentCount","prevRenderTabStop","shiftIndent","nextIndentTabStop","nextRenderTabStop","_addEditOperation","builder","text","addTrackedEditOperation","addEditOperation","getEditOperations","model","startLine","startLineNumber","endLine","endLineNumber","endColumn","shouldIndentEmptyLines","useTabStops","isEmpty","test","getLineContent","previousLineExtraSpaces","extraSpaces","lineNumber","lineText","indentationEndIndex","firstNonWhitespaceIndex","isUnshift","isCheapToTokenize","enterAction","getEnterAction","autoIndent","getLineMaxColumn","appendText","j","lenJ","charCodeAt","removeText","Math","max","desiredIndent","startColumn","getLineLength","oneIndent","min","chr","trackSelection","computeCursorState","helper","lastOp","getInverseEditOperations","result","getTrackedSelection","initialStartColumn","resultStartColumn","getDirection"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/commands/shiftCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { CursorColumns } from '../controller/cursorCommon.js';\r\nimport { Range } from '../core/range.js';\r\nimport { Selection } from '../core/selection.js';\r\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\r\nconst repeatCache = Object.create(null);\r\nexport function cachedStringRepeat(str, count) {\r\n    if (!repeatCache[str]) {\r\n        repeatCache[str] = ['', str];\r\n    }\r\n    const cache = repeatCache[str];\r\n    for (let i = cache.length; i <= count; i++) {\r\n        cache[i] = cache[i - 1] + str;\r\n    }\r\n    return cache[count];\r\n}\r\nexport class ShiftCommand {\r\n    constructor(range, opts) {\r\n        this._opts = opts;\r\n        this._selection = range;\r\n        this._selectionId = null;\r\n        this._useLastEditRangeForCursorEndPosition = false;\r\n        this._selectionStartColumnStaysPut = false;\r\n    }\r\n    static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\r\n        // Determine the visible column where the content starts\r\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\r\n        if (insertSpaces) {\r\n            const indent = cachedStringRepeat(' ', indentSize);\r\n            const desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\r\n            const indentCount = desiredTabStop / indentSize; // will be an integer\r\n            return cachedStringRepeat(indent, indentCount);\r\n        }\r\n        else {\r\n            const indent = '\\t';\r\n            const desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\r\n            const indentCount = desiredTabStop / tabSize; // will be an integer\r\n            return cachedStringRepeat(indent, indentCount);\r\n        }\r\n    }\r\n    static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\r\n        // Determine the visible column where the content starts\r\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\r\n        if (insertSpaces) {\r\n            const indent = cachedStringRepeat(' ', indentSize);\r\n            const desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\r\n            const indentCount = desiredTabStop / indentSize; // will be an integer\r\n            return cachedStringRepeat(indent, indentCount);\r\n        }\r\n        else {\r\n            const indent = '\\t';\r\n            const desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\r\n            const indentCount = desiredTabStop / tabSize; // will be an integer\r\n            return cachedStringRepeat(indent, indentCount);\r\n        }\r\n    }\r\n    _addEditOperation(builder, range, text) {\r\n        if (this._useLastEditRangeForCursorEndPosition) {\r\n            builder.addTrackedEditOperation(range, text);\r\n        }\r\n        else {\r\n            builder.addEditOperation(range, text);\r\n        }\r\n    }\r\n    getEditOperations(model, builder) {\r\n        const startLine = this._selection.startLineNumber;\r\n        let endLine = this._selection.endLineNumber;\r\n        if (this._selection.endColumn === 1 && startLine !== endLine) {\r\n            endLine = endLine - 1;\r\n        }\r\n        const { tabSize, indentSize, insertSpaces } = this._opts;\r\n        const shouldIndentEmptyLines = (startLine === endLine);\r\n        if (this._opts.useTabStops) {\r\n            // if indenting or outdenting on a whitespace only line\r\n            if (this._selection.isEmpty()) {\r\n                if (/^\\s*$/.test(model.getLineContent(startLine))) {\r\n                    this._useLastEditRangeForCursorEndPosition = true;\r\n                }\r\n            }\r\n            // keep track of previous line's \"miss-alignment\"\r\n            let previousLineExtraSpaces = 0, extraSpaces = 0;\r\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\r\n                extraSpaces = 0;\r\n                let lineText = model.getLineContent(lineNumber);\r\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\r\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\r\n                    // empty line or line with no leading whitespace => nothing to do\r\n                    continue;\r\n                }\r\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\r\n                    // do not indent empty lines => nothing to do\r\n                    continue;\r\n                }\r\n                if (indentationEndIndex === -1) {\r\n                    // the entire line is whitespace\r\n                    indentationEndIndex = lineText.length;\r\n                }\r\n                if (lineNumber > 1) {\r\n                    let contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\r\n                    if (contentStartVisibleColumn % indentSize !== 0) {\r\n                        // The current line is \"miss-aligned\", so let's see if this is expected...\r\n                        // This can only happen when it has trailing commas in the indent\r\n                        if (model.isCheapToTokenize(lineNumber - 1)) {\r\n                            let enterAction = LanguageConfigurationRegistry.getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)));\r\n                            if (enterAction) {\r\n                                extraSpaces = previousLineExtraSpaces;\r\n                                if (enterAction.appendText) {\r\n                                    for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\r\n                                        if (enterAction.appendText.charCodeAt(j) === 32 /* Space */) {\r\n                                            extraSpaces++;\r\n                                        }\r\n                                        else {\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (enterAction.removeText) {\r\n                                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\r\n                                }\r\n                                // Act as if `prefixSpaces` is not part of the indentation\r\n                                for (let j = 0; j < extraSpaces; j++) {\r\n                                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* Space */) {\r\n                                        break;\r\n                                    }\r\n                                    indentationEndIndex--;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\r\n                    // line with no leading whitespace => nothing to do\r\n                    continue;\r\n                }\r\n                let desiredIndent;\r\n                if (this._opts.isUnshift) {\r\n                    desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\r\n                }\r\n                else {\r\n                    desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\r\n                }\r\n                this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\r\n                if (lineNumber === startLine && !this._selection.isEmpty()) {\r\n                    // Force the startColumn to stay put because we're inserting after it\r\n                    this._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // if indenting or outdenting on a whitespace only line\r\n            if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\r\n                this._useLastEditRangeForCursorEndPosition = true;\r\n            }\r\n            const oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\r\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\r\n                const lineText = model.getLineContent(lineNumber);\r\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\r\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\r\n                    // empty line or line with no leading whitespace => nothing to do\r\n                    continue;\r\n                }\r\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\r\n                    // do not indent empty lines => nothing to do\r\n                    continue;\r\n                }\r\n                if (indentationEndIndex === -1) {\r\n                    // the entire line is whitespace\r\n                    indentationEndIndex = lineText.length;\r\n                }\r\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\r\n                    // line with no leading whitespace => nothing to do\r\n                    continue;\r\n                }\r\n                if (this._opts.isUnshift) {\r\n                    indentationEndIndex = Math.min(indentationEndIndex, indentSize);\r\n                    for (let i = 0; i < indentationEndIndex; i++) {\r\n                        const chr = lineText.charCodeAt(i);\r\n                        if (chr === 9 /* Tab */) {\r\n                            indentationEndIndex = i + 1;\r\n                            break;\r\n                        }\r\n                    }\r\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\r\n                }\r\n                else {\r\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\r\n                    if (lineNumber === startLine && !this._selection.isEmpty()) {\r\n                        // Force the startColumn to stay put because we're inserting after it\r\n                        this._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._selectionId = builder.trackSelection(this._selection);\r\n    }\r\n    computeCursorState(model, helper) {\r\n        if (this._useLastEditRangeForCursorEndPosition) {\r\n            let lastOp = helper.getInverseEditOperations()[0];\r\n            return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\r\n        }\r\n        const result = helper.getTrackedSelection(this._selectionId);\r\n        if (this._selectionStartColumnStaysPut) {\r\n            // The selection start should not move\r\n            let initialStartColumn = this._selection.startColumn;\r\n            let resultStartColumn = result.startColumn;\r\n            if (resultStartColumn <= initialStartColumn) {\r\n                return result;\r\n            }\r\n            if (result.getDirection() === 0 /* LTR */) {\r\n                return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\r\n            }\r\n            return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}