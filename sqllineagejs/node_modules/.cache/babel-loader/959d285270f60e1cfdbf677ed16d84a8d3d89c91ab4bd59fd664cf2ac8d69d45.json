{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport * as strings from '../../../base/common/strings.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n  const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n  return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n  constructor(lines) {\n    const startColumns = [];\n    const endColumns = [];\n    for (let i = 0, length = lines.length; i < length; i++) {\n      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n      endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n    }\n    this.lines = lines;\n    this._startColumns = startColumns;\n    this._endColumns = endColumns;\n  }\n  getElements() {\n    const elements = [];\n    for (let i = 0, len = this.lines.length; i < len; i++) {\n      elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n    }\n    return elements;\n  }\n  getStartLineNumber(i) {\n    return i + 1;\n  }\n  getEndLineNumber(i) {\n    return i + 1;\n  }\n  createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n    const charCodes = [];\n    const lineNumbers = [];\n    const columns = [];\n    let len = 0;\n    for (let index = startIndex; index <= endIndex; index++) {\n      const lineContent = this.lines[index];\n      const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;\n      const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;\n      for (let col = startColumn; col < endColumn; col++) {\n        charCodes[len] = lineContent.charCodeAt(col - 1);\n        lineNumbers[len] = index + 1;\n        columns[len] = col;\n        len++;\n      }\n    }\n    return new CharSequence(charCodes, lineNumbers, columns);\n  }\n}\nclass CharSequence {\n  constructor(charCodes, lineNumbers, columns) {\n    this._charCodes = charCodes;\n    this._lineNumbers = lineNumbers;\n    this._columns = columns;\n  }\n  getElements() {\n    return this._charCodes;\n  }\n  getStartLineNumber(i) {\n    return this._lineNumbers[i];\n  }\n  getStartColumn(i) {\n    return this._columns[i];\n  }\n  getEndLineNumber(i) {\n    return this._lineNumbers[i];\n  }\n  getEndColumn(i) {\n    return this._columns[i] + 1;\n  }\n}\nclass CharChange {\n  constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalStartColumn = originalStartColumn;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.originalEndColumn = originalEndColumn;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedStartColumn = modifiedStartColumn;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.modifiedEndColumn = modifiedEndColumn;\n  }\n  static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n    let originalStartLineNumber;\n    let originalStartColumn;\n    let originalEndLineNumber;\n    let originalEndColumn;\n    let modifiedStartLineNumber;\n    let modifiedStartColumn;\n    let modifiedEndLineNumber;\n    let modifiedEndColumn;\n    if (diffChange.originalLength === 0) {\n      originalStartLineNumber = 0;\n      originalStartColumn = 0;\n      originalEndLineNumber = 0;\n      originalEndColumn = 0;\n    } else {\n      originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n      originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n      originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n      originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n    }\n    if (diffChange.modifiedLength === 0) {\n      modifiedStartLineNumber = 0;\n      modifiedStartColumn = 0;\n      modifiedEndLineNumber = 0;\n      modifiedEndColumn = 0;\n    } else {\n      modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n      modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n      modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    }\n    return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n  }\n}\nfunction postProcessCharChanges(rawChanges) {\n  if (rawChanges.length <= 1) {\n    return rawChanges;\n  }\n  const result = [rawChanges[0]];\n  let prevChange = result[0];\n  for (let i = 1, len = rawChanges.length; i < len; i++) {\n    const currChange = rawChanges[i];\n    const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n    const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n    // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n    const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n    if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n      // Merge the current change into the previous one\n      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;\n      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;\n    } else {\n      // Add the current change\n      result.push(currChange);\n      prevChange = currChange;\n    }\n  }\n  return result;\n}\nclass LineChange {\n  constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.charChanges = charChanges;\n  }\n  static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n    let originalStartLineNumber;\n    let originalEndLineNumber;\n    let modifiedStartLineNumber;\n    let modifiedEndLineNumber;\n    let charChanges = undefined;\n    if (diffChange.originalLength === 0) {\n      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n      originalEndLineNumber = 0;\n    } else {\n      originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n      originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n    }\n    if (diffChange.modifiedLength === 0) {\n      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n      modifiedEndLineNumber = 0;\n    } else {\n      modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n      modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n    }\n    if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n      // Compute character changes for diff chunks of at most 20 lines...\n      const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n      const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n      if (shouldPostProcessCharChanges) {\n        rawChanges = postProcessCharChanges(rawChanges);\n      }\n      charChanges = [];\n      for (let i = 0, length = rawChanges.length; i < length; i++) {\n        charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n      }\n    }\n    return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n  }\n}\nexport class DiffComputer {\n  constructor(originalLines, modifiedLines, opts) {\n    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n    this.originalLines = originalLines;\n    this.modifiedLines = modifiedLines;\n    this.original = new LineSequence(originalLines);\n    this.modified = new LineSequence(modifiedLines);\n    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n  }\n\n  computeDiff() {\n    if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n      // empty original => fast path\n      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n        return {\n          quitEarly: false,\n          changes: []\n        };\n      }\n      return {\n        quitEarly: false,\n        changes: [{\n          originalStartLineNumber: 1,\n          originalEndLineNumber: 1,\n          modifiedStartLineNumber: 1,\n          modifiedEndLineNumber: this.modified.lines.length,\n          charChanges: [{\n            modifiedEndColumn: 0,\n            modifiedEndLineNumber: 0,\n            modifiedStartColumn: 0,\n            modifiedStartLineNumber: 0,\n            originalEndColumn: 0,\n            originalEndLineNumber: 0,\n            originalStartColumn: 0,\n            originalStartLineNumber: 0\n          }]\n        }]\n      };\n    }\n    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n      // empty modified => fast path\n      return {\n        quitEarly: false,\n        changes: [{\n          originalStartLineNumber: 1,\n          originalEndLineNumber: this.original.lines.length,\n          modifiedStartLineNumber: 1,\n          modifiedEndLineNumber: 1,\n          charChanges: [{\n            modifiedEndColumn: 0,\n            modifiedEndLineNumber: 0,\n            modifiedStartColumn: 0,\n            modifiedStartLineNumber: 0,\n            originalEndColumn: 0,\n            originalEndLineNumber: 0,\n            originalStartColumn: 0,\n            originalStartLineNumber: 0\n          }]\n        }]\n      };\n    }\n    const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n    const rawChanges = diffResult.changes;\n    const quitEarly = diffResult.quitEarly;\n    // The diff is always computed with ignoring trim whitespace\n    // This ensures we get the prettiest diff\n    if (this.shouldIgnoreTrimWhitespace) {\n      const lineChanges = [];\n      for (let i = 0, length = rawChanges.length; i < length; i++) {\n        lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n      }\n      return {\n        quitEarly: quitEarly,\n        changes: lineChanges\n      };\n    }\n    // Need to post-process and introduce changes where the trim whitespace is different\n    // Note that we are looping starting at -1 to also cover the lines before the first change\n    const result = [];\n    let originalLineIndex = 0;\n    let modifiedLineIndex = 0;\n    for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n      const nextChange = i + 1 < len ? rawChanges[i + 1] : null;\n      const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;\n      const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;\n      while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n        const originalLine = this.originalLines[originalLineIndex];\n        const modifiedLine = this.modifiedLines[modifiedLineIndex];\n        if (originalLine !== modifiedLine) {\n          // These lines differ only in trim whitespace\n          // Check the leading whitespace\n          {\n            let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n            let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n            while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n              const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n              const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n              if (originalChar !== modifiedChar) {\n                break;\n              }\n              originalStartColumn--;\n              modifiedStartColumn--;\n            }\n            if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n            }\n          }\n          // Check the trailing whitespace\n          {\n            let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n            let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n            const originalMaxColumn = originalLine.length + 1;\n            const modifiedMaxColumn = modifiedLine.length + 1;\n            while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n              const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n              const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n              if (originalChar !== modifiedChar) {\n                break;\n              }\n              originalEndColumn++;\n              modifiedEndColumn++;\n            }\n            if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n              this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n            }\n          }\n        }\n        originalLineIndex++;\n        modifiedLineIndex++;\n      }\n      if (nextChange) {\n        // Emit the actual change\n        result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n        originalLineIndex += nextChange.originalLength;\n        modifiedLineIndex += nextChange.modifiedLength;\n      }\n    }\n    return {\n      quitEarly: quitEarly,\n      changes: result\n    };\n  }\n  _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n    if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n      // Merged into previous\n      return;\n    }\n    let charChanges = undefined;\n    if (this.shouldComputeCharChanges) {\n      charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n    }\n    result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n  }\n  _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n    const len = result.length;\n    if (len === 0) {\n      return false;\n    }\n    const prevChange = result[len - 1];\n    if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n      // Don't merge with inserts/deletes\n      return false;\n    }\n    if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n      prevChange.originalEndLineNumber = originalLineNumber;\n      prevChange.modifiedEndLineNumber = modifiedLineNumber;\n      if (this.shouldComputeCharChanges && prevChange.charChanges) {\n        prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n      }\n      return true;\n    }\n    return false;\n  }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n  const r = strings.firstNonWhitespaceIndex(txt);\n  if (r === -1) {\n    return defaultValue;\n  }\n  return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n  const r = strings.lastNonWhitespaceIndex(txt);\n  if (r === -1) {\n    return defaultValue;\n  }\n  return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n  if (maximumRuntime === 0) {\n    return () => true;\n  }\n  const startTime = Date.now();\n  return () => {\n    return Date.now() - startTime < maximumRuntime;\n  };\n}","map":{"version":3,"names":["LcsDiff","strings","MINIMUM_MATCHING_CHARACTER_LENGTH","computeDiff","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","diffAlgo","ComputeDiff","LineSequence","constructor","lines","startColumns","endColumns","i","length","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","getElements","elements","len","substring","getStartLineNumber","getEndLineNumber","createCharSequence","shouldIgnoreTrimWhitespace","startIndex","endIndex","charCodes","lineNumbers","columns","index","lineContent","startColumn","endColumn","col","charCodeAt","CharSequence","_charCodes","_lineNumbers","_columns","getStartColumn","getEndColumn","CharChange","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","createFromDiffChange","diffChange","originalCharSequence","modifiedCharSequence","originalLength","originalStart","modifiedLength","modifiedStart","postProcessCharChanges","rawChanges","result","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","matchingLength","Math","min","push","LineChange","charChanges","createFromDiffResult","originalLineSequence","modifiedLineSequence","continueCharDiff","shouldComputeCharChanges","shouldPostProcessCharChanges","undefined","changes","DiffComputer","originalLines","modifiedLines","opts","shouldMakePrettyDiff","original","modified","continueLineDiff","createContinueProcessingPredicate","maxComputationTime","quitEarly","diffResult","lineChanges","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","originalChar","modifiedChar","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","r","firstNonWhitespaceIndex","lastNonWhitespaceIndex","maximumRuntime","startTime","Date","now"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\r\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\r\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\r\n    return diffAlgo.ComputeDiff(pretty);\r\n}\r\nclass LineSequence {\r\n    constructor(lines) {\r\n        const startColumns = [];\r\n        const endColumns = [];\r\n        for (let i = 0, length = lines.length; i < length; i++) {\r\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\r\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\r\n        }\r\n        this.lines = lines;\r\n        this._startColumns = startColumns;\r\n        this._endColumns = endColumns;\r\n    }\r\n    getElements() {\r\n        const elements = [];\r\n        for (let i = 0, len = this.lines.length; i < len; i++) {\r\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\r\n        }\r\n        return elements;\r\n    }\r\n    getStartLineNumber(i) {\r\n        return i + 1;\r\n    }\r\n    getEndLineNumber(i) {\r\n        return i + 1;\r\n    }\r\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\r\n        const charCodes = [];\r\n        const lineNumbers = [];\r\n        const columns = [];\r\n        let len = 0;\r\n        for (let index = startIndex; index <= endIndex; index++) {\r\n            const lineContent = this.lines[index];\r\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\r\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\r\n            for (let col = startColumn; col < endColumn; col++) {\r\n                charCodes[len] = lineContent.charCodeAt(col - 1);\r\n                lineNumbers[len] = index + 1;\r\n                columns[len] = col;\r\n                len++;\r\n            }\r\n        }\r\n        return new CharSequence(charCodes, lineNumbers, columns);\r\n    }\r\n}\r\nclass CharSequence {\r\n    constructor(charCodes, lineNumbers, columns) {\r\n        this._charCodes = charCodes;\r\n        this._lineNumbers = lineNumbers;\r\n        this._columns = columns;\r\n    }\r\n    getElements() {\r\n        return this._charCodes;\r\n    }\r\n    getStartLineNumber(i) {\r\n        return this._lineNumbers[i];\r\n    }\r\n    getStartColumn(i) {\r\n        return this._columns[i];\r\n    }\r\n    getEndLineNumber(i) {\r\n        return this._lineNumbers[i];\r\n    }\r\n    getEndColumn(i) {\r\n        return this._columns[i] + 1;\r\n    }\r\n}\r\nclass CharChange {\r\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\r\n        this.originalStartLineNumber = originalStartLineNumber;\r\n        this.originalStartColumn = originalStartColumn;\r\n        this.originalEndLineNumber = originalEndLineNumber;\r\n        this.originalEndColumn = originalEndColumn;\r\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\r\n        this.modifiedStartColumn = modifiedStartColumn;\r\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\r\n        this.modifiedEndColumn = modifiedEndColumn;\r\n    }\r\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\r\n        let originalStartLineNumber;\r\n        let originalStartColumn;\r\n        let originalEndLineNumber;\r\n        let originalEndColumn;\r\n        let modifiedStartLineNumber;\r\n        let modifiedStartColumn;\r\n        let modifiedEndLineNumber;\r\n        let modifiedEndColumn;\r\n        if (diffChange.originalLength === 0) {\r\n            originalStartLineNumber = 0;\r\n            originalStartColumn = 0;\r\n            originalEndLineNumber = 0;\r\n            originalEndColumn = 0;\r\n        }\r\n        else {\r\n            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\r\n            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\r\n            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\r\n            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\r\n        }\r\n        if (diffChange.modifiedLength === 0) {\r\n            modifiedStartLineNumber = 0;\r\n            modifiedStartColumn = 0;\r\n            modifiedEndLineNumber = 0;\r\n            modifiedEndColumn = 0;\r\n        }\r\n        else {\r\n            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\r\n            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\r\n            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n        }\r\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\r\n    }\r\n}\r\nfunction postProcessCharChanges(rawChanges) {\r\n    if (rawChanges.length <= 1) {\r\n        return rawChanges;\r\n    }\r\n    const result = [rawChanges[0]];\r\n    let prevChange = result[0];\r\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\r\n        const currChange = rawChanges[i];\r\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\r\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\r\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\r\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\r\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\r\n            // Merge the current change into the previous one\r\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\r\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\r\n        }\r\n        else {\r\n            // Add the current change\r\n            result.push(currChange);\r\n            prevChange = currChange;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nclass LineChange {\r\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\r\n        this.originalStartLineNumber = originalStartLineNumber;\r\n        this.originalEndLineNumber = originalEndLineNumber;\r\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\r\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\r\n        this.charChanges = charChanges;\r\n    }\r\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\r\n        let originalStartLineNumber;\r\n        let originalEndLineNumber;\r\n        let modifiedStartLineNumber;\r\n        let modifiedEndLineNumber;\r\n        let charChanges = undefined;\r\n        if (diffChange.originalLength === 0) {\r\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\r\n            originalEndLineNumber = 0;\r\n        }\r\n        else {\r\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\r\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\r\n        }\r\n        if (diffChange.modifiedLength === 0) {\r\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\r\n            modifiedEndLineNumber = 0;\r\n        }\r\n        else {\r\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\r\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n        }\r\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\r\n            // Compute character changes for diff chunks of at most 20 lines...\r\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\r\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\r\n            if (shouldPostProcessCharChanges) {\r\n                rawChanges = postProcessCharChanges(rawChanges);\r\n            }\r\n            charChanges = [];\r\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\r\n                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\r\n            }\r\n        }\r\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\r\n    }\r\n}\r\nexport class DiffComputer {\r\n    constructor(originalLines, modifiedLines, opts) {\r\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\r\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\r\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\r\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\r\n        this.originalLines = originalLines;\r\n        this.modifiedLines = modifiedLines;\r\n        this.original = new LineSequence(originalLines);\r\n        this.modified = new LineSequence(modifiedLines);\r\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\r\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\r\n    }\r\n    computeDiff() {\r\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\r\n            // empty original => fast path\r\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\r\n                return {\r\n                    quitEarly: false,\r\n                    changes: []\r\n                };\r\n            }\r\n            return {\r\n                quitEarly: false,\r\n                changes: [{\r\n                        originalStartLineNumber: 1,\r\n                        originalEndLineNumber: 1,\r\n                        modifiedStartLineNumber: 1,\r\n                        modifiedEndLineNumber: this.modified.lines.length,\r\n                        charChanges: [{\r\n                                modifiedEndColumn: 0,\r\n                                modifiedEndLineNumber: 0,\r\n                                modifiedStartColumn: 0,\r\n                                modifiedStartLineNumber: 0,\r\n                                originalEndColumn: 0,\r\n                                originalEndLineNumber: 0,\r\n                                originalStartColumn: 0,\r\n                                originalStartLineNumber: 0\r\n                            }]\r\n                    }]\r\n            };\r\n        }\r\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\r\n            // empty modified => fast path\r\n            return {\r\n                quitEarly: false,\r\n                changes: [{\r\n                        originalStartLineNumber: 1,\r\n                        originalEndLineNumber: this.original.lines.length,\r\n                        modifiedStartLineNumber: 1,\r\n                        modifiedEndLineNumber: 1,\r\n                        charChanges: [{\r\n                                modifiedEndColumn: 0,\r\n                                modifiedEndLineNumber: 0,\r\n                                modifiedStartColumn: 0,\r\n                                modifiedStartLineNumber: 0,\r\n                                originalEndColumn: 0,\r\n                                originalEndLineNumber: 0,\r\n                                originalStartColumn: 0,\r\n                                originalStartLineNumber: 0\r\n                            }]\r\n                    }]\r\n            };\r\n        }\r\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\r\n        const rawChanges = diffResult.changes;\r\n        const quitEarly = diffResult.quitEarly;\r\n        // The diff is always computed with ignoring trim whitespace\r\n        // This ensures we get the prettiest diff\r\n        if (this.shouldIgnoreTrimWhitespace) {\r\n            const lineChanges = [];\r\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\r\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\r\n            }\r\n            return {\r\n                quitEarly: quitEarly,\r\n                changes: lineChanges\r\n            };\r\n        }\r\n        // Need to post-process and introduce changes where the trim whitespace is different\r\n        // Note that we are looping starting at -1 to also cover the lines before the first change\r\n        const result = [];\r\n        let originalLineIndex = 0;\r\n        let modifiedLineIndex = 0;\r\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\r\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\r\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\r\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\r\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\r\n                const originalLine = this.originalLines[originalLineIndex];\r\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\r\n                if (originalLine !== modifiedLine) {\r\n                    // These lines differ only in trim whitespace\r\n                    // Check the leading whitespace\r\n                    {\r\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\r\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\r\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\r\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\r\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\r\n                            if (originalChar !== modifiedChar) {\r\n                                break;\r\n                            }\r\n                            originalStartColumn--;\r\n                            modifiedStartColumn--;\r\n                        }\r\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\r\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\r\n                        }\r\n                    }\r\n                    // Check the trailing whitespace\r\n                    {\r\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\r\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\r\n                        const originalMaxColumn = originalLine.length + 1;\r\n                        const modifiedMaxColumn = modifiedLine.length + 1;\r\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\r\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\r\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\r\n                            if (originalChar !== modifiedChar) {\r\n                                break;\r\n                            }\r\n                            originalEndColumn++;\r\n                            modifiedEndColumn++;\r\n                        }\r\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\r\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\r\n                        }\r\n                    }\r\n                }\r\n                originalLineIndex++;\r\n                modifiedLineIndex++;\r\n            }\r\n            if (nextChange) {\r\n                // Emit the actual change\r\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\r\n                originalLineIndex += nextChange.originalLength;\r\n                modifiedLineIndex += nextChange.modifiedLength;\r\n            }\r\n        }\r\n        return {\r\n            quitEarly: quitEarly,\r\n            changes: result\r\n        };\r\n    }\r\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\r\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\r\n            // Merged into previous\r\n            return;\r\n        }\r\n        let charChanges = undefined;\r\n        if (this.shouldComputeCharChanges) {\r\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\r\n        }\r\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\r\n    }\r\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\r\n        const len = result.length;\r\n        if (len === 0) {\r\n            return false;\r\n        }\r\n        const prevChange = result[len - 1];\r\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\r\n            // Don't merge with inserts/deletes\r\n            return false;\r\n        }\r\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\r\n            prevChange.originalEndLineNumber = originalLineNumber;\r\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\r\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\r\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nfunction getFirstNonBlankColumn(txt, defaultValue) {\r\n    const r = strings.firstNonWhitespaceIndex(txt);\r\n    if (r === -1) {\r\n        return defaultValue;\r\n    }\r\n    return r + 1;\r\n}\r\nfunction getLastNonBlankColumn(txt, defaultValue) {\r\n    const r = strings.lastNonWhitespaceIndex(txt);\r\n    if (r === -1) {\r\n        return defaultValue;\r\n    }\r\n    return r + 2;\r\n}\r\nfunction createContinueProcessingPredicate(maximumRuntime) {\r\n    if (maximumRuntime === 0) {\r\n        return () => true;\r\n    }\r\n    const startTime = Date.now();\r\n    return () => {\r\n        return Date.now() - startTime < maximumRuntime;\r\n    };\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,OAAO,QAAQ,mCAAmC;AAC3D,OAAO,KAAKC,OAAO,MAAM,iCAAiC;AAC1D,MAAMC,iCAAiC,GAAG,CAAC;AAC3C,SAASC,WAAWA,CAACC,gBAAgB,EAAEC,gBAAgB,EAAEC,2BAA2B,EAAEC,MAAM,EAAE;EAC1F,MAAMC,QAAQ,GAAG,IAAIR,OAAO,CAACI,gBAAgB,EAAEC,gBAAgB,EAAEC,2BAA2B,CAAC;EAC7F,OAAOE,QAAQ,CAACC,WAAW,CAACF,MAAM,CAAC;AACvC;AACA,MAAMG,YAAY,CAAC;EACfC,WAAWA,CAACC,KAAK,EAAE;IACf,MAAMC,YAAY,GAAG,EAAE;IACvB,MAAMC,UAAU,GAAG,EAAE;IACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,MAAM,GAAGJ,KAAK,CAACI,MAAM,EAAED,CAAC,GAAGC,MAAM,EAAED,CAAC,EAAE,EAAE;MACpDF,YAAY,CAACE,CAAC,CAAC,GAAGE,sBAAsB,CAACL,KAAK,CAACG,CAAC,CAAC,EAAE,CAAC,CAAC;MACrDD,UAAU,CAACC,CAAC,CAAC,GAAGG,qBAAqB,CAACN,KAAK,CAACG,CAAC,CAAC,EAAE,CAAC,CAAC;IACtD;IACA,IAAI,CAACH,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACO,aAAa,GAAGN,YAAY;IACjC,IAAI,CAACO,WAAW,GAAGN,UAAU;EACjC;EACAO,WAAWA,CAAA,EAAG;IACV,MAAMC,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEQ,GAAG,GAAG,IAAI,CAACX,KAAK,CAACI,MAAM,EAAED,CAAC,GAAGQ,GAAG,EAAER,CAAC,EAAE,EAAE;MACnDO,QAAQ,CAACP,CAAC,CAAC,GAAG,IAAI,CAACH,KAAK,CAACG,CAAC,CAAC,CAACS,SAAS,CAAC,IAAI,CAACL,aAAa,CAACJ,CAAC,CAAC,GAAG,CAAC,EAAE,IAAI,CAACK,WAAW,CAACL,CAAC,CAAC,GAAG,CAAC,CAAC;IAC7F;IACA,OAAOO,QAAQ;EACnB;EACAG,kBAAkBA,CAACV,CAAC,EAAE;IAClB,OAAOA,CAAC,GAAG,CAAC;EAChB;EACAW,gBAAgBA,CAACX,CAAC,EAAE;IAChB,OAAOA,CAAC,GAAG,CAAC;EAChB;EACAY,kBAAkBA,CAACC,0BAA0B,EAAEC,UAAU,EAAEC,QAAQ,EAAE;IACjE,MAAMC,SAAS,GAAG,EAAE;IACpB,MAAMC,WAAW,GAAG,EAAE;IACtB,MAAMC,OAAO,GAAG,EAAE;IAClB,IAAIV,GAAG,GAAG,CAAC;IACX,KAAK,IAAIW,KAAK,GAAGL,UAAU,EAAEK,KAAK,IAAIJ,QAAQ,EAAEI,KAAK,EAAE,EAAE;MACrD,MAAMC,WAAW,GAAG,IAAI,CAACvB,KAAK,CAACsB,KAAK,CAAC;MACrC,MAAME,WAAW,GAAIR,0BAA0B,GAAG,IAAI,CAACT,aAAa,CAACe,KAAK,CAAC,GAAG,CAAE;MAChF,MAAMG,SAAS,GAAIT,0BAA0B,GAAG,IAAI,CAACR,WAAW,CAACc,KAAK,CAAC,GAAGC,WAAW,CAACnB,MAAM,GAAG,CAAE;MACjG,KAAK,IAAIsB,GAAG,GAAGF,WAAW,EAAEE,GAAG,GAAGD,SAAS,EAAEC,GAAG,EAAE,EAAE;QAChDP,SAAS,CAACR,GAAG,CAAC,GAAGY,WAAW,CAACI,UAAU,CAACD,GAAG,GAAG,CAAC,CAAC;QAChDN,WAAW,CAACT,GAAG,CAAC,GAAGW,KAAK,GAAG,CAAC;QAC5BD,OAAO,CAACV,GAAG,CAAC,GAAGe,GAAG;QAClBf,GAAG,EAAE;MACT;IACJ;IACA,OAAO,IAAIiB,YAAY,CAACT,SAAS,EAAEC,WAAW,EAAEC,OAAO,CAAC;EAC5D;AACJ;AACA,MAAMO,YAAY,CAAC;EACf7B,WAAWA,CAACoB,SAAS,EAAEC,WAAW,EAAEC,OAAO,EAAE;IACzC,IAAI,CAACQ,UAAU,GAAGV,SAAS;IAC3B,IAAI,CAACW,YAAY,GAAGV,WAAW;IAC/B,IAAI,CAACW,QAAQ,GAAGV,OAAO;EAC3B;EACAZ,WAAWA,CAAA,EAAG;IACV,OAAO,IAAI,CAACoB,UAAU;EAC1B;EACAhB,kBAAkBA,CAACV,CAAC,EAAE;IAClB,OAAO,IAAI,CAAC2B,YAAY,CAAC3B,CAAC,CAAC;EAC/B;EACA6B,cAAcA,CAAC7B,CAAC,EAAE;IACd,OAAO,IAAI,CAAC4B,QAAQ,CAAC5B,CAAC,CAAC;EAC3B;EACAW,gBAAgBA,CAACX,CAAC,EAAE;IAChB,OAAO,IAAI,CAAC2B,YAAY,CAAC3B,CAAC,CAAC;EAC/B;EACA8B,YAAYA,CAAC9B,CAAC,EAAE;IACZ,OAAO,IAAI,CAAC4B,QAAQ,CAAC5B,CAAC,CAAC,GAAG,CAAC;EAC/B;AACJ;AACA,MAAM+B,UAAU,CAAC;EACbnC,WAAWA,CAACoC,uBAAuB,EAAEC,mBAAmB,EAAEC,qBAAqB,EAAEC,iBAAiB,EAAEC,uBAAuB,EAAEC,mBAAmB,EAAEC,qBAAqB,EAAEC,iBAAiB,EAAE;IACxL,IAAI,CAACP,uBAAuB,GAAGA,uBAAuB;IACtD,IAAI,CAACC,mBAAmB,GAAGA,mBAAmB;IAC9C,IAAI,CAACC,qBAAqB,GAAGA,qBAAqB;IAClD,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACC,uBAAuB,GAAGA,uBAAuB;IACtD,IAAI,CAACC,mBAAmB,GAAGA,mBAAmB;IAC9C,IAAI,CAACC,qBAAqB,GAAGA,qBAAqB;IAClD,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;EAC9C;EACA,OAAOC,oBAAoBA,CAACC,UAAU,EAAEC,oBAAoB,EAAEC,oBAAoB,EAAE;IAChF,IAAIX,uBAAuB;IAC3B,IAAIC,mBAAmB;IACvB,IAAIC,qBAAqB;IACzB,IAAIC,iBAAiB;IACrB,IAAIC,uBAAuB;IAC3B,IAAIC,mBAAmB;IACvB,IAAIC,qBAAqB;IACzB,IAAIC,iBAAiB;IACrB,IAAIE,UAAU,CAACG,cAAc,KAAK,CAAC,EAAE;MACjCZ,uBAAuB,GAAG,CAAC;MAC3BC,mBAAmB,GAAG,CAAC;MACvBC,qBAAqB,GAAG,CAAC;MACzBC,iBAAiB,GAAG,CAAC;IACzB,CAAC,MACI;MACDH,uBAAuB,GAAGU,oBAAoB,CAAChC,kBAAkB,CAAC+B,UAAU,CAACI,aAAa,CAAC;MAC3FZ,mBAAmB,GAAGS,oBAAoB,CAACb,cAAc,CAACY,UAAU,CAACI,aAAa,CAAC;MACnFX,qBAAqB,GAAGQ,oBAAoB,CAAC/B,gBAAgB,CAAC8B,UAAU,CAACI,aAAa,GAAGJ,UAAU,CAACG,cAAc,GAAG,CAAC,CAAC;MACvHT,iBAAiB,GAAGO,oBAAoB,CAACZ,YAAY,CAACW,UAAU,CAACI,aAAa,GAAGJ,UAAU,CAACG,cAAc,GAAG,CAAC,CAAC;IACnH;IACA,IAAIH,UAAU,CAACK,cAAc,KAAK,CAAC,EAAE;MACjCV,uBAAuB,GAAG,CAAC;MAC3BC,mBAAmB,GAAG,CAAC;MACvBC,qBAAqB,GAAG,CAAC;MACzBC,iBAAiB,GAAG,CAAC;IACzB,CAAC,MACI;MACDH,uBAAuB,GAAGO,oBAAoB,CAACjC,kBAAkB,CAAC+B,UAAU,CAACM,aAAa,CAAC;MAC3FV,mBAAmB,GAAGM,oBAAoB,CAACd,cAAc,CAACY,UAAU,CAACM,aAAa,CAAC;MACnFT,qBAAqB,GAAGK,oBAAoB,CAAChC,gBAAgB,CAAC8B,UAAU,CAACM,aAAa,GAAGN,UAAU,CAACK,cAAc,GAAG,CAAC,CAAC;MACvHP,iBAAiB,GAAGI,oBAAoB,CAACb,YAAY,CAACW,UAAU,CAACM,aAAa,GAAGN,UAAU,CAACK,cAAc,GAAG,CAAC,CAAC;IACnH;IACA,OAAO,IAAIf,UAAU,CAACC,uBAAuB,EAAEC,mBAAmB,EAAEC,qBAAqB,EAAEC,iBAAiB,EAAEC,uBAAuB,EAAEC,mBAAmB,EAAEC,qBAAqB,EAAEC,iBAAiB,CAAC;EACzM;AACJ;AACA,SAASS,sBAAsBA,CAACC,UAAU,EAAE;EACxC,IAAIA,UAAU,CAAChD,MAAM,IAAI,CAAC,EAAE;IACxB,OAAOgD,UAAU;EACrB;EACA,MAAMC,MAAM,GAAG,CAACD,UAAU,CAAC,CAAC,CAAC,CAAC;EAC9B,IAAIE,UAAU,GAAGD,MAAM,CAAC,CAAC,CAAC;EAC1B,KAAK,IAAIlD,CAAC,GAAG,CAAC,EAAEQ,GAAG,GAAGyC,UAAU,CAAChD,MAAM,EAAED,CAAC,GAAGQ,GAAG,EAAER,CAAC,EAAE,EAAE;IACnD,MAAMoD,UAAU,GAAGH,UAAU,CAACjD,CAAC,CAAC;IAChC,MAAMqD,sBAAsB,GAAGD,UAAU,CAACP,aAAa,IAAIM,UAAU,CAACN,aAAa,GAAGM,UAAU,CAACP,cAAc,CAAC;IAChH,MAAMU,sBAAsB,GAAGF,UAAU,CAACL,aAAa,IAAII,UAAU,CAACJ,aAAa,GAAGI,UAAU,CAACL,cAAc,CAAC;IAChH;IACA,MAAMS,cAAc,GAAGC,IAAI,CAACC,GAAG,CAACJ,sBAAsB,EAAEC,sBAAsB,CAAC;IAC/E,IAAIC,cAAc,GAAGpE,iCAAiC,EAAE;MACpD;MACAgE,UAAU,CAACP,cAAc,GAAIQ,UAAU,CAACP,aAAa,GAAGO,UAAU,CAACR,cAAc,GAAIO,UAAU,CAACN,aAAa;MAC7GM,UAAU,CAACL,cAAc,GAAIM,UAAU,CAACL,aAAa,GAAGK,UAAU,CAACN,cAAc,GAAIK,UAAU,CAACJ,aAAa;IACjH,CAAC,MACI;MACD;MACAG,MAAM,CAACQ,IAAI,CAACN,UAAU,CAAC;MACvBD,UAAU,GAAGC,UAAU;IAC3B;EACJ;EACA,OAAOF,MAAM;AACjB;AACA,MAAMS,UAAU,CAAC;EACb/D,WAAWA,CAACoC,uBAAuB,EAAEE,qBAAqB,EAAEE,uBAAuB,EAAEE,qBAAqB,EAAEsB,WAAW,EAAE;IACrH,IAAI,CAAC5B,uBAAuB,GAAGA,uBAAuB;IACtD,IAAI,CAACE,qBAAqB,GAAGA,qBAAqB;IAClD,IAAI,CAACE,uBAAuB,GAAGA,uBAAuB;IACtD,IAAI,CAACE,qBAAqB,GAAGA,qBAAqB;IAClD,IAAI,CAACsB,WAAW,GAAGA,WAAW;EAClC;EACA,OAAOC,oBAAoBA,CAAChD,0BAA0B,EAAE4B,UAAU,EAAEqB,oBAAoB,EAAEC,oBAAoB,EAAEC,gBAAgB,EAAEC,wBAAwB,EAAEC,4BAA4B,EAAE;IACtL,IAAIlC,uBAAuB;IAC3B,IAAIE,qBAAqB;IACzB,IAAIE,uBAAuB;IAC3B,IAAIE,qBAAqB;IACzB,IAAIsB,WAAW,GAAGO,SAAS;IAC3B,IAAI1B,UAAU,CAACG,cAAc,KAAK,CAAC,EAAE;MACjCZ,uBAAuB,GAAG8B,oBAAoB,CAACpD,kBAAkB,CAAC+B,UAAU,CAACI,aAAa,CAAC,GAAG,CAAC;MAC/FX,qBAAqB,GAAG,CAAC;IAC7B,CAAC,MACI;MACDF,uBAAuB,GAAG8B,oBAAoB,CAACpD,kBAAkB,CAAC+B,UAAU,CAACI,aAAa,CAAC;MAC3FX,qBAAqB,GAAG4B,oBAAoB,CAACnD,gBAAgB,CAAC8B,UAAU,CAACI,aAAa,GAAGJ,UAAU,CAACG,cAAc,GAAG,CAAC,CAAC;IAC3H;IACA,IAAIH,UAAU,CAACK,cAAc,KAAK,CAAC,EAAE;MACjCV,uBAAuB,GAAG2B,oBAAoB,CAACrD,kBAAkB,CAAC+B,UAAU,CAACM,aAAa,CAAC,GAAG,CAAC;MAC/FT,qBAAqB,GAAG,CAAC;IAC7B,CAAC,MACI;MACDF,uBAAuB,GAAG2B,oBAAoB,CAACrD,kBAAkB,CAAC+B,UAAU,CAACM,aAAa,CAAC;MAC3FT,qBAAqB,GAAGyB,oBAAoB,CAACpD,gBAAgB,CAAC8B,UAAU,CAACM,aAAa,GAAGN,UAAU,CAACK,cAAc,GAAG,CAAC,CAAC;IAC3H;IACA,IAAImB,wBAAwB,IAAIxB,UAAU,CAACG,cAAc,GAAG,CAAC,IAAIH,UAAU,CAACG,cAAc,GAAG,EAAE,IAAIH,UAAU,CAACK,cAAc,GAAG,CAAC,IAAIL,UAAU,CAACK,cAAc,GAAG,EAAE,IAAIkB,gBAAgB,CAAC,CAAC,EAAE;MACtL;MACA,MAAMtB,oBAAoB,GAAGoB,oBAAoB,CAAClD,kBAAkB,CAACC,0BAA0B,EAAE4B,UAAU,CAACI,aAAa,EAAEJ,UAAU,CAACI,aAAa,GAAGJ,UAAU,CAACG,cAAc,GAAG,CAAC,CAAC;MACpL,MAAMD,oBAAoB,GAAGoB,oBAAoB,CAACnD,kBAAkB,CAACC,0BAA0B,EAAE4B,UAAU,CAACM,aAAa,EAAEN,UAAU,CAACM,aAAa,GAAGN,UAAU,CAACK,cAAc,GAAG,CAAC,CAAC;MACpL,IAAIG,UAAU,GAAG7D,WAAW,CAACsD,oBAAoB,EAAEC,oBAAoB,EAAEqB,gBAAgB,EAAE,IAAI,CAAC,CAACI,OAAO;MACxG,IAAIF,4BAA4B,EAAE;QAC9BjB,UAAU,GAAGD,sBAAsB,CAACC,UAAU,CAAC;MACnD;MACAW,WAAW,GAAG,EAAE;MAChB,KAAK,IAAI5D,CAAC,GAAG,CAAC,EAAEC,MAAM,GAAGgD,UAAU,CAAChD,MAAM,EAAED,CAAC,GAAGC,MAAM,EAAED,CAAC,EAAE,EAAE;QACzD4D,WAAW,CAACF,IAAI,CAAC3B,UAAU,CAACS,oBAAoB,CAACS,UAAU,CAACjD,CAAC,CAAC,EAAE0C,oBAAoB,EAAEC,oBAAoB,CAAC,CAAC;MAChH;IACJ;IACA,OAAO,IAAIgB,UAAU,CAAC3B,uBAAuB,EAAEE,qBAAqB,EAAEE,uBAAuB,EAAEE,qBAAqB,EAAEsB,WAAW,CAAC;EACtI;AACJ;AACA,OAAO,MAAMS,YAAY,CAAC;EACtBzE,WAAWA,CAAC0E,aAAa,EAAEC,aAAa,EAAEC,IAAI,EAAE;IAC5C,IAAI,CAACP,wBAAwB,GAAGO,IAAI,CAACP,wBAAwB;IAC7D,IAAI,CAACC,4BAA4B,GAAGM,IAAI,CAACN,4BAA4B;IACrE,IAAI,CAACrD,0BAA0B,GAAG2D,IAAI,CAAC3D,0BAA0B;IACjE,IAAI,CAAC4D,oBAAoB,GAAGD,IAAI,CAACC,oBAAoB;IACrD,IAAI,CAACH,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACG,QAAQ,GAAG,IAAI/E,YAAY,CAAC2E,aAAa,CAAC;IAC/C,IAAI,CAACK,QAAQ,GAAG,IAAIhF,YAAY,CAAC4E,aAAa,CAAC;IAC/C,IAAI,CAACK,gBAAgB,GAAGC,iCAAiC,CAACL,IAAI,CAACM,kBAAkB,CAAC;IAClF,IAAI,CAACd,gBAAgB,GAAGa,iCAAiC,CAACL,IAAI,CAACM,kBAAkB,KAAK,CAAC,GAAG,CAAC,GAAGtB,IAAI,CAACC,GAAG,CAACe,IAAI,CAACM,kBAAkB,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;EAC5I;;EACA1F,WAAWA,CAAA,EAAG;IACV,IAAI,IAAI,CAACsF,QAAQ,CAAC7E,KAAK,CAACI,MAAM,KAAK,CAAC,IAAI,IAAI,CAACyE,QAAQ,CAAC7E,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,KAAK,CAAC,EAAE;MACzE;MACA,IAAI,IAAI,CAAC0E,QAAQ,CAAC9E,KAAK,CAACI,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC0E,QAAQ,CAAC9E,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,KAAK,CAAC,EAAE;QACzE,OAAO;UACH8E,SAAS,EAAE,KAAK;UAChBX,OAAO,EAAE;QACb,CAAC;MACL;MACA,OAAO;QACHW,SAAS,EAAE,KAAK;QAChBX,OAAO,EAAE,CAAC;UACFpC,uBAAuB,EAAE,CAAC;UAC1BE,qBAAqB,EAAE,CAAC;UACxBE,uBAAuB,EAAE,CAAC;UAC1BE,qBAAqB,EAAE,IAAI,CAACqC,QAAQ,CAAC9E,KAAK,CAACI,MAAM;UACjD2D,WAAW,EAAE,CAAC;YACNrB,iBAAiB,EAAE,CAAC;YACpBD,qBAAqB,EAAE,CAAC;YACxBD,mBAAmB,EAAE,CAAC;YACtBD,uBAAuB,EAAE,CAAC;YAC1BD,iBAAiB,EAAE,CAAC;YACpBD,qBAAqB,EAAE,CAAC;YACxBD,mBAAmB,EAAE,CAAC;YACtBD,uBAAuB,EAAE;UAC7B,CAAC;QACT,CAAC;MACT,CAAC;IACL;IACA,IAAI,IAAI,CAAC2C,QAAQ,CAAC9E,KAAK,CAACI,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC0E,QAAQ,CAAC9E,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,KAAK,CAAC,EAAE;MACzE;MACA,OAAO;QACH8E,SAAS,EAAE,KAAK;QAChBX,OAAO,EAAE,CAAC;UACFpC,uBAAuB,EAAE,CAAC;UAC1BE,qBAAqB,EAAE,IAAI,CAACwC,QAAQ,CAAC7E,KAAK,CAACI,MAAM;UACjDmC,uBAAuB,EAAE,CAAC;UAC1BE,qBAAqB,EAAE,CAAC;UACxBsB,WAAW,EAAE,CAAC;YACNrB,iBAAiB,EAAE,CAAC;YACpBD,qBAAqB,EAAE,CAAC;YACxBD,mBAAmB,EAAE,CAAC;YACtBD,uBAAuB,EAAE,CAAC;YAC1BD,iBAAiB,EAAE,CAAC;YACpBD,qBAAqB,EAAE,CAAC;YACxBD,mBAAmB,EAAE,CAAC;YACtBD,uBAAuB,EAAE;UAC7B,CAAC;QACT,CAAC;MACT,CAAC;IACL;IACA,MAAMgD,UAAU,GAAG5F,WAAW,CAAC,IAAI,CAACsF,QAAQ,EAAE,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACC,gBAAgB,EAAE,IAAI,CAACH,oBAAoB,CAAC;IAC9G,MAAMxB,UAAU,GAAG+B,UAAU,CAACZ,OAAO;IACrC,MAAMW,SAAS,GAAGC,UAAU,CAACD,SAAS;IACtC;IACA;IACA,IAAI,IAAI,CAAClE,0BAA0B,EAAE;MACjC,MAAMoE,WAAW,GAAG,EAAE;MACtB,KAAK,IAAIjF,CAAC,GAAG,CAAC,EAAEC,MAAM,GAAGgD,UAAU,CAAChD,MAAM,EAAED,CAAC,GAAGC,MAAM,EAAED,CAAC,EAAE,EAAE;QACzDiF,WAAW,CAACvB,IAAI,CAACC,UAAU,CAACE,oBAAoB,CAAC,IAAI,CAAChD,0BAA0B,EAAEoC,UAAU,CAACjD,CAAC,CAAC,EAAE,IAAI,CAAC0E,QAAQ,EAAE,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACX,gBAAgB,EAAE,IAAI,CAACC,wBAAwB,EAAE,IAAI,CAACC,4BAA4B,CAAC,CAAC;MAC5N;MACA,OAAO;QACHa,SAAS,EAAEA,SAAS;QACpBX,OAAO,EAAEa;MACb,CAAC;IACL;IACA;IACA;IACA,MAAM/B,MAAM,GAAG,EAAE;IACjB,IAAIgC,iBAAiB,GAAG,CAAC;IACzB,IAAIC,iBAAiB,GAAG,CAAC;IACzB,KAAK,IAAInF,CAAC,GAAG,CAAC,CAAC,CAAC,YAAYQ,GAAG,GAAGyC,UAAU,CAAChD,MAAM,EAAED,CAAC,GAAGQ,GAAG,EAAER,CAAC,EAAE,EAAE;MAC/D,MAAMoF,UAAU,GAAIpF,CAAC,GAAG,CAAC,GAAGQ,GAAG,GAAGyC,UAAU,CAACjD,CAAC,GAAG,CAAC,CAAC,GAAG,IAAK;MAC3D,MAAMqF,YAAY,GAAID,UAAU,GAAGA,UAAU,CAACvC,aAAa,GAAG,IAAI,CAACyB,aAAa,CAACrE,MAAO;MACxF,MAAMqF,YAAY,GAAIF,UAAU,GAAGA,UAAU,CAACrC,aAAa,GAAG,IAAI,CAACwB,aAAa,CAACtE,MAAO;MACxF,OAAOiF,iBAAiB,GAAGG,YAAY,IAAIF,iBAAiB,GAAGG,YAAY,EAAE;QACzE,MAAMC,YAAY,GAAG,IAAI,CAACjB,aAAa,CAACY,iBAAiB,CAAC;QAC1D,MAAMM,YAAY,GAAG,IAAI,CAACjB,aAAa,CAACY,iBAAiB,CAAC;QAC1D,IAAII,YAAY,KAAKC,YAAY,EAAE;UAC/B;UACA;UACA;YACI,IAAIvD,mBAAmB,GAAG/B,sBAAsB,CAACqF,YAAY,EAAE,CAAC,CAAC;YACjE,IAAIlD,mBAAmB,GAAGnC,sBAAsB,CAACsF,YAAY,EAAE,CAAC,CAAC;YACjE,OAAOvD,mBAAmB,GAAG,CAAC,IAAII,mBAAmB,GAAG,CAAC,EAAE;cACvD,MAAMoD,YAAY,GAAGF,YAAY,CAAC/D,UAAU,CAACS,mBAAmB,GAAG,CAAC,CAAC;cACrE,MAAMyD,YAAY,GAAGF,YAAY,CAAChE,UAAU,CAACa,mBAAmB,GAAG,CAAC,CAAC;cACrE,IAAIoD,YAAY,KAAKC,YAAY,EAAE;gBAC/B;cACJ;cACAzD,mBAAmB,EAAE;cACrBI,mBAAmB,EAAE;YACzB;YACA,IAAIJ,mBAAmB,GAAG,CAAC,IAAII,mBAAmB,GAAG,CAAC,EAAE;cACpD,IAAI,CAACsD,6BAA6B,CAACzC,MAAM,EAAEgC,iBAAiB,GAAG,CAAC,EAAE,CAAC,EAAEjD,mBAAmB,EAAEkD,iBAAiB,GAAG,CAAC,EAAE,CAAC,EAAE9C,mBAAmB,CAAC;YAC5I;UACJ;UACA;UACA;YACI,IAAIF,iBAAiB,GAAGhC,qBAAqB,CAACoF,YAAY,EAAE,CAAC,CAAC;YAC9D,IAAIhD,iBAAiB,GAAGpC,qBAAqB,CAACqF,YAAY,EAAE,CAAC,CAAC;YAC9D,MAAMI,iBAAiB,GAAGL,YAAY,CAACtF,MAAM,GAAG,CAAC;YACjD,MAAM4F,iBAAiB,GAAGL,YAAY,CAACvF,MAAM,GAAG,CAAC;YACjD,OAAOkC,iBAAiB,GAAGyD,iBAAiB,IAAIrD,iBAAiB,GAAGsD,iBAAiB,EAAE;cACnF,MAAMJ,YAAY,GAAGF,YAAY,CAAC/D,UAAU,CAACW,iBAAiB,GAAG,CAAC,CAAC;cACnE,MAAMuD,YAAY,GAAGH,YAAY,CAAC/D,UAAU,CAACe,iBAAiB,GAAG,CAAC,CAAC;cACnE,IAAIkD,YAAY,KAAKC,YAAY,EAAE;gBAC/B;cACJ;cACAvD,iBAAiB,EAAE;cACnBI,iBAAiB,EAAE;YACvB;YACA,IAAIJ,iBAAiB,GAAGyD,iBAAiB,IAAIrD,iBAAiB,GAAGsD,iBAAiB,EAAE;cAChF,IAAI,CAACF,6BAA6B,CAACzC,MAAM,EAAEgC,iBAAiB,GAAG,CAAC,EAAE/C,iBAAiB,EAAEyD,iBAAiB,EAAET,iBAAiB,GAAG,CAAC,EAAE5C,iBAAiB,EAAEsD,iBAAiB,CAAC;YACxK;UACJ;QACJ;QACAX,iBAAiB,EAAE;QACnBC,iBAAiB,EAAE;MACvB;MACA,IAAIC,UAAU,EAAE;QACZ;QACAlC,MAAM,CAACQ,IAAI,CAACC,UAAU,CAACE,oBAAoB,CAAC,IAAI,CAAChD,0BAA0B,EAAEuE,UAAU,EAAE,IAAI,CAACV,QAAQ,EAAE,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACX,gBAAgB,EAAE,IAAI,CAACC,wBAAwB,EAAE,IAAI,CAACC,4BAA4B,CAAC,CAAC;QAChNgB,iBAAiB,IAAIE,UAAU,CAACxC,cAAc;QAC9CuC,iBAAiB,IAAIC,UAAU,CAACtC,cAAc;MAClD;IACJ;IACA,OAAO;MACHiC,SAAS,EAAEA,SAAS;MACpBX,OAAO,EAAElB;IACb,CAAC;EACL;EACAyC,6BAA6BA,CAACzC,MAAM,EAAE4C,kBAAkB,EAAE7D,mBAAmB,EAAEE,iBAAiB,EAAE4D,kBAAkB,EAAE1D,mBAAmB,EAAEE,iBAAiB,EAAE;IAC1J,IAAI,IAAI,CAACyD,8BAA8B,CAAC9C,MAAM,EAAE4C,kBAAkB,EAAE7D,mBAAmB,EAAEE,iBAAiB,EAAE4D,kBAAkB,EAAE1D,mBAAmB,EAAEE,iBAAiB,CAAC,EAAE;MACrK;MACA;IACJ;IACA,IAAIqB,WAAW,GAAGO,SAAS;IAC3B,IAAI,IAAI,CAACF,wBAAwB,EAAE;MAC/BL,WAAW,GAAG,CAAC,IAAI7B,UAAU,CAAC+D,kBAAkB,EAAE7D,mBAAmB,EAAE6D,kBAAkB,EAAE3D,iBAAiB,EAAE4D,kBAAkB,EAAE1D,mBAAmB,EAAE0D,kBAAkB,EAAExD,iBAAiB,CAAC,CAAC;IAClM;IACAW,MAAM,CAACQ,IAAI,CAAC,IAAIC,UAAU,CAACmC,kBAAkB,EAAEA,kBAAkB,EAAEC,kBAAkB,EAAEA,kBAAkB,EAAEnC,WAAW,CAAC,CAAC;EAC5H;EACAoC,8BAA8BA,CAAC9C,MAAM,EAAE4C,kBAAkB,EAAE7D,mBAAmB,EAAEE,iBAAiB,EAAE4D,kBAAkB,EAAE1D,mBAAmB,EAAEE,iBAAiB,EAAE;IAC3J,MAAM/B,GAAG,GAAG0C,MAAM,CAACjD,MAAM;IACzB,IAAIO,GAAG,KAAK,CAAC,EAAE;MACX,OAAO,KAAK;IAChB;IACA,MAAM2C,UAAU,GAAGD,MAAM,CAAC1C,GAAG,GAAG,CAAC,CAAC;IAClC,IAAI2C,UAAU,CAACjB,qBAAqB,KAAK,CAAC,IAAIiB,UAAU,CAACb,qBAAqB,KAAK,CAAC,EAAE;MAClF;MACA,OAAO,KAAK;IAChB;IACA,IAAIa,UAAU,CAACjB,qBAAqB,GAAG,CAAC,KAAK4D,kBAAkB,IAAI3C,UAAU,CAACb,qBAAqB,GAAG,CAAC,KAAKyD,kBAAkB,EAAE;MAC5H5C,UAAU,CAACjB,qBAAqB,GAAG4D,kBAAkB;MACrD3C,UAAU,CAACb,qBAAqB,GAAGyD,kBAAkB;MACrD,IAAI,IAAI,CAAC9B,wBAAwB,IAAId,UAAU,CAACS,WAAW,EAAE;QACzDT,UAAU,CAACS,WAAW,CAACF,IAAI,CAAC,IAAI3B,UAAU,CAAC+D,kBAAkB,EAAE7D,mBAAmB,EAAE6D,kBAAkB,EAAE3D,iBAAiB,EAAE4D,kBAAkB,EAAE1D,mBAAmB,EAAE0D,kBAAkB,EAAExD,iBAAiB,CAAC,CAAC;MAC/M;MACA,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;AACJ;AACA,SAASrC,sBAAsBA,CAAC+F,GAAG,EAAEC,YAAY,EAAE;EAC/C,MAAMC,CAAC,GAAGjH,OAAO,CAACkH,uBAAuB,CAACH,GAAG,CAAC;EAC9C,IAAIE,CAAC,KAAK,CAAC,CAAC,EAAE;IACV,OAAOD,YAAY;EACvB;EACA,OAAOC,CAAC,GAAG,CAAC;AAChB;AACA,SAAShG,qBAAqBA,CAAC8F,GAAG,EAAEC,YAAY,EAAE;EAC9C,MAAMC,CAAC,GAAGjH,OAAO,CAACmH,sBAAsB,CAACJ,GAAG,CAAC;EAC7C,IAAIE,CAAC,KAAK,CAAC,CAAC,EAAE;IACV,OAAOD,YAAY;EACvB;EACA,OAAOC,CAAC,GAAG,CAAC;AAChB;AACA,SAAStB,iCAAiCA,CAACyB,cAAc,EAAE;EACvD,IAAIA,cAAc,KAAK,CAAC,EAAE;IACtB,OAAO,MAAM,IAAI;EACrB;EACA,MAAMC,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;EAC5B,OAAO,MAAM;IACT,OAAOD,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,SAAS,GAAGD,cAAc;EAClD,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}