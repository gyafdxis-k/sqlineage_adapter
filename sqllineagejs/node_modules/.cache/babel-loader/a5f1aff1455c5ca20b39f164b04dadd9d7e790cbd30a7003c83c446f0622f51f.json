{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ComposedTreeDelegate } from './abstractTree.js';\nimport { ObjectTree, CompressibleObjectTree } from './objectTree.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { dispose, DisposableStore } from '../../../common/lifecycle.js';\nimport { Emitter, Event } from '../../../common/event.js';\nimport { timeout, createCancelablePromise } from '../../../common/async.js';\nimport { Iterable } from '../../../common/iterator.js';\nimport { ElementsDragAndDropData } from '../list/listView.js';\nimport { isPromiseCanceledError, onUnexpectedError } from '../../../common/errors.js';\nimport { isFilterResult, getVisibleState } from './indexTreeModel.js';\nimport { treeItemLoadingIcon } from './treeIcons.js';\nfunction createAsyncDataTreeNode(props) {\n  return Object.assign(Object.assign({}, props), {\n    children: [],\n    refreshPromise: undefined,\n    stale: true,\n    slow: false,\n    collapsedByDefault: undefined\n  });\n}\nfunction isAncestor(ancestor, descendant) {\n  if (!descendant.parent) {\n    return false;\n  } else if (descendant.parent === ancestor) {\n    return true;\n  } else {\n    return isAncestor(ancestor, descendant.parent);\n  }\n}\nfunction intersects(node, other) {\n  return node === other || isAncestor(node, other) || isAncestor(other, node);\n}\nclass AsyncDataTreeNodeWrapper {\n  constructor(node) {\n    this.node = node;\n  }\n  get element() {\n    return this.node.element.element;\n  }\n  get children() {\n    return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node));\n  }\n  get depth() {\n    return this.node.depth;\n  }\n  get visibleChildrenCount() {\n    return this.node.visibleChildrenCount;\n  }\n  get visibleChildIndex() {\n    return this.node.visibleChildIndex;\n  }\n  get collapsible() {\n    return this.node.collapsible;\n  }\n  get collapsed() {\n    return this.node.collapsed;\n  }\n  get visible() {\n    return this.node.visible;\n  }\n  get filterData() {\n    return this.node.filterData;\n  }\n}\nclass AsyncDataTreeRenderer {\n  constructor(renderer, nodeMapper, onDidChangeTwistieState) {\n    this.renderer = renderer;\n    this.nodeMapper = nodeMapper;\n    this.onDidChangeTwistieState = onDidChangeTwistieState;\n    this.renderedNodes = new Map();\n    this.templateId = renderer.templateId;\n  }\n  renderTemplate(container) {\n    const templateData = this.renderer.renderTemplate(container);\n    return {\n      templateData\n    };\n  }\n  renderElement(node, index, templateData, height) {\n    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n  }\n  renderTwistie(element, twistieElement) {\n    if (element.slow) {\n      twistieElement.classList.add(...treeItemLoadingIcon.classNamesArray);\n      return true;\n    } else {\n      twistieElement.classList.remove(...treeItemLoadingIcon.classNamesArray);\n      return false;\n    }\n  }\n  disposeElement(node, index, templateData, height) {\n    if (this.renderer.disposeElement) {\n      this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n  }\n  disposeTemplate(templateData) {\n    this.renderer.disposeTemplate(templateData.templateData);\n  }\n  dispose() {\n    this.renderedNodes.clear();\n  }\n}\nfunction asTreeEvent(e) {\n  return {\n    browserEvent: e.browserEvent,\n    elements: e.elements.map(e => e.element)\n  };\n}\nfunction asTreeMouseEvent(e) {\n  return {\n    browserEvent: e.browserEvent,\n    element: e.element && e.element.element,\n    target: e.target\n  };\n}\nclass AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData {\n  constructor(data) {\n    super(data.elements.map(node => node.element));\n    this.data = data;\n  }\n}\nfunction asAsyncDataTreeDragAndDropData(data) {\n  if (data instanceof ElementsDragAndDropData) {\n    return new AsyncDataTreeElementsDragAndDropData(data);\n  }\n  return data;\n}\nclass AsyncDataTreeNodeListDragAndDrop {\n  constructor(dnd) {\n    this.dnd = dnd;\n  }\n  getDragURI(node) {\n    return this.dnd.getDragURI(node.element);\n  }\n  getDragLabel(nodes, originalEvent) {\n    if (this.dnd.getDragLabel) {\n      return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\n    }\n    return undefined;\n  }\n  onDragStart(data, originalEvent) {\n    if (this.dnd.onDragStart) {\n      this.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);\n    }\n  }\n  onDragOver(data, targetNode, targetIndex, originalEvent) {\n    let raw = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n  }\n  drop(data, targetNode, targetIndex, originalEvent) {\n    this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n  }\n  onDragEnd(originalEvent) {\n    if (this.dnd.onDragEnd) {\n      this.dnd.onDragEnd(originalEvent);\n    }\n  }\n}\nfunction asObjectTreeOptions(options) {\n  return options && Object.assign(Object.assign({}, options), {\n    collapseByDefault: true,\n    identityProvider: options.identityProvider && {\n      getId(el) {\n        return options.identityProvider.getId(el.element);\n      }\n    },\n    dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),\n    multipleSelectionController: options.multipleSelectionController && {\n      isSelectionSingleChangeEvent(e) {\n        return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), {\n          element: e.element\n        }));\n      },\n      isSelectionRangeChangeEvent(e) {\n        return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), {\n          element: e.element\n        }));\n      }\n    },\n    accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), {\n      getPosInSet: undefined,\n      getSetSize: undefined,\n      getRole: options.accessibilityProvider.getRole ? el => {\n        return options.accessibilityProvider.getRole(el.element);\n      } : () => 'treeitem',\n      isChecked: options.accessibilityProvider.isChecked ? e => {\n        var _a;\n        return !!((_a = options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.isChecked(e.element));\n      } : undefined,\n      getAriaLabel(e) {\n        return options.accessibilityProvider.getAriaLabel(e.element);\n      },\n      getWidgetAriaLabel() {\n        return options.accessibilityProvider.getWidgetAriaLabel();\n      },\n      getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree',\n      getAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\n        return options.accessibilityProvider.getAriaLevel(node.element);\n      }),\n      getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\n        return options.accessibilityProvider.getActiveDescendantId(node.element);\n      })\n    }),\n    filter: options.filter && {\n      filter(e, parentVisibility) {\n        return options.filter.filter(e.element, parentVisibility);\n      }\n    },\n    keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), {\n      getKeyboardNavigationLabel(e) {\n        return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);\n      }\n    }),\n    sorter: undefined,\n    expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : e => options.expandOnlyOnTwistieClick(e.element),\n    additionalScrollHeight: options.additionalScrollHeight\n  });\n}\nfunction dfs(node, fn) {\n  fn(node);\n  node.children.forEach(child => dfs(child, fn));\n}\nexport class AsyncDataTree {\n  constructor(user, container, delegate, renderers, dataSource) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    this.user = user;\n    this.dataSource = dataSource;\n    this.nodes = new Map();\n    this.subTreeRefreshPromises = new Map();\n    this.refreshPromises = new Map();\n    this._onDidRender = new Emitter();\n    this._onDidChangeNodeSlowState = new Emitter();\n    this.nodeMapper = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\n    this.disposables = new DisposableStore();\n    this.identityProvider = options.identityProvider;\n    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n    this.sorter = options.sorter;\n    this.collapseByDefault = options.collapseByDefault;\n    this.tree = this.createTree(user, container, delegate, renderers, options);\n    this.root = createAsyncDataTreeNode({\n      element: undefined,\n      parent: null,\n      hasChildren: true\n    });\n    if (this.identityProvider) {\n      this.root = Object.assign(Object.assign({}, this.root), {\n        id: null\n      });\n    }\n    this.nodes.set(null, this.root);\n    this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n  }\n  get onDidChangeFocus() {\n    return Event.map(this.tree.onDidChangeFocus, asTreeEvent);\n  }\n  get onDidChangeSelection() {\n    return Event.map(this.tree.onDidChangeSelection, asTreeEvent);\n  }\n  get onMouseDblClick() {\n    return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent);\n  }\n  get onPointer() {\n    return Event.map(this.tree.onPointer, asTreeMouseEvent);\n  }\n  get onDidFocus() {\n    return this.tree.onDidFocus;\n  }\n  get onDidDispose() {\n    return this.tree.onDidDispose;\n  }\n  createTree(user, container, delegate, renderers, options) {\n    const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n    const objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\n    const objectTreeOptions = asObjectTreeOptions(options) || {};\n    return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n  }\n  updateOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.tree.updateOptions(options);\n  }\n  // Widget\n  getHTMLElement() {\n    return this.tree.getHTMLElement();\n  }\n  get scrollTop() {\n    return this.tree.scrollTop;\n  }\n  set scrollTop(scrollTop) {\n    this.tree.scrollTop = scrollTop;\n  }\n  domFocus() {\n    this.tree.domFocus();\n  }\n  layout(height, width) {\n    this.tree.layout(height, width);\n  }\n  style(styles) {\n    this.tree.style(styles);\n  }\n  // Model\n  getInput() {\n    return this.root.element;\n  }\n  setInput(input, viewState) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.refreshPromises.forEach(promise => promise.cancel());\n      this.refreshPromises.clear();\n      this.root.element = input;\n      const viewStateContext = viewState && {\n        viewState,\n        focus: [],\n        selection: []\n      };\n      yield this._updateChildren(input, true, false, viewStateContext);\n      if (viewStateContext) {\n        this.tree.setFocus(viewStateContext.focus);\n        this.tree.setSelection(viewStateContext.selection);\n      }\n      if (viewState && typeof viewState.scrollTop === 'number') {\n        this.scrollTop = viewState.scrollTop;\n      }\n    });\n  }\n  _updateChildren() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.root.element;\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let rerender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let viewStateContext = arguments.length > 3 ? arguments[3] : undefined;\n    let options = arguments.length > 4 ? arguments[4] : undefined;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof this.root.element === 'undefined') {\n        throw new TreeError(this.user, 'Tree input not set');\n      }\n      if (this.root.refreshPromise) {\n        yield this.root.refreshPromise;\n        yield Event.toPromise(this._onDidRender.event);\n      }\n      const node = this.getDataNode(element);\n      yield this.refreshAndRenderNode(node, recursive, viewStateContext, options);\n      if (rerender) {\n        try {\n          this.tree.rerender(node);\n        } catch (_a) {\n          // missing nodes are fine, this could've resulted from\n          // parallel refresh calls, removing `node` altogether\n        }\n      }\n    });\n  }\n  // View\n  rerender(element) {\n    if (element === undefined || element === this.root.element) {\n      this.tree.rerender();\n      return;\n    }\n    const node = this.getDataNode(element);\n    this.tree.rerender(node);\n  }\n  collapse(element) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const node = this.getDataNode(element);\n    return this.tree.collapse(node === this.root ? null : node, recursive);\n  }\n  expand(element) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof this.root.element === 'undefined') {\n        throw new TreeError(this.user, 'Tree input not set');\n      }\n      if (this.root.refreshPromise) {\n        yield this.root.refreshPromise;\n        yield Event.toPromise(this._onDidRender.event);\n      }\n      const node = this.getDataNode(element);\n      if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\n        return false;\n      }\n      if (node.refreshPromise) {\n        yield this.root.refreshPromise;\n        yield Event.toPromise(this._onDidRender.event);\n      }\n      if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\n        return false;\n      }\n      const result = this.tree.expand(node === this.root ? null : node, recursive);\n      if (node.refreshPromise) {\n        yield this.root.refreshPromise;\n        yield Event.toPromise(this._onDidRender.event);\n      }\n      return result;\n    });\n  }\n  setSelection(elements, browserEvent) {\n    const nodes = elements.map(e => this.getDataNode(e));\n    this.tree.setSelection(nodes, browserEvent);\n  }\n  getSelection() {\n    const nodes = this.tree.getSelection();\n    return nodes.map(n => n.element);\n  }\n  setFocus(elements, browserEvent) {\n    const nodes = elements.map(e => this.getDataNode(e));\n    this.tree.setFocus(nodes, browserEvent);\n  }\n  getFocus() {\n    const nodes = this.tree.getFocus();\n    return nodes.map(n => n.element);\n  }\n  reveal(element, relativeTop) {\n    this.tree.reveal(this.getDataNode(element), relativeTop);\n  }\n  // Implementation\n  getDataNode(element) {\n    const node = this.nodes.get(element === this.root.element ? null : element);\n    if (!node) {\n      throw new TreeError(this.user, \"Data tree node not found: \".concat(element));\n    }\n    return node;\n  }\n  refreshAndRenderNode(node, recursive, viewStateContext, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.refreshNode(node, recursive, viewStateContext);\n      this.render(node, viewStateContext, options);\n    });\n  }\n  refreshNode(node, recursive, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let result;\n      this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n        if (!result && intersects(refreshNode, node)) {\n          result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n        }\n      });\n      if (result) {\n        return result;\n      }\n      return this.doRefreshSubTree(node, recursive, viewStateContext);\n    });\n  }\n  doRefreshSubTree(node, recursive, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let done;\n      node.refreshPromise = new Promise(c => done = c);\n      this.subTreeRefreshPromises.set(node, node.refreshPromise);\n      node.refreshPromise.finally(() => {\n        node.refreshPromise = undefined;\n        this.subTreeRefreshPromises.delete(node);\n      });\n      try {\n        const childrenToRefresh = yield this.doRefreshNode(node, recursive, viewStateContext);\n        node.stale = false;\n        yield Promise.all(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n      } finally {\n        done();\n      }\n    });\n  }\n  doRefreshNode(node, recursive, viewStateContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      node.hasChildren = !!this.dataSource.hasChildren(node.element);\n      let childrenPromise;\n      if (!node.hasChildren) {\n        childrenPromise = Promise.resolve(Iterable.empty());\n      } else {\n        const slowTimeout = timeout(800);\n        slowTimeout.then(() => {\n          node.slow = true;\n          this._onDidChangeNodeSlowState.fire(node);\n        }, _ => null);\n        childrenPromise = this.doGetChildren(node).finally(() => slowTimeout.cancel());\n      }\n      try {\n        const children = yield childrenPromise;\n        return this.setChildren(node, children, recursive, viewStateContext);\n      } catch (err) {\n        if (node !== this.root && this.tree.hasElement(node)) {\n          this.tree.collapse(node);\n        }\n        if (isPromiseCanceledError(err)) {\n          return [];\n        }\n        throw err;\n      } finally {\n        if (node.slow) {\n          node.slow = false;\n          this._onDidChangeNodeSlowState.fire(node);\n        }\n      }\n    });\n  }\n  doGetChildren(node) {\n    let result = this.refreshPromises.get(node);\n    if (result) {\n      return result;\n    }\n    result = createCancelablePromise(() => __awaiter(this, void 0, void 0, function* () {\n      const children = yield this.dataSource.getChildren(node.element);\n      return this.processChildren(children);\n    }));\n    this.refreshPromises.set(node, result);\n    return result.finally(() => {\n      this.refreshPromises.delete(node);\n    });\n  }\n  _onDidChangeCollapseState(_ref) {\n    let {\n      node,\n      deep\n    } = _ref;\n    if (node.element === null) {\n      return;\n    }\n    if (!node.collapsed && node.element.stale) {\n      if (deep) {\n        this.collapse(node.element.element);\n      } else {\n        this.refreshAndRenderNode(node.element, false).catch(onUnexpectedError);\n      }\n    }\n  }\n  setChildren(node, childrenElementsIterable, recursive, viewStateContext) {\n    const childrenElements = [...childrenElementsIterable];\n    // perf: if the node was and still is a leaf, avoid all this hassle\n    if (node.children.length === 0 && childrenElements.length === 0) {\n      return [];\n    }\n    const nodesToForget = new Map();\n    const childrenTreeNodesById = new Map();\n    for (const child of node.children) {\n      nodesToForget.set(child.element, child);\n      if (this.identityProvider) {\n        const collapsed = this.tree.isCollapsed(child);\n        childrenTreeNodesById.set(child.id, {\n          node: child,\n          collapsed\n        });\n      }\n    }\n    const childrenToRefresh = [];\n    const children = childrenElements.map(element => {\n      const hasChildren = !!this.dataSource.hasChildren(element);\n      if (!this.identityProvider) {\n        const asyncDataTreeNode = createAsyncDataTreeNode({\n          element,\n          parent: node,\n          hasChildren\n        });\n        if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n          asyncDataTreeNode.collapsedByDefault = false;\n          childrenToRefresh.push(asyncDataTreeNode);\n        }\n        return asyncDataTreeNode;\n      }\n      const id = this.identityProvider.getId(element).toString();\n      const result = childrenTreeNodesById.get(id);\n      if (result) {\n        const asyncDataTreeNode = result.node;\n        nodesToForget.delete(asyncDataTreeNode.element);\n        this.nodes.delete(asyncDataTreeNode.element);\n        this.nodes.set(element, asyncDataTreeNode);\n        asyncDataTreeNode.element = element;\n        asyncDataTreeNode.hasChildren = hasChildren;\n        if (recursive) {\n          if (result.collapsed) {\n            asyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element)));\n            asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\n            asyncDataTreeNode.stale = true;\n          } else {\n            childrenToRefresh.push(asyncDataTreeNode);\n          }\n        } else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n          asyncDataTreeNode.collapsedByDefault = false;\n          childrenToRefresh.push(asyncDataTreeNode);\n        }\n        return asyncDataTreeNode;\n      }\n      const childAsyncDataTreeNode = createAsyncDataTreeNode({\n        element,\n        parent: node,\n        id,\n        hasChildren\n      });\n      if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n        viewStateContext.focus.push(childAsyncDataTreeNode);\n      }\n      if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n        viewStateContext.selection.push(childAsyncDataTreeNode);\n      }\n      if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n        childrenToRefresh.push(childAsyncDataTreeNode);\n      } else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\n        childAsyncDataTreeNode.collapsedByDefault = false;\n        childrenToRefresh.push(childAsyncDataTreeNode);\n      }\n      return childAsyncDataTreeNode;\n    });\n    for (const node of nodesToForget.values()) {\n      dfs(node, node => this.nodes.delete(node.element));\n    }\n    for (const child of children) {\n      this.nodes.set(child.element, child);\n    }\n    node.children.splice(0, node.children.length, ...children);\n    // TODO@joao this doesn't take filter into account\n    if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\n      children[0].collapsedByDefault = false;\n      childrenToRefresh.push(children[0]);\n    }\n    return childrenToRefresh;\n  }\n  render(node, viewStateContext, options) {\n    const children = node.children.map(node => this.asTreeElement(node, viewStateContext));\n    const objectTreeOptions = options && Object.assign(Object.assign({}, options), {\n      diffIdentityProvider: options.diffIdentityProvider && {\n        getId(node) {\n          return options.diffIdentityProvider.getId(node.element);\n        }\n      }\n    });\n    this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\n    if (node !== this.root) {\n      this.tree.setCollapsible(node, node.hasChildren);\n    }\n    this._onDidRender.fire();\n  }\n  asTreeElement(node, viewStateContext) {\n    if (node.stale) {\n      return {\n        element: node,\n        collapsible: node.hasChildren,\n        collapsed: true\n      };\n    }\n    let collapsed;\n    if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\n      collapsed = false;\n    } else {\n      collapsed = node.collapsedByDefault;\n    }\n    node.collapsedByDefault = undefined;\n    return {\n      element: node,\n      children: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\n      collapsible: node.hasChildren,\n      collapsed\n    };\n  }\n  processChildren(children) {\n    if (this.sorter) {\n      children = [...children].sort(this.sorter.compare.bind(this.sorter));\n    }\n    return children;\n  }\n  dispose() {\n    this.disposables.dispose();\n  }\n}\nclass CompressibleAsyncDataTreeNodeWrapper {\n  constructor(node) {\n    this.node = node;\n  }\n  get element() {\n    return {\n      elements: this.node.element.elements.map(e => e.element),\n      incompressible: this.node.element.incompressible\n    };\n  }\n  get children() {\n    return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n  }\n  get depth() {\n    return this.node.depth;\n  }\n  get visibleChildrenCount() {\n    return this.node.visibleChildrenCount;\n  }\n  get visibleChildIndex() {\n    return this.node.visibleChildIndex;\n  }\n  get collapsible() {\n    return this.node.collapsible;\n  }\n  get collapsed() {\n    return this.node.collapsed;\n  }\n  get visible() {\n    return this.node.visible;\n  }\n  get filterData() {\n    return this.node.filterData;\n  }\n}\nclass CompressibleAsyncDataTreeRenderer {\n  constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {\n    this.renderer = renderer;\n    this.nodeMapper = nodeMapper;\n    this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;\n    this.onDidChangeTwistieState = onDidChangeTwistieState;\n    this.renderedNodes = new Map();\n    this.disposables = [];\n    this.templateId = renderer.templateId;\n  }\n  renderTemplate(container) {\n    const templateData = this.renderer.renderTemplate(container);\n    return {\n      templateData\n    };\n  }\n  renderElement(node, index, templateData, height) {\n    this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n  }\n  renderCompressedElements(node, index, templateData, height) {\n    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n  }\n  renderTwistie(element, twistieElement) {\n    if (element.slow) {\n      twistieElement.classList.add(...treeItemLoadingIcon.classNamesArray);\n      return true;\n    } else {\n      twistieElement.classList.remove(...treeItemLoadingIcon.classNamesArray);\n      return false;\n    }\n  }\n  disposeElement(node, index, templateData, height) {\n    if (this.renderer.disposeElement) {\n      this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\n    }\n  }\n  disposeCompressedElements(node, index, templateData, height) {\n    if (this.renderer.disposeCompressedElements) {\n      this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\n    }\n  }\n  disposeTemplate(templateData) {\n    this.renderer.disposeTemplate(templateData.templateData);\n  }\n  dispose() {\n    this.renderedNodes.clear();\n    this.disposables = dispose(this.disposables);\n  }\n}\nfunction asCompressibleObjectTreeOptions(options) {\n  const objectTreeOptions = options && asObjectTreeOptions(options);\n  return objectTreeOptions && Object.assign(Object.assign({}, objectTreeOptions), {\n    keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, objectTreeOptions.keyboardNavigationLabelProvider), {\n      getCompressedNodeKeyboardNavigationLabel(els) {\n        return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element));\n      }\n    })\n  });\n}\nexport class CompressibleAsyncDataTree extends AsyncDataTree {\n  constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource) {\n    let options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n    super(user, container, virtualDelegate, renderers, dataSource, options);\n    this.compressionDelegate = compressionDelegate;\n    this.compressibleNodeMapper = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\n    this.filter = options.filter;\n  }\n  createTree(user, container, delegate, renderers, options) {\n    const objectTreeDelegate = new ComposedTreeDelegate(delegate);\n    const objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\n    const objectTreeOptions = asCompressibleObjectTreeOptions(options) || {};\n    return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n  }\n  asTreeElement(node, viewStateContext) {\n    return Object.assign({\n      incompressible: this.compressionDelegate.isIncompressible(node.element)\n    }, super.asTreeElement(node, viewStateContext));\n  }\n  updateOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.tree.updateOptions(options);\n  }\n  render(node, viewStateContext) {\n    if (!this.identityProvider) {\n      return super.render(node, viewStateContext);\n    }\n    // Preserve traits across compressions. Hacky but does the trick.\n    // This is hard to fix properly since it requires rewriting the traits\n    // across trees and lists. Let's just keep it this way for now.\n    const getId = element => this.identityProvider.getId(element).toString();\n    const getUncompressedIds = nodes => {\n      const result = new Set();\n      for (const node of nodes) {\n        const compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\n        if (!compressedNode.element) {\n          continue;\n        }\n        for (const node of compressedNode.element.elements) {\n          result.add(getId(node.element));\n        }\n      }\n      return result;\n    };\n    const oldSelection = getUncompressedIds(this.tree.getSelection());\n    const oldFocus = getUncompressedIds(this.tree.getFocus());\n    super.render(node, viewStateContext);\n    const selection = this.getSelection();\n    let didChangeSelection = false;\n    const focus = this.getFocus();\n    let didChangeFocus = false;\n    const visit = node => {\n      const compressedNode = node.element;\n      if (compressedNode) {\n        for (let i = 0; i < compressedNode.elements.length; i++) {\n          const id = getId(compressedNode.elements[i].element);\n          const element = compressedNode.elements[compressedNode.elements.length - 1].element;\n          // github.com/microsoft/vscode/issues/85938\n          if (oldSelection.has(id) && selection.indexOf(element) === -1) {\n            selection.push(element);\n            didChangeSelection = true;\n          }\n          if (oldFocus.has(id) && focus.indexOf(element) === -1) {\n            focus.push(element);\n            didChangeFocus = true;\n          }\n        }\n      }\n      node.children.forEach(visit);\n    };\n    visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\n    if (didChangeSelection) {\n      this.setSelection(selection);\n    }\n    if (didChangeFocus) {\n      this.setFocus(focus);\n    }\n  }\n  // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\n  // and we have to filter everything beforehand\n  // Related to #85193 and #85835\n  processChildren(children) {\n    if (this.filter) {\n      children = Iterable.filter(children, e => {\n        const result = this.filter.filter(e, 1 /* Visible */);\n        const visibility = getVisibility(result);\n        if (visibility === 2 /* Recurse */) {\n          throw new Error('Recursive tree visibility not supported in async data compressed trees');\n        }\n        return visibility === 1 /* Visible */;\n      });\n    }\n\n    return super.processChildren(children);\n  }\n}\nfunction getVisibility(filterResult) {\n  if (typeof filterResult === 'boolean') {\n    return filterResult ? 1 /* Visible */ : 0 /* Hidden */;\n  } else if (isFilterResult(filterResult)) {\n    return getVisibleState(filterResult.visibility);\n  } else {\n    return getVisibleState(filterResult);\n  }\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","ComposedTreeDelegate","ObjectTree","CompressibleObjectTree","TreeError","WeakMapper","dispose","DisposableStore","Emitter","Event","timeout","createCancelablePromise","Iterable","ElementsDragAndDropData","isPromiseCanceledError","onUnexpectedError","isFilterResult","getVisibleState","treeItemLoadingIcon","createAsyncDataTreeNode","props","Object","assign","children","refreshPromise","undefined","stale","slow","collapsedByDefault","isAncestor","ancestor","descendant","parent","intersects","node","other","AsyncDataTreeNodeWrapper","constructor","element","map","depth","visibleChildrenCount","visibleChildIndex","collapsible","collapsed","visible","filterData","AsyncDataTreeRenderer","renderer","nodeMapper","onDidChangeTwistieState","renderedNodes","Map","templateId","renderTemplate","container","templateData","renderElement","index","height","renderTwistie","twistieElement","classList","add","classNamesArray","remove","disposeElement","disposeTemplate","clear","asTreeEvent","browserEvent","elements","asTreeMouseEvent","target","AsyncDataTreeElementsDragAndDropData","data","asAsyncDataTreeDragAndDropData","AsyncDataTreeNodeListDragAndDrop","dnd","getDragURI","getDragLabel","nodes","originalEvent","onDragStart","onDragOver","targetNode","targetIndex","raw","arguments","length","drop","onDragEnd","asObjectTreeOptions","options","collapseByDefault","identityProvider","getId","el","multipleSelectionController","isSelectionSingleChangeEvent","isSelectionRangeChangeEvent","accessibilityProvider","getPosInSet","getSetSize","getRole","isChecked","_a","getAriaLabel","getWidgetAriaLabel","getWidgetRole","getAriaLevel","getActiveDescendantId","filter","parentVisibility","keyboardNavigationLabelProvider","getKeyboardNavigationLabel","sorter","expandOnlyOnTwistieClick","additionalScrollHeight","dfs","fn","forEach","child","AsyncDataTree","user","delegate","renderers","dataSource","subTreeRefreshPromises","refreshPromises","_onDidRender","_onDidChangeNodeSlowState","disposables","autoExpandSingleChildren","tree","createTree","root","hasChildren","id","set","onDidChangeCollapseState","_onDidChangeCollapseState","onDidChangeFocus","onDidChangeSelection","onMouseDblClick","onPointer","onDidFocus","onDidDispose","objectTreeDelegate","objectTreeRenderers","r","event","objectTreeOptions","updateOptions","getHTMLElement","scrollTop","domFocus","layout","width","style","styles","getInput","setInput","input","viewState","promise","cancel","viewStateContext","focus","selection","_updateChildren","setFocus","setSelection","recursive","rerender","toPromise","getDataNode","refreshAndRenderNode","collapse","expand","hasElement","isCollapsible","isCollapsed","getSelection","n","getFocus","reveal","relativeTop","get","concat","refreshNode","render","doRefreshSubTree","c","finally","delete","childrenToRefresh","doRefreshNode","all","childrenPromise","empty","slowTimeout","fire","_","doGetChildren","setChildren","err","getChildren","processChildren","_ref","deep","catch","childrenElementsIterable","childrenElements","nodesToForget","childrenTreeNodesById","asyncDataTreeNode","push","toString","splice","childAsyncDataTreeNode","indexOf","expanded","values","asTreeElement","diffIdentityProvider","setCollapsible","sort","compare","bind","CompressibleAsyncDataTreeNodeWrapper","incompressible","CompressibleAsyncDataTreeRenderer","compressibleNodeMapperProvider","renderCompressedElements","disposeCompressedElements","asCompressibleObjectTreeOptions","getCompressedNodeKeyboardNavigationLabel","els","CompressibleAsyncDataTree","virtualDelegate","compressionDelegate","compressibleNodeMapper","isIncompressible","getUncompressedIds","Set","compressedNode","getCompressedTreeNode","oldSelection","oldFocus","didChangeSelection","didChangeFocus","visit","i","has","visibility","getVisibility","Error","filterResult"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/asyncDataTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { ComposedTreeDelegate } from './abstractTree.js';\r\nimport { ObjectTree, CompressibleObjectTree } from './objectTree.js';\r\nimport { TreeError, WeakMapper } from './tree.js';\r\nimport { dispose, DisposableStore } from '../../../common/lifecycle.js';\r\nimport { Emitter, Event } from '../../../common/event.js';\r\nimport { timeout, createCancelablePromise } from '../../../common/async.js';\r\nimport { Iterable } from '../../../common/iterator.js';\r\nimport { ElementsDragAndDropData } from '../list/listView.js';\r\nimport { isPromiseCanceledError, onUnexpectedError } from '../../../common/errors.js';\r\nimport { isFilterResult, getVisibleState } from './indexTreeModel.js';\r\nimport { treeItemLoadingIcon } from './treeIcons.js';\r\nfunction createAsyncDataTreeNode(props) {\r\n    return Object.assign(Object.assign({}, props), { children: [], refreshPromise: undefined, stale: true, slow: false, collapsedByDefault: undefined });\r\n}\r\nfunction isAncestor(ancestor, descendant) {\r\n    if (!descendant.parent) {\r\n        return false;\r\n    }\r\n    else if (descendant.parent === ancestor) {\r\n        return true;\r\n    }\r\n    else {\r\n        return isAncestor(ancestor, descendant.parent);\r\n    }\r\n}\r\nfunction intersects(node, other) {\r\n    return node === other || isAncestor(node, other) || isAncestor(other, node);\r\n}\r\nclass AsyncDataTreeNodeWrapper {\r\n    constructor(node) {\r\n        this.node = node;\r\n    }\r\n    get element() { return this.node.element.element; }\r\n    get children() { return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node)); }\r\n    get depth() { return this.node.depth; }\r\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\r\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\r\n    get collapsible() { return this.node.collapsible; }\r\n    get collapsed() { return this.node.collapsed; }\r\n    get visible() { return this.node.visible; }\r\n    get filterData() { return this.node.filterData; }\r\n}\r\nclass AsyncDataTreeRenderer {\r\n    constructor(renderer, nodeMapper, onDidChangeTwistieState) {\r\n        this.renderer = renderer;\r\n        this.nodeMapper = nodeMapper;\r\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\r\n        this.renderedNodes = new Map();\r\n        this.templateId = renderer.templateId;\r\n    }\r\n    renderTemplate(container) {\r\n        const templateData = this.renderer.renderTemplate(container);\r\n        return { templateData };\r\n    }\r\n    renderElement(node, index, templateData, height) {\r\n        this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\r\n    }\r\n    renderTwistie(element, twistieElement) {\r\n        if (element.slow) {\r\n            twistieElement.classList.add(...treeItemLoadingIcon.classNamesArray);\r\n            return true;\r\n        }\r\n        else {\r\n            twistieElement.classList.remove(...treeItemLoadingIcon.classNamesArray);\r\n            return false;\r\n        }\r\n    }\r\n    disposeElement(node, index, templateData, height) {\r\n        if (this.renderer.disposeElement) {\r\n            this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\r\n        }\r\n    }\r\n    disposeTemplate(templateData) {\r\n        this.renderer.disposeTemplate(templateData.templateData);\r\n    }\r\n    dispose() {\r\n        this.renderedNodes.clear();\r\n    }\r\n}\r\nfunction asTreeEvent(e) {\r\n    return {\r\n        browserEvent: e.browserEvent,\r\n        elements: e.elements.map(e => e.element)\r\n    };\r\n}\r\nfunction asTreeMouseEvent(e) {\r\n    return {\r\n        browserEvent: e.browserEvent,\r\n        element: e.element && e.element.element,\r\n        target: e.target\r\n    };\r\n}\r\nclass AsyncDataTreeElementsDragAndDropData extends ElementsDragAndDropData {\r\n    constructor(data) {\r\n        super(data.elements.map(node => node.element));\r\n        this.data = data;\r\n    }\r\n}\r\nfunction asAsyncDataTreeDragAndDropData(data) {\r\n    if (data instanceof ElementsDragAndDropData) {\r\n        return new AsyncDataTreeElementsDragAndDropData(data);\r\n    }\r\n    return data;\r\n}\r\nclass AsyncDataTreeNodeListDragAndDrop {\r\n    constructor(dnd) {\r\n        this.dnd = dnd;\r\n    }\r\n    getDragURI(node) {\r\n        return this.dnd.getDragURI(node.element);\r\n    }\r\n    getDragLabel(nodes, originalEvent) {\r\n        if (this.dnd.getDragLabel) {\r\n            return this.dnd.getDragLabel(nodes.map(node => node.element), originalEvent);\r\n        }\r\n        return undefined;\r\n    }\r\n    onDragStart(data, originalEvent) {\r\n        if (this.dnd.onDragStart) {\r\n            this.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);\r\n        }\r\n    }\r\n    onDragOver(data, targetNode, targetIndex, originalEvent, raw = true) {\r\n        return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\r\n    }\r\n    drop(data, targetNode, targetIndex, originalEvent) {\r\n        this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\r\n    }\r\n    onDragEnd(originalEvent) {\r\n        if (this.dnd.onDragEnd) {\r\n            this.dnd.onDragEnd(originalEvent);\r\n        }\r\n    }\r\n}\r\nfunction asObjectTreeOptions(options) {\r\n    return options && Object.assign(Object.assign({}, options), { collapseByDefault: true, identityProvider: options.identityProvider && {\r\n            getId(el) {\r\n                return options.identityProvider.getId(el.element);\r\n            }\r\n        }, dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd), multipleSelectionController: options.multipleSelectionController && {\r\n            isSelectionSingleChangeEvent(e) {\r\n                return options.multipleSelectionController.isSelectionSingleChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\r\n            },\r\n            isSelectionRangeChangeEvent(e) {\r\n                return options.multipleSelectionController.isSelectionRangeChangeEvent(Object.assign(Object.assign({}, e), { element: e.element }));\r\n            }\r\n        }, accessibilityProvider: options.accessibilityProvider && Object.assign(Object.assign({}, options.accessibilityProvider), { getPosInSet: undefined, getSetSize: undefined, getRole: options.accessibilityProvider.getRole ? (el) => {\r\n                return options.accessibilityProvider.getRole(el.element);\r\n            } : () => 'treeitem', isChecked: options.accessibilityProvider.isChecked ? (e) => {\r\n                var _a;\r\n                return !!((_a = options.accessibilityProvider) === null || _a === void 0 ? void 0 : _a.isChecked(e.element));\r\n            } : undefined, getAriaLabel(e) {\r\n                return options.accessibilityProvider.getAriaLabel(e.element);\r\n            },\r\n            getWidgetAriaLabel() {\r\n                return options.accessibilityProvider.getWidgetAriaLabel();\r\n            }, getWidgetRole: options.accessibilityProvider.getWidgetRole ? () => options.accessibilityProvider.getWidgetRole() : () => 'tree', getAriaLevel: options.accessibilityProvider.getAriaLevel && (node => {\r\n                return options.accessibilityProvider.getAriaLevel(node.element);\r\n            }), getActiveDescendantId: options.accessibilityProvider.getActiveDescendantId && (node => {\r\n                return options.accessibilityProvider.getActiveDescendantId(node.element);\r\n            }) }), filter: options.filter && {\r\n            filter(e, parentVisibility) {\r\n                return options.filter.filter(e.element, parentVisibility);\r\n            }\r\n        }, keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, options.keyboardNavigationLabelProvider), { getKeyboardNavigationLabel(e) {\r\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);\r\n            } }), sorter: undefined, expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (e => options.expandOnlyOnTwistieClick(e.element))), additionalScrollHeight: options.additionalScrollHeight });\r\n}\r\nfunction dfs(node, fn) {\r\n    fn(node);\r\n    node.children.forEach(child => dfs(child, fn));\r\n}\r\nexport class AsyncDataTree {\r\n    constructor(user, container, delegate, renderers, dataSource, options = {}) {\r\n        this.user = user;\r\n        this.dataSource = dataSource;\r\n        this.nodes = new Map();\r\n        this.subTreeRefreshPromises = new Map();\r\n        this.refreshPromises = new Map();\r\n        this._onDidRender = new Emitter();\r\n        this._onDidChangeNodeSlowState = new Emitter();\r\n        this.nodeMapper = new WeakMapper(node => new AsyncDataTreeNodeWrapper(node));\r\n        this.disposables = new DisposableStore();\r\n        this.identityProvider = options.identityProvider;\r\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\r\n        this.sorter = options.sorter;\r\n        this.collapseByDefault = options.collapseByDefault;\r\n        this.tree = this.createTree(user, container, delegate, renderers, options);\r\n        this.root = createAsyncDataTreeNode({\r\n            element: undefined,\r\n            parent: null,\r\n            hasChildren: true\r\n        });\r\n        if (this.identityProvider) {\r\n            this.root = Object.assign(Object.assign({}, this.root), { id: null });\r\n        }\r\n        this.nodes.set(null, this.root);\r\n        this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\r\n    }\r\n    get onDidChangeFocus() { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }\r\n    get onDidChangeSelection() { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }\r\n    get onMouseDblClick() { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }\r\n    get onPointer() { return Event.map(this.tree.onPointer, asTreeMouseEvent); }\r\n    get onDidFocus() { return this.tree.onDidFocus; }\r\n    get onDidDispose() { return this.tree.onDidDispose; }\r\n    createTree(user, container, delegate, renderers, options) {\r\n        const objectTreeDelegate = new ComposedTreeDelegate(delegate);\r\n        const objectTreeRenderers = renderers.map(r => new AsyncDataTreeRenderer(r, this.nodeMapper, this._onDidChangeNodeSlowState.event));\r\n        const objectTreeOptions = asObjectTreeOptions(options) || {};\r\n        return new ObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\r\n    }\r\n    updateOptions(options = {}) {\r\n        this.tree.updateOptions(options);\r\n    }\r\n    // Widget\r\n    getHTMLElement() {\r\n        return this.tree.getHTMLElement();\r\n    }\r\n    get scrollTop() {\r\n        return this.tree.scrollTop;\r\n    }\r\n    set scrollTop(scrollTop) {\r\n        this.tree.scrollTop = scrollTop;\r\n    }\r\n    domFocus() {\r\n        this.tree.domFocus();\r\n    }\r\n    layout(height, width) {\r\n        this.tree.layout(height, width);\r\n    }\r\n    style(styles) {\r\n        this.tree.style(styles);\r\n    }\r\n    // Model\r\n    getInput() {\r\n        return this.root.element;\r\n    }\r\n    setInput(input, viewState) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.refreshPromises.forEach(promise => promise.cancel());\r\n            this.refreshPromises.clear();\r\n            this.root.element = input;\r\n            const viewStateContext = viewState && { viewState, focus: [], selection: [] };\r\n            yield this._updateChildren(input, true, false, viewStateContext);\r\n            if (viewStateContext) {\r\n                this.tree.setFocus(viewStateContext.focus);\r\n                this.tree.setSelection(viewStateContext.selection);\r\n            }\r\n            if (viewState && typeof viewState.scrollTop === 'number') {\r\n                this.scrollTop = viewState.scrollTop;\r\n            }\r\n        });\r\n    }\r\n    _updateChildren(element = this.root.element, recursive = true, rerender = false, viewStateContext, options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (typeof this.root.element === 'undefined') {\r\n                throw new TreeError(this.user, 'Tree input not set');\r\n            }\r\n            if (this.root.refreshPromise) {\r\n                yield this.root.refreshPromise;\r\n                yield Event.toPromise(this._onDidRender.event);\r\n            }\r\n            const node = this.getDataNode(element);\r\n            yield this.refreshAndRenderNode(node, recursive, viewStateContext, options);\r\n            if (rerender) {\r\n                try {\r\n                    this.tree.rerender(node);\r\n                }\r\n                catch (_a) {\r\n                    // missing nodes are fine, this could've resulted from\r\n                    // parallel refresh calls, removing `node` altogether\r\n                }\r\n            }\r\n        });\r\n    }\r\n    // View\r\n    rerender(element) {\r\n        if (element === undefined || element === this.root.element) {\r\n            this.tree.rerender();\r\n            return;\r\n        }\r\n        const node = this.getDataNode(element);\r\n        this.tree.rerender(node);\r\n    }\r\n    collapse(element, recursive = false) {\r\n        const node = this.getDataNode(element);\r\n        return this.tree.collapse(node === this.root ? null : node, recursive);\r\n    }\r\n    expand(element, recursive = false) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (typeof this.root.element === 'undefined') {\r\n                throw new TreeError(this.user, 'Tree input not set');\r\n            }\r\n            if (this.root.refreshPromise) {\r\n                yield this.root.refreshPromise;\r\n                yield Event.toPromise(this._onDidRender.event);\r\n            }\r\n            const node = this.getDataNode(element);\r\n            if (this.tree.hasElement(node) && !this.tree.isCollapsible(node)) {\r\n                return false;\r\n            }\r\n            if (node.refreshPromise) {\r\n                yield this.root.refreshPromise;\r\n                yield Event.toPromise(this._onDidRender.event);\r\n            }\r\n            if (node !== this.root && !node.refreshPromise && !this.tree.isCollapsed(node)) {\r\n                return false;\r\n            }\r\n            const result = this.tree.expand(node === this.root ? null : node, recursive);\r\n            if (node.refreshPromise) {\r\n                yield this.root.refreshPromise;\r\n                yield Event.toPromise(this._onDidRender.event);\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    setSelection(elements, browserEvent) {\r\n        const nodes = elements.map(e => this.getDataNode(e));\r\n        this.tree.setSelection(nodes, browserEvent);\r\n    }\r\n    getSelection() {\r\n        const nodes = this.tree.getSelection();\r\n        return nodes.map(n => n.element);\r\n    }\r\n    setFocus(elements, browserEvent) {\r\n        const nodes = elements.map(e => this.getDataNode(e));\r\n        this.tree.setFocus(nodes, browserEvent);\r\n    }\r\n    getFocus() {\r\n        const nodes = this.tree.getFocus();\r\n        return nodes.map(n => n.element);\r\n    }\r\n    reveal(element, relativeTop) {\r\n        this.tree.reveal(this.getDataNode(element), relativeTop);\r\n    }\r\n    // Implementation\r\n    getDataNode(element) {\r\n        const node = this.nodes.get((element === this.root.element ? null : element));\r\n        if (!node) {\r\n            throw new TreeError(this.user, `Data tree node not found: ${element}`);\r\n        }\r\n        return node;\r\n    }\r\n    refreshAndRenderNode(node, recursive, viewStateContext, options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.refreshNode(node, recursive, viewStateContext);\r\n            this.render(node, viewStateContext, options);\r\n        });\r\n    }\r\n    refreshNode(node, recursive, viewStateContext) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let result;\r\n            this.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\r\n                if (!result && intersects(refreshNode, node)) {\r\n                    result = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\r\n                }\r\n            });\r\n            if (result) {\r\n                return result;\r\n            }\r\n            return this.doRefreshSubTree(node, recursive, viewStateContext);\r\n        });\r\n    }\r\n    doRefreshSubTree(node, recursive, viewStateContext) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let done;\r\n            node.refreshPromise = new Promise(c => done = c);\r\n            this.subTreeRefreshPromises.set(node, node.refreshPromise);\r\n            node.refreshPromise.finally(() => {\r\n                node.refreshPromise = undefined;\r\n                this.subTreeRefreshPromises.delete(node);\r\n            });\r\n            try {\r\n                const childrenToRefresh = yield this.doRefreshNode(node, recursive, viewStateContext);\r\n                node.stale = false;\r\n                yield Promise.all(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\r\n            }\r\n            finally {\r\n                done();\r\n            }\r\n        });\r\n    }\r\n    doRefreshNode(node, recursive, viewStateContext) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            node.hasChildren = !!this.dataSource.hasChildren(node.element);\r\n            let childrenPromise;\r\n            if (!node.hasChildren) {\r\n                childrenPromise = Promise.resolve(Iterable.empty());\r\n            }\r\n            else {\r\n                const slowTimeout = timeout(800);\r\n                slowTimeout.then(() => {\r\n                    node.slow = true;\r\n                    this._onDidChangeNodeSlowState.fire(node);\r\n                }, _ => null);\r\n                childrenPromise = this.doGetChildren(node)\r\n                    .finally(() => slowTimeout.cancel());\r\n            }\r\n            try {\r\n                const children = yield childrenPromise;\r\n                return this.setChildren(node, children, recursive, viewStateContext);\r\n            }\r\n            catch (err) {\r\n                if (node !== this.root && this.tree.hasElement(node)) {\r\n                    this.tree.collapse(node);\r\n                }\r\n                if (isPromiseCanceledError(err)) {\r\n                    return [];\r\n                }\r\n                throw err;\r\n            }\r\n            finally {\r\n                if (node.slow) {\r\n                    node.slow = false;\r\n                    this._onDidChangeNodeSlowState.fire(node);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    doGetChildren(node) {\r\n        let result = this.refreshPromises.get(node);\r\n        if (result) {\r\n            return result;\r\n        }\r\n        result = createCancelablePromise(() => __awaiter(this, void 0, void 0, function* () {\r\n            const children = yield this.dataSource.getChildren(node.element);\r\n            return this.processChildren(children);\r\n        }));\r\n        this.refreshPromises.set(node, result);\r\n        return result.finally(() => { this.refreshPromises.delete(node); });\r\n    }\r\n    _onDidChangeCollapseState({ node, deep }) {\r\n        if (node.element === null) {\r\n            return;\r\n        }\r\n        if (!node.collapsed && node.element.stale) {\r\n            if (deep) {\r\n                this.collapse(node.element.element);\r\n            }\r\n            else {\r\n                this.refreshAndRenderNode(node.element, false)\r\n                    .catch(onUnexpectedError);\r\n            }\r\n        }\r\n    }\r\n    setChildren(node, childrenElementsIterable, recursive, viewStateContext) {\r\n        const childrenElements = [...childrenElementsIterable];\r\n        // perf: if the node was and still is a leaf, avoid all this hassle\r\n        if (node.children.length === 0 && childrenElements.length === 0) {\r\n            return [];\r\n        }\r\n        const nodesToForget = new Map();\r\n        const childrenTreeNodesById = new Map();\r\n        for (const child of node.children) {\r\n            nodesToForget.set(child.element, child);\r\n            if (this.identityProvider) {\r\n                const collapsed = this.tree.isCollapsed(child);\r\n                childrenTreeNodesById.set(child.id, { node: child, collapsed });\r\n            }\r\n        }\r\n        const childrenToRefresh = [];\r\n        const children = childrenElements.map(element => {\r\n            const hasChildren = !!this.dataSource.hasChildren(element);\r\n            if (!this.identityProvider) {\r\n                const asyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, hasChildren });\r\n                if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\r\n                    asyncDataTreeNode.collapsedByDefault = false;\r\n                    childrenToRefresh.push(asyncDataTreeNode);\r\n                }\r\n                return asyncDataTreeNode;\r\n            }\r\n            const id = this.identityProvider.getId(element).toString();\r\n            const result = childrenTreeNodesById.get(id);\r\n            if (result) {\r\n                const asyncDataTreeNode = result.node;\r\n                nodesToForget.delete(asyncDataTreeNode.element);\r\n                this.nodes.delete(asyncDataTreeNode.element);\r\n                this.nodes.set(element, asyncDataTreeNode);\r\n                asyncDataTreeNode.element = element;\r\n                asyncDataTreeNode.hasChildren = hasChildren;\r\n                if (recursive) {\r\n                    if (result.collapsed) {\r\n                        asyncDataTreeNode.children.forEach(node => dfs(node, node => this.nodes.delete(node.element)));\r\n                        asyncDataTreeNode.children.splice(0, asyncDataTreeNode.children.length);\r\n                        asyncDataTreeNode.stale = true;\r\n                    }\r\n                    else {\r\n                        childrenToRefresh.push(asyncDataTreeNode);\r\n                    }\r\n                }\r\n                else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\r\n                    asyncDataTreeNode.collapsedByDefault = false;\r\n                    childrenToRefresh.push(asyncDataTreeNode);\r\n                }\r\n                return asyncDataTreeNode;\r\n            }\r\n            const childAsyncDataTreeNode = createAsyncDataTreeNode({ element, parent: node, id, hasChildren });\r\n            if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\r\n                viewStateContext.focus.push(childAsyncDataTreeNode);\r\n            }\r\n            if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\r\n                viewStateContext.selection.push(childAsyncDataTreeNode);\r\n            }\r\n            if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\r\n                childrenToRefresh.push(childAsyncDataTreeNode);\r\n            }\r\n            else if (hasChildren && this.collapseByDefault && !this.collapseByDefault(element)) {\r\n                childAsyncDataTreeNode.collapsedByDefault = false;\r\n                childrenToRefresh.push(childAsyncDataTreeNode);\r\n            }\r\n            return childAsyncDataTreeNode;\r\n        });\r\n        for (const node of nodesToForget.values()) {\r\n            dfs(node, node => this.nodes.delete(node.element));\r\n        }\r\n        for (const child of children) {\r\n            this.nodes.set(child.element, child);\r\n        }\r\n        node.children.splice(0, node.children.length, ...children);\r\n        // TODO@joao this doesn't take filter into account\r\n        if (node !== this.root && this.autoExpandSingleChildren && children.length === 1 && childrenToRefresh.length === 0) {\r\n            children[0].collapsedByDefault = false;\r\n            childrenToRefresh.push(children[0]);\r\n        }\r\n        return childrenToRefresh;\r\n    }\r\n    render(node, viewStateContext, options) {\r\n        const children = node.children.map(node => this.asTreeElement(node, viewStateContext));\r\n        const objectTreeOptions = options && Object.assign(Object.assign({}, options), { diffIdentityProvider: options.diffIdentityProvider && {\r\n                getId(node) {\r\n                    return options.diffIdentityProvider.getId(node.element);\r\n                }\r\n            } });\r\n        this.tree.setChildren(node === this.root ? null : node, children, objectTreeOptions);\r\n        if (node !== this.root) {\r\n            this.tree.setCollapsible(node, node.hasChildren);\r\n        }\r\n        this._onDidRender.fire();\r\n    }\r\n    asTreeElement(node, viewStateContext) {\r\n        if (node.stale) {\r\n            return {\r\n                element: node,\r\n                collapsible: node.hasChildren,\r\n                collapsed: true\r\n            };\r\n        }\r\n        let collapsed;\r\n        if (viewStateContext && viewStateContext.viewState.expanded && node.id && viewStateContext.viewState.expanded.indexOf(node.id) > -1) {\r\n            collapsed = false;\r\n        }\r\n        else {\r\n            collapsed = node.collapsedByDefault;\r\n        }\r\n        node.collapsedByDefault = undefined;\r\n        return {\r\n            element: node,\r\n            children: node.hasChildren ? Iterable.map(node.children, child => this.asTreeElement(child, viewStateContext)) : [],\r\n            collapsible: node.hasChildren,\r\n            collapsed\r\n        };\r\n    }\r\n    processChildren(children) {\r\n        if (this.sorter) {\r\n            children = [...children].sort(this.sorter.compare.bind(this.sorter));\r\n        }\r\n        return children;\r\n    }\r\n    dispose() {\r\n        this.disposables.dispose();\r\n    }\r\n}\r\nclass CompressibleAsyncDataTreeNodeWrapper {\r\n    constructor(node) {\r\n        this.node = node;\r\n    }\r\n    get element() {\r\n        return {\r\n            elements: this.node.element.elements.map(e => e.element),\r\n            incompressible: this.node.element.incompressible\r\n        };\r\n    }\r\n    get children() { return this.node.children.map(node => new CompressibleAsyncDataTreeNodeWrapper(node)); }\r\n    get depth() { return this.node.depth; }\r\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\r\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\r\n    get collapsible() { return this.node.collapsible; }\r\n    get collapsed() { return this.node.collapsed; }\r\n    get visible() { return this.node.visible; }\r\n    get filterData() { return this.node.filterData; }\r\n}\r\nclass CompressibleAsyncDataTreeRenderer {\r\n    constructor(renderer, nodeMapper, compressibleNodeMapperProvider, onDidChangeTwistieState) {\r\n        this.renderer = renderer;\r\n        this.nodeMapper = nodeMapper;\r\n        this.compressibleNodeMapperProvider = compressibleNodeMapperProvider;\r\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\r\n        this.renderedNodes = new Map();\r\n        this.disposables = [];\r\n        this.templateId = renderer.templateId;\r\n    }\r\n    renderTemplate(container) {\r\n        const templateData = this.renderer.renderTemplate(container);\r\n        return { templateData };\r\n    }\r\n    renderElement(node, index, templateData, height) {\r\n        this.renderer.renderElement(this.nodeMapper.map(node), index, templateData.templateData, height);\r\n    }\r\n    renderCompressedElements(node, index, templateData, height) {\r\n        this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\r\n    }\r\n    renderTwistie(element, twistieElement) {\r\n        if (element.slow) {\r\n            twistieElement.classList.add(...treeItemLoadingIcon.classNamesArray);\r\n            return true;\r\n        }\r\n        else {\r\n            twistieElement.classList.remove(...treeItemLoadingIcon.classNamesArray);\r\n            return false;\r\n        }\r\n    }\r\n    disposeElement(node, index, templateData, height) {\r\n        if (this.renderer.disposeElement) {\r\n            this.renderer.disposeElement(this.nodeMapper.map(node), index, templateData.templateData, height);\r\n        }\r\n    }\r\n    disposeCompressedElements(node, index, templateData, height) {\r\n        if (this.renderer.disposeCompressedElements) {\r\n            this.renderer.disposeCompressedElements(this.compressibleNodeMapperProvider().map(node), index, templateData.templateData, height);\r\n        }\r\n    }\r\n    disposeTemplate(templateData) {\r\n        this.renderer.disposeTemplate(templateData.templateData);\r\n    }\r\n    dispose() {\r\n        this.renderedNodes.clear();\r\n        this.disposables = dispose(this.disposables);\r\n    }\r\n}\r\nfunction asCompressibleObjectTreeOptions(options) {\r\n    const objectTreeOptions = options && asObjectTreeOptions(options);\r\n    return objectTreeOptions && Object.assign(Object.assign({}, objectTreeOptions), { keyboardNavigationLabelProvider: objectTreeOptions.keyboardNavigationLabelProvider && Object.assign(Object.assign({}, objectTreeOptions.keyboardNavigationLabelProvider), { getCompressedNodeKeyboardNavigationLabel(els) {\r\n                return options.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(els.map(e => e.element));\r\n            } }) });\r\n}\r\nexport class CompressibleAsyncDataTree extends AsyncDataTree {\r\n    constructor(user, container, virtualDelegate, compressionDelegate, renderers, dataSource, options = {}) {\r\n        super(user, container, virtualDelegate, renderers, dataSource, options);\r\n        this.compressionDelegate = compressionDelegate;\r\n        this.compressibleNodeMapper = new WeakMapper(node => new CompressibleAsyncDataTreeNodeWrapper(node));\r\n        this.filter = options.filter;\r\n    }\r\n    createTree(user, container, delegate, renderers, options) {\r\n        const objectTreeDelegate = new ComposedTreeDelegate(delegate);\r\n        const objectTreeRenderers = renderers.map(r => new CompressibleAsyncDataTreeRenderer(r, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event));\r\n        const objectTreeOptions = asCompressibleObjectTreeOptions(options) || {};\r\n        return new CompressibleObjectTree(user, container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\r\n    }\r\n    asTreeElement(node, viewStateContext) {\r\n        return Object.assign({ incompressible: this.compressionDelegate.isIncompressible(node.element) }, super.asTreeElement(node, viewStateContext));\r\n    }\r\n    updateOptions(options = {}) {\r\n        this.tree.updateOptions(options);\r\n    }\r\n    render(node, viewStateContext) {\r\n        if (!this.identityProvider) {\r\n            return super.render(node, viewStateContext);\r\n        }\r\n        // Preserve traits across compressions. Hacky but does the trick.\r\n        // This is hard to fix properly since it requires rewriting the traits\r\n        // across trees and lists. Let's just keep it this way for now.\r\n        const getId = (element) => this.identityProvider.getId(element).toString();\r\n        const getUncompressedIds = (nodes) => {\r\n            const result = new Set();\r\n            for (const node of nodes) {\r\n                const compressedNode = this.tree.getCompressedTreeNode(node === this.root ? null : node);\r\n                if (!compressedNode.element) {\r\n                    continue;\r\n                }\r\n                for (const node of compressedNode.element.elements) {\r\n                    result.add(getId(node.element));\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        const oldSelection = getUncompressedIds(this.tree.getSelection());\r\n        const oldFocus = getUncompressedIds(this.tree.getFocus());\r\n        super.render(node, viewStateContext);\r\n        const selection = this.getSelection();\r\n        let didChangeSelection = false;\r\n        const focus = this.getFocus();\r\n        let didChangeFocus = false;\r\n        const visit = (node) => {\r\n            const compressedNode = node.element;\r\n            if (compressedNode) {\r\n                for (let i = 0; i < compressedNode.elements.length; i++) {\r\n                    const id = getId(compressedNode.elements[i].element);\r\n                    const element = compressedNode.elements[compressedNode.elements.length - 1].element;\r\n                    // github.com/microsoft/vscode/issues/85938\r\n                    if (oldSelection.has(id) && selection.indexOf(element) === -1) {\r\n                        selection.push(element);\r\n                        didChangeSelection = true;\r\n                    }\r\n                    if (oldFocus.has(id) && focus.indexOf(element) === -1) {\r\n                        focus.push(element);\r\n                        didChangeFocus = true;\r\n                    }\r\n                }\r\n            }\r\n            node.children.forEach(visit);\r\n        };\r\n        visit(this.tree.getCompressedTreeNode(node === this.root ? null : node));\r\n        if (didChangeSelection) {\r\n            this.setSelection(selection);\r\n        }\r\n        if (didChangeFocus) {\r\n            this.setFocus(focus);\r\n        }\r\n    }\r\n    // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work\r\n    // and we have to filter everything beforehand\r\n    // Related to #85193 and #85835\r\n    processChildren(children) {\r\n        if (this.filter) {\r\n            children = Iterable.filter(children, e => {\r\n                const result = this.filter.filter(e, 1 /* Visible */);\r\n                const visibility = getVisibility(result);\r\n                if (visibility === 2 /* Recurse */) {\r\n                    throw new Error('Recursive tree visibility not supported in async data compressed trees');\r\n                }\r\n                return visibility === 1 /* Visible */;\r\n            });\r\n        }\r\n        return super.processChildren(children);\r\n    }\r\n}\r\nfunction getVisibility(filterResult) {\r\n    if (typeof filterResult === 'boolean') {\r\n        return filterResult ? 1 /* Visible */ : 0 /* Hidden */;\r\n    }\r\n    else if (isFilterResult(filterResult)) {\r\n        return getVisibleState(filterResult.visibility);\r\n    }\r\n    else {\r\n        return getVisibleState(filterResult);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}