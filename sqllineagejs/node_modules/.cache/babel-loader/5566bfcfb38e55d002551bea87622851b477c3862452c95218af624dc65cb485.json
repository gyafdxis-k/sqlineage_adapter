{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationTokenSource } from './cancellation.js';\nimport * as errors from './errors.js';\nimport { toDisposable } from './lifecycle.js';\nexport function isThenable(obj) {\n  return obj && typeof obj.then === 'function';\n}\nexport function createCancelablePromise(callback) {\n  const source = new CancellationTokenSource();\n  const thenable = callback(source.token);\n  const promise = new Promise((resolve, reject) => {\n    source.token.onCancellationRequested(() => {\n      reject(errors.canceled());\n    });\n    Promise.resolve(thenable).then(value => {\n      source.dispose();\n      resolve(value);\n    }, err => {\n      source.dispose();\n      reject(err);\n    });\n  });\n  return new class {\n    cancel() {\n      source.cancel();\n    }\n    then(resolve, reject) {\n      return promise.then(resolve, reject);\n    }\n    catch(reject) {\n      return this.then(undefined, reject);\n    }\n    finally(onfinally) {\n      return promise.finally(onfinally);\n    }\n  }();\n}\nexport function raceCancellation(promise, token, defaultValue) {\n  return Promise.race([promise, new Promise(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\n}\n/**\r\n * A helper to delay (debounce) execution of a task that is being requested often.\r\n *\r\n * Following the throttler, now imagine the mail man wants to optimize the number of\r\n * trips proactively. The trip itself can be long, so he decides not to make the trip\r\n * as soon as a letter is submitted. Instead he waits a while, in case more\r\n * letters are submitted. After said waiting period, if no letters were submitted, he\r\n * decides to make the trip. Imagine that N more letters were submitted after the first\r\n * one, all within a short period of time between each other. Even though N+1\r\n * submissions occurred, only 1 delivery was made.\r\n *\r\n * The delayer offers this behavior via the trigger() method, into which both the task\r\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\r\n * the example:\r\n *\r\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\r\n * \t\tconst letters = [];\r\n *\r\n * \t\tfunction letterReceived(l) {\r\n * \t\t\tletters.push(l);\r\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\r\n * \t\t}\r\n */\nexport class Delayer {\n  constructor(defaultDelay) {\n    this.defaultDelay = defaultDelay;\n    this.timeout = null;\n    this.completionPromise = null;\n    this.doResolve = null;\n    this.doReject = null;\n    this.task = null;\n  }\n  trigger(task) {\n    let delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultDelay;\n    this.task = task;\n    this.cancelTimeout();\n    if (!this.completionPromise) {\n      this.completionPromise = new Promise((resolve, reject) => {\n        this.doResolve = resolve;\n        this.doReject = reject;\n      }).then(() => {\n        this.completionPromise = null;\n        this.doResolve = null;\n        if (this.task) {\n          const task = this.task;\n          this.task = null;\n          return task();\n        }\n        return undefined;\n      });\n    }\n    this.timeout = setTimeout(() => {\n      this.timeout = null;\n      if (this.doResolve) {\n        this.doResolve(null);\n      }\n    }, delay);\n    return this.completionPromise;\n  }\n  isTriggered() {\n    return this.timeout !== null;\n  }\n  cancel() {\n    this.cancelTimeout();\n    if (this.completionPromise) {\n      if (this.doReject) {\n        this.doReject(errors.canceled());\n      }\n      this.completionPromise = null;\n    }\n  }\n  cancelTimeout() {\n    if (this.timeout !== null) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n    }\n  }\n  dispose() {\n    this.cancelTimeout();\n  }\n}\nexport function timeout(millis, token) {\n  if (!token) {\n    return createCancelablePromise(token => timeout(millis, token));\n  }\n  return new Promise((resolve, reject) => {\n    const handle = setTimeout(resolve, millis);\n    token.onCancellationRequested(() => {\n      clearTimeout(handle);\n      reject(errors.canceled());\n    });\n  });\n}\nexport function disposableTimeout(handler) {\n  let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const timer = setTimeout(handler, timeout);\n  return toDisposable(() => clearTimeout(timer));\n}\nexport function first(promiseFactories) {\n  let shouldStop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : t => !!t;\n  let defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let index = 0;\n  const len = promiseFactories.length;\n  const loop = () => {\n    if (index >= len) {\n      return Promise.resolve(defaultValue);\n    }\n    const factory = promiseFactories[index++];\n    const promise = Promise.resolve(factory());\n    return promise.then(result => {\n      if (shouldStop(result)) {\n        return Promise.resolve(result);\n      }\n      return loop();\n    });\n  };\n  return loop();\n}\nexport class TimeoutTimer {\n  constructor(runner, timeout) {\n    this._token = -1;\n    if (typeof runner === 'function' && typeof timeout === 'number') {\n      this.setIfNotSet(runner, timeout);\n    }\n  }\n  dispose() {\n    this.cancel();\n  }\n  cancel() {\n    if (this._token !== -1) {\n      clearTimeout(this._token);\n      this._token = -1;\n    }\n  }\n  cancelAndSet(runner, timeout) {\n    this.cancel();\n    this._token = setTimeout(() => {\n      this._token = -1;\n      runner();\n    }, timeout);\n  }\n  setIfNotSet(runner, timeout) {\n    if (this._token !== -1) {\n      // timer is already set\n      return;\n    }\n    this._token = setTimeout(() => {\n      this._token = -1;\n      runner();\n    }, timeout);\n  }\n}\nexport class IntervalTimer {\n  constructor() {\n    this._token = -1;\n  }\n  dispose() {\n    this.cancel();\n  }\n  cancel() {\n    if (this._token !== -1) {\n      clearInterval(this._token);\n      this._token = -1;\n    }\n  }\n  cancelAndSet(runner, interval) {\n    this.cancel();\n    this._token = setInterval(() => {\n      runner();\n    }, interval);\n  }\n}\nexport class RunOnceScheduler {\n  constructor(runner, delay) {\n    this.timeoutToken = -1;\n    this.runner = runner;\n    this.timeout = delay;\n    this.timeoutHandler = this.onTimeout.bind(this);\n  }\n  /**\r\n   * Dispose RunOnceScheduler\r\n   */\n  dispose() {\n    this.cancel();\n    this.runner = null;\n  }\n  /**\r\n   * Cancel current scheduled runner (if any).\r\n   */\n  cancel() {\n    if (this.isScheduled()) {\n      clearTimeout(this.timeoutToken);\n      this.timeoutToken = -1;\n    }\n  }\n  /**\r\n   * Cancel previous runner (if any) & schedule a new runner.\r\n   */\n  schedule() {\n    let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    this.cancel();\n    this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n  }\n  get delay() {\n    return this.timeout;\n  }\n  set delay(value) {\n    this.timeout = value;\n  }\n  /**\r\n   * Returns true if scheduled.\r\n   */\n  isScheduled() {\n    return this.timeoutToken !== -1;\n  }\n  onTimeout() {\n    this.timeoutToken = -1;\n    if (this.runner) {\n      this.doRun();\n    }\n  }\n  doRun() {\n    if (this.runner) {\n      this.runner();\n    }\n  }\n}\n/**\r\n * Execute the callback the next time the browser is idle\r\n */\nexport let runWhenIdle;\n(function () {\n  if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n    const dummyIdle = Object.freeze({\n      didTimeout: true,\n      timeRemaining() {\n        return 15;\n      }\n    });\n    runWhenIdle = runner => {\n      const handle = setTimeout(() => runner(dummyIdle));\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n          disposed = true;\n          clearTimeout(handle);\n        }\n      };\n    };\n  } else {\n    runWhenIdle = (runner, timeout) => {\n      const handle = requestIdleCallback(runner, typeof timeout === 'number' ? {\n        timeout\n      } : undefined);\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n          disposed = true;\n          cancelIdleCallback(handle);\n        }\n      };\n    };\n  }\n})();\n/**\r\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\r\n * here: https://philipwalton.com/articles/idle-until-urgent/\r\n */\nexport class IdleValue {\n  constructor(executor) {\n    this._didRun = false;\n    this._executor = () => {\n      try {\n        this._value = executor();\n      } catch (err) {\n        this._error = err;\n      } finally {\n        this._didRun = true;\n      }\n    };\n    this._handle = runWhenIdle(() => this._executor());\n  }\n  dispose() {\n    this._handle.dispose();\n  }\n  get value() {\n    if (!this._didRun) {\n      this._handle.dispose();\n      this._executor();\n    }\n    if (this._error) {\n      throw this._error;\n    }\n    return this._value;\n  }\n}","map":{"version":3,"names":["CancellationTokenSource","errors","toDisposable","isThenable","obj","then","createCancelablePromise","callback","source","thenable","token","promise","Promise","resolve","reject","onCancellationRequested","canceled","value","dispose","err","cancel","catch","undefined","finally","onfinally","raceCancellation","defaultValue","race","Delayer","constructor","defaultDelay","timeout","completionPromise","doResolve","doReject","task","trigger","delay","arguments","length","cancelTimeout","setTimeout","isTriggered","clearTimeout","millis","handle","disposableTimeout","handler","timer","first","promiseFactories","shouldStop","t","index","len","loop","factory","result","TimeoutTimer","runner","_token","setIfNotSet","cancelAndSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","onTimeout","bind","isScheduled","schedule","doRun","runWhenIdle","requestIdleCallback","cancelIdleCallback","dummyIdle","Object","freeze","didTimeout","timeRemaining","disposed","IdleValue","executor","_didRun","_executor","_value","_error","_handle"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/async.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { CancellationTokenSource } from './cancellation.js';\r\nimport * as errors from './errors.js';\r\nimport { toDisposable } from './lifecycle.js';\r\nexport function isThenable(obj) {\r\n    return obj && typeof obj.then === 'function';\r\n}\r\nexport function createCancelablePromise(callback) {\r\n    const source = new CancellationTokenSource();\r\n    const thenable = callback(source.token);\r\n    const promise = new Promise((resolve, reject) => {\r\n        source.token.onCancellationRequested(() => {\r\n            reject(errors.canceled());\r\n        });\r\n        Promise.resolve(thenable).then(value => {\r\n            source.dispose();\r\n            resolve(value);\r\n        }, err => {\r\n            source.dispose();\r\n            reject(err);\r\n        });\r\n    });\r\n    return new class {\r\n        cancel() {\r\n            source.cancel();\r\n        }\r\n        then(resolve, reject) {\r\n            return promise.then(resolve, reject);\r\n        }\r\n        catch(reject) {\r\n            return this.then(undefined, reject);\r\n        }\r\n        finally(onfinally) {\r\n            return promise.finally(onfinally);\r\n        }\r\n    };\r\n}\r\nexport function raceCancellation(promise, token, defaultValue) {\r\n    return Promise.race([promise, new Promise(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\r\n}\r\n/**\r\n * A helper to delay (debounce) execution of a task that is being requested often.\r\n *\r\n * Following the throttler, now imagine the mail man wants to optimize the number of\r\n * trips proactively. The trip itself can be long, so he decides not to make the trip\r\n * as soon as a letter is submitted. Instead he waits a while, in case more\r\n * letters are submitted. After said waiting period, if no letters were submitted, he\r\n * decides to make the trip. Imagine that N more letters were submitted after the first\r\n * one, all within a short period of time between each other. Even though N+1\r\n * submissions occurred, only 1 delivery was made.\r\n *\r\n * The delayer offers this behavior via the trigger() method, into which both the task\r\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\r\n * the example:\r\n *\r\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\r\n * \t\tconst letters = [];\r\n *\r\n * \t\tfunction letterReceived(l) {\r\n * \t\t\tletters.push(l);\r\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\r\n * \t\t}\r\n */\r\nexport class Delayer {\r\n    constructor(defaultDelay) {\r\n        this.defaultDelay = defaultDelay;\r\n        this.timeout = null;\r\n        this.completionPromise = null;\r\n        this.doResolve = null;\r\n        this.doReject = null;\r\n        this.task = null;\r\n    }\r\n    trigger(task, delay = this.defaultDelay) {\r\n        this.task = task;\r\n        this.cancelTimeout();\r\n        if (!this.completionPromise) {\r\n            this.completionPromise = new Promise((resolve, reject) => {\r\n                this.doResolve = resolve;\r\n                this.doReject = reject;\r\n            }).then(() => {\r\n                this.completionPromise = null;\r\n                this.doResolve = null;\r\n                if (this.task) {\r\n                    const task = this.task;\r\n                    this.task = null;\r\n                    return task();\r\n                }\r\n                return undefined;\r\n            });\r\n        }\r\n        this.timeout = setTimeout(() => {\r\n            this.timeout = null;\r\n            if (this.doResolve) {\r\n                this.doResolve(null);\r\n            }\r\n        }, delay);\r\n        return this.completionPromise;\r\n    }\r\n    isTriggered() {\r\n        return this.timeout !== null;\r\n    }\r\n    cancel() {\r\n        this.cancelTimeout();\r\n        if (this.completionPromise) {\r\n            if (this.doReject) {\r\n                this.doReject(errors.canceled());\r\n            }\r\n            this.completionPromise = null;\r\n        }\r\n    }\r\n    cancelTimeout() {\r\n        if (this.timeout !== null) {\r\n            clearTimeout(this.timeout);\r\n            this.timeout = null;\r\n        }\r\n    }\r\n    dispose() {\r\n        this.cancelTimeout();\r\n    }\r\n}\r\nexport function timeout(millis, token) {\r\n    if (!token) {\r\n        return createCancelablePromise(token => timeout(millis, token));\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n        const handle = setTimeout(resolve, millis);\r\n        token.onCancellationRequested(() => {\r\n            clearTimeout(handle);\r\n            reject(errors.canceled());\r\n        });\r\n    });\r\n}\r\nexport function disposableTimeout(handler, timeout = 0) {\r\n    const timer = setTimeout(handler, timeout);\r\n    return toDisposable(() => clearTimeout(timer));\r\n}\r\nexport function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\r\n    let index = 0;\r\n    const len = promiseFactories.length;\r\n    const loop = () => {\r\n        if (index >= len) {\r\n            return Promise.resolve(defaultValue);\r\n        }\r\n        const factory = promiseFactories[index++];\r\n        const promise = Promise.resolve(factory());\r\n        return promise.then(result => {\r\n            if (shouldStop(result)) {\r\n                return Promise.resolve(result);\r\n            }\r\n            return loop();\r\n        });\r\n    };\r\n    return loop();\r\n}\r\nexport class TimeoutTimer {\r\n    constructor(runner, timeout) {\r\n        this._token = -1;\r\n        if (typeof runner === 'function' && typeof timeout === 'number') {\r\n            this.setIfNotSet(runner, timeout);\r\n        }\r\n    }\r\n    dispose() {\r\n        this.cancel();\r\n    }\r\n    cancel() {\r\n        if (this._token !== -1) {\r\n            clearTimeout(this._token);\r\n            this._token = -1;\r\n        }\r\n    }\r\n    cancelAndSet(runner, timeout) {\r\n        this.cancel();\r\n        this._token = setTimeout(() => {\r\n            this._token = -1;\r\n            runner();\r\n        }, timeout);\r\n    }\r\n    setIfNotSet(runner, timeout) {\r\n        if (this._token !== -1) {\r\n            // timer is already set\r\n            return;\r\n        }\r\n        this._token = setTimeout(() => {\r\n            this._token = -1;\r\n            runner();\r\n        }, timeout);\r\n    }\r\n}\r\nexport class IntervalTimer {\r\n    constructor() {\r\n        this._token = -1;\r\n    }\r\n    dispose() {\r\n        this.cancel();\r\n    }\r\n    cancel() {\r\n        if (this._token !== -1) {\r\n            clearInterval(this._token);\r\n            this._token = -1;\r\n        }\r\n    }\r\n    cancelAndSet(runner, interval) {\r\n        this.cancel();\r\n        this._token = setInterval(() => {\r\n            runner();\r\n        }, interval);\r\n    }\r\n}\r\nexport class RunOnceScheduler {\r\n    constructor(runner, delay) {\r\n        this.timeoutToken = -1;\r\n        this.runner = runner;\r\n        this.timeout = delay;\r\n        this.timeoutHandler = this.onTimeout.bind(this);\r\n    }\r\n    /**\r\n     * Dispose RunOnceScheduler\r\n     */\r\n    dispose() {\r\n        this.cancel();\r\n        this.runner = null;\r\n    }\r\n    /**\r\n     * Cancel current scheduled runner (if any).\r\n     */\r\n    cancel() {\r\n        if (this.isScheduled()) {\r\n            clearTimeout(this.timeoutToken);\r\n            this.timeoutToken = -1;\r\n        }\r\n    }\r\n    /**\r\n     * Cancel previous runner (if any) & schedule a new runner.\r\n     */\r\n    schedule(delay = this.timeout) {\r\n        this.cancel();\r\n        this.timeoutToken = setTimeout(this.timeoutHandler, delay);\r\n    }\r\n    get delay() {\r\n        return this.timeout;\r\n    }\r\n    set delay(value) {\r\n        this.timeout = value;\r\n    }\r\n    /**\r\n     * Returns true if scheduled.\r\n     */\r\n    isScheduled() {\r\n        return this.timeoutToken !== -1;\r\n    }\r\n    onTimeout() {\r\n        this.timeoutToken = -1;\r\n        if (this.runner) {\r\n            this.doRun();\r\n        }\r\n    }\r\n    doRun() {\r\n        if (this.runner) {\r\n            this.runner();\r\n        }\r\n    }\r\n}\r\n/**\r\n * Execute the callback the next time the browser is idle\r\n */\r\nexport let runWhenIdle;\r\n(function () {\r\n    if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\r\n        const dummyIdle = Object.freeze({\r\n            didTimeout: true,\r\n            timeRemaining() { return 15; }\r\n        });\r\n        runWhenIdle = (runner) => {\r\n            const handle = setTimeout(() => runner(dummyIdle));\r\n            let disposed = false;\r\n            return {\r\n                dispose() {\r\n                    if (disposed) {\r\n                        return;\r\n                    }\r\n                    disposed = true;\r\n                    clearTimeout(handle);\r\n                }\r\n            };\r\n        };\r\n    }\r\n    else {\r\n        runWhenIdle = (runner, timeout) => {\r\n            const handle = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\r\n            let disposed = false;\r\n            return {\r\n                dispose() {\r\n                    if (disposed) {\r\n                        return;\r\n                    }\r\n                    disposed = true;\r\n                    cancelIdleCallback(handle);\r\n                }\r\n            };\r\n        };\r\n    }\r\n})();\r\n/**\r\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\r\n * here: https://philipwalton.com/articles/idle-until-urgent/\r\n */\r\nexport class IdleValue {\r\n    constructor(executor) {\r\n        this._didRun = false;\r\n        this._executor = () => {\r\n            try {\r\n                this._value = executor();\r\n            }\r\n            catch (err) {\r\n                this._error = err;\r\n            }\r\n            finally {\r\n                this._didRun = true;\r\n            }\r\n        };\r\n        this._handle = runWhenIdle(() => this._executor());\r\n    }\r\n    dispose() {\r\n        this._handle.dispose();\r\n    }\r\n    get value() {\r\n        if (!this._didRun) {\r\n            this._handle.dispose();\r\n            this._executor();\r\n        }\r\n        if (this._error) {\r\n            throw this._error;\r\n        }\r\n        return this._value;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}