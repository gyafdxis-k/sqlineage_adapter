{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Configuration } from '../config/configuration.js';\nimport { LineBreakData } from '../../common/viewModel/viewModel.js';\nconst ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('domLineBreaksComputer', {\n  createHTML: value => value\n});\nexport class DOMLineBreaksComputerFactory {\n  static create() {\n    return new DOMLineBreaksComputerFactory();\n  }\n  constructor() {}\n  createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n    tabSize = tabSize | 0; //@perf\n    wrappingColumn = +wrappingColumn; //@perf\n    let requests = [];\n    return {\n      addRequest: (lineText, previousLineBreakData) => {\n        requests.push(lineText);\n      },\n      finalize: () => {\n        return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent);\n      }\n    };\n  }\n}\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent) {\n  var _a;\n  if (firstLineBreakColumn === -1) {\n    const result = [];\n    for (let i = 0, len = requests.length; i < len; i++) {\n      result[i] = null;\n    }\n    return result;\n  }\n  const overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\n  // Cannot respect WrappingIndent.Indent and WrappingIndent.DeepIndent because that would require\n  // two dom layouts, in order to first set the width of the first line, and then set the width of the wrapped lines\n  if (wrappingIndent === 2 /* Indent */ || wrappingIndent === 3 /* DeepIndent */) {\n    wrappingIndent = 1 /* Same */;\n  }\n\n  const containerDomNode = document.createElement('div');\n  Configuration.applyFontInfoSlow(containerDomNode, fontInfo);\n  const sb = createStringBuilder(10000);\n  const firstNonWhitespaceIndices = [];\n  const wrappedTextIndentLengths = [];\n  const renderLineContents = [];\n  const allCharOffsets = [];\n  const allVisibleColumns = [];\n  for (let i = 0; i < requests.length; i++) {\n    const lineContent = requests[i];\n    let firstNonWhitespaceIndex = 0;\n    let wrappedTextIndentLength = 0;\n    let width = overallWidth;\n    if (wrappingIndent !== 0 /* None */) {\n      firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n      if (firstNonWhitespaceIndex === -1) {\n        // all whitespace line\n        firstNonWhitespaceIndex = 0;\n      } else {\n        // Track existing indent\n        for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n          const charWidth = lineContent.charCodeAt(i) === 9 /* Tab */ ? tabSize - wrappedTextIndentLength % tabSize : 1;\n          wrappedTextIndentLength += charWidth;\n        }\n        const indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\n        // Force sticking to beginning of line if no character would fit except for the indentation\n        if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n          firstNonWhitespaceIndex = 0;\n          wrappedTextIndentLength = 0;\n        } else {\n          width = overallWidth - indentWidth;\n        }\n      }\n    }\n    const renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n    const tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb);\n    firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\n    wrappedTextIndentLengths[i] = wrappedTextIndentLength;\n    renderLineContents[i] = renderLineContent;\n    allCharOffsets[i] = tmp[0];\n    allVisibleColumns[i] = tmp[1];\n  }\n  const html = sb.build();\n  const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\n  containerDomNode.innerHTML = trustedhtml;\n  containerDomNode.style.position = 'absolute';\n  containerDomNode.style.top = '10000';\n  containerDomNode.style.wordWrap = 'break-word';\n  document.body.appendChild(containerDomNode);\n  let range = document.createRange();\n  const lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n  let result = [];\n  for (let i = 0; i < requests.length; i++) {\n    const lineDomNode = lineDomNodes[i];\n    const breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\n    if (breakOffsets === null) {\n      result[i] = null;\n      continue;\n    }\n    const firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\n    const wrappedTextIndentLength = wrappedTextIndentLengths[i];\n    const visibleColumns = allVisibleColumns[i];\n    const breakOffsetsVisibleColumn = [];\n    for (let j = 0, len = breakOffsets.length; j < len; j++) {\n      breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n    }\n    if (firstNonWhitespaceIndex !== 0) {\n      // All break offsets are relative to the renderLineContent, make them absolute again\n      for (let j = 0, len = breakOffsets.length; j < len; j++) {\n        breakOffsets[j] += firstNonWhitespaceIndex;\n      }\n    }\n    result[i] = new LineBreakData(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\n  }\n  document.body.removeChild(containerDomNode);\n  return result;\n}\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb) {\n  sb.appendASCIIString('<div style=\"width:');\n  sb.appendASCIIString(String(width));\n  sb.appendASCIIString('px;\">');\n  // if (containsRTL) {\n  // \tsb.appendASCIIString('\" dir=\"ltr');\n  // }\n  const len = lineContent.length;\n  let visibleColumn = initialVisibleColumn;\n  let charOffset = 0;\n  let charOffsets = [];\n  let visibleColumns = [];\n  let nextCharCode = 0 < len ? lineContent.charCodeAt(0) : 0 /* Null */;\n  sb.appendASCIIString('<span>');\n  for (let charIndex = 0; charIndex < len; charIndex++) {\n    if (charIndex !== 0 && charIndex % 16384 /* SPAN_MODULO_LIMIT */ === 0) {\n      sb.appendASCIIString('</span><span>');\n    }\n    charOffsets[charIndex] = charOffset;\n    visibleColumns[charIndex] = visibleColumn;\n    const charCode = nextCharCode;\n    nextCharCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */;\n    let producedCharacters = 1;\n    let charWidth = 1;\n    switch (charCode) {\n      case 9 /* Tab */:\n        producedCharacters = tabSize - visibleColumn % tabSize;\n        charWidth = producedCharacters;\n        for (let space = 1; space <= producedCharacters; space++) {\n          if (space < producedCharacters) {\n            sb.write1(0xA0); // &nbsp;\n          } else {\n            sb.appendASCII(32 /* Space */);\n          }\n        }\n\n        break;\n      case 32 /* Space */:\n        if (nextCharCode === 32 /* Space */) {\n          sb.write1(0xA0); // &nbsp;\n        } else {\n          sb.appendASCII(32 /* Space */);\n        }\n\n        break;\n      case 60 /* LessThan */:\n        sb.appendASCIIString('&lt;');\n        break;\n      case 62 /* GreaterThan */:\n        sb.appendASCIIString('&gt;');\n        break;\n      case 38 /* Ampersand */:\n        sb.appendASCIIString('&amp;');\n        break;\n      case 0 /* Null */:\n        sb.appendASCIIString('&#00;');\n        break;\n      case 65279 /* UTF8_BOM */:\n      case 8232 /* LINE_SEPARATOR */:\n      case 8233 /* PARAGRAPH_SEPARATOR */:\n      case 133 /* NEXT_LINE */:\n        sb.write1(0xFFFD);\n        break;\n      default:\n        if (strings.isFullWidthCharacter(charCode)) {\n          charWidth++;\n        }\n        // if (renderControlCharacters && charCode < 32) {\n        // \tsb.write1(9216 + charCode);\n        // } else {\n        sb.write1(charCode);\n      // }\n    }\n\n    charOffset += producedCharacters;\n    visibleColumn += charWidth;\n  }\n  sb.appendASCIIString('</span>');\n  charOffsets[lineContent.length] = charOffset;\n  visibleColumns[lineContent.length] = visibleColumn;\n  sb.appendASCIIString('</div>');\n  return [charOffsets, visibleColumns];\n}\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n  if (lineContent.length <= 1) {\n    return null;\n  }\n  const spans = Array.prototype.slice.call(lineDomNode.children, 0);\n  const breakOffsets = [];\n  try {\n    discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n  } catch (err) {\n    console.log(err);\n    return null;\n  }\n  if (breakOffsets.length === 0) {\n    return null;\n  }\n  breakOffsets.push(lineContent.length);\n  return breakOffsets;\n}\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\n  if (low === high) {\n    return;\n  }\n  lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\n  highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\n  if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n    // same line\n    return;\n  }\n  // there is at least one line break between these two offsets\n  if (low + 1 === high) {\n    // the two characters are adjacent, so the line break must be exactly between them\n    result.push(high);\n    return;\n  }\n  const mid = low + (high - low) / 2 | 0;\n  const midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\n  discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\n  discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\n}\nfunction readClientRect(range, spans, startOffset, endOffset) {\n  range.setStart(spans[startOffset / 16384 /* SPAN_MODULO_LIMIT */ | 0].firstChild, startOffset % 16384 /* SPAN_MODULO_LIMIT */);\n  range.setEnd(spans[endOffset / 16384 /* SPAN_MODULO_LIMIT */ | 0].firstChild, endOffset % 16384 /* SPAN_MODULO_LIMIT */);\n  return range.getClientRects();\n}","map":{"version":3,"names":["_a","createStringBuilder","strings","Configuration","LineBreakData","ttPolicy","window","trustedTypes","createPolicy","createHTML","value","DOMLineBreaksComputerFactory","create","constructor","createLineBreaksComputer","fontInfo","tabSize","wrappingColumn","wrappingIndent","requests","addRequest","lineText","previousLineBreakData","push","finalize","createLineBreaks","firstLineBreakColumn","result","i","len","length","overallWidth","Math","round","typicalHalfwidthCharacterWidth","containerDomNode","document","createElement","applyFontInfoSlow","sb","firstNonWhitespaceIndices","wrappedTextIndentLengths","renderLineContents","allCharOffsets","allVisibleColumns","lineContent","firstNonWhitespaceIndex","wrappedTextIndentLength","width","charWidth","charCodeAt","indentWidth","ceil","spaceWidth","typicalFullwidthCharacterWidth","renderLineContent","substr","tmp","renderLine","html","build","trustedhtml","innerHTML","style","position","top","wordWrap","body","appendChild","range","createRange","lineDomNodes","Array","prototype","slice","call","children","lineDomNode","breakOffsets","readLineBreaks","visibleColumns","breakOffsetsVisibleColumn","j","removeChild","initialVisibleColumn","appendASCIIString","String","visibleColumn","charOffset","charOffsets","nextCharCode","charIndex","charCode","producedCharacters","space","write1","appendASCII","isFullWidthCharacter","spans","discoverBreaks","err","console","log","low","lowRects","high","highRects","readClientRect","abs","mid","midRects","startOffset","endOffset","setStart","firstChild","setEnd","getClientRects"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/browser/view/domLineBreaksComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar _a;\r\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { Configuration } from '../config/configuration.js';\r\nimport { LineBreakData } from '../../common/viewModel/viewModel.js';\r\nconst ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('domLineBreaksComputer', { createHTML: value => value });\r\nexport class DOMLineBreaksComputerFactory {\r\n    static create() {\r\n        return new DOMLineBreaksComputerFactory();\r\n    }\r\n    constructor() {\r\n    }\r\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\r\n        tabSize = tabSize | 0; //@perf\r\n        wrappingColumn = +wrappingColumn; //@perf\r\n        let requests = [];\r\n        return {\r\n            addRequest: (lineText, previousLineBreakData) => {\r\n                requests.push(lineText);\r\n            },\r\n            finalize: () => {\r\n                return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent);\r\n            }\r\n        };\r\n    }\r\n}\r\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent) {\r\n    var _a;\r\n    if (firstLineBreakColumn === -1) {\r\n        const result = [];\r\n        for (let i = 0, len = requests.length; i < len; i++) {\r\n            result[i] = null;\r\n        }\r\n        return result;\r\n    }\r\n    const overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\r\n    // Cannot respect WrappingIndent.Indent and WrappingIndent.DeepIndent because that would require\r\n    // two dom layouts, in order to first set the width of the first line, and then set the width of the wrapped lines\r\n    if (wrappingIndent === 2 /* Indent */ || wrappingIndent === 3 /* DeepIndent */) {\r\n        wrappingIndent = 1 /* Same */;\r\n    }\r\n    const containerDomNode = document.createElement('div');\r\n    Configuration.applyFontInfoSlow(containerDomNode, fontInfo);\r\n    const sb = createStringBuilder(10000);\r\n    const firstNonWhitespaceIndices = [];\r\n    const wrappedTextIndentLengths = [];\r\n    const renderLineContents = [];\r\n    const allCharOffsets = [];\r\n    const allVisibleColumns = [];\r\n    for (let i = 0; i < requests.length; i++) {\r\n        const lineContent = requests[i];\r\n        let firstNonWhitespaceIndex = 0;\r\n        let wrappedTextIndentLength = 0;\r\n        let width = overallWidth;\r\n        if (wrappingIndent !== 0 /* None */) {\r\n            firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\r\n            if (firstNonWhitespaceIndex === -1) {\r\n                // all whitespace line\r\n                firstNonWhitespaceIndex = 0;\r\n            }\r\n            else {\r\n                // Track existing indent\r\n                for (let i = 0; i < firstNonWhitespaceIndex; i++) {\r\n                    const charWidth = (lineContent.charCodeAt(i) === 9 /* Tab */\r\n                        ? (tabSize - (wrappedTextIndentLength % tabSize))\r\n                        : 1);\r\n                    wrappedTextIndentLength += charWidth;\r\n                }\r\n                const indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\r\n                // Force sticking to beginning of line if no character would fit except for the indentation\r\n                if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\r\n                    firstNonWhitespaceIndex = 0;\r\n                    wrappedTextIndentLength = 0;\r\n                }\r\n                else {\r\n                    width = overallWidth - indentWidth;\r\n                }\r\n            }\r\n        }\r\n        const renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\r\n        const tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb);\r\n        firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\r\n        wrappedTextIndentLengths[i] = wrappedTextIndentLength;\r\n        renderLineContents[i] = renderLineContent;\r\n        allCharOffsets[i] = tmp[0];\r\n        allVisibleColumns[i] = tmp[1];\r\n    }\r\n    const html = sb.build();\r\n    const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\r\n    containerDomNode.innerHTML = trustedhtml;\r\n    containerDomNode.style.position = 'absolute';\r\n    containerDomNode.style.top = '10000';\r\n    containerDomNode.style.wordWrap = 'break-word';\r\n    document.body.appendChild(containerDomNode);\r\n    let range = document.createRange();\r\n    const lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\r\n    let result = [];\r\n    for (let i = 0; i < requests.length; i++) {\r\n        const lineDomNode = lineDomNodes[i];\r\n        const breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\r\n        if (breakOffsets === null) {\r\n            result[i] = null;\r\n            continue;\r\n        }\r\n        const firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\r\n        const wrappedTextIndentLength = wrappedTextIndentLengths[i];\r\n        const visibleColumns = allVisibleColumns[i];\r\n        const breakOffsetsVisibleColumn = [];\r\n        for (let j = 0, len = breakOffsets.length; j < len; j++) {\r\n            breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\r\n        }\r\n        if (firstNonWhitespaceIndex !== 0) {\r\n            // All break offsets are relative to the renderLineContent, make them absolute again\r\n            for (let j = 0, len = breakOffsets.length; j < len; j++) {\r\n                breakOffsets[j] += firstNonWhitespaceIndex;\r\n            }\r\n        }\r\n        result[i] = new LineBreakData(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\r\n    }\r\n    document.body.removeChild(containerDomNode);\r\n    return result;\r\n}\r\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb) {\r\n    sb.appendASCIIString('<div style=\"width:');\r\n    sb.appendASCIIString(String(width));\r\n    sb.appendASCIIString('px;\">');\r\n    // if (containsRTL) {\r\n    // \tsb.appendASCIIString('\" dir=\"ltr');\r\n    // }\r\n    const len = lineContent.length;\r\n    let visibleColumn = initialVisibleColumn;\r\n    let charOffset = 0;\r\n    let charOffsets = [];\r\n    let visibleColumns = [];\r\n    let nextCharCode = (0 < len ? lineContent.charCodeAt(0) : 0 /* Null */);\r\n    sb.appendASCIIString('<span>');\r\n    for (let charIndex = 0; charIndex < len; charIndex++) {\r\n        if (charIndex !== 0 && charIndex % 16384 /* SPAN_MODULO_LIMIT */ === 0) {\r\n            sb.appendASCIIString('</span><span>');\r\n        }\r\n        charOffsets[charIndex] = charOffset;\r\n        visibleColumns[charIndex] = visibleColumn;\r\n        const charCode = nextCharCode;\r\n        nextCharCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\r\n        let producedCharacters = 1;\r\n        let charWidth = 1;\r\n        switch (charCode) {\r\n            case 9 /* Tab */:\r\n                producedCharacters = (tabSize - (visibleColumn % tabSize));\r\n                charWidth = producedCharacters;\r\n                for (let space = 1; space <= producedCharacters; space++) {\r\n                    if (space < producedCharacters) {\r\n                        sb.write1(0xA0); // &nbsp;\r\n                    }\r\n                    else {\r\n                        sb.appendASCII(32 /* Space */);\r\n                    }\r\n                }\r\n                break;\r\n            case 32 /* Space */:\r\n                if (nextCharCode === 32 /* Space */) {\r\n                    sb.write1(0xA0); // &nbsp;\r\n                }\r\n                else {\r\n                    sb.appendASCII(32 /* Space */);\r\n                }\r\n                break;\r\n            case 60 /* LessThan */:\r\n                sb.appendASCIIString('&lt;');\r\n                break;\r\n            case 62 /* GreaterThan */:\r\n                sb.appendASCIIString('&gt;');\r\n                break;\r\n            case 38 /* Ampersand */:\r\n                sb.appendASCIIString('&amp;');\r\n                break;\r\n            case 0 /* Null */:\r\n                sb.appendASCIIString('&#00;');\r\n                break;\r\n            case 65279 /* UTF8_BOM */:\r\n            case 8232 /* LINE_SEPARATOR */:\r\n            case 8233 /* PARAGRAPH_SEPARATOR */:\r\n            case 133 /* NEXT_LINE */:\r\n                sb.write1(0xFFFD);\r\n                break;\r\n            default:\r\n                if (strings.isFullWidthCharacter(charCode)) {\r\n                    charWidth++;\r\n                }\r\n                // if (renderControlCharacters && charCode < 32) {\r\n                // \tsb.write1(9216 + charCode);\r\n                // } else {\r\n                sb.write1(charCode);\r\n            // }\r\n        }\r\n        charOffset += producedCharacters;\r\n        visibleColumn += charWidth;\r\n    }\r\n    sb.appendASCIIString('</span>');\r\n    charOffsets[lineContent.length] = charOffset;\r\n    visibleColumns[lineContent.length] = visibleColumn;\r\n    sb.appendASCIIString('</div>');\r\n    return [charOffsets, visibleColumns];\r\n}\r\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\r\n    if (lineContent.length <= 1) {\r\n        return null;\r\n    }\r\n    const spans = Array.prototype.slice.call(lineDomNode.children, 0);\r\n    const breakOffsets = [];\r\n    try {\r\n        discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\r\n    }\r\n    catch (err) {\r\n        console.log(err);\r\n        return null;\r\n    }\r\n    if (breakOffsets.length === 0) {\r\n        return null;\r\n    }\r\n    breakOffsets.push(lineContent.length);\r\n    return breakOffsets;\r\n}\r\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\r\n    if (low === high) {\r\n        return;\r\n    }\r\n    lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\r\n    highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\r\n    if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\r\n        // same line\r\n        return;\r\n    }\r\n    // there is at least one line break between these two offsets\r\n    if (low + 1 === high) {\r\n        // the two characters are adjacent, so the line break must be exactly between them\r\n        result.push(high);\r\n        return;\r\n    }\r\n    const mid = low + ((high - low) / 2) | 0;\r\n    const midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\r\n    discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\r\n    discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\r\n}\r\nfunction readClientRect(range, spans, startOffset, endOffset) {\r\n    range.setStart(spans[(startOffset / 16384 /* SPAN_MODULO_LIMIT */) | 0].firstChild, startOffset % 16384 /* SPAN_MODULO_LIMIT */);\r\n    range.setEnd(spans[(endOffset / 16384 /* SPAN_MODULO_LIMIT */) | 0].firstChild, endOffset % 16384 /* SPAN_MODULO_LIMIT */);\r\n    return range.getClientRects();\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}