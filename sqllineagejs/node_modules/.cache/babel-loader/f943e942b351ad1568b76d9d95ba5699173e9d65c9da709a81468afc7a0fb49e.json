{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nexport class PieceTreeTextBufferFactory {\n  constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n    this._chunks = _chunks;\n    this._bom = _bom;\n    this._cr = _cr;\n    this._lf = _lf;\n    this._crlf = _crlf;\n    this._containsRTL = _containsRTL;\n    this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n    this._isBasicASCII = _isBasicASCII;\n    this._normalizeEOL = _normalizeEOL;\n  }\n  _getEOL(defaultEOL) {\n    const totalEOLCount = this._cr + this._lf + this._crlf;\n    const totalCRCount = this._cr + this._crlf;\n    if (totalEOLCount === 0) {\n      // This is an empty file or a file with precisely one line\n      return defaultEOL === 1 /* LF */ ? '\\n' : '\\r\\n';\n    }\n    if (totalCRCount > totalEOLCount / 2) {\n      // More than half of the file contains \\r\\n ending lines\n      return '\\r\\n';\n    }\n    // At least one line more ends in \\n\n    return '\\n';\n  }\n  create(defaultEOL) {\n    const eol = this._getEOL(defaultEOL);\n    let chunks = this._chunks;\n    if (this._normalizeEOL && (eol === '\\r\\n' && (this._cr > 0 || this._lf > 0) || eol === '\\n' && (this._cr > 0 || this._crlf > 0))) {\n      // Normalize pieces\n      for (let i = 0, len = chunks.length; i < len; i++) {\n        let str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n        let newLineStart = createLineStartsFast(str);\n        chunks[i] = new StringBuffer(str, newLineStart);\n      }\n    }\n    const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n    return {\n      textBuffer: textBuffer,\n      disposable: textBuffer\n    };\n  }\n}\nexport class PieceTreeTextBufferBuilder {\n  constructor() {\n    this.chunks = [];\n    this.BOM = '';\n    this._hasPreviousChar = false;\n    this._previousChar = 0;\n    this._tmpLineStarts = [];\n    this.cr = 0;\n    this.lf = 0;\n    this.crlf = 0;\n    this.containsRTL = false;\n    this.containsUnusualLineTerminators = false;\n    this.isBasicASCII = true;\n  }\n  acceptChunk(chunk) {\n    if (chunk.length === 0) {\n      return;\n    }\n    if (this.chunks.length === 0) {\n      if (strings.startsWithUTF8BOM(chunk)) {\n        this.BOM = strings.UTF8_BOM_CHARACTER;\n        chunk = chunk.substr(1);\n      }\n    }\n    const lastChar = chunk.charCodeAt(chunk.length - 1);\n    if (lastChar === 13 /* CarriageReturn */ || lastChar >= 0xD800 && lastChar <= 0xDBFF) {\n      // last character is \\r or a high surrogate => keep it back\n      this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n      this._hasPreviousChar = true;\n      this._previousChar = lastChar;\n    } else {\n      this._acceptChunk1(chunk, false);\n      this._hasPreviousChar = false;\n      this._previousChar = lastChar;\n    }\n  }\n  _acceptChunk1(chunk, allowEmptyStrings) {\n    if (!allowEmptyStrings && chunk.length === 0) {\n      // Nothing to do\n      return;\n    }\n    if (this._hasPreviousChar) {\n      this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n    } else {\n      this._acceptChunk2(chunk);\n    }\n  }\n  _acceptChunk2(chunk) {\n    const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n    this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n    this.cr += lineStarts.cr;\n    this.lf += lineStarts.lf;\n    this.crlf += lineStarts.crlf;\n    if (this.isBasicASCII) {\n      this.isBasicASCII = lineStarts.isBasicASCII;\n    }\n    if (!this.isBasicASCII && !this.containsRTL) {\n      // No need to check if it is basic ASCII\n      this.containsRTL = strings.containsRTL(chunk);\n    }\n    if (!this.isBasicASCII && !this.containsUnusualLineTerminators) {\n      // No need to check if it is basic ASCII\n      this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n    }\n  }\n  finish() {\n    let normalizeEOL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._finish();\n    return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n  }\n  _finish() {\n    if (this.chunks.length === 0) {\n      this._acceptChunk1('', true);\n    }\n    if (this._hasPreviousChar) {\n      this._hasPreviousChar = false;\n      // recreate last chunk\n      let lastChunk = this.chunks[this.chunks.length - 1];\n      lastChunk.buffer += String.fromCharCode(this._previousChar);\n      let newLineStarts = createLineStartsFast(lastChunk.buffer);\n      lastChunk.lineStarts = newLineStarts;\n      if (this._previousChar === 13 /* CarriageReturn */) {\n        this.cr++;\n      }\n    }\n  }\n}","map":{"version":3,"names":["strings","StringBuffer","createLineStarts","createLineStartsFast","PieceTreeTextBuffer","PieceTreeTextBufferFactory","constructor","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","_getEOL","defaultEOL","totalEOLCount","totalCRCount","create","eol","chunks","i","len","length","str","buffer","replace","newLineStart","textBuffer","disposable","PieceTreeTextBufferBuilder","BOM","_hasPreviousChar","_previousChar","_tmpLineStarts","cr","lf","crlf","containsRTL","containsUnusualLineTerminators","isBasicASCII","acceptChunk","chunk","startsWithUTF8BOM","UTF8_BOM_CHARACTER","substr","lastChar","charCodeAt","_acceptChunk1","allowEmptyStrings","_acceptChunk2","String","fromCharCode","lineStarts","push","finish","normalizeEOL","arguments","undefined","_finish","lastChunk","newLineStarts"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../../base/common/strings.js';\r\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\r\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\r\nexport class PieceTreeTextBufferFactory {\r\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\r\n        this._chunks = _chunks;\r\n        this._bom = _bom;\r\n        this._cr = _cr;\r\n        this._lf = _lf;\r\n        this._crlf = _crlf;\r\n        this._containsRTL = _containsRTL;\r\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\r\n        this._isBasicASCII = _isBasicASCII;\r\n        this._normalizeEOL = _normalizeEOL;\r\n    }\r\n    _getEOL(defaultEOL) {\r\n        const totalEOLCount = this._cr + this._lf + this._crlf;\r\n        const totalCRCount = this._cr + this._crlf;\r\n        if (totalEOLCount === 0) {\r\n            // This is an empty file or a file with precisely one line\r\n            return (defaultEOL === 1 /* LF */ ? '\\n' : '\\r\\n');\r\n        }\r\n        if (totalCRCount > totalEOLCount / 2) {\r\n            // More than half of the file contains \\r\\n ending lines\r\n            return '\\r\\n';\r\n        }\r\n        // At least one line more ends in \\n\r\n        return '\\n';\r\n    }\r\n    create(defaultEOL) {\r\n        const eol = this._getEOL(defaultEOL);\r\n        let chunks = this._chunks;\r\n        if (this._normalizeEOL &&\r\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\r\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\r\n            // Normalize pieces\r\n            for (let i = 0, len = chunks.length; i < len; i++) {\r\n                let str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\r\n                let newLineStart = createLineStartsFast(str);\r\n                chunks[i] = new StringBuffer(str, newLineStart);\r\n            }\r\n        }\r\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\r\n        return { textBuffer: textBuffer, disposable: textBuffer };\r\n    }\r\n}\r\nexport class PieceTreeTextBufferBuilder {\r\n    constructor() {\r\n        this.chunks = [];\r\n        this.BOM = '';\r\n        this._hasPreviousChar = false;\r\n        this._previousChar = 0;\r\n        this._tmpLineStarts = [];\r\n        this.cr = 0;\r\n        this.lf = 0;\r\n        this.crlf = 0;\r\n        this.containsRTL = false;\r\n        this.containsUnusualLineTerminators = false;\r\n        this.isBasicASCII = true;\r\n    }\r\n    acceptChunk(chunk) {\r\n        if (chunk.length === 0) {\r\n            return;\r\n        }\r\n        if (this.chunks.length === 0) {\r\n            if (strings.startsWithUTF8BOM(chunk)) {\r\n                this.BOM = strings.UTF8_BOM_CHARACTER;\r\n                chunk = chunk.substr(1);\r\n            }\r\n        }\r\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\r\n        if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\r\n            // last character is \\r or a high surrogate => keep it back\r\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\r\n            this._hasPreviousChar = true;\r\n            this._previousChar = lastChar;\r\n        }\r\n        else {\r\n            this._acceptChunk1(chunk, false);\r\n            this._hasPreviousChar = false;\r\n            this._previousChar = lastChar;\r\n        }\r\n    }\r\n    _acceptChunk1(chunk, allowEmptyStrings) {\r\n        if (!allowEmptyStrings && chunk.length === 0) {\r\n            // Nothing to do\r\n            return;\r\n        }\r\n        if (this._hasPreviousChar) {\r\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\r\n        }\r\n        else {\r\n            this._acceptChunk2(chunk);\r\n        }\r\n    }\r\n    _acceptChunk2(chunk) {\r\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\r\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\r\n        this.cr += lineStarts.cr;\r\n        this.lf += lineStarts.lf;\r\n        this.crlf += lineStarts.crlf;\r\n        if (this.isBasicASCII) {\r\n            this.isBasicASCII = lineStarts.isBasicASCII;\r\n        }\r\n        if (!this.isBasicASCII && !this.containsRTL) {\r\n            // No need to check if it is basic ASCII\r\n            this.containsRTL = strings.containsRTL(chunk);\r\n        }\r\n        if (!this.isBasicASCII && !this.containsUnusualLineTerminators) {\r\n            // No need to check if it is basic ASCII\r\n            this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\r\n        }\r\n    }\r\n    finish(normalizeEOL = true) {\r\n        this._finish();\r\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\r\n    }\r\n    _finish() {\r\n        if (this.chunks.length === 0) {\r\n            this._acceptChunk1('', true);\r\n        }\r\n        if (this._hasPreviousChar) {\r\n            this._hasPreviousChar = false;\r\n            // recreate last chunk\r\n            let lastChunk = this.chunks[this.chunks.length - 1];\r\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\r\n            let newLineStarts = createLineStartsFast(lastChunk.buffer);\r\n            lastChunk.lineStarts = newLineStarts;\r\n            if (this._previousChar === 13 /* CarriageReturn */) {\r\n                this.cr++;\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}