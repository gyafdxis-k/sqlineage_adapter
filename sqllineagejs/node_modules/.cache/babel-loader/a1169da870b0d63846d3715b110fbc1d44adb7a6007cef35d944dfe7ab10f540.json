{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from './cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n  static addCursorDown(viewModel, cursors, useLogicalLine) {\n    let result = [],\n      resultLen = 0;\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n      if (useLogicalLine) {\n        result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n      } else {\n        result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n      }\n    }\n    return result;\n  }\n  static addCursorUp(viewModel, cursors, useLogicalLine) {\n    let result = [],\n      resultLen = 0;\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n      if (useLogicalLine) {\n        result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n      } else {\n        result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n      }\n    }\n    return result;\n  }\n  static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n    }\n    return result;\n  }\n  static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n    const currentViewStateColumn = cursor.viewState.position.column;\n    const currentModelStateColumn = cursor.modelState.position.column;\n    const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n    const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n    const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n    const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n    if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n      return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n    } else {\n      return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n    }\n  }\n  static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n    return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n  }\n  static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n    return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n  }\n  static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n    }\n    return result;\n  }\n  static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n    const viewStatePosition = cursor.viewState.position;\n    const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n    const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n    const modelStatePosition = cursor.modelState.position;\n    const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n    const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n    if (isEndOfViewLine || isEndLineOfWrappedLine) {\n      return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n    } else {\n      return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n    }\n  }\n  static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n    return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n  }\n  static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n    return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n  }\n  static expandLineSelection(viewModel, cursors) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      const startLineNumber = cursor.modelState.selection.startLineNumber;\n      const lineCount = viewModel.model.getLineCount();\n      let endLineNumber = cursor.modelState.selection.endLineNumber;\n      let endColumn;\n      if (endLineNumber === lineCount) {\n        endColumn = viewModel.model.getLineMaxColumn(lineCount);\n      } else {\n        endLineNumber++;\n        endColumn = 1;\n      }\n      result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0, new Position(endLineNumber, endColumn), 0));\n    }\n    return result;\n  }\n  static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    return result;\n  }\n  static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    return result;\n  }\n  static selectAll(viewModel, cursor) {\n    const lineCount = viewModel.model.getLineCount();\n    const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n    return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(lineCount, maxColumn), 0));\n  }\n  static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n    const position = viewModel.model.validatePosition(_position);\n    const viewPosition = _viewPosition ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position) : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position);\n    if (!inSelectionMode || !cursor.modelState.hasSelection()) {\n      // Entering line selection for the first time\n      const lineCount = viewModel.model.getLineCount();\n      let selectToLineNumber = position.lineNumber + 1;\n      let selectToColumn = 1;\n      if (selectToLineNumber > lineCount) {\n        selectToLineNumber = lineCount;\n        selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n      }\n      return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 0, new Position(selectToLineNumber, selectToColumn), 0));\n    }\n    // Continuing line selection\n    const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n    if (position.lineNumber < enteringLineNumber) {\n      return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), viewPosition.lineNumber, 1, 0));\n    } else if (position.lineNumber > enteringLineNumber) {\n      const lineCount = viewModel.getLineCount();\n      let selectToViewLineNumber = viewPosition.lineNumber + 1;\n      let selectToViewColumn = 1;\n      if (selectToViewLineNumber > lineCount) {\n        selectToViewLineNumber = lineCount;\n        selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n      }\n      return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), selectToViewLineNumber, selectToViewColumn, 0));\n    } else {\n      const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n      return CursorState.fromModelState(cursor.modelState.move(cursor.modelState.hasSelection(), endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n    }\n  }\n  static word(viewModel, cursor, inSelectionMode, _position) {\n    const position = viewModel.model.validatePosition(_position);\n    return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n  }\n  static cancelSelection(viewModel, cursor) {\n    if (!cursor.modelState.hasSelection()) {\n      return new CursorState(cursor.modelState, cursor.viewState);\n    }\n    const lineNumber = cursor.viewState.position.lineNumber;\n    const column = cursor.viewState.position.column;\n    return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0, new Position(lineNumber, column), 0));\n  }\n  static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n    const position = viewModel.model.validatePosition(_position);\n    const viewPosition = _viewPosition ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position) : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position);\n    return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n  }\n  static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n    switch (direction) {\n      case 0 /* Left */:\n        {\n          if (unit === 4 /* HalfLine */) {\n            // Move left by half the current line length\n            return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n          } else {\n            // Move left by `moveParams.value` columns\n            return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n          }\n        }\n      case 1 /* Right */:\n        {\n          if (unit === 4 /* HalfLine */) {\n            // Move right by half the current line length\n            return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n          } else {\n            // Move right by `moveParams.value` columns\n            return this._moveRight(viewModel, cursors, inSelectionMode, value);\n          }\n        }\n      case 2 /* Up */:\n        {\n          if (unit === 2 /* WrappedLine */) {\n            // Move up by view lines\n            return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n          } else {\n            // Move up by model lines\n            return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n          }\n        }\n      case 3 /* Down */:\n        {\n          if (unit === 2 /* WrappedLine */) {\n            // Move down by view lines\n            return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n          } else {\n            // Move down by model lines\n            return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n          }\n        }\n      case 4 /* WrappedLineStart */:\n        {\n          // Move to the beginning of the current view line\n          return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n        }\n      case 5 /* WrappedLineFirstNonWhitespaceCharacter */:\n        {\n          // Move to the first non-whitespace column of the current view line\n          return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n        }\n      case 6 /* WrappedLineColumnCenter */:\n        {\n          // Move to the \"center\" of the current view line\n          return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n        }\n      case 7 /* WrappedLineEnd */:\n        {\n          // Move to the end of the current view line\n          return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n        }\n      case 8 /* WrappedLineLastNonWhitespaceCharacter */:\n        {\n          // Move to the last non-whitespace column of the current view line\n          return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n        }\n      default:\n        return null;\n    }\n  }\n  static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n    const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n    const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n    switch (direction) {\n      case 9 /* ViewPortTop */:\n        {\n          // Move to the nth line start in the viewport (from the top)\n          const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n          const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n          return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n        }\n      case 11 /* ViewPortBottom */:\n        {\n          // Move to the nth line start in the viewport (from the bottom)\n          const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n          const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n          return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n        }\n      case 10 /* ViewPortCenter */:\n        {\n          // Move to the line start in the viewport center\n          const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n          const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n          return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n        }\n      case 12 /* ViewPortIfOutside */:\n        {\n          // Move to a position inside the viewport\n          let result = [];\n          for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n          }\n          return result;\n        }\n      default:\n        return null;\n    }\n  }\n  static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n    let viewLineNumber = cursor.viewState.position.lineNumber;\n    if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n      // Nothing to do, cursor is in viewport\n      return new CursorState(cursor.modelState, cursor.viewState);\n    } else {\n      if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n        viewLineNumber = visibleViewRange.endLineNumber - 1;\n      }\n      if (viewLineNumber < visibleViewRange.startLineNumber) {\n        viewLineNumber = visibleViewRange.startLineNumber;\n      }\n      const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n      return this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n    }\n  }\n  /**\r\n   * Find the nth line start included in the range (from the start).\r\n   */\n  static _firstLineNumberInRange(model, range, count) {\n    let startLineNumber = range.startLineNumber;\n    if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n      // Move on to the second line if the first line start is not included in the range\n      startLineNumber++;\n    }\n    return Math.min(range.endLineNumber, startLineNumber + count - 1);\n  }\n  /**\r\n   * Find the nth line start included in the range (from the end).\r\n   */\n  static _lastLineNumberInRange(model, range, count) {\n    let startLineNumber = range.startLineNumber;\n    if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n      // Move on to the second line if the first line start is not included in the range\n      startLineNumber++;\n    }\n    return Math.max(startLineNumber, range.endLineNumber - count + 1);\n  }\n  static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n    const hasMultipleCursors = cursors.length > 1;\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      const skipWrappingPointStop = hasMultipleCursors || !cursor.viewState.hasSelection();\n      let newViewState = MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns);\n      if (skipWrappingPointStop && noOfColumns === 1 && cursor.viewState.position.column === viewModel.getLineMinColumn(cursor.viewState.position.lineNumber) && newViewState.position.lineNumber !== cursor.viewState.position.lineNumber) {\n        // moved over to the previous view line\n        const newViewModelPosition = viewModel.coordinatesConverter.convertViewPositionToModelPosition(newViewState.position);\n        if (newViewModelPosition.lineNumber === cursor.modelState.position.lineNumber) {\n          // stayed on the same model line => pass wrapping point where 2 view positions map to a single model position\n          newViewState = MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, newViewState, inSelectionMode, 1);\n        }\n      }\n      result[i] = CursorState.fromViewState(newViewState);\n    }\n    return result;\n  }\n  static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      const viewLineNumber = cursor.viewState.position.lineNumber;\n      const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n      result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n    }\n    return result;\n  }\n  static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n    const hasMultipleCursors = cursors.length > 1;\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      const skipWrappingPointStop = hasMultipleCursors || !cursor.viewState.hasSelection();\n      let newViewState = MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns);\n      if (skipWrappingPointStop && noOfColumns === 1 && cursor.viewState.position.column === viewModel.getLineMaxColumn(cursor.viewState.position.lineNumber) && newViewState.position.lineNumber !== cursor.viewState.position.lineNumber) {\n        // moved over to the next view line\n        const newViewModelPosition = viewModel.coordinatesConverter.convertViewPositionToModelPosition(newViewState.position);\n        if (newViewModelPosition.lineNumber === cursor.modelState.position.lineNumber) {\n          // stayed on the same model line => pass wrapping point where 2 view positions map to a single model position\n          newViewState = MoveOperations.moveRight(viewModel.cursorConfig, viewModel, newViewState, inSelectionMode, 1);\n        }\n      }\n      result[i] = CursorState.fromViewState(newViewState);\n    }\n    return result;\n  }\n  static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      const viewLineNumber = cursor.viewState.position.lineNumber;\n      const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n      result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n    }\n    return result;\n  }\n  static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n    }\n    return result;\n  }\n  static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n    }\n    return result;\n  }\n  static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n    }\n    return result;\n  }\n  static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n    }\n    return result;\n  }\n  static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n    return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n  }\n  static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n    return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n  }\n  static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      const viewLineNumber = cursor.viewState.position.lineNumber;\n      const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n      result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n    }\n    return result;\n  }\n  static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      const viewLineNumber = cursor.viewState.position.lineNumber;\n      const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n      result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n    }\n    return result;\n  }\n  static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      const viewLineNumber = cursor.viewState.position.lineNumber;\n      const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n      result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n    }\n    return result;\n  }\n  static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      const viewLineNumber = cursor.viewState.position.lineNumber;\n      const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n      result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n    }\n    return result;\n  }\n  static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n    let result = [];\n    for (let i = 0, len = cursors.length; i < len; i++) {\n      const cursor = cursors[i];\n      const viewLineNumber = cursor.viewState.position.lineNumber;\n      const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n      result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n    }\n    return result;\n  }\n}\nexport var CursorMove;\n(function (CursorMove) {\n  const isCursorMoveArgs = function (arg) {\n    if (!types.isObject(arg)) {\n      return false;\n    }\n    let cursorMoveArg = arg;\n    if (!types.isString(cursorMoveArg.to)) {\n      return false;\n    }\n    if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n      return false;\n    }\n    if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n      return false;\n    }\n    if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n      return false;\n    }\n    return true;\n  };\n  CursorMove.description = {\n    description: 'Move cursor to a logical position in the view',\n    args: [{\n      name: 'Cursor move argument object',\n      description: \"Property-value pairs that can be passed through this argument:\\n\\t\\t\\t\\t\\t* 'to': A mandatory logical position value providing where to move the cursor.\\n\\t\\t\\t\\t\\t\\t```\\n\\t\\t\\t\\t\\t\\t'left', 'right', 'up', 'down'\\n\\t\\t\\t\\t\\t\\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\\n\\t\\t\\t\\t\\t\\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\\n\\t\\t\\t\\t\\t\\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\\n\\t\\t\\t\\t\\t\\t```\\n\\t\\t\\t\\t\\t* 'by': Unit to move. Default is computed based on 'to' value.\\n\\t\\t\\t\\t\\t\\t```\\n\\t\\t\\t\\t\\t\\t'line', 'wrappedLine', 'character', 'halfLine'\\n\\t\\t\\t\\t\\t\\t```\\n\\t\\t\\t\\t\\t* 'value': Number of units to move. Default is '1'.\\n\\t\\t\\t\\t\\t* 'select': If 'true' makes the selection. Default is 'false'.\\n\\t\\t\\t\\t\",\n      constraint: isCursorMoveArgs,\n      schema: {\n        'type': 'object',\n        'required': ['to'],\n        'properties': {\n          'to': {\n            'type': 'string',\n            'enum': ['left', 'right', 'up', 'down', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n          },\n          'by': {\n            'type': 'string',\n            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n          },\n          'value': {\n            'type': 'number',\n            'default': 1\n          },\n          'select': {\n            'type': 'boolean',\n            'default': false\n          }\n        }\n      }\n    }]\n  };\n  /**\r\n   * Positions in the view for cursor move command.\r\n   */\n  CursorMove.RawDirection = {\n    Left: 'left',\n    Right: 'right',\n    Up: 'up',\n    Down: 'down',\n    WrappedLineStart: 'wrappedLineStart',\n    WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n    WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n    WrappedLineEnd: 'wrappedLineEnd',\n    WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n    ViewPortTop: 'viewPortTop',\n    ViewPortCenter: 'viewPortCenter',\n    ViewPortBottom: 'viewPortBottom',\n    ViewPortIfOutside: 'viewPortIfOutside'\n  };\n  /**\r\n   * Units for Cursor move 'by' argument\r\n   */\n  CursorMove.RawUnit = {\n    Line: 'line',\n    WrappedLine: 'wrappedLine',\n    Character: 'character',\n    HalfLine: 'halfLine'\n  };\n  function parse(args) {\n    if (!args.to) {\n      // illegal arguments\n      return null;\n    }\n    let direction;\n    switch (args.to) {\n      case CursorMove.RawDirection.Left:\n        direction = 0 /* Left */;\n        break;\n      case CursorMove.RawDirection.Right:\n        direction = 1 /* Right */;\n        break;\n      case CursorMove.RawDirection.Up:\n        direction = 2 /* Up */;\n        break;\n      case CursorMove.RawDirection.Down:\n        direction = 3 /* Down */;\n        break;\n      case CursorMove.RawDirection.WrappedLineStart:\n        direction = 4 /* WrappedLineStart */;\n        break;\n      case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n        direction = 5 /* WrappedLineFirstNonWhitespaceCharacter */;\n        break;\n      case CursorMove.RawDirection.WrappedLineColumnCenter:\n        direction = 6 /* WrappedLineColumnCenter */;\n        break;\n      case CursorMove.RawDirection.WrappedLineEnd:\n        direction = 7 /* WrappedLineEnd */;\n        break;\n      case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n        direction = 8 /* WrappedLineLastNonWhitespaceCharacter */;\n        break;\n      case CursorMove.RawDirection.ViewPortTop:\n        direction = 9 /* ViewPortTop */;\n        break;\n      case CursorMove.RawDirection.ViewPortBottom:\n        direction = 11 /* ViewPortBottom */;\n        break;\n      case CursorMove.RawDirection.ViewPortCenter:\n        direction = 10 /* ViewPortCenter */;\n        break;\n      case CursorMove.RawDirection.ViewPortIfOutside:\n        direction = 12 /* ViewPortIfOutside */;\n        break;\n      default:\n        // illegal arguments\n        return null;\n    }\n    let unit = 0 /* None */;\n    switch (args.by) {\n      case CursorMove.RawUnit.Line:\n        unit = 1 /* Line */;\n        break;\n      case CursorMove.RawUnit.WrappedLine:\n        unit = 2 /* WrappedLine */;\n        break;\n      case CursorMove.RawUnit.Character:\n        unit = 3 /* Character */;\n        break;\n      case CursorMove.RawUnit.HalfLine:\n        unit = 4 /* HalfLine */;\n        break;\n    }\n    return {\n      direction: direction,\n      unit: unit,\n      select: !!args.select,\n      value: args.value || 1\n    };\n  }\n  CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));","map":{"version":3,"names":["types","CursorState","SingleCursorState","MoveOperations","WordOperations","Position","Range","CursorMoveCommands","addCursorDown","viewModel","cursors","useLogicalLine","result","resultLen","i","len","length","cursor","modelState","viewState","fromModelState","translateDown","cursorConfig","model","fromViewState","addCursorUp","translateUp","moveToBeginningOfLine","inSelectionMode","_moveToLineStart","currentViewStateColumn","position","column","currentModelStateColumn","isFirstLineOfWrappedLine","currentViewStatelineNumber","lineNumber","firstNonBlankColumn","getLineFirstNonWhitespaceColumn","isBeginningOfViewLine","_moveToLineStartByView","_moveToLineStartByModel","moveToEndOfLine","sticky","_moveToLineEnd","viewStatePosition","viewModelMaxColumn","getLineMaxColumn","isEndOfViewLine","modelStatePosition","modelMaxColumn","isEndLineOfWrappedLine","_moveToLineEndByModel","_moveToLineEndByView","expandLineSelection","startLineNumber","selection","lineCount","getLineCount","endLineNumber","endColumn","moveToBeginningOfBuffer","moveToEndOfBuffer","selectAll","maxColumn","line","_position","_viewPosition","validatePosition","viewPosition","coordinatesConverter","validateViewPosition","convertModelPositionToViewPosition","hasSelection","selectToLineNumber","selectToColumn","enteringLineNumber","selectionStart","getStartPosition","move","selectToViewLineNumber","selectToViewColumn","endPositionOfSelectionStart","getEndPosition","word","cancelSelection","moveTo","simpleMove","direction","value","unit","_moveHalfLineLeft","_moveLeft","_moveHalfLineRight","_moveRight","_moveUpByViewLines","_moveUpByModelLines","_moveDownByViewLines","_moveDownByModelLines","_moveToViewMinColumn","_moveToViewFirstNonWhitespaceColumn","_moveToViewCenterColumn","_moveToViewMaxColumn","_moveToViewLastNonWhitespaceColumn","viewportMove","visibleViewRange","getCompletelyVisibleViewRange","visibleModelRange","convertViewRangeToModelRange","modelLineNumber","_firstLineNumberInRange","modelColumn","_moveToModelPosition","_lastLineNumberInRange","Math","round","findPositionInViewportIfOutside","viewLineNumber","viewColumn","_moveToViewPosition","range","count","startColumn","getLineMinColumn","min","max","noOfColumns","hasMultipleCursors","skipWrappingPointStop","newViewState","moveLeft","newViewModelPosition","convertViewPositionToModelPosition","halfLine","getLineContent","moveRight","linesCount","moveDown","moveUp","toViewLineNumber","toViewColumn","toModelLineNumber","toModelColumn","getLineLastNonWhitespaceColumn","CursorMove","isCursorMoveArgs","arg","isObject","cursorMoveArg","isString","to","isUndefined","select","isBoolean","by","isNumber","description","args","name","constraint","schema","RawDirection","Left","Right","Up","Down","WrappedLineStart","WrappedLineFirstNonWhitespaceCharacter","WrappedLineColumnCenter","WrappedLineEnd","WrappedLineLastNonWhitespaceCharacter","ViewPortTop","ViewPortCenter","ViewPortBottom","ViewPortIfOutside","RawUnit","Line","WrappedLine","Character","HalfLine","parse"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/controller/cursorMoveCommands.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as types from '../../../base/common/types.js';\r\nimport { CursorState, SingleCursorState } from './cursorCommon.js';\r\nimport { MoveOperations } from './cursorMoveOperations.js';\r\nimport { WordOperations } from './cursorWordOperations.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nexport class CursorMoveCommands {\r\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\r\n        let result = [], resultLen = 0;\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\r\n            if (useLogicalLine) {\r\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\r\n            }\r\n            else {\r\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\r\n        let result = [], resultLen = 0;\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\r\n            if (useLogicalLine) {\r\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\r\n            }\r\n            else {\r\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\r\n        }\r\n        return result;\r\n    }\r\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\r\n        const currentViewStateColumn = cursor.viewState.position.column;\r\n        const currentModelStateColumn = cursor.modelState.position.column;\r\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\r\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\r\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\r\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\r\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\r\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\r\n        }\r\n        else {\r\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\r\n        }\r\n    }\r\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\r\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\r\n    }\r\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\r\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\r\n    }\r\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\r\n        }\r\n        return result;\r\n    }\r\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\r\n        const viewStatePosition = cursor.viewState.position;\r\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\r\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\r\n        const modelStatePosition = cursor.modelState.position;\r\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\r\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\r\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\r\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\r\n        }\r\n        else {\r\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\r\n        }\r\n    }\r\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\r\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\r\n    }\r\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\r\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\r\n    }\r\n    static expandLineSelection(viewModel, cursors) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\r\n            const lineCount = viewModel.model.getLineCount();\r\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\r\n            let endColumn;\r\n            if (endLineNumber === lineCount) {\r\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\r\n            }\r\n            else {\r\n                endLineNumber++;\r\n                endColumn = 1;\r\n            }\r\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0, new Position(endLineNumber, endColumn), 0));\r\n        }\r\n        return result;\r\n    }\r\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\r\n        }\r\n        return result;\r\n    }\r\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\r\n        }\r\n        return result;\r\n    }\r\n    static selectAll(viewModel, cursor) {\r\n        const lineCount = viewModel.model.getLineCount();\r\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\r\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(lineCount, maxColumn), 0));\r\n    }\r\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\r\n        const position = viewModel.model.validatePosition(_position);\r\n        const viewPosition = (_viewPosition\r\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\r\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\r\n        if (!inSelectionMode || !cursor.modelState.hasSelection()) {\r\n            // Entering line selection for the first time\r\n            const lineCount = viewModel.model.getLineCount();\r\n            let selectToLineNumber = position.lineNumber + 1;\r\n            let selectToColumn = 1;\r\n            if (selectToLineNumber > lineCount) {\r\n                selectToLineNumber = lineCount;\r\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\r\n            }\r\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 0, new Position(selectToLineNumber, selectToColumn), 0));\r\n        }\r\n        // Continuing line selection\r\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\r\n        if (position.lineNumber < enteringLineNumber) {\r\n            return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), viewPosition.lineNumber, 1, 0));\r\n        }\r\n        else if (position.lineNumber > enteringLineNumber) {\r\n            const lineCount = viewModel.getLineCount();\r\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\r\n            let selectToViewColumn = 1;\r\n            if (selectToViewLineNumber > lineCount) {\r\n                selectToViewLineNumber = lineCount;\r\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\r\n            }\r\n            return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), selectToViewLineNumber, selectToViewColumn, 0));\r\n        }\r\n        else {\r\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\r\n            return CursorState.fromModelState(cursor.modelState.move(cursor.modelState.hasSelection(), endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\r\n        }\r\n    }\r\n    static word(viewModel, cursor, inSelectionMode, _position) {\r\n        const position = viewModel.model.validatePosition(_position);\r\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\r\n    }\r\n    static cancelSelection(viewModel, cursor) {\r\n        if (!cursor.modelState.hasSelection()) {\r\n            return new CursorState(cursor.modelState, cursor.viewState);\r\n        }\r\n        const lineNumber = cursor.viewState.position.lineNumber;\r\n        const column = cursor.viewState.position.column;\r\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0, new Position(lineNumber, column), 0));\r\n    }\r\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\r\n        const position = viewModel.model.validatePosition(_position);\r\n        const viewPosition = (_viewPosition\r\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\r\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\r\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\r\n    }\r\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\r\n        switch (direction) {\r\n            case 0 /* Left */: {\r\n                if (unit === 4 /* HalfLine */) {\r\n                    // Move left by half the current line length\r\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\r\n                }\r\n                else {\r\n                    // Move left by `moveParams.value` columns\r\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\r\n                }\r\n            }\r\n            case 1 /* Right */: {\r\n                if (unit === 4 /* HalfLine */) {\r\n                    // Move right by half the current line length\r\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\r\n                }\r\n                else {\r\n                    // Move right by `moveParams.value` columns\r\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\r\n                }\r\n            }\r\n            case 2 /* Up */: {\r\n                if (unit === 2 /* WrappedLine */) {\r\n                    // Move up by view lines\r\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\r\n                }\r\n                else {\r\n                    // Move up by model lines\r\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\r\n                }\r\n            }\r\n            case 3 /* Down */: {\r\n                if (unit === 2 /* WrappedLine */) {\r\n                    // Move down by view lines\r\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\r\n                }\r\n                else {\r\n                    // Move down by model lines\r\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\r\n                }\r\n            }\r\n            case 4 /* WrappedLineStart */: {\r\n                // Move to the beginning of the current view line\r\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\r\n            }\r\n            case 5 /* WrappedLineFirstNonWhitespaceCharacter */: {\r\n                // Move to the first non-whitespace column of the current view line\r\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\r\n            }\r\n            case 6 /* WrappedLineColumnCenter */: {\r\n                // Move to the \"center\" of the current view line\r\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\r\n            }\r\n            case 7 /* WrappedLineEnd */: {\r\n                // Move to the end of the current view line\r\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\r\n            }\r\n            case 8 /* WrappedLineLastNonWhitespaceCharacter */: {\r\n                // Move to the last non-whitespace column of the current view line\r\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\r\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\r\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\r\n        switch (direction) {\r\n            case 9 /* ViewPortTop */: {\r\n                // Move to the nth line start in the viewport (from the top)\r\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\r\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\r\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\r\n            }\r\n            case 11 /* ViewPortBottom */: {\r\n                // Move to the nth line start in the viewport (from the bottom)\r\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\r\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\r\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\r\n            }\r\n            case 10 /* ViewPortCenter */: {\r\n                // Move to the line start in the viewport center\r\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\r\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\r\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\r\n            }\r\n            case 12 /* ViewPortIfOutside */: {\r\n                // Move to a position inside the viewport\r\n                let result = [];\r\n                for (let i = 0, len = cursors.length; i < len; i++) {\r\n                    const cursor = cursors[i];\r\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\r\n                }\r\n                return result;\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\r\n        let viewLineNumber = cursor.viewState.position.lineNumber;\r\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\r\n            // Nothing to do, cursor is in viewport\r\n            return new CursorState(cursor.modelState, cursor.viewState);\r\n        }\r\n        else {\r\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\r\n                viewLineNumber = visibleViewRange.endLineNumber - 1;\r\n            }\r\n            if (viewLineNumber < visibleViewRange.startLineNumber) {\r\n                viewLineNumber = visibleViewRange.startLineNumber;\r\n            }\r\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\r\n            return this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\r\n        }\r\n    }\r\n    /**\r\n     * Find the nth line start included in the range (from the start).\r\n     */\r\n    static _firstLineNumberInRange(model, range, count) {\r\n        let startLineNumber = range.startLineNumber;\r\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\r\n            // Move on to the second line if the first line start is not included in the range\r\n            startLineNumber++;\r\n        }\r\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\r\n    }\r\n    /**\r\n     * Find the nth line start included in the range (from the end).\r\n     */\r\n    static _lastLineNumberInRange(model, range, count) {\r\n        let startLineNumber = range.startLineNumber;\r\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\r\n            // Move on to the second line if the first line start is not included in the range\r\n            startLineNumber++;\r\n        }\r\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\r\n    }\r\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\r\n        const hasMultipleCursors = (cursors.length > 1);\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            const skipWrappingPointStop = hasMultipleCursors || !cursor.viewState.hasSelection();\r\n            let newViewState = MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns);\r\n            if (skipWrappingPointStop\r\n                && noOfColumns === 1\r\n                && cursor.viewState.position.column === viewModel.getLineMinColumn(cursor.viewState.position.lineNumber)\r\n                && newViewState.position.lineNumber !== cursor.viewState.position.lineNumber) {\r\n                // moved over to the previous view line\r\n                const newViewModelPosition = viewModel.coordinatesConverter.convertViewPositionToModelPosition(newViewState.position);\r\n                if (newViewModelPosition.lineNumber === cursor.modelState.position.lineNumber) {\r\n                    // stayed on the same model line => pass wrapping point where 2 view positions map to a single model position\r\n                    newViewState = MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, newViewState, inSelectionMode, 1);\r\n                }\r\n            }\r\n            result[i] = CursorState.fromViewState(newViewState);\r\n        }\r\n        return result;\r\n    }\r\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            const viewLineNumber = cursor.viewState.position.lineNumber;\r\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\r\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\r\n        }\r\n        return result;\r\n    }\r\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\r\n        const hasMultipleCursors = (cursors.length > 1);\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            const skipWrappingPointStop = hasMultipleCursors || !cursor.viewState.hasSelection();\r\n            let newViewState = MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns);\r\n            if (skipWrappingPointStop\r\n                && noOfColumns === 1\r\n                && cursor.viewState.position.column === viewModel.getLineMaxColumn(cursor.viewState.position.lineNumber)\r\n                && newViewState.position.lineNumber !== cursor.viewState.position.lineNumber) {\r\n                // moved over to the next view line\r\n                const newViewModelPosition = viewModel.coordinatesConverter.convertViewPositionToModelPosition(newViewState.position);\r\n                if (newViewModelPosition.lineNumber === cursor.modelState.position.lineNumber) {\r\n                    // stayed on the same model line => pass wrapping point where 2 view positions map to a single model position\r\n                    newViewState = MoveOperations.moveRight(viewModel.cursorConfig, viewModel, newViewState, inSelectionMode, 1);\r\n                }\r\n            }\r\n            result[i] = CursorState.fromViewState(newViewState);\r\n        }\r\n        return result;\r\n    }\r\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            const viewLineNumber = cursor.viewState.position.lineNumber;\r\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\r\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\r\n        }\r\n        return result;\r\n    }\r\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\r\n        }\r\n        return result;\r\n    }\r\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\r\n        }\r\n        return result;\r\n    }\r\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\r\n        }\r\n        return result;\r\n    }\r\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\r\n        }\r\n        return result;\r\n    }\r\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\r\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\r\n    }\r\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\r\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\r\n    }\r\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            const viewLineNumber = cursor.viewState.position.lineNumber;\r\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\r\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\r\n        }\r\n        return result;\r\n    }\r\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            const viewLineNumber = cursor.viewState.position.lineNumber;\r\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\r\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\r\n        }\r\n        return result;\r\n    }\r\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            const viewLineNumber = cursor.viewState.position.lineNumber;\r\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\r\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\r\n        }\r\n        return result;\r\n    }\r\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            const viewLineNumber = cursor.viewState.position.lineNumber;\r\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\r\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\r\n        }\r\n        return result;\r\n    }\r\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\r\n        let result = [];\r\n        for (let i = 0, len = cursors.length; i < len; i++) {\r\n            const cursor = cursors[i];\r\n            const viewLineNumber = cursor.viewState.position.lineNumber;\r\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\r\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexport var CursorMove;\r\n(function (CursorMove) {\r\n    const isCursorMoveArgs = function (arg) {\r\n        if (!types.isObject(arg)) {\r\n            return false;\r\n        }\r\n        let cursorMoveArg = arg;\r\n        if (!types.isString(cursorMoveArg.to)) {\r\n            return false;\r\n        }\r\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\r\n            return false;\r\n        }\r\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\r\n            return false;\r\n        }\r\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    CursorMove.description = {\r\n        description: 'Move cursor to a logical position in the view',\r\n        args: [\r\n            {\r\n                name: 'Cursor move argument object',\r\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down'\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\r\n                constraint: isCursorMoveArgs,\r\n                schema: {\r\n                    'type': 'object',\r\n                    'required': ['to'],\r\n                    'properties': {\r\n                        'to': {\r\n                            'type': 'string',\r\n                            'enum': ['left', 'right', 'up', 'down', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\r\n                        },\r\n                        'by': {\r\n                            'type': 'string',\r\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\r\n                        },\r\n                        'value': {\r\n                            'type': 'number',\r\n                            'default': 1\r\n                        },\r\n                        'select': {\r\n                            'type': 'boolean',\r\n                            'default': false\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        ]\r\n    };\r\n    /**\r\n     * Positions in the view for cursor move command.\r\n     */\r\n    CursorMove.RawDirection = {\r\n        Left: 'left',\r\n        Right: 'right',\r\n        Up: 'up',\r\n        Down: 'down',\r\n        WrappedLineStart: 'wrappedLineStart',\r\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\r\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\r\n        WrappedLineEnd: 'wrappedLineEnd',\r\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\r\n        ViewPortTop: 'viewPortTop',\r\n        ViewPortCenter: 'viewPortCenter',\r\n        ViewPortBottom: 'viewPortBottom',\r\n        ViewPortIfOutside: 'viewPortIfOutside'\r\n    };\r\n    /**\r\n     * Units for Cursor move 'by' argument\r\n     */\r\n    CursorMove.RawUnit = {\r\n        Line: 'line',\r\n        WrappedLine: 'wrappedLine',\r\n        Character: 'character',\r\n        HalfLine: 'halfLine'\r\n    };\r\n    function parse(args) {\r\n        if (!args.to) {\r\n            // illegal arguments\r\n            return null;\r\n        }\r\n        let direction;\r\n        switch (args.to) {\r\n            case CursorMove.RawDirection.Left:\r\n                direction = 0 /* Left */;\r\n                break;\r\n            case CursorMove.RawDirection.Right:\r\n                direction = 1 /* Right */;\r\n                break;\r\n            case CursorMove.RawDirection.Up:\r\n                direction = 2 /* Up */;\r\n                break;\r\n            case CursorMove.RawDirection.Down:\r\n                direction = 3 /* Down */;\r\n                break;\r\n            case CursorMove.RawDirection.WrappedLineStart:\r\n                direction = 4 /* WrappedLineStart */;\r\n                break;\r\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\r\n                direction = 5 /* WrappedLineFirstNonWhitespaceCharacter */;\r\n                break;\r\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\r\n                direction = 6 /* WrappedLineColumnCenter */;\r\n                break;\r\n            case CursorMove.RawDirection.WrappedLineEnd:\r\n                direction = 7 /* WrappedLineEnd */;\r\n                break;\r\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\r\n                direction = 8 /* WrappedLineLastNonWhitespaceCharacter */;\r\n                break;\r\n            case CursorMove.RawDirection.ViewPortTop:\r\n                direction = 9 /* ViewPortTop */;\r\n                break;\r\n            case CursorMove.RawDirection.ViewPortBottom:\r\n                direction = 11 /* ViewPortBottom */;\r\n                break;\r\n            case CursorMove.RawDirection.ViewPortCenter:\r\n                direction = 10 /* ViewPortCenter */;\r\n                break;\r\n            case CursorMove.RawDirection.ViewPortIfOutside:\r\n                direction = 12 /* ViewPortIfOutside */;\r\n                break;\r\n            default:\r\n                // illegal arguments\r\n                return null;\r\n        }\r\n        let unit = 0 /* None */;\r\n        switch (args.by) {\r\n            case CursorMove.RawUnit.Line:\r\n                unit = 1 /* Line */;\r\n                break;\r\n            case CursorMove.RawUnit.WrappedLine:\r\n                unit = 2 /* WrappedLine */;\r\n                break;\r\n            case CursorMove.RawUnit.Character:\r\n                unit = 3 /* Character */;\r\n                break;\r\n            case CursorMove.RawUnit.HalfLine:\r\n                unit = 4 /* HalfLine */;\r\n                break;\r\n        }\r\n        return {\r\n            direction: direction,\r\n            unit: unit,\r\n            select: (!!args.select),\r\n            value: (args.value || 1)\r\n        };\r\n    }\r\n    CursorMove.parse = parse;\r\n})(CursorMove || (CursorMove = {}));\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}