{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ShiftCommand } from '../../common/commands/shiftCommand.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { IndentAction } from '../../common/modes/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport * as indentUtils from '../indentation/indentUtils.js';\nexport class MoveLinesCommand {\n  constructor(selection, isMovingDown, autoIndent) {\n    this._selection = selection;\n    this._isMovingDown = isMovingDown;\n    this._autoIndent = autoIndent;\n    this._selectionId = null;\n    this._moveEndLineSelectionShrink = false;\n  }\n  getEditOperations(model, builder) {\n    let modelLineCount = model.getLineCount();\n    if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n      this._selectionId = builder.trackSelection(this._selection);\n      return;\n    }\n    if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n      this._selectionId = builder.trackSelection(this._selection);\n      return;\n    }\n    this._moveEndPositionDown = false;\n    let s = this._selection;\n    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n      this._moveEndPositionDown = true;\n      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n    }\n    const {\n      tabSize,\n      indentSize,\n      insertSpaces\n    } = model.getOptions();\n    let indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n    let virtualModel = {\n      getLineTokens: lineNumber => {\n        return model.getLineTokens(lineNumber);\n      },\n      getLanguageIdentifier: () => {\n        return model.getLanguageIdentifier();\n      },\n      getLanguageIdAtPosition: (lineNumber, column) => {\n        return model.getLanguageIdAtPosition(lineNumber, column);\n      },\n      getLineContent: null\n    };\n    if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n      // Current line is empty\n      let lineNumber = s.startLineNumber;\n      let otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;\n      if (model.getLineMaxColumn(otherLineNumber) === 1) {\n        // Other line number is empty too, so no editing is needed\n        // Add a no-op to force running by the model\n        builder.addEditOperation(new Range(1, 1, 1, 1), null);\n      } else {\n        // Type content from other line number on line number\n        builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));\n        // Remove content from other line number\n        builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n      }\n      // Track selection at the other line number\n      s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\n    } else {\n      let movingLineNumber;\n      let movingLineText;\n      if (this._isMovingDown) {\n        movingLineNumber = s.endLineNumber + 1;\n        movingLineText = model.getLineContent(movingLineNumber);\n        // Delete line that needs to be moved\n        builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\n        let insertingText = movingLineText;\n        if (this.shouldAutoIndent(model, s)) {\n          let movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);\n          // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n          if (movingLineMatchResult !== null) {\n            let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n            let newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n            let newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n            insertingText = newIndentation + this.trimLeft(movingLineText);\n          } else {\n            // no enter rule matches, let's check indentatin rules then.\n            virtualModel.getLineContent = lineNumber => {\n              if (lineNumber === s.startLineNumber) {\n                return model.getLineContent(movingLineNumber);\n              } else {\n                return model.getLineContent(lineNumber);\n              }\n            };\n            let indentOfMovingLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter);\n            if (indentOfMovingLine !== null) {\n              let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n              let newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n              let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n              if (newSpaceCnt !== oldSpaceCnt) {\n                let newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                insertingText = newIndentation + this.trimLeft(movingLineText);\n              }\n            }\n          }\n          // add edit operations for moving line first to make sure it's executed after we make indentation change\n          // to s.startLineNumber\n          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n          let ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);\n          // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n          if (ret !== null) {\n            if (ret !== 0) {\n              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n            }\n          } else {\n            // it doesn't match onEnter rules, let's check indentation rules then.\n            virtualModel.getLineContent = lineNumber => {\n              if (lineNumber === s.startLineNumber) {\n                return insertingText;\n              } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                return model.getLineContent(lineNumber - 1);\n              } else {\n                return model.getLineContent(lineNumber);\n              }\n            };\n            let newIndentatOfMovingBlock = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter);\n            if (newIndentatOfMovingBlock !== null) {\n              const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n              const newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n              const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n              if (newSpaceCnt !== oldSpaceCnt) {\n                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n              }\n            }\n          }\n        } else {\n          // Insert line that needs to be moved before\n          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n        }\n      } else {\n        movingLineNumber = s.startLineNumber - 1;\n        movingLineText = model.getLineContent(movingLineNumber);\n        // Delete line that needs to be moved\n        builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);\n        // Insert line that needs to be moved after\n        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n        if (this.shouldAutoIndent(model, s)) {\n          virtualModel.getLineContent = lineNumber => {\n            if (lineNumber === movingLineNumber) {\n              return model.getLineContent(s.startLineNumber);\n            } else {\n              return model.getLineContent(lineNumber);\n            }\n          };\n          let ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);\n          // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n          if (ret !== null) {\n            if (ret !== 0) {\n              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n            }\n          } else {\n            // it doesn't match any onEnter rule, let's check indentation rules then.\n            let indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter);\n            if (indentOfFirstLine !== null) {\n              // adjust the indentation of the moving block\n              let oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n              let newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n              let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\n              if (newSpaceCnt !== oldSpaceCnt) {\n                let spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n              }\n            }\n          }\n        }\n      }\n    }\n    this._selectionId = builder.trackSelection(s);\n  }\n  buildIndentConverter(tabSize, indentSize, insertSpaces) {\n    return {\n      shiftIndent: indentation => {\n        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      },\n      unshiftIndent: indentation => {\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      }\n    };\n  }\n  parseEnterResult(model, indentConverter, tabSize, line, enter) {\n    if (enter) {\n      let enterPrefix = enter.indentation;\n      if (enter.indentAction === IndentAction.None) {\n        enterPrefix = enter.indentation + enter.appendText;\n      } else if (enter.indentAction === IndentAction.Indent) {\n        enterPrefix = enter.indentation + enter.appendText;\n      } else if (enter.indentAction === IndentAction.IndentOutdent) {\n        enterPrefix = enter.indentation;\n      } else if (enter.indentAction === IndentAction.Outdent) {\n        enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;\n      }\n      let movingLineText = model.getLineContent(line);\n      if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {\n        let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n        let newIndentation = strings.getLeadingWhitespace(enterPrefix);\n        let indentMetadataOfMovelingLine = LanguageConfigurationRegistry.getIndentMetadata(model, line);\n        if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2 /* DECREASE_MASK */) {\n          newIndentation = indentConverter.unshiftIndent(newIndentation);\n        }\n        let newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n        let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n        return newSpaceCnt - oldSpaceCnt;\n      }\n    }\n    return null;\n  }\n  /**\r\n   *\r\n   * @param model\r\n   * @param indentConverter\r\n   * @param tabSize\r\n   * @param line the line moving down\r\n   * @param futureAboveLineNumber the line which will be at the `line` position\r\n   * @param futureAboveLineText\r\n   */\n  matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {\n    if (strings.lastNonWhitespaceIndex(futureAboveLineText) >= 0) {\n      // break\n      let maxColumn = model.getLineMaxColumn(futureAboveLineNumber);\n      let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn));\n      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    } else {\n      // go upwards, starting from `line - 1`\n      let validPrecedingLine = line - 1;\n      while (validPrecedingLine >= 1) {\n        let lineContent = model.getLineContent(validPrecedingLine);\n        let nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n        if (nonWhitespaceIdx >= 0) {\n          break;\n        }\n        validPrecedingLine--;\n      }\n      if (validPrecedingLine < 1 || line > model.getLineCount()) {\n        return null;\n      }\n      let maxColumn = model.getLineMaxColumn(validPrecedingLine);\n      let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));\n      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    }\n  }\n  matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {\n    let validPrecedingLine = oneLineAbove;\n    while (validPrecedingLine >= 1) {\n      // ship empty lines as empty lines just inherit indentation\n      let lineContent;\n      if (validPrecedingLine === oneLineAbove && previousLineText !== undefined) {\n        lineContent = previousLineText;\n      } else {\n        lineContent = model.getLineContent(validPrecedingLine);\n      }\n      let nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n      if (nonWhitespaceIdx >= 0) {\n        break;\n      }\n      validPrecedingLine--;\n    }\n    if (validPrecedingLine < 1 || line > model.getLineCount()) {\n      return null;\n    }\n    let maxColumn = model.getLineMaxColumn(validPrecedingLine);\n    let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));\n    return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n  }\n  trimLeft(str) {\n    return str.replace(/^\\s+/, '');\n  }\n  shouldAutoIndent(model, selection) {\n    if (this._autoIndent < 4 /* Full */) {\n      return false;\n    }\n    // if it's not easy to tokenize, we stop auto indent.\n    if (!model.isCheapToTokenize(selection.startLineNumber)) {\n      return false;\n    }\n    let languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n    let languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n    if (languageAtSelectionStart !== languageAtSelectionEnd) {\n      return false;\n    }\n    if (LanguageConfigurationRegistry.getIndentRulesSupport(languageAtSelectionStart) === null) {\n      return false;\n    }\n    return true;\n  }\n  getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\n    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n      let lineContent = model.getLineContent(i);\n      let originalIndent = strings.getLeadingWhitespace(lineContent);\n      let originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n      let newSpacesCnt = originalSpacesCnt + offset;\n      let newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n      if (newIndent !== originalIndent) {\n        builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\n        if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n          // as users select part of the original indent white spaces\n          // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n          this._moveEndLineSelectionShrink = true;\n        }\n      }\n    }\n  }\n  computeCursorState(model, helper) {\n    let result = helper.getTrackedSelection(this._selectionId);\n    if (this._moveEndPositionDown) {\n      result = result.setEndPosition(result.endLineNumber + 1, 1);\n    }\n    if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n      result = result.setEndPosition(result.endLineNumber, 2);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["strings","ShiftCommand","Range","Selection","IndentAction","LanguageConfigurationRegistry","indentUtils","MoveLinesCommand","constructor","selection","isMovingDown","autoIndent","_selection","_isMovingDown","_autoIndent","_selectionId","_moveEndLineSelectionShrink","getEditOperations","model","builder","modelLineCount","getLineCount","endLineNumber","trackSelection","startLineNumber","_moveEndPositionDown","s","endColumn","setEndPosition","getLineMaxColumn","tabSize","indentSize","insertSpaces","getOptions","indentConverter","buildIndentConverter","virtualModel","getLineTokens","lineNumber","getLanguageIdentifier","getLanguageIdAtPosition","column","getLineContent","otherLineNumber","addEditOperation","movingLineNumber","movingLineText","insertingText","shouldAutoIndent","movingLineMatchResult","matchEnterRule","oldIndentation","getLeadingWhitespace","newSpaceCnt","getSpaceCnt","newIndentation","generateIndent","trimLeft","indentOfMovingLine","getGoodIndentForLine","oldSpaceCnt","ret","matchEnterRuleMovingDown","getIndentEditsOfMovingBlock","newIndentatOfMovingBlock","spaceCntOffset","indentOfFirstLine","oldIndent","shiftIndent","indentation","length","unshiftIndent","parseEnterResult","line","enter","enterPrefix","indentAction","None","appendText","Indent","IndentOutdent","Outdent","indexOf","indentMetadataOfMovelingLine","getIndentMetadata","futureAboveLineNumber","futureAboveLineText","lastNonWhitespaceIndex","maxColumn","getEnterAction","validPrecedingLine","lineContent","nonWhitespaceIdx","oneLineAbove","previousLineText","undefined","str","replace","isCheapToTokenize","languageAtSelectionStart","languageAtSelectionEnd","getIndentRulesSupport","offset","i","originalIndent","originalSpacesCnt","newSpacesCnt","newIndent","computeCursorState","helper","result","getTrackedSelection"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/moveLinesCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { ShiftCommand } from '../../common/commands/shiftCommand.js';\r\nimport { Range } from '../../common/core/range.js';\r\nimport { Selection } from '../../common/core/selection.js';\r\nimport { IndentAction } from '../../common/modes/languageConfiguration.js';\r\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\r\nimport * as indentUtils from '../indentation/indentUtils.js';\r\nexport class MoveLinesCommand {\r\n    constructor(selection, isMovingDown, autoIndent) {\r\n        this._selection = selection;\r\n        this._isMovingDown = isMovingDown;\r\n        this._autoIndent = autoIndent;\r\n        this._selectionId = null;\r\n        this._moveEndLineSelectionShrink = false;\r\n    }\r\n    getEditOperations(model, builder) {\r\n        let modelLineCount = model.getLineCount();\r\n        if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\r\n            this._selectionId = builder.trackSelection(this._selection);\r\n            return;\r\n        }\r\n        if (!this._isMovingDown && this._selection.startLineNumber === 1) {\r\n            this._selectionId = builder.trackSelection(this._selection);\r\n            return;\r\n        }\r\n        this._moveEndPositionDown = false;\r\n        let s = this._selection;\r\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\r\n            this._moveEndPositionDown = true;\r\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\r\n        }\r\n        const { tabSize, indentSize, insertSpaces } = model.getOptions();\r\n        let indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\r\n        let virtualModel = {\r\n            getLineTokens: (lineNumber) => {\r\n                return model.getLineTokens(lineNumber);\r\n            },\r\n            getLanguageIdentifier: () => {\r\n                return model.getLanguageIdentifier();\r\n            },\r\n            getLanguageIdAtPosition: (lineNumber, column) => {\r\n                return model.getLanguageIdAtPosition(lineNumber, column);\r\n            },\r\n            getLineContent: null,\r\n        };\r\n        if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\r\n            // Current line is empty\r\n            let lineNumber = s.startLineNumber;\r\n            let otherLineNumber = (this._isMovingDown ? lineNumber + 1 : lineNumber - 1);\r\n            if (model.getLineMaxColumn(otherLineNumber) === 1) {\r\n                // Other line number is empty too, so no editing is needed\r\n                // Add a no-op to force running by the model\r\n                builder.addEditOperation(new Range(1, 1, 1, 1), null);\r\n            }\r\n            else {\r\n                // Type content from other line number on line number\r\n                builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));\r\n                // Remove content from other line number\r\n                builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\r\n            }\r\n            // Track selection at the other line number\r\n            s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\r\n        }\r\n        else {\r\n            let movingLineNumber;\r\n            let movingLineText;\r\n            if (this._isMovingDown) {\r\n                movingLineNumber = s.endLineNumber + 1;\r\n                movingLineText = model.getLineContent(movingLineNumber);\r\n                // Delete line that needs to be moved\r\n                builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\r\n                let insertingText = movingLineText;\r\n                if (this.shouldAutoIndent(model, s)) {\r\n                    let movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);\r\n                    // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\r\n                    if (movingLineMatchResult !== null) {\r\n                        let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\r\n                        let newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\r\n                        let newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\r\n                        insertingText = newIndentation + this.trimLeft(movingLineText);\r\n                    }\r\n                    else {\r\n                        // no enter rule matches, let's check indentatin rules then.\r\n                        virtualModel.getLineContent = (lineNumber) => {\r\n                            if (lineNumber === s.startLineNumber) {\r\n                                return model.getLineContent(movingLineNumber);\r\n                            }\r\n                            else {\r\n                                return model.getLineContent(lineNumber);\r\n                            }\r\n                        };\r\n                        let indentOfMovingLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter);\r\n                        if (indentOfMovingLine !== null) {\r\n                            let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\r\n                            let newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\r\n                            let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\r\n                            if (newSpaceCnt !== oldSpaceCnt) {\r\n                                let newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\r\n                                insertingText = newIndentation + this.trimLeft(movingLineText);\r\n                            }\r\n                        }\r\n                    }\r\n                    // add edit operations for moving line first to make sure it's executed after we make indentation change\r\n                    // to s.startLineNumber\r\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\r\n                    let ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);\r\n                    // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\r\n                    if (ret !== null) {\r\n                        if (ret !== 0) {\r\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // it doesn't match onEnter rules, let's check indentation rules then.\r\n                        virtualModel.getLineContent = (lineNumber) => {\r\n                            if (lineNumber === s.startLineNumber) {\r\n                                return insertingText;\r\n                            }\r\n                            else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\r\n                                return model.getLineContent(lineNumber - 1);\r\n                            }\r\n                            else {\r\n                                return model.getLineContent(lineNumber);\r\n                            }\r\n                        };\r\n                        let newIndentatOfMovingBlock = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter);\r\n                        if (newIndentatOfMovingBlock !== null) {\r\n                            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\r\n                            const newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\r\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\r\n                            if (newSpaceCnt !== oldSpaceCnt) {\r\n                                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\r\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Insert line that needs to be moved before\r\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\r\n                }\r\n            }\r\n            else {\r\n                movingLineNumber = s.startLineNumber - 1;\r\n                movingLineText = model.getLineContent(movingLineNumber);\r\n                // Delete line that needs to be moved\r\n                builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);\r\n                // Insert line that needs to be moved after\r\n                builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\r\n                if (this.shouldAutoIndent(model, s)) {\r\n                    virtualModel.getLineContent = (lineNumber) => {\r\n                        if (lineNumber === movingLineNumber) {\r\n                            return model.getLineContent(s.startLineNumber);\r\n                        }\r\n                        else {\r\n                            return model.getLineContent(lineNumber);\r\n                        }\r\n                    };\r\n                    let ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);\r\n                    // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\r\n                    if (ret !== null) {\r\n                        if (ret !== 0) {\r\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // it doesn't match any onEnter rule, let's check indentation rules then.\r\n                        let indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter);\r\n                        if (indentOfFirstLine !== null) {\r\n                            // adjust the indentation of the moving block\r\n                            let oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\r\n                            let newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\r\n                            let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\r\n                            if (newSpaceCnt !== oldSpaceCnt) {\r\n                                let spaceCntOffset = newSpaceCnt - oldSpaceCnt;\r\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._selectionId = builder.trackSelection(s);\r\n    }\r\n    buildIndentConverter(tabSize, indentSize, insertSpaces) {\r\n        return {\r\n            shiftIndent: (indentation) => {\r\n                return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\r\n            },\r\n            unshiftIndent: (indentation) => {\r\n                return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\r\n            }\r\n        };\r\n    }\r\n    parseEnterResult(model, indentConverter, tabSize, line, enter) {\r\n        if (enter) {\r\n            let enterPrefix = enter.indentation;\r\n            if (enter.indentAction === IndentAction.None) {\r\n                enterPrefix = enter.indentation + enter.appendText;\r\n            }\r\n            else if (enter.indentAction === IndentAction.Indent) {\r\n                enterPrefix = enter.indentation + enter.appendText;\r\n            }\r\n            else if (enter.indentAction === IndentAction.IndentOutdent) {\r\n                enterPrefix = enter.indentation;\r\n            }\r\n            else if (enter.indentAction === IndentAction.Outdent) {\r\n                enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;\r\n            }\r\n            let movingLineText = model.getLineContent(line);\r\n            if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {\r\n                let oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\r\n                let newIndentation = strings.getLeadingWhitespace(enterPrefix);\r\n                let indentMetadataOfMovelingLine = LanguageConfigurationRegistry.getIndentMetadata(model, line);\r\n                if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2 /* DECREASE_MASK */) {\r\n                    newIndentation = indentConverter.unshiftIndent(newIndentation);\r\n                }\r\n                let newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\r\n                let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\r\n                return newSpaceCnt - oldSpaceCnt;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     *\r\n     * @param model\r\n     * @param indentConverter\r\n     * @param tabSize\r\n     * @param line the line moving down\r\n     * @param futureAboveLineNumber the line which will be at the `line` position\r\n     * @param futureAboveLineText\r\n     */\r\n    matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {\r\n        if (strings.lastNonWhitespaceIndex(futureAboveLineText) >= 0) {\r\n            // break\r\n            let maxColumn = model.getLineMaxColumn(futureAboveLineNumber);\r\n            let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn));\r\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\r\n        }\r\n        else {\r\n            // go upwards, starting from `line - 1`\r\n            let validPrecedingLine = line - 1;\r\n            while (validPrecedingLine >= 1) {\r\n                let lineContent = model.getLineContent(validPrecedingLine);\r\n                let nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\r\n                if (nonWhitespaceIdx >= 0) {\r\n                    break;\r\n                }\r\n                validPrecedingLine--;\r\n            }\r\n            if (validPrecedingLine < 1 || line > model.getLineCount()) {\r\n                return null;\r\n            }\r\n            let maxColumn = model.getLineMaxColumn(validPrecedingLine);\r\n            let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));\r\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\r\n        }\r\n    }\r\n    matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {\r\n        let validPrecedingLine = oneLineAbove;\r\n        while (validPrecedingLine >= 1) {\r\n            // ship empty lines as empty lines just inherit indentation\r\n            let lineContent;\r\n            if (validPrecedingLine === oneLineAbove && previousLineText !== undefined) {\r\n                lineContent = previousLineText;\r\n            }\r\n            else {\r\n                lineContent = model.getLineContent(validPrecedingLine);\r\n            }\r\n            let nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\r\n            if (nonWhitespaceIdx >= 0) {\r\n                break;\r\n            }\r\n            validPrecedingLine--;\r\n        }\r\n        if (validPrecedingLine < 1 || line > model.getLineCount()) {\r\n            return null;\r\n        }\r\n        let maxColumn = model.getLineMaxColumn(validPrecedingLine);\r\n        let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));\r\n        return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\r\n    }\r\n    trimLeft(str) {\r\n        return str.replace(/^\\s+/, '');\r\n    }\r\n    shouldAutoIndent(model, selection) {\r\n        if (this._autoIndent < 4 /* Full */) {\r\n            return false;\r\n        }\r\n        // if it's not easy to tokenize, we stop auto indent.\r\n        if (!model.isCheapToTokenize(selection.startLineNumber)) {\r\n            return false;\r\n        }\r\n        let languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\r\n        let languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\r\n        if (languageAtSelectionStart !== languageAtSelectionEnd) {\r\n            return false;\r\n        }\r\n        if (LanguageConfigurationRegistry.getIndentRulesSupport(languageAtSelectionStart) === null) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\r\n        for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\r\n            let lineContent = model.getLineContent(i);\r\n            let originalIndent = strings.getLeadingWhitespace(lineContent);\r\n            let originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\r\n            let newSpacesCnt = originalSpacesCnt + offset;\r\n            let newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\r\n            if (newIndent !== originalIndent) {\r\n                builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\r\n                if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\r\n                    // as users select part of the original indent white spaces\r\n                    // when we adjust the indentation of endLine, we should adjust the cursor position as well.\r\n                    this._moveEndLineSelectionShrink = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    computeCursorState(model, helper) {\r\n        let result = helper.getTrackedSelection(this._selectionId);\r\n        if (this._moveEndPositionDown) {\r\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\r\n        }\r\n        if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\r\n            result = result.setEndPosition(result.endLineNumber, 2);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}