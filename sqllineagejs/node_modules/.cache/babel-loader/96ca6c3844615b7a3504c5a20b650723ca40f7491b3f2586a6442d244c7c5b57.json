{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalMouseMoveMonitor, standardMouseMoveMerger } from '../../../../base/browser/globalMouseMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel/viewModel.js';\nimport { minimapSelection, scrollbarShadow, minimapBackground, minimapSliderBackground, minimapSliderHoverBackground, minimapSliderActiveBackground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { MinimapPosition } from '../../../common/model.js';\nimport { once } from '../../../../base/common/functional.js';\n/**\r\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\r\n */\nconst MOUSE_DRAG_RESET_DISTANCE = 140;\nconst GUTTER_DECORATION_WIDTH = 2;\nclass MinimapOptions {\n  constructor(configuration, theme, tokensColorTracker) {\n    const options = configuration.options;\n    const pixelRatio = options.get(122 /* pixelRatio */);\n    const layoutInfo = options.get(124 /* layoutInfo */);\n    const minimapLayout = layoutInfo.minimap;\n    const fontInfo = options.get(38 /* fontInfo */);\n    const minimapOpts = options.get(59 /* minimap */);\n    this.renderMinimap = minimapLayout.renderMinimap;\n    this.size = minimapOpts.size;\n    this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n    this.scrollBeyondLastLine = options.get(89 /* scrollBeyondLastLine */);\n    this.showSlider = minimapOpts.showSlider;\n    this.pixelRatio = pixelRatio;\n    this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this.lineHeight = options.get(53 /* lineHeight */);\n    this.minimapLeft = minimapLayout.minimapLeft;\n    this.minimapWidth = minimapLayout.minimapWidth;\n    this.minimapHeight = layoutInfo.height;\n    this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n    this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n    this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n    this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n    this.isSampling = minimapLayout.minimapIsSampling;\n    this.editorHeight = layoutInfo.height;\n    this.fontScale = minimapLayout.minimapScale;\n    this.minimapLineHeight = minimapLayout.minimapLineHeight;\n    this.minimapCharWidth = 1 /* BASE_CHAR_WIDTH */ * this.fontScale;\n    this.charRenderer = once(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n    this.backgroundColor = MinimapOptions._getMinimapBackground(theme, tokensColorTracker);\n  }\n  static _getMinimapBackground(theme, tokensColorTracker) {\n    const themeColor = theme.getColor(minimapBackground);\n    if (themeColor) {\n      return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, themeColor.rgba.a);\n    }\n    return tokensColorTracker.getColor(2 /* DefaultBackground */);\n  }\n\n  equals(other) {\n    return this.renderMinimap === other.renderMinimap && this.size === other.size && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === other.scrollBeyondLastLine && this.showSlider === other.showSlider && this.pixelRatio === other.pixelRatio && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth && this.lineHeight === other.lineHeight && this.minimapLeft === other.minimapLeft && this.minimapWidth === other.minimapWidth && this.minimapHeight === other.minimapHeight && this.canvasInnerWidth === other.canvasInnerWidth && this.canvasInnerHeight === other.canvasInnerHeight && this.canvasOuterWidth === other.canvasOuterWidth && this.canvasOuterHeight === other.canvasOuterHeight && this.isSampling === other.isSampling && this.editorHeight === other.editorHeight && this.fontScale === other.fontScale && this.minimapLineHeight === other.minimapLineHeight && this.minimapCharWidth === other.minimapCharWidth && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor);\n  }\n}\nclass MinimapLayout {\n  constructor(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber) {\n    this.scrollTop = scrollTop;\n    this.scrollHeight = scrollHeight;\n    this.sliderNeeded = sliderNeeded;\n    this._computedSliderRatio = computedSliderRatio;\n    this.sliderTop = sliderTop;\n    this.sliderHeight = sliderHeight;\n    this.startLineNumber = startLineNumber;\n    this.endLineNumber = endLineNumber;\n  }\n  /**\r\n   * Compute a desired `scrollPosition` such that the slider moves by `delta`.\r\n   */\n  getDesiredScrollTopFromDelta(delta) {\n    return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n  }\n  getDesiredScrollTopFromTouchLocation(pageY) {\n    return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n  }\n  static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n    const pixelRatio = options.pixelRatio;\n    const minimapLineHeight = options.minimapLineHeight;\n    const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n    const lineHeight = options.lineHeight;\n    if (options.minimapHeightIsEditorHeight) {\n      const logicalScrollHeight = realLineCount * options.lineHeight + (options.scrollBeyondLastLine ? viewportHeight - options.lineHeight : 0);\n      const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n      const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\n      // The slider can move from 0 to `maxMinimapSliderTop`\n      // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n      const computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n      const sliderTop = scrollTop * computedSliderRatio;\n      const sliderNeeded = maxMinimapSliderTop > 0;\n      const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n      return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, 1, Math.min(lineCount, maxLinesFitting));\n    }\n    // The visible line count in a viewport can change due to a number of reasons:\n    //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n    //    e.g. for a line height of 20, and a viewport height of 600\n    //          * scrollTop = 0  => visible lines are [1, 30]\n    //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n    //          * scrollTop = 20 => visible lines are [2, 31]\n    //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n    //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n    // We must first establish a desirable slider height.\n    let sliderHeight;\n    if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n      // case b) from above: there are whitespace gaps in the viewport.\n      // In this case, the height of the slider directly reflects the visible line count.\n      const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n      sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n    } else {\n      // The slider has a stable height\n      const expectedViewportLineCount = viewportHeight / lineHeight;\n      sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n    }\n    let maxMinimapSliderTop;\n    if (options.scrollBeyondLastLine) {\n      // The minimap slider, when dragged all the way down, will contain the last line at its top\n      maxMinimapSliderTop = (lineCount - 1) * minimapLineHeight / pixelRatio;\n    } else {\n      // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n      maxMinimapSliderTop = Math.max(0, lineCount * minimapLineHeight / pixelRatio - sliderHeight);\n    }\n    maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n    // The slider can move from 0 to `maxMinimapSliderTop`\n    // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n    const computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n    const sliderTop = scrollTop * computedSliderRatio;\n    let extraLinesAtTheBottom = 0;\n    if (options.scrollBeyondLastLine) {\n      const expectedViewportLineCount = viewportHeight / lineHeight;\n      extraLinesAtTheBottom = expectedViewportLineCount - 1;\n    }\n    if (minimapLinesFitting >= lineCount + extraLinesAtTheBottom) {\n      // All lines fit in the minimap\n      const startLineNumber = 1;\n      const endLineNumber = lineCount;\n      const sliderNeeded = maxMinimapSliderTop > 0;\n      return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);\n    } else {\n      let startLineNumber = Math.max(1, Math.floor(viewportStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n      // Avoid flickering caused by a partial viewport start line\n      // by being consistent w.r.t. the previous layout decision\n      if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n        if (previousLayout.scrollTop > scrollTop) {\n          // Scrolling up => never increase `startLineNumber`\n          startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n        }\n        if (previousLayout.scrollTop < scrollTop) {\n          // Scrolling down => never decrease `startLineNumber`\n          startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n        }\n      }\n      const endLineNumber = Math.min(lineCount, startLineNumber + minimapLinesFitting - 1);\n      const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n      const sliderTopAligned = (viewportStartLineNumber - startLineNumber + partialLine) * minimapLineHeight / pixelRatio;\n      return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, startLineNumber, endLineNumber);\n    }\n  }\n}\nclass MinimapLine {\n  constructor(dy) {\n    this.dy = dy;\n  }\n  onContentChanged() {\n    this.dy = -1;\n  }\n  onTokensChanged() {\n    this.dy = -1;\n  }\n}\nMinimapLine.INVALID = new MinimapLine(-1);\nclass RenderData {\n  constructor(renderedLayout, imageData, lines) {\n    this.renderedLayout = renderedLayout;\n    this._imageData = imageData;\n    this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\n    this._renderedLines._set(renderedLayout.startLineNumber, lines);\n  }\n  /**\r\n   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\r\n   */\n  linesEquals(layout) {\n    if (!this.scrollEquals(layout)) {\n      return false;\n    }\n    const tmp = this._renderedLines._get();\n    const lines = tmp.lines;\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].dy === -1) {\n        // This line is invalid\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\r\n   * Check if the current RenderData matches the new layout's scroll position\r\n   */\n  scrollEquals(layout) {\n    return this.renderedLayout.startLineNumber === layout.startLineNumber && this.renderedLayout.endLineNumber === layout.endLineNumber;\n  }\n  _get() {\n    const tmp = this._renderedLines._get();\n    return {\n      imageData: this._imageData,\n      rendLineNumberStart: tmp.rendLineNumberStart,\n      lines: tmp.lines\n    };\n  }\n  onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n    return this._renderedLines.onLinesChanged(changeFromLineNumber, changeToLineNumber);\n  }\n  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n    this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n  }\n  onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n    this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n  }\n  onTokensChanged(ranges) {\n    return this._renderedLines.onTokensChanged(ranges);\n  }\n}\n/**\r\n * Some sort of double buffering.\r\n *\r\n * Keeps two buffers around that will be rotated for painting.\r\n * Always gives a buffer that is filled with the background color.\r\n */\nclass MinimapBuffers {\n  constructor(ctx, WIDTH, HEIGHT, background) {\n    this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n    this._buffers = [ctx.createImageData(WIDTH, HEIGHT), ctx.createImageData(WIDTH, HEIGHT)];\n    this._lastUsedBuffer = 0;\n  }\n  getBuffer() {\n    // rotate buffers\n    this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n    const result = this._buffers[this._lastUsedBuffer];\n    // fill with background color\n    result.data.set(this._backgroundFillData);\n    return result;\n  }\n  static _createBackgroundFillData(WIDTH, HEIGHT, background) {\n    const backgroundR = background.r;\n    const backgroundG = background.g;\n    const backgroundB = background.b;\n    const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n    let offset = 0;\n    for (let i = 0; i < HEIGHT; i++) {\n      for (let j = 0; j < WIDTH; j++) {\n        result[offset] = backgroundR;\n        result[offset + 1] = backgroundG;\n        result[offset + 2] = backgroundB;\n        result[offset + 3] = 255;\n        offset += 4;\n      }\n    }\n    return result;\n  }\n}\nclass MinimapSamplingState {\n  constructor(samplingRatio, minimapLines) {\n    this.samplingRatio = samplingRatio;\n    this.minimapLines = minimapLines;\n  }\n  static compute(options, viewLineCount, oldSamplingState) {\n    if (options.renderMinimap === 0 /* None */ || !options.isSampling) {\n      return [null, []];\n    }\n    // ratio is intentionally not part of the layout to avoid the layout changing all the time\n    // so we need to recompute it again...\n    const pixelRatio = options.pixelRatio;\n    const lineHeight = options.lineHeight;\n    const scrollBeyondLastLine = options.scrollBeyondLastLine;\n    const {\n      minimapLineCount\n    } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n      viewLineCount: viewLineCount,\n      scrollBeyondLastLine: scrollBeyondLastLine,\n      height: options.editorHeight,\n      lineHeight: lineHeight,\n      pixelRatio: pixelRatio\n    });\n    const ratio = viewLineCount / minimapLineCount;\n    const halfRatio = ratio / 2;\n    if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n      let result = [];\n      result[0] = 1;\n      if (minimapLineCount > 1) {\n        for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n          result[i] = Math.round(i * ratio + halfRatio);\n        }\n        result[minimapLineCount - 1] = viewLineCount;\n      }\n      return [new MinimapSamplingState(ratio, result), []];\n    }\n    const oldMinimapLines = oldSamplingState.minimapLines;\n    const oldLength = oldMinimapLines.length;\n    let result = [];\n    let oldIndex = 0;\n    let oldDeltaLineCount = 0;\n    let minViewLineNumber = 1;\n    const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n    let events = [];\n    let lastEvent = null;\n    for (let i = 0; i < minimapLineCount; i++) {\n      const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n      const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n      while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n        if (events.length < MAX_EVENT_COUNT) {\n          const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n          if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n            lastEvent.deleteToLineNumber++;\n          } else {\n            lastEvent = {\n              type: 'deleted',\n              _oldIndex: oldIndex,\n              deleteFromLineNumber: oldMinimapLineNumber,\n              deleteToLineNumber: oldMinimapLineNumber\n            };\n            events.push(lastEvent);\n          }\n          oldDeltaLineCount--;\n        }\n        oldIndex++;\n      }\n      let selectedViewLineNumber;\n      if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n        // reuse the old sampled line\n        selectedViewLineNumber = oldMinimapLines[oldIndex];\n        oldIndex++;\n      } else {\n        if (i === 0) {\n          selectedViewLineNumber = 1;\n        } else if (i + 1 === minimapLineCount) {\n          selectedViewLineNumber = viewLineCount;\n        } else {\n          selectedViewLineNumber = Math.round(i * ratio + halfRatio);\n        }\n        if (events.length < MAX_EVENT_COUNT) {\n          const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n          if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n            lastEvent.insertToLineNumber++;\n          } else {\n            lastEvent = {\n              type: 'inserted',\n              _i: i,\n              insertFromLineNumber: oldMinimapLineNumber,\n              insertToLineNumber: oldMinimapLineNumber\n            };\n            events.push(lastEvent);\n          }\n          oldDeltaLineCount++;\n        }\n      }\n      result[i] = selectedViewLineNumber;\n      minViewLineNumber = selectedViewLineNumber;\n    }\n    if (events.length < MAX_EVENT_COUNT) {\n      while (oldIndex < oldLength) {\n        const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n        if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n          lastEvent.deleteToLineNumber++;\n        } else {\n          lastEvent = {\n            type: 'deleted',\n            _oldIndex: oldIndex,\n            deleteFromLineNumber: oldMinimapLineNumber,\n            deleteToLineNumber: oldMinimapLineNumber\n          };\n          events.push(lastEvent);\n        }\n        oldDeltaLineCount--;\n        oldIndex++;\n      }\n    } else {\n      // too many events, just give up\n      events = [{\n        type: 'flush'\n      }];\n    }\n    return [new MinimapSamplingState(ratio, result), events];\n  }\n  modelLineToMinimapLine(lineNumber) {\n    return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n  }\n  /**\r\n   * Will return null if the model line ranges are not intersecting with a sampled model line.\r\n   */\n  modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n    let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n    while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n      fromLineIndex--;\n    }\n    let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n    while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n      toLineIndex++;\n    }\n    if (fromLineIndex === toLineIndex) {\n      const sampledLineNumber = this.minimapLines[fromLineIndex];\n      if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n        // This line is not part of the sampled lines ==> nothing to do\n        return null;\n      }\n    }\n    return [fromLineIndex + 1, toLineIndex + 1];\n  }\n  /**\r\n   * Will always return a range, even if it is not intersecting with a sampled model line.\r\n   */\n  decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n    let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n    let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n    if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n      if (minimapLineEnd === this.minimapLines.length) {\n        if (minimapLineStart > 1) {\n          minimapLineStart--;\n        }\n      } else {\n        minimapLineEnd++;\n      }\n    }\n    return [minimapLineStart, minimapLineEnd];\n  }\n  onLinesDeleted(e) {\n    // have the mapping be sticky\n    const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n    let changeStartIndex = this.minimapLines.length;\n    let changeEndIndex = 0;\n    for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n      if (this.minimapLines[i] < e.fromLineNumber) {\n        break;\n      }\n      if (this.minimapLines[i] <= e.toLineNumber) {\n        // this line got deleted => move to previous available\n        this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n        changeStartIndex = Math.min(changeStartIndex, i);\n        changeEndIndex = Math.max(changeEndIndex, i);\n      } else {\n        this.minimapLines[i] -= deletedLineCount;\n      }\n    }\n    return [changeStartIndex, changeEndIndex];\n  }\n  onLinesInserted(e) {\n    // have the mapping be sticky\n    const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n    for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n      if (this.minimapLines[i] < e.fromLineNumber) {\n        break;\n      }\n      this.minimapLines[i] += insertedLineCount;\n    }\n  }\n}\nexport class Minimap extends ViewPart {\n  constructor(context) {\n    super(context);\n    this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n    this._selections = [];\n    this._minimapSelections = null;\n    this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n    const [samplingState] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), null);\n    this._samplingState = samplingState;\n    this._shouldCheckSampling = false;\n    this._actual = new InnerMinimap(context.theme, this);\n  }\n  dispose() {\n    this._actual.dispose();\n    super.dispose();\n  }\n  getDomNode() {\n    return this._actual.getDomNode();\n  }\n  _onOptionsMaybeChanged() {\n    const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n    if (this.options.equals(opts)) {\n      return false;\n    }\n    this.options = opts;\n    this._recreateLineSampling();\n    this._actual.onDidChangeOptions();\n    return true;\n  }\n  // ---- begin view event handlers\n  onConfigurationChanged(e) {\n    return this._onOptionsMaybeChanged();\n  }\n  onCursorStateChanged(e) {\n    this._selections = e.selections;\n    this._minimapSelections = null;\n    return this._actual.onSelectionChanged();\n  }\n  onDecorationsChanged(e) {\n    if (e.affectsMinimap) {\n      return this._actual.onDecorationsChanged();\n    }\n    return false;\n  }\n  onFlushed(e) {\n    if (this._samplingState) {\n      this._shouldCheckSampling = true;\n    }\n    return this._actual.onFlushed();\n  }\n  onLinesChanged(e) {\n    if (this._samplingState) {\n      const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.toLineNumber);\n      if (minimapLineRange) {\n        return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1]);\n      } else {\n        return false;\n      }\n    } else {\n      return this._actual.onLinesChanged(e.fromLineNumber, e.toLineNumber);\n    }\n  }\n  onLinesDeleted(e) {\n    if (this._samplingState) {\n      const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n      if (changeStartIndex <= changeEndIndex) {\n        this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex + 1);\n      }\n      this._shouldCheckSampling = true;\n      return true;\n    } else {\n      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n    }\n  }\n  onLinesInserted(e) {\n    if (this._samplingState) {\n      this._samplingState.onLinesInserted(e);\n      this._shouldCheckSampling = true;\n      return true;\n    } else {\n      return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n    }\n  }\n  onScrollChanged(e) {\n    return this._actual.onScrollChanged();\n  }\n  onThemeChanged(e) {\n    this._context.model.invalidateMinimapColorCache();\n    this._actual.onThemeChanged();\n    this._onOptionsMaybeChanged();\n    return true;\n  }\n  onTokensChanged(e) {\n    if (this._samplingState) {\n      let ranges = [];\n      for (const range of e.ranges) {\n        const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n        if (minimapLineRange) {\n          ranges.push({\n            fromLineNumber: minimapLineRange[0],\n            toLineNumber: minimapLineRange[1]\n          });\n        }\n      }\n      if (ranges.length) {\n        return this._actual.onTokensChanged(ranges);\n      } else {\n        return false;\n      }\n    } else {\n      return this._actual.onTokensChanged(e.ranges);\n    }\n  }\n  onTokensColorsChanged(e) {\n    this._onOptionsMaybeChanged();\n    return this._actual.onTokensColorsChanged();\n  }\n  onZonesChanged(e) {\n    return this._actual.onZonesChanged();\n  }\n  // --- end event handlers\n  prepareRender(ctx) {\n    if (this._shouldCheckSampling) {\n      this._shouldCheckSampling = false;\n      this._recreateLineSampling();\n    }\n  }\n  render(ctx) {\n    let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n    let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n    if (this._samplingState) {\n      viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n      viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n    }\n    const minimapCtx = {\n      viewportContainsWhitespaceGaps: ctx.viewportData.whitespaceViewportData.length > 0,\n      scrollWidth: ctx.scrollWidth,\n      scrollHeight: ctx.scrollHeight,\n      viewportStartLineNumber: viewportStartLineNumber,\n      viewportEndLineNumber: viewportEndLineNumber,\n      viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n      scrollTop: ctx.scrollTop,\n      scrollLeft: ctx.scrollLeft,\n      viewportWidth: ctx.viewportWidth,\n      viewportHeight: ctx.viewportHeight\n    };\n    this._actual.render(minimapCtx);\n  }\n  //#region IMinimapModel\n  _recreateLineSampling() {\n    this._minimapSelections = null;\n    const wasSampling = Boolean(this._samplingState);\n    const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), this._samplingState);\n    this._samplingState = samplingState;\n    if (wasSampling && this._samplingState) {\n      // was sampling, is sampling\n      for (const event of events) {\n        switch (event.type) {\n          case 'deleted':\n            this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n            break;\n          case 'inserted':\n            this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n            break;\n          case 'flush':\n            this._actual.onFlushed();\n            break;\n        }\n      }\n    }\n  }\n  getLineCount() {\n    if (this._samplingState) {\n      return this._samplingState.minimapLines.length;\n    }\n    return this._context.model.getLineCount();\n  }\n  getRealLineCount() {\n    return this._context.model.getLineCount();\n  }\n  getLineContent(lineNumber) {\n    if (this._samplingState) {\n      return this._context.model.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n    }\n    return this._context.model.getLineContent(lineNumber);\n  }\n  getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n    if (this._samplingState) {\n      let result = [];\n      for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n        if (needed[lineIndex]) {\n          result[lineIndex] = this._context.model.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n        } else {\n          result[lineIndex] = null;\n        }\n      }\n      return result;\n    }\n    return this._context.model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n  }\n  getSelections() {\n    if (this._minimapSelections === null) {\n      if (this._samplingState) {\n        this._minimapSelections = [];\n        for (const selection of this._selections) {\n          const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n          this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n        }\n      } else {\n        this._minimapSelections = this._selections;\n      }\n    }\n    return this._minimapSelections;\n  }\n  getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n    let visibleRange;\n    if (this._samplingState) {\n      const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n      const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n      visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.model.getLineMaxColumn(modelEndLineNumber));\n    } else {\n      visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.model.getLineMaxColumn(endLineNumber));\n    }\n    const decorations = this._context.model.getDecorationsInViewport(visibleRange);\n    if (this._samplingState) {\n      let result = [];\n      for (const decoration of decorations) {\n        if (!decoration.options.minimap) {\n          continue;\n        }\n        const range = decoration.range;\n        const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n        const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n        result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n      }\n      return result;\n    }\n    return decorations;\n  }\n  getOptions() {\n    return this._context.model.getTextModelOptions();\n  }\n  revealLineNumber(lineNumber) {\n    if (this._samplingState) {\n      lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n    }\n    this._context.model.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* Center */, 0 /* Smooth */);\n  }\n\n  setScrollTop(scrollTop) {\n    this._context.model.setScrollPosition({\n      scrollTop: scrollTop\n    }, 1 /* Immediate */);\n  }\n}\n\nclass InnerMinimap extends Disposable {\n  constructor(theme, model) {\n    super();\n    this._renderDecorations = false;\n    this._gestureInProgress = false;\n    this._theme = theme;\n    this._model = model;\n    this._lastRenderData = null;\n    this._buffers = null;\n    this._selectionColor = this._theme.getColor(minimapSelection);\n    this._domNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(this._domNode, 8 /* Minimap */);\n    this._domNode.setClassName(this._getMinimapDomNodeClassName());\n    this._domNode.setPosition('absolute');\n    this._domNode.setAttribute('role', 'presentation');\n    this._domNode.setAttribute('aria-hidden', 'true');\n    this._shadow = createFastDomNode(document.createElement('div'));\n    this._shadow.setClassName('minimap-shadow-hidden');\n    this._domNode.appendChild(this._shadow);\n    this._canvas = createFastDomNode(document.createElement('canvas'));\n    this._canvas.setPosition('absolute');\n    this._canvas.setLeft(0);\n    this._domNode.appendChild(this._canvas);\n    this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n    this._decorationsCanvas.setPosition('absolute');\n    this._decorationsCanvas.setClassName('minimap-decorations-layer');\n    this._decorationsCanvas.setLeft(0);\n    this._domNode.appendChild(this._decorationsCanvas);\n    this._slider = createFastDomNode(document.createElement('div'));\n    this._slider.setPosition('absolute');\n    this._slider.setClassName('minimap-slider');\n    this._slider.setLayerHinting(true);\n    this._slider.setContain('strict');\n    this._domNode.appendChild(this._slider);\n    this._sliderHorizontal = createFastDomNode(document.createElement('div'));\n    this._sliderHorizontal.setPosition('absolute');\n    this._sliderHorizontal.setClassName('minimap-slider-horizontal');\n    this._slider.appendChild(this._sliderHorizontal);\n    this._applyLayout();\n    this._mouseDownListener = dom.addStandardDisposableListener(this._domNode.domNode, 'mousedown', e => {\n      e.preventDefault();\n      const renderMinimap = this._model.options.renderMinimap;\n      if (renderMinimap === 0 /* None */) {\n        return;\n      }\n      if (!this._lastRenderData) {\n        return;\n      }\n      if (this._model.options.size !== 'proportional') {\n        if (e.leftButton && this._lastRenderData) {\n          // pretend the click occured in the center of the slider\n          const position = dom.getDomNodePagePosition(this._slider.domNode);\n          const initialPosY = position.top + position.height / 2;\n          this._startSliderDragging(e.buttons, e.posx, initialPosY, e.posy, this._lastRenderData.renderedLayout);\n        }\n        return;\n      }\n      const minimapLineHeight = this._model.options.minimapLineHeight;\n      const internalOffsetY = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * e.browserEvent.offsetY;\n      const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n      let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber;\n      lineNumber = Math.min(lineNumber, this._model.getLineCount());\n      this._model.revealLineNumber(lineNumber);\n    });\n    this._sliderMouseMoveMonitor = new GlobalMouseMoveMonitor();\n    this._sliderMouseDownListener = dom.addStandardDisposableListener(this._slider.domNode, 'mousedown', e => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (e.leftButton && this._lastRenderData) {\n        this._startSliderDragging(e.buttons, e.posx, e.posy, e.posy, this._lastRenderData.renderedLayout);\n      }\n    });\n    this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n    this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (this._lastRenderData) {\n        this._slider.toggleClassName('active', true);\n        this._gestureInProgress = true;\n        this.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (this._lastRenderData && this._gestureInProgress) {\n        this.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, e => {\n      e.preventDefault();\n      e.stopPropagation();\n      this._gestureInProgress = false;\n      this._slider.toggleClassName('active', false);\n    });\n  }\n  _startSliderDragging(initialButtons, initialPosX, initialPosY, posy, initialSliderState) {\n    this._slider.toggleClassName('active', true);\n    const handleMouseMove = (posy, posx) => {\n      const mouseOrthogonalDelta = Math.abs(posx - initialPosX);\n      if (platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {\n        // The mouse has wondered away from the scrollbar => reset dragging\n        this._model.setScrollTop(initialSliderState.scrollTop);\n        return;\n      }\n      const mouseDelta = posy - initialPosY;\n      this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(mouseDelta));\n    };\n    if (posy !== initialPosY) {\n      handleMouseMove(posy, initialPosX);\n    }\n    this._sliderMouseMoveMonitor.startMonitoring(this._slider.domNode, initialButtons, standardMouseMoveMerger, mouseMoveData => handleMouseMove(mouseMoveData.posy, mouseMoveData.posx), () => {\n      this._slider.toggleClassName('active', false);\n    });\n  }\n  scrollDueToTouchEvent(touch) {\n    const startY = this._domNode.domNode.getBoundingClientRect().top;\n    const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n    this._model.setScrollTop(scrollTop);\n  }\n  dispose() {\n    this._mouseDownListener.dispose();\n    this._sliderMouseMoveMonitor.dispose();\n    this._sliderMouseDownListener.dispose();\n    this._gestureDisposable.dispose();\n    this._sliderTouchStartListener.dispose();\n    this._sliderTouchMoveListener.dispose();\n    this._sliderTouchEndListener.dispose();\n    super.dispose();\n  }\n  _getMinimapDomNodeClassName() {\n    if (this._model.options.showSlider === 'always') {\n      return 'minimap slider-always';\n    }\n    return 'minimap slider-mouseover';\n  }\n  getDomNode() {\n    return this._domNode;\n  }\n  _applyLayout() {\n    this._domNode.setLeft(this._model.options.minimapLeft);\n    this._domNode.setWidth(this._model.options.minimapWidth);\n    this._domNode.setHeight(this._model.options.minimapHeight);\n    this._shadow.setHeight(this._model.options.minimapHeight);\n    this._canvas.setWidth(this._model.options.canvasOuterWidth);\n    this._canvas.setHeight(this._model.options.canvasOuterHeight);\n    this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n    this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n    this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n    this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n    this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n    this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n    this._slider.setWidth(this._model.options.minimapWidth);\n  }\n  _getBuffer() {\n    if (!this._buffers) {\n      if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n        this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n      }\n    }\n    return this._buffers ? this._buffers.getBuffer() : null;\n  }\n  // ---- begin view event handlers\n  onDidChangeOptions() {\n    this._lastRenderData = null;\n    this._buffers = null;\n    this._applyLayout();\n    this._domNode.setClassName(this._getMinimapDomNodeClassName());\n  }\n  onSelectionChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n  onDecorationsChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n  onFlushed() {\n    this._lastRenderData = null;\n    return true;\n  }\n  onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n    if (this._lastRenderData) {\n      return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeToLineNumber);\n    }\n    return false;\n  }\n  onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n    if (this._lastRenderData) {\n      this._lastRenderData.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    }\n    return true;\n  }\n  onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n    if (this._lastRenderData) {\n      this._lastRenderData.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    }\n    return true;\n  }\n  onScrollChanged() {\n    this._renderDecorations = true;\n    return true;\n  }\n  onThemeChanged() {\n    this._selectionColor = this._theme.getColor(minimapSelection);\n    this._renderDecorations = true;\n    return true;\n  }\n  onTokensChanged(ranges) {\n    if (this._lastRenderData) {\n      return this._lastRenderData.onTokensChanged(ranges);\n    }\n    return false;\n  }\n  onTokensColorsChanged() {\n    this._lastRenderData = null;\n    this._buffers = null;\n    return true;\n  }\n  onZonesChanged() {\n    this._lastRenderData = null;\n    return true;\n  }\n  // --- end event handlers\n  render(renderingCtx) {\n    const renderMinimap = this._model.options.renderMinimap;\n    if (renderMinimap === 0 /* None */) {\n      this._shadow.setClassName('minimap-shadow-hidden');\n      this._sliderHorizontal.setWidth(0);\n      this._sliderHorizontal.setHeight(0);\n      return;\n    }\n    if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n      this._shadow.setClassName('minimap-shadow-hidden');\n    } else {\n      this._shadow.setClassName('minimap-shadow-visible');\n    }\n    const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n    this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n    this._slider.setTop(layout.sliderTop);\n    this._slider.setHeight(layout.sliderHeight);\n    // Compute horizontal slider coordinates\n    const scrollLeftChars = renderingCtx.scrollLeft / this._model.options.typicalHalfwidthCharacterWidth;\n    const horizontalSliderLeft = Math.min(this._model.options.minimapWidth, Math.round(scrollLeftChars * this._model.options.minimapCharWidth / this._model.options.pixelRatio));\n    this._sliderHorizontal.setLeft(horizontalSliderLeft);\n    this._sliderHorizontal.setWidth(this._model.options.minimapWidth - horizontalSliderLeft);\n    this._sliderHorizontal.setTop(0);\n    this._sliderHorizontal.setHeight(layout.sliderHeight);\n    this.renderDecorations(layout);\n    this._lastRenderData = this.renderLines(layout);\n  }\n  renderDecorations(layout) {\n    if (this._renderDecorations) {\n      this._renderDecorations = false;\n      const selections = this._model.getSelections();\n      const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n      const {\n        canvasInnerWidth,\n        canvasInnerHeight\n      } = this._model.options;\n      const lineHeight = this._model.options.minimapLineHeight;\n      const characterWidth = this._model.options.minimapCharWidth;\n      const tabSize = this._model.getOptions().tabSize;\n      const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n      canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n      const lineOffsetMap = new Map();\n      for (let i = 0; i < selections.length; i++) {\n        const selection = selections[i];\n        for (let line = selection.startLineNumber; line <= selection.endLineNumber; line++) {\n          this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth);\n        }\n      }\n      // Loop over decorations, ignoring those that don't have the minimap property set and rendering rectangles for each line the decoration spans\n      for (let i = 0; i < decorations.length; i++) {\n        const decoration = decorations[i];\n        if (!decoration.options.minimap) {\n          continue;\n        }\n        const decorationColor = decoration.options.minimap.getColor(this._theme);\n        for (let line = decoration.range.startLineNumber; line <= decoration.range.endLineNumber; line++) {\n          switch (decoration.options.minimap.position) {\n            case MinimapPosition.Inline:\n              this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth);\n              continue;\n            case MinimapPosition.Gutter:\n              const y = (line - layout.startLineNumber) * lineHeight;\n              const x = 2;\n              this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, lineHeight);\n              continue;\n          }\n        }\n      }\n    }\n  }\n  renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, lineHeight, tabSize, charWidth) {\n    const y = (lineNumber - layout.startLineNumber) * lineHeight;\n    // Skip rendering the line if it's vertically outside our viewport\n    if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n      return;\n    }\n    // Cache line offset data so that it is only read once per line\n    let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n    const isFirstDecorationForLine = !lineIndexToXOffset;\n    if (!lineIndexToXOffset) {\n      const lineData = this._model.getLineContent(lineNumber);\n      lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n      for (let i = 1; i < lineData.length + 1; i++) {\n        const charCode = lineData.charCodeAt(i - 1);\n        const dx = charCode === 9 /* Tab */ ? tabSize * charWidth : strings.isFullWidthCharacter(charCode) ? 2 * charWidth : charWidth;\n        lineIndexToXOffset[i] = lineIndexToXOffset[i - 1] + dx;\n      }\n      lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n    }\n    const {\n      startColumn,\n      endColumn,\n      startLineNumber,\n      endLineNumber\n    } = decorationRange;\n    const x = startLineNumber === lineNumber ? lineIndexToXOffset[startColumn - 1] : MINIMAP_GUTTER_WIDTH;\n    const endColumnForLine = endLineNumber > lineNumber ? lineIndexToXOffset.length - 1 : endColumn - 1;\n    if (endColumnForLine > 0) {\n      // If the decoration starts at the last character of the column and spans over it, ensure it has a width\n      const width = lineIndexToXOffset[endColumnForLine] - x || 2;\n      this.renderDecoration(canvasContext, decorationColor, x, y, width, height);\n    }\n    if (isFirstDecorationForLine) {\n      this.renderLineHighlight(canvasContext, decorationColor, y, height);\n    }\n  }\n  renderLineHighlight(canvasContext, decorationColor, y, height) {\n    canvasContext.fillStyle = decorationColor && decorationColor.transparent(0.5).toString() || '';\n    canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, height);\n  }\n  renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n    canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n    canvasContext.fillRect(x, y, width, height);\n  }\n  renderLines(layout) {\n    const startLineNumber = layout.startLineNumber;\n    const endLineNumber = layout.endLineNumber;\n    const minimapLineHeight = this._model.options.minimapLineHeight;\n    // Check if nothing changed w.r.t. lines from last frame\n    if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n      const _lastData = this._lastRenderData._get();\n      // Nice!! Nothing changed from last frame\n      return new RenderData(layout, _lastData.imageData, _lastData.lines);\n    }\n    // Oh well!! We need to repaint some lines...\n    const imageData = this._getBuffer();\n    if (!imageData) {\n      // 0 width or 0 height canvas, nothing to do\n      return null;\n    }\n    // Render untouched lines by using last rendered data.\n    let [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);\n    // Fetch rendering info from view model for rest of lines that need rendering.\n    const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n    const tabSize = this._model.getOptions().tabSize;\n    const background = this._model.options.backgroundColor;\n    const tokensColorTracker = this._model.tokensColorTracker;\n    const useLighterFont = tokensColorTracker.backgroundIsLight();\n    const renderMinimap = this._model.options.renderMinimap;\n    const charRenderer = this._model.options.charRenderer();\n    const fontScale = this._model.options.fontScale;\n    const minimapCharWidth = this._model.options.minimapCharWidth;\n    const baseCharHeight = renderMinimap === 1 /* Text */ ? 2 /* BASE_CHAR_HEIGHT */ : 2 /* BASE_CHAR_HEIGHT */ + 1;\n    const renderMinimapLineHeight = baseCharHeight * fontScale;\n    const innerLinePadding = minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0;\n    // Render the rest of lines\n    let dy = 0;\n    const renderedLines = [];\n    for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n      if (needed[lineIndex]) {\n        InnerMinimap._renderLine(imageData, background, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n      }\n      renderedLines[lineIndex] = new MinimapLine(dy);\n      dy += minimapLineHeight;\n    }\n    const dirtyY1 = _dirtyY1 === -1 ? 0 : _dirtyY1;\n    const dirtyY2 = _dirtyY2 === -1 ? imageData.height : _dirtyY2;\n    const dirtyHeight = dirtyY2 - dirtyY1;\n    // Finally, paint to the canvas\n    const ctx = this._canvas.domNode.getContext('2d');\n    ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n    // Save rendered data for reuse on next frame if possible\n    return new RenderData(layout, imageData, renderedLines);\n  }\n  static _renderUntouchedLines(target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n    const needed = [];\n    if (!lastRenderData) {\n      for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n        needed[i] = true;\n      }\n      return [-1, -1, needed];\n    }\n    const _lastData = lastRenderData._get();\n    const lastTargetData = _lastData.imageData.data;\n    const lastStartLineNumber = _lastData.rendLineNumberStart;\n    const lastLines = _lastData.lines;\n    const lastLinesLength = lastLines.length;\n    const WIDTH = target.width;\n    const targetData = target.data;\n    const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n    let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n    let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n    let copySourceStart = -1;\n    let copySourceEnd = -1;\n    let copyDestStart = -1;\n    let copyDestEnd = -1;\n    let dest_dy = 0;\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const lineIndex = lineNumber - startLineNumber;\n      const lastLineIndex = lineNumber - lastStartLineNumber;\n      const source_dy = lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1;\n      if (source_dy === -1) {\n        needed[lineIndex] = true;\n        dest_dy += minimapLineHeight;\n        continue;\n      }\n      const sourceStart = source_dy * WIDTH * 4;\n      const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n      const destStart = dest_dy * WIDTH * 4;\n      const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n      if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n        // contiguous zone => extend copy request\n        copySourceEnd = sourceEnd;\n        copyDestEnd = destEnd;\n      } else {\n        if (copySourceStart !== -1) {\n          // flush existing copy request\n          targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n          if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n            dirtyPixel1 = copySourceEnd;\n          }\n          if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n            dirtyPixel2 = copySourceStart;\n          }\n        }\n        copySourceStart = sourceStart;\n        copySourceEnd = sourceEnd;\n        copyDestStart = destStart;\n        copyDestEnd = destEnd;\n      }\n      needed[lineIndex] = false;\n      dest_dy += minimapLineHeight;\n    }\n    if (copySourceStart !== -1) {\n      // flush existing copy request\n      targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n      if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n        dirtyPixel1 = copySourceEnd;\n      }\n      if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n        dirtyPixel2 = copySourceStart;\n      }\n    }\n    const dirtyY1 = dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4);\n    const dirtyY2 = dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4);\n    return [dirtyY1, dirtyY2, needed];\n  }\n  static _renderLine(target, backgroundColor, useLighterFont, renderMinimap, charWidth, colorTracker, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n    const content = lineData.content;\n    const tokens = lineData.tokens;\n    const maxDx = target.width - charWidth;\n    const force1pxHeight = minimapLineHeight === 1;\n    let dx = MINIMAP_GUTTER_WIDTH;\n    let charIndex = 0;\n    let tabsCharDelta = 0;\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n      const tokenEndIndex = tokens.getEndOffset(tokenIndex);\n      const tokenColorId = tokens.getForeground(tokenIndex);\n      const tokenColor = colorTracker.getColor(tokenColorId);\n      for (; charIndex < tokenEndIndex; charIndex++) {\n        if (dx > maxDx) {\n          // hit edge of minimap\n          return;\n        }\n        const charCode = content.charCodeAt(charIndex);\n        if (charCode === 9 /* Tab */) {\n          const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n          tabsCharDelta += insertSpacesCount - 1;\n          // No need to render anything since tab is invisible\n          dx += insertSpacesCount * charWidth;\n        } else if (charCode === 32 /* Space */) {\n          // No need to render anything since space is invisible\n          dx += charWidth;\n        } else {\n          // Render twice for a full width character\n          const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n          for (let i = 0; i < count; i++) {\n            if (renderMinimap === 2 /* Blocks */) {\n              minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, backgroundColor, useLighterFont, force1pxHeight);\n            } else {\n              // RenderMinimap.Text\n              minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, backgroundColor, fontScale, useLighterFont, force1pxHeight);\n            }\n            dx += charWidth;\n            if (dx > maxDx) {\n              // hit edge of minimap\n              return;\n            }\n          }\n        }\n      }\n    }\n  }\n}\nregisterThemingParticipant((theme, collector) => {\n  const minimapBackgroundValue = theme.getColor(minimapBackground);\n  if (minimapBackgroundValue) {\n    collector.addRule(\".monaco-editor .minimap > canvas { opacity: \".concat(minimapBackgroundValue.rgba.a, \"; will-change: opacity; }\"));\n  }\n  const sliderBackground = theme.getColor(minimapSliderBackground);\n  if (sliderBackground) {\n    collector.addRule(\".monaco-editor .minimap-slider .minimap-slider-horizontal { background: \".concat(sliderBackground, \"; }\"));\n  }\n  const sliderHoverBackground = theme.getColor(minimapSliderHoverBackground);\n  if (sliderHoverBackground) {\n    collector.addRule(\".monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: \".concat(sliderHoverBackground, \"; }\"));\n  }\n  const sliderActiveBackground = theme.getColor(minimapSliderActiveBackground);\n  if (sliderActiveBackground) {\n    collector.addRule(\".monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: \".concat(sliderActiveBackground, \"; }\"));\n  }\n  const shadow = theme.getColor(scrollbarShadow);\n  if (shadow) {\n    collector.addRule(\".monaco-editor .minimap-shadow-visible { box-shadow: \".concat(shadow, \" -6px 0 6px -6px inset; }\"));\n  }\n});","map":{"version":3,"names":["dom","createFastDomNode","GlobalMouseMoveMonitor","standardMouseMoveMerger","Disposable","platform","strings","RenderedLinesCollection","PartFingerprints","ViewPart","MINIMAP_GUTTER_WIDTH","EditorLayoutInfoComputer","Range","RGBA8","MinimapTokensColorTracker","ViewModelDecoration","minimapSelection","scrollbarShadow","minimapBackground","minimapSliderBackground","minimapSliderHoverBackground","minimapSliderActiveBackground","registerThemingParticipant","Selection","EventType","Gesture","MinimapCharRendererFactory","MinimapPosition","once","MOUSE_DRAG_RESET_DISTANCE","GUTTER_DECORATION_WIDTH","MinimapOptions","constructor","configuration","theme","tokensColorTracker","options","pixelRatio","get","layoutInfo","minimapLayout","minimap","fontInfo","minimapOpts","renderMinimap","size","minimapHeightIsEditorHeight","scrollBeyondLastLine","showSlider","typicalHalfwidthCharacterWidth","lineHeight","minimapLeft","minimapWidth","minimapHeight","height","canvasInnerWidth","minimapCanvasInnerWidth","canvasInnerHeight","minimapCanvasInnerHeight","canvasOuterWidth","minimapCanvasOuterWidth","canvasOuterHeight","minimapCanvasOuterHeight","isSampling","minimapIsSampling","editorHeight","fontScale","minimapScale","minimapLineHeight","minimapCharWidth","charRenderer","create","fontFamily","backgroundColor","_getMinimapBackground","themeColor","getColor","rgba","r","g","b","a","equals","other","MinimapLayout","scrollTop","scrollHeight","sliderNeeded","computedSliderRatio","sliderTop","sliderHeight","startLineNumber","endLineNumber","_computedSliderRatio","getDesiredScrollTopFromDelta","delta","Math","round","getDesiredScrollTopFromTouchLocation","pageY","viewportStartLineNumber","viewportEndLineNumber","viewportStartLineNumberVerticalOffset","viewportHeight","viewportContainsWhitespaceGaps","lineCount","realLineCount","previousLayout","minimapLinesFitting","floor","logicalScrollHeight","max","maxMinimapSliderTop","maxLinesFitting","min","viewportLineCount","expectedViewportLineCount","extraLinesAtTheBottom","partialLine","sliderTopAligned","MinimapLine","dy","onContentChanged","onTokensChanged","INVALID","RenderData","renderedLayout","imageData","lines","_imageData","_renderedLines","_set","linesEquals","layout","scrollEquals","tmp","_get","i","len","length","rendLineNumberStart","onLinesChanged","changeFromLineNumber","changeToLineNumber","onLinesDeleted","deleteFromLineNumber","deleteToLineNumber","onLinesInserted","insertFromLineNumber","insertToLineNumber","ranges","MinimapBuffers","ctx","WIDTH","HEIGHT","background","_backgroundFillData","_createBackgroundFillData","_buffers","createImageData","_lastUsedBuffer","getBuffer","result","data","set","backgroundR","backgroundG","backgroundB","Uint8ClampedArray","offset","j","MinimapSamplingState","samplingRatio","minimapLines","compute","viewLineCount","oldSamplingState","minimapLineCount","computeContainedMinimapLineCount","ratio","halfRatio","lastIndex","oldMinimapLines","oldLength","oldIndex","oldDeltaLineCount","minViewLineNumber","MAX_EVENT_COUNT","events","lastEvent","fromViewLineNumber","toViewLineNumber","oldMinimapLineNumber","type","_oldIndex","push","selectedViewLineNumber","_i","modelLineToMinimapLine","lineNumber","modelLineRangeToMinimapLineRange","fromLineNumber","toLineNumber","fromLineIndex","toLineIndex","sampledLineNumber","decorationLineRangeToMinimapLineRange","minimapLineStart","minimapLineEnd","e","deletedLineCount","changeStartIndex","changeEndIndex","insertedLineCount","Minimap","context","getInstance","_selections","_minimapSelections","_context","samplingState","model","getLineCount","_samplingState","_shouldCheckSampling","_actual","InnerMinimap","dispose","getDomNode","_onOptionsMaybeChanged","opts","_recreateLineSampling","onDidChangeOptions","onConfigurationChanged","onCursorStateChanged","selections","onSelectionChanged","onDecorationsChanged","affectsMinimap","onFlushed","minimapLineRange","onScrollChanged","onThemeChanged","invalidateMinimapColorCache","range","onTokensColorsChanged","onZonesChanged","prepareRender","render","visibleRange","minimapCtx","viewportData","whitespaceViewportData","scrollWidth","getVerticalOffsetForLineNumber","scrollLeft","viewportWidth","wasSampling","Boolean","event","getRealLineCount","getLineContent","getMinimapLinesRenderingData","needed","lineIndex","getViewLineData","getSelections","selection","startColumn","endColumn","getMinimapDecorationsInViewport","modelStartLineNumber","modelEndLineNumber","getLineMaxColumn","decorations","getDecorationsInViewport","decoration","minimapStartLineNumber","minimapEndLineNumber","getOptions","getTextModelOptions","revealLineNumber","revealRange","setScrollTop","setScrollPosition","_renderDecorations","_gestureInProgress","_theme","_model","_lastRenderData","_selectionColor","_domNode","document","createElement","write","setClassName","_getMinimapDomNodeClassName","setPosition","setAttribute","_shadow","appendChild","_canvas","setLeft","_decorationsCanvas","_slider","setLayerHinting","setContain","_sliderHorizontal","_applyLayout","_mouseDownListener","addStandardDisposableListener","domNode","preventDefault","leftButton","position","getDomNodePagePosition","initialPosY","top","_startSliderDragging","buttons","posx","posy","internalOffsetY","browserEvent","offsetY","_sliderMouseMoveMonitor","_sliderMouseDownListener","stopPropagation","_gestureDisposable","addTarget","_sliderTouchStartListener","addDisposableListener","Start","toggleClassName","scrollDueToTouchEvent","passive","_sliderTouchMoveListener","Change","_sliderTouchEndListener","End","initialButtons","initialPosX","initialSliderState","handleMouseMove","mouseOrthogonalDelta","abs","isWindows","mouseDelta","startMonitoring","mouseMoveData","touch","startY","getBoundingClientRect","setWidth","setHeight","width","_getBuffer","getContext","renderingCtx","setDisplay","setTop","scrollLeftChars","horizontalSliderLeft","renderDecorations","renderLines","characterWidth","tabSize","canvasContext","clearRect","lineOffsetMap","Map","line","renderDecorationOnLine","decorationColor","Inline","Gutter","y","x","renderDecoration","decorationRange","charWidth","lineIndexToXOffset","isFirstDecorationForLine","lineData","charCode","charCodeAt","dx","isFullWidthCharacter","endColumnForLine","renderLineHighlight","fillStyle","transparent","toString","fillRect","canvas","_lastData","_dirtyY1","_dirtyY2","_renderUntouchedLines","lineInfo","useLighterFont","backgroundIsLight","baseCharHeight","renderMinimapLineHeight","innerLinePadding","renderedLines","_renderLine","dirtyY1","dirtyY2","dirtyHeight","putImageData","target","lastRenderData","lastTargetData","lastStartLineNumber","lastLines","lastLinesLength","targetData","maxDestPixel","dirtyPixel1","dirtyPixel2","copySourceStart","copySourceEnd","copyDestStart","copyDestEnd","dest_dy","lastLineIndex","source_dy","sourceStart","sourceEnd","destStart","destEnd","subarray","colorTracker","minimapCharRenderer","content","tokens","maxDx","force1pxHeight","charIndex","tabsCharDelta","tokenIndex","tokensLen","getCount","tokenEndIndex","getEndOffset","tokenColorId","getForeground","tokenColor","insertSpacesCount","count","blockRenderChar","renderChar","collector","minimapBackgroundValue","addRule","concat","sliderBackground","sliderHoverBackground","sliderActiveBackground","shadow"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimap.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport './minimap.css';\r\nimport * as dom from '../../../../base/browser/dom.js';\r\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\r\nimport { GlobalMouseMoveMonitor, standardMouseMoveMerger } from '../../../../base/browser/globalMouseMoveMonitor.js';\r\nimport { Disposable } from '../../../../base/common/lifecycle.js';\r\nimport * as platform from '../../../../base/common/platform.js';\r\nimport * as strings from '../../../../base/common/strings.js';\r\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\r\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\r\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\r\nimport { Range } from '../../../common/core/range.js';\r\nimport { RGBA8 } from '../../../common/core/rgba.js';\r\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\r\nimport { ViewModelDecoration } from '../../../common/viewModel/viewModel.js';\r\nimport { minimapSelection, scrollbarShadow, minimapBackground, minimapSliderBackground, minimapSliderHoverBackground, minimapSliderActiveBackground } from '../../../../platform/theme/common/colorRegistry.js';\r\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\r\nimport { Selection } from '../../../common/core/selection.js';\r\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\r\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\r\nimport { MinimapPosition } from '../../../common/model.js';\r\nimport { once } from '../../../../base/common/functional.js';\r\n/**\r\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\r\n */\r\nconst MOUSE_DRAG_RESET_DISTANCE = 140;\r\nconst GUTTER_DECORATION_WIDTH = 2;\r\nclass MinimapOptions {\r\n    constructor(configuration, theme, tokensColorTracker) {\r\n        const options = configuration.options;\r\n        const pixelRatio = options.get(122 /* pixelRatio */);\r\n        const layoutInfo = options.get(124 /* layoutInfo */);\r\n        const minimapLayout = layoutInfo.minimap;\r\n        const fontInfo = options.get(38 /* fontInfo */);\r\n        const minimapOpts = options.get(59 /* minimap */);\r\n        this.renderMinimap = minimapLayout.renderMinimap;\r\n        this.size = minimapOpts.size;\r\n        this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\r\n        this.scrollBeyondLastLine = options.get(89 /* scrollBeyondLastLine */);\r\n        this.showSlider = minimapOpts.showSlider;\r\n        this.pixelRatio = pixelRatio;\r\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\r\n        this.lineHeight = options.get(53 /* lineHeight */);\r\n        this.minimapLeft = minimapLayout.minimapLeft;\r\n        this.minimapWidth = minimapLayout.minimapWidth;\r\n        this.minimapHeight = layoutInfo.height;\r\n        this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\r\n        this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\r\n        this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\r\n        this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\r\n        this.isSampling = minimapLayout.minimapIsSampling;\r\n        this.editorHeight = layoutInfo.height;\r\n        this.fontScale = minimapLayout.minimapScale;\r\n        this.minimapLineHeight = minimapLayout.minimapLineHeight;\r\n        this.minimapCharWidth = 1 /* BASE_CHAR_WIDTH */ * this.fontScale;\r\n        this.charRenderer = once(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\r\n        this.backgroundColor = MinimapOptions._getMinimapBackground(theme, tokensColorTracker);\r\n    }\r\n    static _getMinimapBackground(theme, tokensColorTracker) {\r\n        const themeColor = theme.getColor(minimapBackground);\r\n        if (themeColor) {\r\n            return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, themeColor.rgba.a);\r\n        }\r\n        return tokensColorTracker.getColor(2 /* DefaultBackground */);\r\n    }\r\n    equals(other) {\r\n        return (this.renderMinimap === other.renderMinimap\r\n            && this.size === other.size\r\n            && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight\r\n            && this.scrollBeyondLastLine === other.scrollBeyondLastLine\r\n            && this.showSlider === other.showSlider\r\n            && this.pixelRatio === other.pixelRatio\r\n            && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth\r\n            && this.lineHeight === other.lineHeight\r\n            && this.minimapLeft === other.minimapLeft\r\n            && this.minimapWidth === other.minimapWidth\r\n            && this.minimapHeight === other.minimapHeight\r\n            && this.canvasInnerWidth === other.canvasInnerWidth\r\n            && this.canvasInnerHeight === other.canvasInnerHeight\r\n            && this.canvasOuterWidth === other.canvasOuterWidth\r\n            && this.canvasOuterHeight === other.canvasOuterHeight\r\n            && this.isSampling === other.isSampling\r\n            && this.editorHeight === other.editorHeight\r\n            && this.fontScale === other.fontScale\r\n            && this.minimapLineHeight === other.minimapLineHeight\r\n            && this.minimapCharWidth === other.minimapCharWidth\r\n            && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor));\r\n    }\r\n}\r\nclass MinimapLayout {\r\n    constructor(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber) {\r\n        this.scrollTop = scrollTop;\r\n        this.scrollHeight = scrollHeight;\r\n        this.sliderNeeded = sliderNeeded;\r\n        this._computedSliderRatio = computedSliderRatio;\r\n        this.sliderTop = sliderTop;\r\n        this.sliderHeight = sliderHeight;\r\n        this.startLineNumber = startLineNumber;\r\n        this.endLineNumber = endLineNumber;\r\n    }\r\n    /**\r\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\r\n     */\r\n    getDesiredScrollTopFromDelta(delta) {\r\n        return Math.round(this.scrollTop + delta / this._computedSliderRatio);\r\n    }\r\n    getDesiredScrollTopFromTouchLocation(pageY) {\r\n        return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\r\n    }\r\n    static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\r\n        const pixelRatio = options.pixelRatio;\r\n        const minimapLineHeight = options.minimapLineHeight;\r\n        const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\r\n        const lineHeight = options.lineHeight;\r\n        if (options.minimapHeightIsEditorHeight) {\r\n            const logicalScrollHeight = (realLineCount * options.lineHeight\r\n                + (options.scrollBeyondLastLine ? viewportHeight - options.lineHeight : 0));\r\n            const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\r\n            const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\r\n            // The slider can move from 0 to `maxMinimapSliderTop`\r\n            // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\r\n            const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\r\n            const sliderTop = (scrollTop * computedSliderRatio);\r\n            const sliderNeeded = (maxMinimapSliderTop > 0);\r\n            const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\r\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, 1, Math.min(lineCount, maxLinesFitting));\r\n        }\r\n        // The visible line count in a viewport can change due to a number of reasons:\r\n        //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\r\n        //    e.g. for a line height of 20, and a viewport height of 600\r\n        //          * scrollTop = 0  => visible lines are [1, 30]\r\n        //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\r\n        //          * scrollTop = 20 => visible lines are [2, 31]\r\n        //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\r\n        //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\r\n        // We must first establish a desirable slider height.\r\n        let sliderHeight;\r\n        if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\r\n            // case b) from above: there are whitespace gaps in the viewport.\r\n            // In this case, the height of the slider directly reflects the visible line count.\r\n            const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\r\n            sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\r\n        }\r\n        else {\r\n            // The slider has a stable height\r\n            const expectedViewportLineCount = viewportHeight / lineHeight;\r\n            sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\r\n        }\r\n        let maxMinimapSliderTop;\r\n        if (options.scrollBeyondLastLine) {\r\n            // The minimap slider, when dragged all the way down, will contain the last line at its top\r\n            maxMinimapSliderTop = (lineCount - 1) * minimapLineHeight / pixelRatio;\r\n        }\r\n        else {\r\n            // The minimap slider, when dragged all the way down, will contain the last line at its bottom\r\n            maxMinimapSliderTop = Math.max(0, lineCount * minimapLineHeight / pixelRatio - sliderHeight);\r\n        }\r\n        maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\r\n        // The slider can move from 0 to `maxMinimapSliderTop`\r\n        // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\r\n        const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\r\n        const sliderTop = (scrollTop * computedSliderRatio);\r\n        let extraLinesAtTheBottom = 0;\r\n        if (options.scrollBeyondLastLine) {\r\n            const expectedViewportLineCount = viewportHeight / lineHeight;\r\n            extraLinesAtTheBottom = expectedViewportLineCount - 1;\r\n        }\r\n        if (minimapLinesFitting >= lineCount + extraLinesAtTheBottom) {\r\n            // All lines fit in the minimap\r\n            const startLineNumber = 1;\r\n            const endLineNumber = lineCount;\r\n            const sliderNeeded = (maxMinimapSliderTop > 0);\r\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);\r\n        }\r\n        else {\r\n            let startLineNumber = Math.max(1, Math.floor(viewportStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\r\n            // Avoid flickering caused by a partial viewport start line\r\n            // by being consistent w.r.t. the previous layout decision\r\n            if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\r\n                if (previousLayout.scrollTop > scrollTop) {\r\n                    // Scrolling up => never increase `startLineNumber`\r\n                    startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\r\n                }\r\n                if (previousLayout.scrollTop < scrollTop) {\r\n                    // Scrolling down => never decrease `startLineNumber`\r\n                    startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\r\n                }\r\n            }\r\n            const endLineNumber = Math.min(lineCount, startLineNumber + minimapLinesFitting - 1);\r\n            const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\r\n            const sliderTopAligned = (viewportStartLineNumber - startLineNumber + partialLine) * minimapLineHeight / pixelRatio;\r\n            return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, startLineNumber, endLineNumber);\r\n        }\r\n    }\r\n}\r\nclass MinimapLine {\r\n    constructor(dy) {\r\n        this.dy = dy;\r\n    }\r\n    onContentChanged() {\r\n        this.dy = -1;\r\n    }\r\n    onTokensChanged() {\r\n        this.dy = -1;\r\n    }\r\n}\r\nMinimapLine.INVALID = new MinimapLine(-1);\r\nclass RenderData {\r\n    constructor(renderedLayout, imageData, lines) {\r\n        this.renderedLayout = renderedLayout;\r\n        this._imageData = imageData;\r\n        this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\r\n        this._renderedLines._set(renderedLayout.startLineNumber, lines);\r\n    }\r\n    /**\r\n     * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\r\n     */\r\n    linesEquals(layout) {\r\n        if (!this.scrollEquals(layout)) {\r\n            return false;\r\n        }\r\n        const tmp = this._renderedLines._get();\r\n        const lines = tmp.lines;\r\n        for (let i = 0, len = lines.length; i < len; i++) {\r\n            if (lines[i].dy === -1) {\r\n                // This line is invalid\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Check if the current RenderData matches the new layout's scroll position\r\n     */\r\n    scrollEquals(layout) {\r\n        return this.renderedLayout.startLineNumber === layout.startLineNumber\r\n            && this.renderedLayout.endLineNumber === layout.endLineNumber;\r\n    }\r\n    _get() {\r\n        const tmp = this._renderedLines._get();\r\n        return {\r\n            imageData: this._imageData,\r\n            rendLineNumberStart: tmp.rendLineNumberStart,\r\n            lines: tmp.lines\r\n        };\r\n    }\r\n    onLinesChanged(changeFromLineNumber, changeToLineNumber) {\r\n        return this._renderedLines.onLinesChanged(changeFromLineNumber, changeToLineNumber);\r\n    }\r\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\r\n        this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\r\n    }\r\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\r\n        this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\r\n    }\r\n    onTokensChanged(ranges) {\r\n        return this._renderedLines.onTokensChanged(ranges);\r\n    }\r\n}\r\n/**\r\n * Some sort of double buffering.\r\n *\r\n * Keeps two buffers around that will be rotated for painting.\r\n * Always gives a buffer that is filled with the background color.\r\n */\r\nclass MinimapBuffers {\r\n    constructor(ctx, WIDTH, HEIGHT, background) {\r\n        this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\r\n        this._buffers = [\r\n            ctx.createImageData(WIDTH, HEIGHT),\r\n            ctx.createImageData(WIDTH, HEIGHT)\r\n        ];\r\n        this._lastUsedBuffer = 0;\r\n    }\r\n    getBuffer() {\r\n        // rotate buffers\r\n        this._lastUsedBuffer = 1 - this._lastUsedBuffer;\r\n        const result = this._buffers[this._lastUsedBuffer];\r\n        // fill with background color\r\n        result.data.set(this._backgroundFillData);\r\n        return result;\r\n    }\r\n    static _createBackgroundFillData(WIDTH, HEIGHT, background) {\r\n        const backgroundR = background.r;\r\n        const backgroundG = background.g;\r\n        const backgroundB = background.b;\r\n        const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\r\n        let offset = 0;\r\n        for (let i = 0; i < HEIGHT; i++) {\r\n            for (let j = 0; j < WIDTH; j++) {\r\n                result[offset] = backgroundR;\r\n                result[offset + 1] = backgroundG;\r\n                result[offset + 2] = backgroundB;\r\n                result[offset + 3] = 255;\r\n                offset += 4;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nclass MinimapSamplingState {\r\n    constructor(samplingRatio, minimapLines) {\r\n        this.samplingRatio = samplingRatio;\r\n        this.minimapLines = minimapLines;\r\n    }\r\n    static compute(options, viewLineCount, oldSamplingState) {\r\n        if (options.renderMinimap === 0 /* None */ || !options.isSampling) {\r\n            return [null, []];\r\n        }\r\n        // ratio is intentionally not part of the layout to avoid the layout changing all the time\r\n        // so we need to recompute it again...\r\n        const pixelRatio = options.pixelRatio;\r\n        const lineHeight = options.lineHeight;\r\n        const scrollBeyondLastLine = options.scrollBeyondLastLine;\r\n        const { minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\r\n            viewLineCount: viewLineCount,\r\n            scrollBeyondLastLine: scrollBeyondLastLine,\r\n            height: options.editorHeight,\r\n            lineHeight: lineHeight,\r\n            pixelRatio: pixelRatio\r\n        });\r\n        const ratio = viewLineCount / minimapLineCount;\r\n        const halfRatio = ratio / 2;\r\n        if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\r\n            let result = [];\r\n            result[0] = 1;\r\n            if (minimapLineCount > 1) {\r\n                for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\r\n                    result[i] = Math.round(i * ratio + halfRatio);\r\n                }\r\n                result[minimapLineCount - 1] = viewLineCount;\r\n            }\r\n            return [new MinimapSamplingState(ratio, result), []];\r\n        }\r\n        const oldMinimapLines = oldSamplingState.minimapLines;\r\n        const oldLength = oldMinimapLines.length;\r\n        let result = [];\r\n        let oldIndex = 0;\r\n        let oldDeltaLineCount = 0;\r\n        let minViewLineNumber = 1;\r\n        const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\r\n        let events = [];\r\n        let lastEvent = null;\r\n        for (let i = 0; i < minimapLineCount; i++) {\r\n            const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\r\n            const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\r\n            while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\r\n                if (events.length < MAX_EVENT_COUNT) {\r\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\r\n                    if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\r\n                        lastEvent.deleteToLineNumber++;\r\n                    }\r\n                    else {\r\n                        lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\r\n                        events.push(lastEvent);\r\n                    }\r\n                    oldDeltaLineCount--;\r\n                }\r\n                oldIndex++;\r\n            }\r\n            let selectedViewLineNumber;\r\n            if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\r\n                // reuse the old sampled line\r\n                selectedViewLineNumber = oldMinimapLines[oldIndex];\r\n                oldIndex++;\r\n            }\r\n            else {\r\n                if (i === 0) {\r\n                    selectedViewLineNumber = 1;\r\n                }\r\n                else if (i + 1 === minimapLineCount) {\r\n                    selectedViewLineNumber = viewLineCount;\r\n                }\r\n                else {\r\n                    selectedViewLineNumber = Math.round(i * ratio + halfRatio);\r\n                }\r\n                if (events.length < MAX_EVENT_COUNT) {\r\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\r\n                    if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\r\n                        lastEvent.insertToLineNumber++;\r\n                    }\r\n                    else {\r\n                        lastEvent = { type: 'inserted', _i: i, insertFromLineNumber: oldMinimapLineNumber, insertToLineNumber: oldMinimapLineNumber };\r\n                        events.push(lastEvent);\r\n                    }\r\n                    oldDeltaLineCount++;\r\n                }\r\n            }\r\n            result[i] = selectedViewLineNumber;\r\n            minViewLineNumber = selectedViewLineNumber;\r\n        }\r\n        if (events.length < MAX_EVENT_COUNT) {\r\n            while (oldIndex < oldLength) {\r\n                const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\r\n                if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\r\n                    lastEvent.deleteToLineNumber++;\r\n                }\r\n                else {\r\n                    lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\r\n                    events.push(lastEvent);\r\n                }\r\n                oldDeltaLineCount--;\r\n                oldIndex++;\r\n            }\r\n        }\r\n        else {\r\n            // too many events, just give up\r\n            events = [{ type: 'flush' }];\r\n        }\r\n        return [new MinimapSamplingState(ratio, result), events];\r\n    }\r\n    modelLineToMinimapLine(lineNumber) {\r\n        return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\r\n    }\r\n    /**\r\n     * Will return null if the model line ranges are not intersecting with a sampled model line.\r\n     */\r\n    modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\r\n        let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\r\n        while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\r\n            fromLineIndex--;\r\n        }\r\n        let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\r\n        while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\r\n            toLineIndex++;\r\n        }\r\n        if (fromLineIndex === toLineIndex) {\r\n            const sampledLineNumber = this.minimapLines[fromLineIndex];\r\n            if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\r\n                // This line is not part of the sampled lines ==> nothing to do\r\n                return null;\r\n            }\r\n        }\r\n        return [fromLineIndex + 1, toLineIndex + 1];\r\n    }\r\n    /**\r\n     * Will always return a range, even if it is not intersecting with a sampled model line.\r\n     */\r\n    decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\r\n        let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\r\n        let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\r\n        if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\r\n            if (minimapLineEnd === this.minimapLines.length) {\r\n                if (minimapLineStart > 1) {\r\n                    minimapLineStart--;\r\n                }\r\n            }\r\n            else {\r\n                minimapLineEnd++;\r\n            }\r\n        }\r\n        return [minimapLineStart, minimapLineEnd];\r\n    }\r\n    onLinesDeleted(e) {\r\n        // have the mapping be sticky\r\n        const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\r\n        let changeStartIndex = this.minimapLines.length;\r\n        let changeEndIndex = 0;\r\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\r\n            if (this.minimapLines[i] < e.fromLineNumber) {\r\n                break;\r\n            }\r\n            if (this.minimapLines[i] <= e.toLineNumber) {\r\n                // this line got deleted => move to previous available\r\n                this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\r\n                changeStartIndex = Math.min(changeStartIndex, i);\r\n                changeEndIndex = Math.max(changeEndIndex, i);\r\n            }\r\n            else {\r\n                this.minimapLines[i] -= deletedLineCount;\r\n            }\r\n        }\r\n        return [changeStartIndex, changeEndIndex];\r\n    }\r\n    onLinesInserted(e) {\r\n        // have the mapping be sticky\r\n        const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\r\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\r\n            if (this.minimapLines[i] < e.fromLineNumber) {\r\n                break;\r\n            }\r\n            this.minimapLines[i] += insertedLineCount;\r\n        }\r\n    }\r\n}\r\nexport class Minimap extends ViewPart {\r\n    constructor(context) {\r\n        super(context);\r\n        this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\r\n        this._selections = [];\r\n        this._minimapSelections = null;\r\n        this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\r\n        const [samplingState,] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), null);\r\n        this._samplingState = samplingState;\r\n        this._shouldCheckSampling = false;\r\n        this._actual = new InnerMinimap(context.theme, this);\r\n    }\r\n    dispose() {\r\n        this._actual.dispose();\r\n        super.dispose();\r\n    }\r\n    getDomNode() {\r\n        return this._actual.getDomNode();\r\n    }\r\n    _onOptionsMaybeChanged() {\r\n        const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\r\n        if (this.options.equals(opts)) {\r\n            return false;\r\n        }\r\n        this.options = opts;\r\n        this._recreateLineSampling();\r\n        this._actual.onDidChangeOptions();\r\n        return true;\r\n    }\r\n    // ---- begin view event handlers\r\n    onConfigurationChanged(e) {\r\n        return this._onOptionsMaybeChanged();\r\n    }\r\n    onCursorStateChanged(e) {\r\n        this._selections = e.selections;\r\n        this._minimapSelections = null;\r\n        return this._actual.onSelectionChanged();\r\n    }\r\n    onDecorationsChanged(e) {\r\n        if (e.affectsMinimap) {\r\n            return this._actual.onDecorationsChanged();\r\n        }\r\n        return false;\r\n    }\r\n    onFlushed(e) {\r\n        if (this._samplingState) {\r\n            this._shouldCheckSampling = true;\r\n        }\r\n        return this._actual.onFlushed();\r\n    }\r\n    onLinesChanged(e) {\r\n        if (this._samplingState) {\r\n            const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.toLineNumber);\r\n            if (minimapLineRange) {\r\n                return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1]);\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return this._actual.onLinesChanged(e.fromLineNumber, e.toLineNumber);\r\n        }\r\n    }\r\n    onLinesDeleted(e) {\r\n        if (this._samplingState) {\r\n            const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\r\n            if (changeStartIndex <= changeEndIndex) {\r\n                this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex + 1);\r\n            }\r\n            this._shouldCheckSampling = true;\r\n            return true;\r\n        }\r\n        else {\r\n            return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\r\n        }\r\n    }\r\n    onLinesInserted(e) {\r\n        if (this._samplingState) {\r\n            this._samplingState.onLinesInserted(e);\r\n            this._shouldCheckSampling = true;\r\n            return true;\r\n        }\r\n        else {\r\n            return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\r\n        }\r\n    }\r\n    onScrollChanged(e) {\r\n        return this._actual.onScrollChanged();\r\n    }\r\n    onThemeChanged(e) {\r\n        this._context.model.invalidateMinimapColorCache();\r\n        this._actual.onThemeChanged();\r\n        this._onOptionsMaybeChanged();\r\n        return true;\r\n    }\r\n    onTokensChanged(e) {\r\n        if (this._samplingState) {\r\n            let ranges = [];\r\n            for (const range of e.ranges) {\r\n                const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\r\n                if (minimapLineRange) {\r\n                    ranges.push({ fromLineNumber: minimapLineRange[0], toLineNumber: minimapLineRange[1] });\r\n                }\r\n            }\r\n            if (ranges.length) {\r\n                return this._actual.onTokensChanged(ranges);\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return this._actual.onTokensChanged(e.ranges);\r\n        }\r\n    }\r\n    onTokensColorsChanged(e) {\r\n        this._onOptionsMaybeChanged();\r\n        return this._actual.onTokensColorsChanged();\r\n    }\r\n    onZonesChanged(e) {\r\n        return this._actual.onZonesChanged();\r\n    }\r\n    // --- end event handlers\r\n    prepareRender(ctx) {\r\n        if (this._shouldCheckSampling) {\r\n            this._shouldCheckSampling = false;\r\n            this._recreateLineSampling();\r\n        }\r\n    }\r\n    render(ctx) {\r\n        let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\r\n        let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\r\n        if (this._samplingState) {\r\n            viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\r\n            viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\r\n        }\r\n        const minimapCtx = {\r\n            viewportContainsWhitespaceGaps: (ctx.viewportData.whitespaceViewportData.length > 0),\r\n            scrollWidth: ctx.scrollWidth,\r\n            scrollHeight: ctx.scrollHeight,\r\n            viewportStartLineNumber: viewportStartLineNumber,\r\n            viewportEndLineNumber: viewportEndLineNumber,\r\n            viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\r\n            scrollTop: ctx.scrollTop,\r\n            scrollLeft: ctx.scrollLeft,\r\n            viewportWidth: ctx.viewportWidth,\r\n            viewportHeight: ctx.viewportHeight,\r\n        };\r\n        this._actual.render(minimapCtx);\r\n    }\r\n    //#region IMinimapModel\r\n    _recreateLineSampling() {\r\n        this._minimapSelections = null;\r\n        const wasSampling = Boolean(this._samplingState);\r\n        const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), this._samplingState);\r\n        this._samplingState = samplingState;\r\n        if (wasSampling && this._samplingState) {\r\n            // was sampling, is sampling\r\n            for (const event of events) {\r\n                switch (event.type) {\r\n                    case 'deleted':\r\n                        this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\r\n                        break;\r\n                    case 'inserted':\r\n                        this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\r\n                        break;\r\n                    case 'flush':\r\n                        this._actual.onFlushed();\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    getLineCount() {\r\n        if (this._samplingState) {\r\n            return this._samplingState.minimapLines.length;\r\n        }\r\n        return this._context.model.getLineCount();\r\n    }\r\n    getRealLineCount() {\r\n        return this._context.model.getLineCount();\r\n    }\r\n    getLineContent(lineNumber) {\r\n        if (this._samplingState) {\r\n            return this._context.model.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\r\n        }\r\n        return this._context.model.getLineContent(lineNumber);\r\n    }\r\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\r\n        if (this._samplingState) {\r\n            let result = [];\r\n            for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\r\n                if (needed[lineIndex]) {\r\n                    result[lineIndex] = this._context.model.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\r\n                }\r\n                else {\r\n                    result[lineIndex] = null;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n        return this._context.model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\r\n    }\r\n    getSelections() {\r\n        if (this._minimapSelections === null) {\r\n            if (this._samplingState) {\r\n                this._minimapSelections = [];\r\n                for (const selection of this._selections) {\r\n                    const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\r\n                    this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\r\n                }\r\n            }\r\n            else {\r\n                this._minimapSelections = this._selections;\r\n            }\r\n        }\r\n        return this._minimapSelections;\r\n    }\r\n    getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\r\n        let visibleRange;\r\n        if (this._samplingState) {\r\n            const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\r\n            const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\r\n            visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.model.getLineMaxColumn(modelEndLineNumber));\r\n        }\r\n        else {\r\n            visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.model.getLineMaxColumn(endLineNumber));\r\n        }\r\n        const decorations = this._context.model.getDecorationsInViewport(visibleRange);\r\n        if (this._samplingState) {\r\n            let result = [];\r\n            for (const decoration of decorations) {\r\n                if (!decoration.options.minimap) {\r\n                    continue;\r\n                }\r\n                const range = decoration.range;\r\n                const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\r\n                const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\r\n                result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\r\n            }\r\n            return result;\r\n        }\r\n        return decorations;\r\n    }\r\n    getOptions() {\r\n        return this._context.model.getTextModelOptions();\r\n    }\r\n    revealLineNumber(lineNumber) {\r\n        if (this._samplingState) {\r\n            lineNumber = this._samplingState.minimapLines[lineNumber - 1];\r\n        }\r\n        this._context.model.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* Center */, 0 /* Smooth */);\r\n    }\r\n    setScrollTop(scrollTop) {\r\n        this._context.model.setScrollPosition({\r\n            scrollTop: scrollTop\r\n        }, 1 /* Immediate */);\r\n    }\r\n}\r\nclass InnerMinimap extends Disposable {\r\n    constructor(theme, model) {\r\n        super();\r\n        this._renderDecorations = false;\r\n        this._gestureInProgress = false;\r\n        this._theme = theme;\r\n        this._model = model;\r\n        this._lastRenderData = null;\r\n        this._buffers = null;\r\n        this._selectionColor = this._theme.getColor(minimapSelection);\r\n        this._domNode = createFastDomNode(document.createElement('div'));\r\n        PartFingerprints.write(this._domNode, 8 /* Minimap */);\r\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\r\n        this._domNode.setPosition('absolute');\r\n        this._domNode.setAttribute('role', 'presentation');\r\n        this._domNode.setAttribute('aria-hidden', 'true');\r\n        this._shadow = createFastDomNode(document.createElement('div'));\r\n        this._shadow.setClassName('minimap-shadow-hidden');\r\n        this._domNode.appendChild(this._shadow);\r\n        this._canvas = createFastDomNode(document.createElement('canvas'));\r\n        this._canvas.setPosition('absolute');\r\n        this._canvas.setLeft(0);\r\n        this._domNode.appendChild(this._canvas);\r\n        this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\r\n        this._decorationsCanvas.setPosition('absolute');\r\n        this._decorationsCanvas.setClassName('minimap-decorations-layer');\r\n        this._decorationsCanvas.setLeft(0);\r\n        this._domNode.appendChild(this._decorationsCanvas);\r\n        this._slider = createFastDomNode(document.createElement('div'));\r\n        this._slider.setPosition('absolute');\r\n        this._slider.setClassName('minimap-slider');\r\n        this._slider.setLayerHinting(true);\r\n        this._slider.setContain('strict');\r\n        this._domNode.appendChild(this._slider);\r\n        this._sliderHorizontal = createFastDomNode(document.createElement('div'));\r\n        this._sliderHorizontal.setPosition('absolute');\r\n        this._sliderHorizontal.setClassName('minimap-slider-horizontal');\r\n        this._slider.appendChild(this._sliderHorizontal);\r\n        this._applyLayout();\r\n        this._mouseDownListener = dom.addStandardDisposableListener(this._domNode.domNode, 'mousedown', (e) => {\r\n            e.preventDefault();\r\n            const renderMinimap = this._model.options.renderMinimap;\r\n            if (renderMinimap === 0 /* None */) {\r\n                return;\r\n            }\r\n            if (!this._lastRenderData) {\r\n                return;\r\n            }\r\n            if (this._model.options.size !== 'proportional') {\r\n                if (e.leftButton && this._lastRenderData) {\r\n                    // pretend the click occured in the center of the slider\r\n                    const position = dom.getDomNodePagePosition(this._slider.domNode);\r\n                    const initialPosY = position.top + position.height / 2;\r\n                    this._startSliderDragging(e.buttons, e.posx, initialPosY, e.posy, this._lastRenderData.renderedLayout);\r\n                }\r\n                return;\r\n            }\r\n            const minimapLineHeight = this._model.options.minimapLineHeight;\r\n            const internalOffsetY = (this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight) * e.browserEvent.offsetY;\r\n            const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\r\n            let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber;\r\n            lineNumber = Math.min(lineNumber, this._model.getLineCount());\r\n            this._model.revealLineNumber(lineNumber);\r\n        });\r\n        this._sliderMouseMoveMonitor = new GlobalMouseMoveMonitor();\r\n        this._sliderMouseDownListener = dom.addStandardDisposableListener(this._slider.domNode, 'mousedown', (e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            if (e.leftButton && this._lastRenderData) {\r\n                this._startSliderDragging(e.buttons, e.posx, e.posy, e.posy, this._lastRenderData.renderedLayout);\r\n            }\r\n        });\r\n        this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\r\n        this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, (e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            if (this._lastRenderData) {\r\n                this._slider.toggleClassName('active', true);\r\n                this._gestureInProgress = true;\r\n                this.scrollDueToTouchEvent(e);\r\n            }\r\n        }, { passive: false });\r\n        this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, (e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            if (this._lastRenderData && this._gestureInProgress) {\r\n                this.scrollDueToTouchEvent(e);\r\n            }\r\n        }, { passive: false });\r\n        this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, (e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            this._gestureInProgress = false;\r\n            this._slider.toggleClassName('active', false);\r\n        });\r\n    }\r\n    _startSliderDragging(initialButtons, initialPosX, initialPosY, posy, initialSliderState) {\r\n        this._slider.toggleClassName('active', true);\r\n        const handleMouseMove = (posy, posx) => {\r\n            const mouseOrthogonalDelta = Math.abs(posx - initialPosX);\r\n            if (platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {\r\n                // The mouse has wondered away from the scrollbar => reset dragging\r\n                this._model.setScrollTop(initialSliderState.scrollTop);\r\n                return;\r\n            }\r\n            const mouseDelta = posy - initialPosY;\r\n            this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(mouseDelta));\r\n        };\r\n        if (posy !== initialPosY) {\r\n            handleMouseMove(posy, initialPosX);\r\n        }\r\n        this._sliderMouseMoveMonitor.startMonitoring(this._slider.domNode, initialButtons, standardMouseMoveMerger, (mouseMoveData) => handleMouseMove(mouseMoveData.posy, mouseMoveData.posx), () => {\r\n            this._slider.toggleClassName('active', false);\r\n        });\r\n    }\r\n    scrollDueToTouchEvent(touch) {\r\n        const startY = this._domNode.domNode.getBoundingClientRect().top;\r\n        const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\r\n        this._model.setScrollTop(scrollTop);\r\n    }\r\n    dispose() {\r\n        this._mouseDownListener.dispose();\r\n        this._sliderMouseMoveMonitor.dispose();\r\n        this._sliderMouseDownListener.dispose();\r\n        this._gestureDisposable.dispose();\r\n        this._sliderTouchStartListener.dispose();\r\n        this._sliderTouchMoveListener.dispose();\r\n        this._sliderTouchEndListener.dispose();\r\n        super.dispose();\r\n    }\r\n    _getMinimapDomNodeClassName() {\r\n        if (this._model.options.showSlider === 'always') {\r\n            return 'minimap slider-always';\r\n        }\r\n        return 'minimap slider-mouseover';\r\n    }\r\n    getDomNode() {\r\n        return this._domNode;\r\n    }\r\n    _applyLayout() {\r\n        this._domNode.setLeft(this._model.options.minimapLeft);\r\n        this._domNode.setWidth(this._model.options.minimapWidth);\r\n        this._domNode.setHeight(this._model.options.minimapHeight);\r\n        this._shadow.setHeight(this._model.options.minimapHeight);\r\n        this._canvas.setWidth(this._model.options.canvasOuterWidth);\r\n        this._canvas.setHeight(this._model.options.canvasOuterHeight);\r\n        this._canvas.domNode.width = this._model.options.canvasInnerWidth;\r\n        this._canvas.domNode.height = this._model.options.canvasInnerHeight;\r\n        this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\r\n        this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\r\n        this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\r\n        this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\r\n        this._slider.setWidth(this._model.options.minimapWidth);\r\n    }\r\n    _getBuffer() {\r\n        if (!this._buffers) {\r\n            if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\r\n                this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\r\n            }\r\n        }\r\n        return this._buffers ? this._buffers.getBuffer() : null;\r\n    }\r\n    // ---- begin view event handlers\r\n    onDidChangeOptions() {\r\n        this._lastRenderData = null;\r\n        this._buffers = null;\r\n        this._applyLayout();\r\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\r\n    }\r\n    onSelectionChanged() {\r\n        this._renderDecorations = true;\r\n        return true;\r\n    }\r\n    onDecorationsChanged() {\r\n        this._renderDecorations = true;\r\n        return true;\r\n    }\r\n    onFlushed() {\r\n        this._lastRenderData = null;\r\n        return true;\r\n    }\r\n    onLinesChanged(changeFromLineNumber, changeToLineNumber) {\r\n        if (this._lastRenderData) {\r\n            return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeToLineNumber);\r\n        }\r\n        return false;\r\n    }\r\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\r\n        if (this._lastRenderData) {\r\n            this._lastRenderData.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\r\n        }\r\n        return true;\r\n    }\r\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\r\n        if (this._lastRenderData) {\r\n            this._lastRenderData.onLinesInserted(insertFromLineNumber, insertToLineNumber);\r\n        }\r\n        return true;\r\n    }\r\n    onScrollChanged() {\r\n        this._renderDecorations = true;\r\n        return true;\r\n    }\r\n    onThemeChanged() {\r\n        this._selectionColor = this._theme.getColor(minimapSelection);\r\n        this._renderDecorations = true;\r\n        return true;\r\n    }\r\n    onTokensChanged(ranges) {\r\n        if (this._lastRenderData) {\r\n            return this._lastRenderData.onTokensChanged(ranges);\r\n        }\r\n        return false;\r\n    }\r\n    onTokensColorsChanged() {\r\n        this._lastRenderData = null;\r\n        this._buffers = null;\r\n        return true;\r\n    }\r\n    onZonesChanged() {\r\n        this._lastRenderData = null;\r\n        return true;\r\n    }\r\n    // --- end event handlers\r\n    render(renderingCtx) {\r\n        const renderMinimap = this._model.options.renderMinimap;\r\n        if (renderMinimap === 0 /* None */) {\r\n            this._shadow.setClassName('minimap-shadow-hidden');\r\n            this._sliderHorizontal.setWidth(0);\r\n            this._sliderHorizontal.setHeight(0);\r\n            return;\r\n        }\r\n        if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\r\n            this._shadow.setClassName('minimap-shadow-hidden');\r\n        }\r\n        else {\r\n            this._shadow.setClassName('minimap-shadow-visible');\r\n        }\r\n        const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\r\n        this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\r\n        this._slider.setTop(layout.sliderTop);\r\n        this._slider.setHeight(layout.sliderHeight);\r\n        // Compute horizontal slider coordinates\r\n        const scrollLeftChars = renderingCtx.scrollLeft / this._model.options.typicalHalfwidthCharacterWidth;\r\n        const horizontalSliderLeft = Math.min(this._model.options.minimapWidth, Math.round(scrollLeftChars * this._model.options.minimapCharWidth / this._model.options.pixelRatio));\r\n        this._sliderHorizontal.setLeft(horizontalSliderLeft);\r\n        this._sliderHorizontal.setWidth(this._model.options.minimapWidth - horizontalSliderLeft);\r\n        this._sliderHorizontal.setTop(0);\r\n        this._sliderHorizontal.setHeight(layout.sliderHeight);\r\n        this.renderDecorations(layout);\r\n        this._lastRenderData = this.renderLines(layout);\r\n    }\r\n    renderDecorations(layout) {\r\n        if (this._renderDecorations) {\r\n            this._renderDecorations = false;\r\n            const selections = this._model.getSelections();\r\n            const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\r\n            const { canvasInnerWidth, canvasInnerHeight } = this._model.options;\r\n            const lineHeight = this._model.options.minimapLineHeight;\r\n            const characterWidth = this._model.options.minimapCharWidth;\r\n            const tabSize = this._model.getOptions().tabSize;\r\n            const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\r\n            canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\r\n            const lineOffsetMap = new Map();\r\n            for (let i = 0; i < selections.length; i++) {\r\n                const selection = selections[i];\r\n                for (let line = selection.startLineNumber; line <= selection.endLineNumber; line++) {\r\n                    this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth);\r\n                }\r\n            }\r\n            // Loop over decorations, ignoring those that don't have the minimap property set and rendering rectangles for each line the decoration spans\r\n            for (let i = 0; i < decorations.length; i++) {\r\n                const decoration = decorations[i];\r\n                if (!decoration.options.minimap) {\r\n                    continue;\r\n                }\r\n                const decorationColor = decoration.options.minimap.getColor(this._theme);\r\n                for (let line = decoration.range.startLineNumber; line <= decoration.range.endLineNumber; line++) {\r\n                    switch (decoration.options.minimap.position) {\r\n                        case MinimapPosition.Inline:\r\n                            this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth);\r\n                            continue;\r\n                        case MinimapPosition.Gutter:\r\n                            const y = (line - layout.startLineNumber) * lineHeight;\r\n                            const x = 2;\r\n                            this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, lineHeight);\r\n                            continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, lineHeight, tabSize, charWidth) {\r\n        const y = (lineNumber - layout.startLineNumber) * lineHeight;\r\n        // Skip rendering the line if it's vertically outside our viewport\r\n        if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\r\n            return;\r\n        }\r\n        // Cache line offset data so that it is only read once per line\r\n        let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\r\n        const isFirstDecorationForLine = !lineIndexToXOffset;\r\n        if (!lineIndexToXOffset) {\r\n            const lineData = this._model.getLineContent(lineNumber);\r\n            lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\r\n            for (let i = 1; i < lineData.length + 1; i++) {\r\n                const charCode = lineData.charCodeAt(i - 1);\r\n                const dx = charCode === 9 /* Tab */\r\n                    ? tabSize * charWidth\r\n                    : strings.isFullWidthCharacter(charCode)\r\n                        ? 2 * charWidth\r\n                        : charWidth;\r\n                lineIndexToXOffset[i] = lineIndexToXOffset[i - 1] + dx;\r\n            }\r\n            lineOffsetMap.set(lineNumber, lineIndexToXOffset);\r\n        }\r\n        const { startColumn, endColumn, startLineNumber, endLineNumber } = decorationRange;\r\n        const x = startLineNumber === lineNumber ? lineIndexToXOffset[startColumn - 1] : MINIMAP_GUTTER_WIDTH;\r\n        const endColumnForLine = endLineNumber > lineNumber ? lineIndexToXOffset.length - 1 : endColumn - 1;\r\n        if (endColumnForLine > 0) {\r\n            // If the decoration starts at the last character of the column and spans over it, ensure it has a width\r\n            const width = lineIndexToXOffset[endColumnForLine] - x || 2;\r\n            this.renderDecoration(canvasContext, decorationColor, x, y, width, height);\r\n        }\r\n        if (isFirstDecorationForLine) {\r\n            this.renderLineHighlight(canvasContext, decorationColor, y, height);\r\n        }\r\n    }\r\n    renderLineHighlight(canvasContext, decorationColor, y, height) {\r\n        canvasContext.fillStyle = decorationColor && decorationColor.transparent(0.5).toString() || '';\r\n        canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, height);\r\n    }\r\n    renderDecoration(canvasContext, decorationColor, x, y, width, height) {\r\n        canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\r\n        canvasContext.fillRect(x, y, width, height);\r\n    }\r\n    renderLines(layout) {\r\n        const startLineNumber = layout.startLineNumber;\r\n        const endLineNumber = layout.endLineNumber;\r\n        const minimapLineHeight = this._model.options.minimapLineHeight;\r\n        // Check if nothing changed w.r.t. lines from last frame\r\n        if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\r\n            const _lastData = this._lastRenderData._get();\r\n            // Nice!! Nothing changed from last frame\r\n            return new RenderData(layout, _lastData.imageData, _lastData.lines);\r\n        }\r\n        // Oh well!! We need to repaint some lines...\r\n        const imageData = this._getBuffer();\r\n        if (!imageData) {\r\n            // 0 width or 0 height canvas, nothing to do\r\n            return null;\r\n        }\r\n        // Render untouched lines by using last rendered data.\r\n        let [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);\r\n        // Fetch rendering info from view model for rest of lines that need rendering.\r\n        const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\r\n        const tabSize = this._model.getOptions().tabSize;\r\n        const background = this._model.options.backgroundColor;\r\n        const tokensColorTracker = this._model.tokensColorTracker;\r\n        const useLighterFont = tokensColorTracker.backgroundIsLight();\r\n        const renderMinimap = this._model.options.renderMinimap;\r\n        const charRenderer = this._model.options.charRenderer();\r\n        const fontScale = this._model.options.fontScale;\r\n        const minimapCharWidth = this._model.options.minimapCharWidth;\r\n        const baseCharHeight = (renderMinimap === 1 /* Text */ ? 2 /* BASE_CHAR_HEIGHT */ : 2 /* BASE_CHAR_HEIGHT */ + 1);\r\n        const renderMinimapLineHeight = baseCharHeight * fontScale;\r\n        const innerLinePadding = (minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0);\r\n        // Render the rest of lines\r\n        let dy = 0;\r\n        const renderedLines = [];\r\n        for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\r\n            if (needed[lineIndex]) {\r\n                InnerMinimap._renderLine(imageData, background, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\r\n            }\r\n            renderedLines[lineIndex] = new MinimapLine(dy);\r\n            dy += minimapLineHeight;\r\n        }\r\n        const dirtyY1 = (_dirtyY1 === -1 ? 0 : _dirtyY1);\r\n        const dirtyY2 = (_dirtyY2 === -1 ? imageData.height : _dirtyY2);\r\n        const dirtyHeight = dirtyY2 - dirtyY1;\r\n        // Finally, paint to the canvas\r\n        const ctx = this._canvas.domNode.getContext('2d');\r\n        ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\r\n        // Save rendered data for reuse on next frame if possible\r\n        return new RenderData(layout, imageData, renderedLines);\r\n    }\r\n    static _renderUntouchedLines(target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\r\n        const needed = [];\r\n        if (!lastRenderData) {\r\n            for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\r\n                needed[i] = true;\r\n            }\r\n            return [-1, -1, needed];\r\n        }\r\n        const _lastData = lastRenderData._get();\r\n        const lastTargetData = _lastData.imageData.data;\r\n        const lastStartLineNumber = _lastData.rendLineNumberStart;\r\n        const lastLines = _lastData.lines;\r\n        const lastLinesLength = lastLines.length;\r\n        const WIDTH = target.width;\r\n        const targetData = target.data;\r\n        const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\r\n        let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\r\n        let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\r\n        let copySourceStart = -1;\r\n        let copySourceEnd = -1;\r\n        let copyDestStart = -1;\r\n        let copyDestEnd = -1;\r\n        let dest_dy = 0;\r\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            const lineIndex = lineNumber - startLineNumber;\r\n            const lastLineIndex = lineNumber - lastStartLineNumber;\r\n            const source_dy = (lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1);\r\n            if (source_dy === -1) {\r\n                needed[lineIndex] = true;\r\n                dest_dy += minimapLineHeight;\r\n                continue;\r\n            }\r\n            const sourceStart = source_dy * WIDTH * 4;\r\n            const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\r\n            const destStart = dest_dy * WIDTH * 4;\r\n            const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\r\n            if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\r\n                // contiguous zone => extend copy request\r\n                copySourceEnd = sourceEnd;\r\n                copyDestEnd = destEnd;\r\n            }\r\n            else {\r\n                if (copySourceStart !== -1) {\r\n                    // flush existing copy request\r\n                    targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\r\n                    if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\r\n                        dirtyPixel1 = copySourceEnd;\r\n                    }\r\n                    if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\r\n                        dirtyPixel2 = copySourceStart;\r\n                    }\r\n                }\r\n                copySourceStart = sourceStart;\r\n                copySourceEnd = sourceEnd;\r\n                copyDestStart = destStart;\r\n                copyDestEnd = destEnd;\r\n            }\r\n            needed[lineIndex] = false;\r\n            dest_dy += minimapLineHeight;\r\n        }\r\n        if (copySourceStart !== -1) {\r\n            // flush existing copy request\r\n            targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\r\n            if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\r\n                dirtyPixel1 = copySourceEnd;\r\n            }\r\n            if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\r\n                dirtyPixel2 = copySourceStart;\r\n            }\r\n        }\r\n        const dirtyY1 = (dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4));\r\n        const dirtyY2 = (dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4));\r\n        return [dirtyY1, dirtyY2, needed];\r\n    }\r\n    static _renderLine(target, backgroundColor, useLighterFont, renderMinimap, charWidth, colorTracker, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\r\n        const content = lineData.content;\r\n        const tokens = lineData.tokens;\r\n        const maxDx = target.width - charWidth;\r\n        const force1pxHeight = (minimapLineHeight === 1);\r\n        let dx = MINIMAP_GUTTER_WIDTH;\r\n        let charIndex = 0;\r\n        let tabsCharDelta = 0;\r\n        for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\r\n            const tokenEndIndex = tokens.getEndOffset(tokenIndex);\r\n            const tokenColorId = tokens.getForeground(tokenIndex);\r\n            const tokenColor = colorTracker.getColor(tokenColorId);\r\n            for (; charIndex < tokenEndIndex; charIndex++) {\r\n                if (dx > maxDx) {\r\n                    // hit edge of minimap\r\n                    return;\r\n                }\r\n                const charCode = content.charCodeAt(charIndex);\r\n                if (charCode === 9 /* Tab */) {\r\n                    const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\r\n                    tabsCharDelta += insertSpacesCount - 1;\r\n                    // No need to render anything since tab is invisible\r\n                    dx += insertSpacesCount * charWidth;\r\n                }\r\n                else if (charCode === 32 /* Space */) {\r\n                    // No need to render anything since space is invisible\r\n                    dx += charWidth;\r\n                }\r\n                else {\r\n                    // Render twice for a full width character\r\n                    const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\r\n                    for (let i = 0; i < count; i++) {\r\n                        if (renderMinimap === 2 /* Blocks */) {\r\n                            minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, backgroundColor, useLighterFont, force1pxHeight);\r\n                        }\r\n                        else { // RenderMinimap.Text\r\n                            minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, backgroundColor, fontScale, useLighterFont, force1pxHeight);\r\n                        }\r\n                        dx += charWidth;\r\n                        if (dx > maxDx) {\r\n                            // hit edge of minimap\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nregisterThemingParticipant((theme, collector) => {\r\n    const minimapBackgroundValue = theme.getColor(minimapBackground);\r\n    if (minimapBackgroundValue) {\r\n        collector.addRule(`.monaco-editor .minimap > canvas { opacity: ${minimapBackgroundValue.rgba.a}; will-change: opacity; }`);\r\n    }\r\n    const sliderBackground = theme.getColor(minimapSliderBackground);\r\n    if (sliderBackground) {\r\n        collector.addRule(`.monaco-editor .minimap-slider .minimap-slider-horizontal { background: ${sliderBackground}; }`);\r\n    }\r\n    const sliderHoverBackground = theme.getColor(minimapSliderHoverBackground);\r\n    if (sliderHoverBackground) {\r\n        collector.addRule(`.monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: ${sliderHoverBackground}; }`);\r\n    }\r\n    const sliderActiveBackground = theme.getColor(minimapSliderActiveBackground);\r\n    if (sliderActiveBackground) {\r\n        collector.addRule(`.monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: ${sliderActiveBackground}; }`);\r\n    }\r\n    const shadow = theme.getColor(scrollbarShadow);\r\n    if (shadow) {\r\n        collector.addRule(`.monaco-editor .minimap-shadow-visible { box-shadow: ${shadow} -6px 0 6px -6px inset; }`);\r\n    }\r\n});\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,eAAe;AACtB,OAAO,KAAKA,GAAG,MAAM,iCAAiC;AACtD,SAASC,iBAAiB,QAAQ,yCAAyC;AAC3E,SAASC,sBAAsB,EAAEC,uBAAuB,QAAQ,oDAAoD;AACpH,SAASC,UAAU,QAAQ,sCAAsC;AACjE,OAAO,KAAKC,QAAQ,MAAM,qCAAqC;AAC/D,OAAO,KAAKC,OAAO,MAAM,oCAAoC;AAC7D,SAASC,uBAAuB,QAAQ,yBAAyB;AACjE,SAASC,gBAAgB,EAAEC,QAAQ,QAAQ,wBAAwB;AACnE,SAASC,oBAAoB,EAAEC,wBAAwB,QAAQ,yCAAyC;AACxG,SAASC,KAAK,QAAQ,+BAA+B;AACrD,SAASC,KAAK,QAAQ,8BAA8B;AACpD,SAASC,yBAAyB,QAAQ,wDAAwD;AAClG,SAASC,mBAAmB,QAAQ,wCAAwC;AAC5E,SAASC,gBAAgB,EAAEC,eAAe,EAAEC,iBAAiB,EAAEC,uBAAuB,EAAEC,4BAA4B,EAAEC,6BAA6B,QAAQ,oDAAoD;AAC/M,SAASC,0BAA0B,QAAQ,mDAAmD;AAC9F,SAASC,SAAS,QAAQ,mCAAmC;AAC7D,SAASC,SAAS,EAAEC,OAAO,QAAQ,mCAAmC;AACtE,SAASC,0BAA0B,QAAQ,iCAAiC;AAC5E,SAASC,eAAe,QAAQ,0BAA0B;AAC1D,SAASC,IAAI,QAAQ,uCAAuC;AAC5D;AACA;AACA;AACA,MAAMC,yBAAyB,GAAG,GAAG;AACrC,MAAMC,uBAAuB,GAAG,CAAC;AACjC,MAAMC,cAAc,CAAC;EACjBC,WAAWA,CAACC,aAAa,EAAEC,KAAK,EAAEC,kBAAkB,EAAE;IAClD,MAAMC,OAAO,GAAGH,aAAa,CAACG,OAAO;IACrC,MAAMC,UAAU,GAAGD,OAAO,CAACE,GAAG,CAAC,GAAG,CAAC,gBAAgB,CAAC;IACpD,MAAMC,UAAU,GAAGH,OAAO,CAACE,GAAG,CAAC,GAAG,CAAC,gBAAgB,CAAC;IACpD,MAAME,aAAa,GAAGD,UAAU,CAACE,OAAO;IACxC,MAAMC,QAAQ,GAAGN,OAAO,CAACE,GAAG,CAAC,EAAE,CAAC,cAAc,CAAC;IAC/C,MAAMK,WAAW,GAAGP,OAAO,CAACE,GAAG,CAAC,EAAE,CAAC,aAAa,CAAC;IACjD,IAAI,CAACM,aAAa,GAAGJ,aAAa,CAACI,aAAa;IAChD,IAAI,CAACC,IAAI,GAAGF,WAAW,CAACE,IAAI;IAC5B,IAAI,CAACC,2BAA2B,GAAGN,aAAa,CAACM,2BAA2B;IAC5E,IAAI,CAACC,oBAAoB,GAAGX,OAAO,CAACE,GAAG,CAAC,EAAE,CAAC,0BAA0B,CAAC;IACtE,IAAI,CAACU,UAAU,GAAGL,WAAW,CAACK,UAAU;IACxC,IAAI,CAACX,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACY,8BAA8B,GAAGP,QAAQ,CAACO,8BAA8B;IAC7E,IAAI,CAACC,UAAU,GAAGd,OAAO,CAACE,GAAG,CAAC,EAAE,CAAC,gBAAgB,CAAC;IAClD,IAAI,CAACa,WAAW,GAAGX,aAAa,CAACW,WAAW;IAC5C,IAAI,CAACC,YAAY,GAAGZ,aAAa,CAACY,YAAY;IAC9C,IAAI,CAACC,aAAa,GAAGd,UAAU,CAACe,MAAM;IACtC,IAAI,CAACC,gBAAgB,GAAGf,aAAa,CAACgB,uBAAuB;IAC7D,IAAI,CAACC,iBAAiB,GAAGjB,aAAa,CAACkB,wBAAwB;IAC/D,IAAI,CAACC,gBAAgB,GAAGnB,aAAa,CAACoB,uBAAuB;IAC7D,IAAI,CAACC,iBAAiB,GAAGrB,aAAa,CAACsB,wBAAwB;IAC/D,IAAI,CAACC,UAAU,GAAGvB,aAAa,CAACwB,iBAAiB;IACjD,IAAI,CAACC,YAAY,GAAG1B,UAAU,CAACe,MAAM;IACrC,IAAI,CAACY,SAAS,GAAG1B,aAAa,CAAC2B,YAAY;IAC3C,IAAI,CAACC,iBAAiB,GAAG5B,aAAa,CAAC4B,iBAAiB;IACxD,IAAI,CAACC,gBAAgB,GAAG,CAAC,CAAC,wBAAwB,IAAI,CAACH,SAAS;IAChE,IAAI,CAACI,YAAY,GAAG1C,IAAI,CAAC,MAAMF,0BAA0B,CAAC6C,MAAM,CAAC,IAAI,CAACL,SAAS,EAAExB,QAAQ,CAAC8B,UAAU,CAAC,CAAC;IACtG,IAAI,CAACC,eAAe,GAAG1C,cAAc,CAAC2C,qBAAqB,CAACxC,KAAK,EAAEC,kBAAkB,CAAC;EAC1F;EACA,OAAOuC,qBAAqBA,CAACxC,KAAK,EAAEC,kBAAkB,EAAE;IACpD,MAAMwC,UAAU,GAAGzC,KAAK,CAAC0C,QAAQ,CAAC1D,iBAAiB,CAAC;IACpD,IAAIyD,UAAU,EAAE;MACZ,OAAO,IAAI9D,KAAK,CAAC8D,UAAU,CAACE,IAAI,CAACC,CAAC,EAAEH,UAAU,CAACE,IAAI,CAACE,CAAC,EAAEJ,UAAU,CAACE,IAAI,CAACG,CAAC,EAAEL,UAAU,CAACE,IAAI,CAACI,CAAC,CAAC;IAChG;IACA,OAAO9C,kBAAkB,CAACyC,QAAQ,CAAC,CAAC,CAAC,uBAAuB,CAAC;EACjE;;EACAM,MAAMA,CAACC,KAAK,EAAE;IACV,OAAQ,IAAI,CAACvC,aAAa,KAAKuC,KAAK,CAACvC,aAAa,IAC3C,IAAI,CAACC,IAAI,KAAKsC,KAAK,CAACtC,IAAI,IACxB,IAAI,CAACC,2BAA2B,KAAKqC,KAAK,CAACrC,2BAA2B,IACtE,IAAI,CAACC,oBAAoB,KAAKoC,KAAK,CAACpC,oBAAoB,IACxD,IAAI,CAACC,UAAU,KAAKmC,KAAK,CAACnC,UAAU,IACpC,IAAI,CAACX,UAAU,KAAK8C,KAAK,CAAC9C,UAAU,IACpC,IAAI,CAACY,8BAA8B,KAAKkC,KAAK,CAAClC,8BAA8B,IAC5E,IAAI,CAACC,UAAU,KAAKiC,KAAK,CAACjC,UAAU,IACpC,IAAI,CAACC,WAAW,KAAKgC,KAAK,CAAChC,WAAW,IACtC,IAAI,CAACC,YAAY,KAAK+B,KAAK,CAAC/B,YAAY,IACxC,IAAI,CAACC,aAAa,KAAK8B,KAAK,CAAC9B,aAAa,IAC1C,IAAI,CAACE,gBAAgB,KAAK4B,KAAK,CAAC5B,gBAAgB,IAChD,IAAI,CAACE,iBAAiB,KAAK0B,KAAK,CAAC1B,iBAAiB,IAClD,IAAI,CAACE,gBAAgB,KAAKwB,KAAK,CAACxB,gBAAgB,IAChD,IAAI,CAACE,iBAAiB,KAAKsB,KAAK,CAACtB,iBAAiB,IAClD,IAAI,CAACE,UAAU,KAAKoB,KAAK,CAACpB,UAAU,IACpC,IAAI,CAACE,YAAY,KAAKkB,KAAK,CAAClB,YAAY,IACxC,IAAI,CAACC,SAAS,KAAKiB,KAAK,CAACjB,SAAS,IAClC,IAAI,CAACE,iBAAiB,KAAKe,KAAK,CAACf,iBAAiB,IAClD,IAAI,CAACC,gBAAgB,KAAKc,KAAK,CAACd,gBAAgB,IAChD,IAAI,CAACI,eAAe,IAAI,IAAI,CAACA,eAAe,CAACS,MAAM,CAACC,KAAK,CAACV,eAAe,CAAC;EACrF;AACJ;AACA,MAAMW,aAAa,CAAC;EAChBpD,WAAWA,CAACqD,SAAS,EAAEC,YAAY,EAAEC,YAAY,EAAEC,mBAAmB,EAAEC,SAAS,EAAEC,YAAY,EAAEC,eAAe,EAAEC,aAAa,EAAE;IAC7H,IAAI,CAACP,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACM,oBAAoB,GAAGL,mBAAmB;IAC/C,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,aAAa,GAAGA,aAAa;EACtC;EACA;AACJ;AACA;EACIE,4BAA4BA,CAACC,KAAK,EAAE;IAChC,OAAOC,IAAI,CAACC,KAAK,CAAC,IAAI,CAACZ,SAAS,GAAGU,KAAK,GAAG,IAAI,CAACF,oBAAoB,CAAC;EACzE;EACAK,oCAAoCA,CAACC,KAAK,EAAE;IACxC,OAAOH,IAAI,CAACC,KAAK,CAAC,CAACE,KAAK,GAAG,IAAI,CAACT,YAAY,GAAG,CAAC,IAAI,IAAI,CAACG,oBAAoB,CAAC;EAClF;EACA,OAAOtB,MAAMA,CAACnC,OAAO,EAAEgE,uBAAuB,EAAEC,qBAAqB,EAAEC,qCAAqC,EAAEC,cAAc,EAAEC,8BAA8B,EAAEC,SAAS,EAAEC,aAAa,EAAErB,SAAS,EAAEC,YAAY,EAAEqB,cAAc,EAAE;IAC7N,MAAMtE,UAAU,GAAGD,OAAO,CAACC,UAAU;IACrC,MAAM+B,iBAAiB,GAAGhC,OAAO,CAACgC,iBAAiB;IACnD,MAAMwC,mBAAmB,GAAGZ,IAAI,CAACa,KAAK,CAACzE,OAAO,CAACqB,iBAAiB,GAAGW,iBAAiB,CAAC;IACrF,MAAMlB,UAAU,GAAGd,OAAO,CAACc,UAAU;IACrC,IAAId,OAAO,CAACU,2BAA2B,EAAE;MACrC,MAAMgE,mBAAmB,GAAIJ,aAAa,GAAGtE,OAAO,CAACc,UAAU,IACxDd,OAAO,CAACW,oBAAoB,GAAGwD,cAAc,GAAGnE,OAAO,CAACc,UAAU,GAAG,CAAC,CAAE;MAC/E,MAAMwC,YAAY,GAAGM,IAAI,CAACe,GAAG,CAAC,CAAC,EAAEf,IAAI,CAACa,KAAK,CAACN,cAAc,GAAGA,cAAc,GAAGO,mBAAmB,CAAC,CAAC;MACnG,MAAME,mBAAmB,GAAGhB,IAAI,CAACe,GAAG,CAAC,CAAC,EAAE3E,OAAO,CAACiB,aAAa,GAAGqC,YAAY,CAAC;MAC7E;MACA;MACA,MAAMF,mBAAmB,GAAIwB,mBAAmB,IAAK1B,YAAY,GAAGiB,cAAc,CAAC;MACnF,MAAMd,SAAS,GAAIJ,SAAS,GAAGG,mBAAoB;MACnD,MAAMD,YAAY,GAAIyB,mBAAmB,GAAG,CAAE;MAC9C,MAAMC,eAAe,GAAGjB,IAAI,CAACa,KAAK,CAACzE,OAAO,CAACqB,iBAAiB,GAAGrB,OAAO,CAACgC,iBAAiB,CAAC;MACzF,OAAO,IAAIgB,aAAa,CAACC,SAAS,EAAEC,YAAY,EAAEC,YAAY,EAAEC,mBAAmB,EAAEC,SAAS,EAAEC,YAAY,EAAE,CAAC,EAAEM,IAAI,CAACkB,GAAG,CAACT,SAAS,EAAEQ,eAAe,CAAC,CAAC;IAC1J;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIvB,YAAY;IAChB,IAAIc,8BAA8B,IAAIH,qBAAqB,KAAKI,SAAS,EAAE;MACvE;MACA;MACA,MAAMU,iBAAiB,GAAGd,qBAAqB,GAAGD,uBAAuB,GAAG,CAAC;MAC7EV,YAAY,GAAGM,IAAI,CAACa,KAAK,CAACM,iBAAiB,GAAG/C,iBAAiB,GAAG/B,UAAU,CAAC;IACjF,CAAC,MACI;MACD;MACA,MAAM+E,yBAAyB,GAAGb,cAAc,GAAGrD,UAAU;MAC7DwC,YAAY,GAAGM,IAAI,CAACa,KAAK,CAACO,yBAAyB,GAAGhD,iBAAiB,GAAG/B,UAAU,CAAC;IACzF;IACA,IAAI2E,mBAAmB;IACvB,IAAI5E,OAAO,CAACW,oBAAoB,EAAE;MAC9B;MACAiE,mBAAmB,GAAG,CAACP,SAAS,GAAG,CAAC,IAAIrC,iBAAiB,GAAG/B,UAAU;IAC1E,CAAC,MACI;MACD;MACA2E,mBAAmB,GAAGhB,IAAI,CAACe,GAAG,CAAC,CAAC,EAAEN,SAAS,GAAGrC,iBAAiB,GAAG/B,UAAU,GAAGqD,YAAY,CAAC;IAChG;IACAsB,mBAAmB,GAAGhB,IAAI,CAACkB,GAAG,CAAC9E,OAAO,CAACiB,aAAa,GAAGqC,YAAY,EAAEsB,mBAAmB,CAAC;IACzF;IACA;IACA,MAAMxB,mBAAmB,GAAIwB,mBAAmB,IAAK1B,YAAY,GAAGiB,cAAc,CAAC;IACnF,MAAMd,SAAS,GAAIJ,SAAS,GAAGG,mBAAoB;IACnD,IAAI6B,qBAAqB,GAAG,CAAC;IAC7B,IAAIjF,OAAO,CAACW,oBAAoB,EAAE;MAC9B,MAAMqE,yBAAyB,GAAGb,cAAc,GAAGrD,UAAU;MAC7DmE,qBAAqB,GAAGD,yBAAyB,GAAG,CAAC;IACzD;IACA,IAAIR,mBAAmB,IAAIH,SAAS,GAAGY,qBAAqB,EAAE;MAC1D;MACA,MAAM1B,eAAe,GAAG,CAAC;MACzB,MAAMC,aAAa,GAAGa,SAAS;MAC/B,MAAMlB,YAAY,GAAIyB,mBAAmB,GAAG,CAAE;MAC9C,OAAO,IAAI5B,aAAa,CAACC,SAAS,EAAEC,YAAY,EAAEC,YAAY,EAAEC,mBAAmB,EAAEC,SAAS,EAAEC,YAAY,EAAEC,eAAe,EAAEC,aAAa,CAAC;IACjJ,CAAC,MACI;MACD,IAAID,eAAe,GAAGK,IAAI,CAACe,GAAG,CAAC,CAAC,EAAEf,IAAI,CAACa,KAAK,CAACT,uBAAuB,GAAGX,SAAS,GAAGpD,UAAU,GAAG+B,iBAAiB,CAAC,CAAC;MACnH;MACA;MACA,IAAIuC,cAAc,IAAIA,cAAc,CAACrB,YAAY,KAAKA,YAAY,EAAE;QAChE,IAAIqB,cAAc,CAACtB,SAAS,GAAGA,SAAS,EAAE;UACtC;UACAM,eAAe,GAAGK,IAAI,CAACkB,GAAG,CAACvB,eAAe,EAAEgB,cAAc,CAAChB,eAAe,CAAC;QAC/E;QACA,IAAIgB,cAAc,CAACtB,SAAS,GAAGA,SAAS,EAAE;UACtC;UACAM,eAAe,GAAGK,IAAI,CAACe,GAAG,CAACpB,eAAe,EAAEgB,cAAc,CAAChB,eAAe,CAAC;QAC/E;MACJ;MACA,MAAMC,aAAa,GAAGI,IAAI,CAACkB,GAAG,CAACT,SAAS,EAAEd,eAAe,GAAGiB,mBAAmB,GAAG,CAAC,CAAC;MACpF,MAAMU,WAAW,GAAG,CAACjC,SAAS,GAAGiB,qCAAqC,IAAIpD,UAAU;MACpF,MAAMqE,gBAAgB,GAAG,CAACnB,uBAAuB,GAAGT,eAAe,GAAG2B,WAAW,IAAIlD,iBAAiB,GAAG/B,UAAU;MACnH,OAAO,IAAI+C,aAAa,CAACC,SAAS,EAAEC,YAAY,EAAE,IAAI,EAAEE,mBAAmB,EAAE+B,gBAAgB,EAAE7B,YAAY,EAAEC,eAAe,EAAEC,aAAa,CAAC;IAChJ;EACJ;AACJ;AACA,MAAM4B,WAAW,CAAC;EACdxF,WAAWA,CAACyF,EAAE,EAAE;IACZ,IAAI,CAACA,EAAE,GAAGA,EAAE;EAChB;EACAC,gBAAgBA,CAAA,EAAG;IACf,IAAI,CAACD,EAAE,GAAG,CAAC,CAAC;EAChB;EACAE,eAAeA,CAAA,EAAG;IACd,IAAI,CAACF,EAAE,GAAG,CAAC,CAAC;EAChB;AACJ;AACAD,WAAW,CAACI,OAAO,GAAG,IAAIJ,WAAW,CAAC,CAAC,CAAC,CAAC;AACzC,MAAMK,UAAU,CAAC;EACb7F,WAAWA,CAAC8F,cAAc,EAAEC,SAAS,EAAEC,KAAK,EAAE;IAC1C,IAAI,CAACF,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACG,UAAU,GAAGF,SAAS;IAC3B,IAAI,CAACG,cAAc,GAAG,IAAI3H,uBAAuB,CAAC,MAAMiH,WAAW,CAACI,OAAO,CAAC;IAC5E,IAAI,CAACM,cAAc,CAACC,IAAI,CAACL,cAAc,CAACnC,eAAe,EAAEqC,KAAK,CAAC;EACnE;EACA;AACJ;AACA;EACII,WAAWA,CAACC,MAAM,EAAE;IAChB,IAAI,CAAC,IAAI,CAACC,YAAY,CAACD,MAAM,CAAC,EAAE;MAC5B,OAAO,KAAK;IAChB;IACA,MAAME,GAAG,GAAG,IAAI,CAACL,cAAc,CAACM,IAAI,CAAC,CAAC;IACtC,MAAMR,KAAK,GAAGO,GAAG,CAACP,KAAK;IACvB,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGV,KAAK,CAACW,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC9C,IAAIT,KAAK,CAACS,CAAC,CAAC,CAAChB,EAAE,KAAK,CAAC,CAAC,EAAE;QACpB;QACA,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIa,YAAYA,CAACD,MAAM,EAAE;IACjB,OAAO,IAAI,CAACP,cAAc,CAACnC,eAAe,KAAK0C,MAAM,CAAC1C,eAAe,IAC9D,IAAI,CAACmC,cAAc,CAAClC,aAAa,KAAKyC,MAAM,CAACzC,aAAa;EACrE;EACA4C,IAAIA,CAAA,EAAG;IACH,MAAMD,GAAG,GAAG,IAAI,CAACL,cAAc,CAACM,IAAI,CAAC,CAAC;IACtC,OAAO;MACHT,SAAS,EAAE,IAAI,CAACE,UAAU;MAC1BW,mBAAmB,EAAEL,GAAG,CAACK,mBAAmB;MAC5CZ,KAAK,EAAEO,GAAG,CAACP;IACf,CAAC;EACL;EACAa,cAAcA,CAACC,oBAAoB,EAAEC,kBAAkB,EAAE;IACrD,OAAO,IAAI,CAACb,cAAc,CAACW,cAAc,CAACC,oBAAoB,EAAEC,kBAAkB,CAAC;EACvF;EACAC,cAAcA,CAACC,oBAAoB,EAAEC,kBAAkB,EAAE;IACrD,IAAI,CAAChB,cAAc,CAACc,cAAc,CAACC,oBAAoB,EAAEC,kBAAkB,CAAC;EAChF;EACAC,eAAeA,CAACC,oBAAoB,EAAEC,kBAAkB,EAAE;IACtD,IAAI,CAACnB,cAAc,CAACiB,eAAe,CAACC,oBAAoB,EAAEC,kBAAkB,CAAC;EACjF;EACA1B,eAAeA,CAAC2B,MAAM,EAAE;IACpB,OAAO,IAAI,CAACpB,cAAc,CAACP,eAAe,CAAC2B,MAAM,CAAC;EACtD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,cAAc,CAAC;EACjBvH,WAAWA,CAACwH,GAAG,EAAEC,KAAK,EAAEC,MAAM,EAAEC,UAAU,EAAE;IACxC,IAAI,CAACC,mBAAmB,GAAGL,cAAc,CAACM,yBAAyB,CAACJ,KAAK,EAAEC,MAAM,EAAEC,UAAU,CAAC;IAC9F,IAAI,CAACG,QAAQ,GAAG,CACZN,GAAG,CAACO,eAAe,CAACN,KAAK,EAAEC,MAAM,CAAC,EAClCF,GAAG,CAACO,eAAe,CAACN,KAAK,EAAEC,MAAM,CAAC,CACrC;IACD,IAAI,CAACM,eAAe,GAAG,CAAC;EAC5B;EACAC,SAASA,CAAA,EAAG;IACR;IACA,IAAI,CAACD,eAAe,GAAG,CAAC,GAAG,IAAI,CAACA,eAAe;IAC/C,MAAME,MAAM,GAAG,IAAI,CAACJ,QAAQ,CAAC,IAAI,CAACE,eAAe,CAAC;IAClD;IACAE,MAAM,CAACC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACR,mBAAmB,CAAC;IACzC,OAAOM,MAAM;EACjB;EACA,OAAOL,yBAAyBA,CAACJ,KAAK,EAAEC,MAAM,EAAEC,UAAU,EAAE;IACxD,MAAMU,WAAW,GAAGV,UAAU,CAAC7E,CAAC;IAChC,MAAMwF,WAAW,GAAGX,UAAU,CAAC5E,CAAC;IAChC,MAAMwF,WAAW,GAAGZ,UAAU,CAAC3E,CAAC;IAChC,MAAMkF,MAAM,GAAG,IAAIM,iBAAiB,CAACf,KAAK,GAAGC,MAAM,GAAG,CAAC,CAAC;IACxD,IAAIe,MAAM,GAAG,CAAC;IACd,KAAK,IAAIhC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,MAAM,EAAEjB,CAAC,EAAE,EAAE;MAC7B,KAAK,IAAIiC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,KAAK,EAAEiB,CAAC,EAAE,EAAE;QAC5BR,MAAM,CAACO,MAAM,CAAC,GAAGJ,WAAW;QAC5BH,MAAM,CAACO,MAAM,GAAG,CAAC,CAAC,GAAGH,WAAW;QAChCJ,MAAM,CAACO,MAAM,GAAG,CAAC,CAAC,GAAGF,WAAW;QAChCL,MAAM,CAACO,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG;QACxBA,MAAM,IAAI,CAAC;MACf;IACJ;IACA,OAAOP,MAAM;EACjB;AACJ;AACA,MAAMS,oBAAoB,CAAC;EACvB3I,WAAWA,CAAC4I,aAAa,EAAEC,YAAY,EAAE;IACrC,IAAI,CAACD,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,YAAY,GAAGA,YAAY;EACpC;EACA,OAAOC,OAAOA,CAAC1I,OAAO,EAAE2I,aAAa,EAAEC,gBAAgB,EAAE;IACrD,IAAI5I,OAAO,CAACQ,aAAa,KAAK,CAAC,CAAC,cAAc,CAACR,OAAO,CAAC2B,UAAU,EAAE;MAC/D,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;IACrB;IACA;IACA;IACA,MAAM1B,UAAU,GAAGD,OAAO,CAACC,UAAU;IACrC,MAAMa,UAAU,GAAGd,OAAO,CAACc,UAAU;IACrC,MAAMH,oBAAoB,GAAGX,OAAO,CAACW,oBAAoB;IACzD,MAAM;MAAEkI;IAAiB,CAAC,GAAGtK,wBAAwB,CAACuK,gCAAgC,CAAC;MACnFH,aAAa,EAAEA,aAAa;MAC5BhI,oBAAoB,EAAEA,oBAAoB;MAC1CO,MAAM,EAAElB,OAAO,CAAC6B,YAAY;MAC5Bf,UAAU,EAAEA,UAAU;MACtBb,UAAU,EAAEA;IAChB,CAAC,CAAC;IACF,MAAM8I,KAAK,GAAGJ,aAAa,GAAGE,gBAAgB;IAC9C,MAAMG,SAAS,GAAGD,KAAK,GAAG,CAAC;IAC3B,IAAI,CAACH,gBAAgB,IAAIA,gBAAgB,CAACH,YAAY,CAAClC,MAAM,KAAK,CAAC,EAAE;MACjE,IAAIuB,MAAM,GAAG,EAAE;MACfA,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC;MACb,IAAIe,gBAAgB,GAAG,CAAC,EAAE;QACtB,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAE4C,SAAS,GAAGJ,gBAAgB,GAAG,CAAC,EAAExC,CAAC,GAAG4C,SAAS,EAAE5C,CAAC,EAAE,EAAE;UAClEyB,MAAM,CAACzB,CAAC,CAAC,GAAGzC,IAAI,CAACC,KAAK,CAACwC,CAAC,GAAG0C,KAAK,GAAGC,SAAS,CAAC;QACjD;QACAlB,MAAM,CAACe,gBAAgB,GAAG,CAAC,CAAC,GAAGF,aAAa;MAChD;MACA,OAAO,CAAC,IAAIJ,oBAAoB,CAACQ,KAAK,EAAEjB,MAAM,CAAC,EAAE,EAAE,CAAC;IACxD;IACA,MAAMoB,eAAe,GAAGN,gBAAgB,CAACH,YAAY;IACrD,MAAMU,SAAS,GAAGD,eAAe,CAAC3C,MAAM;IACxC,IAAIuB,MAAM,GAAG,EAAE;IACf,IAAIsB,QAAQ,GAAG,CAAC;IAChB,IAAIC,iBAAiB,GAAG,CAAC;IACzB,IAAIC,iBAAiB,GAAG,CAAC;IACzB,MAAMC,eAAe,GAAG,EAAE,CAAC,CAAC;IAC5B,IAAIC,MAAM,GAAG,EAAE;IACf,IAAIC,SAAS,GAAG,IAAI;IACpB,KAAK,IAAIpD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwC,gBAAgB,EAAExC,CAAC,EAAE,EAAE;MACvC,MAAMqD,kBAAkB,GAAG9F,IAAI,CAACe,GAAG,CAAC2E,iBAAiB,EAAE1F,IAAI,CAACC,KAAK,CAACwC,CAAC,GAAG0C,KAAK,CAAC,CAAC;MAC7E,MAAMY,gBAAgB,GAAG/F,IAAI,CAACe,GAAG,CAAC+E,kBAAkB,EAAE9F,IAAI,CAACC,KAAK,CAAC,CAACwC,CAAC,GAAG,CAAC,IAAI0C,KAAK,CAAC,CAAC;MAClF,OAAOK,QAAQ,GAAGD,SAAS,IAAID,eAAe,CAACE,QAAQ,CAAC,GAAGM,kBAAkB,EAAE;QAC3E,IAAIF,MAAM,CAACjD,MAAM,GAAGgD,eAAe,EAAE;UACjC,MAAMK,oBAAoB,GAAGR,QAAQ,GAAG,CAAC,GAAGC,iBAAiB;UAC7D,IAAII,SAAS,IAAIA,SAAS,CAACI,IAAI,KAAK,SAAS,IAAIJ,SAAS,CAACK,SAAS,KAAKV,QAAQ,GAAG,CAAC,EAAE;YACnFK,SAAS,CAAC3C,kBAAkB,EAAE;UAClC,CAAC,MACI;YACD2C,SAAS,GAAG;cAAEI,IAAI,EAAE,SAAS;cAAEC,SAAS,EAAEV,QAAQ;cAAEvC,oBAAoB,EAAE+C,oBAAoB;cAAE9C,kBAAkB,EAAE8C;YAAqB,CAAC;YAC1IJ,MAAM,CAACO,IAAI,CAACN,SAAS,CAAC;UAC1B;UACAJ,iBAAiB,EAAE;QACvB;QACAD,QAAQ,EAAE;MACd;MACA,IAAIY,sBAAsB;MAC1B,IAAIZ,QAAQ,GAAGD,SAAS,IAAID,eAAe,CAACE,QAAQ,CAAC,IAAIO,gBAAgB,EAAE;QACvE;QACAK,sBAAsB,GAAGd,eAAe,CAACE,QAAQ,CAAC;QAClDA,QAAQ,EAAE;MACd,CAAC,MACI;QACD,IAAI/C,CAAC,KAAK,CAAC,EAAE;UACT2D,sBAAsB,GAAG,CAAC;QAC9B,CAAC,MACI,IAAI3D,CAAC,GAAG,CAAC,KAAKwC,gBAAgB,EAAE;UACjCmB,sBAAsB,GAAGrB,aAAa;QAC1C,CAAC,MACI;UACDqB,sBAAsB,GAAGpG,IAAI,CAACC,KAAK,CAACwC,CAAC,GAAG0C,KAAK,GAAGC,SAAS,CAAC;QAC9D;QACA,IAAIQ,MAAM,CAACjD,MAAM,GAAGgD,eAAe,EAAE;UACjC,MAAMK,oBAAoB,GAAGR,QAAQ,GAAG,CAAC,GAAGC,iBAAiB;UAC7D,IAAII,SAAS,IAAIA,SAAS,CAACI,IAAI,KAAK,UAAU,IAAIJ,SAAS,CAACQ,EAAE,KAAK5D,CAAC,GAAG,CAAC,EAAE;YACtEoD,SAAS,CAACxC,kBAAkB,EAAE;UAClC,CAAC,MACI;YACDwC,SAAS,GAAG;cAAEI,IAAI,EAAE,UAAU;cAAEI,EAAE,EAAE5D,CAAC;cAAEW,oBAAoB,EAAE4C,oBAAoB;cAAE3C,kBAAkB,EAAE2C;YAAqB,CAAC;YAC7HJ,MAAM,CAACO,IAAI,CAACN,SAAS,CAAC;UAC1B;UACAJ,iBAAiB,EAAE;QACvB;MACJ;MACAvB,MAAM,CAACzB,CAAC,CAAC,GAAG2D,sBAAsB;MAClCV,iBAAiB,GAAGU,sBAAsB;IAC9C;IACA,IAAIR,MAAM,CAACjD,MAAM,GAAGgD,eAAe,EAAE;MACjC,OAAOH,QAAQ,GAAGD,SAAS,EAAE;QACzB,MAAMS,oBAAoB,GAAGR,QAAQ,GAAG,CAAC,GAAGC,iBAAiB;QAC7D,IAAII,SAAS,IAAIA,SAAS,CAACI,IAAI,KAAK,SAAS,IAAIJ,SAAS,CAACK,SAAS,KAAKV,QAAQ,GAAG,CAAC,EAAE;UACnFK,SAAS,CAAC3C,kBAAkB,EAAE;QAClC,CAAC,MACI;UACD2C,SAAS,GAAG;YAAEI,IAAI,EAAE,SAAS;YAAEC,SAAS,EAAEV,QAAQ;YAAEvC,oBAAoB,EAAE+C,oBAAoB;YAAE9C,kBAAkB,EAAE8C;UAAqB,CAAC;UAC1IJ,MAAM,CAACO,IAAI,CAACN,SAAS,CAAC;QAC1B;QACAJ,iBAAiB,EAAE;QACnBD,QAAQ,EAAE;MACd;IACJ,CAAC,MACI;MACD;MACAI,MAAM,GAAG,CAAC;QAAEK,IAAI,EAAE;MAAQ,CAAC,CAAC;IAChC;IACA,OAAO,CAAC,IAAItB,oBAAoB,CAACQ,KAAK,EAAEjB,MAAM,CAAC,EAAE0B,MAAM,CAAC;EAC5D;EACAU,sBAAsBA,CAACC,UAAU,EAAE;IAC/B,OAAOvG,IAAI,CAACkB,GAAG,CAAC,IAAI,CAAC2D,YAAY,CAAClC,MAAM,EAAE3C,IAAI,CAACe,GAAG,CAAC,CAAC,EAAEf,IAAI,CAACC,KAAK,CAACsG,UAAU,GAAG,IAAI,CAAC3B,aAAa,CAAC,CAAC,CAAC;EACvG;EACA;AACJ;AACA;EACI4B,gCAAgCA,CAACC,cAAc,EAAEC,YAAY,EAAE;IAC3D,IAAIC,aAAa,GAAG,IAAI,CAACL,sBAAsB,CAACG,cAAc,CAAC,GAAG,CAAC;IACnE,OAAOE,aAAa,GAAG,CAAC,IAAI,IAAI,CAAC9B,YAAY,CAAC8B,aAAa,GAAG,CAAC,CAAC,IAAIF,cAAc,EAAE;MAChFE,aAAa,EAAE;IACnB;IACA,IAAIC,WAAW,GAAG,IAAI,CAACN,sBAAsB,CAACI,YAAY,CAAC,GAAG,CAAC;IAC/D,OAAOE,WAAW,GAAG,CAAC,GAAG,IAAI,CAAC/B,YAAY,CAAClC,MAAM,IAAI,IAAI,CAACkC,YAAY,CAAC+B,WAAW,GAAG,CAAC,CAAC,IAAIF,YAAY,EAAE;MACrGE,WAAW,EAAE;IACjB;IACA,IAAID,aAAa,KAAKC,WAAW,EAAE;MAC/B,MAAMC,iBAAiB,GAAG,IAAI,CAAChC,YAAY,CAAC8B,aAAa,CAAC;MAC1D,IAAIE,iBAAiB,GAAGJ,cAAc,IAAII,iBAAiB,GAAGH,YAAY,EAAE;QACxE;QACA,OAAO,IAAI;MACf;IACJ;IACA,OAAO,CAACC,aAAa,GAAG,CAAC,EAAEC,WAAW,GAAG,CAAC,CAAC;EAC/C;EACA;AACJ;AACA;EACIE,qCAAqCA,CAACnH,eAAe,EAAEC,aAAa,EAAE;IAClE,IAAImH,gBAAgB,GAAG,IAAI,CAACT,sBAAsB,CAAC3G,eAAe,CAAC;IACnE,IAAIqH,cAAc,GAAG,IAAI,CAACV,sBAAsB,CAAC1G,aAAa,CAAC;IAC/D,IAAID,eAAe,KAAKC,aAAa,IAAIoH,cAAc,KAAKD,gBAAgB,EAAE;MAC1E,IAAIC,cAAc,KAAK,IAAI,CAACnC,YAAY,CAAClC,MAAM,EAAE;QAC7C,IAAIoE,gBAAgB,GAAG,CAAC,EAAE;UACtBA,gBAAgB,EAAE;QACtB;MACJ,CAAC,MACI;QACDC,cAAc,EAAE;MACpB;IACJ;IACA,OAAO,CAACD,gBAAgB,EAAEC,cAAc,CAAC;EAC7C;EACAhE,cAAcA,CAACiE,CAAC,EAAE;IACd;IACA,MAAMC,gBAAgB,GAAGD,CAAC,CAACP,YAAY,GAAGO,CAAC,CAACR,cAAc,GAAG,CAAC;IAC9D,IAAIU,gBAAgB,GAAG,IAAI,CAACtC,YAAY,CAAClC,MAAM;IAC/C,IAAIyE,cAAc,GAAG,CAAC;IACtB,KAAK,IAAI3E,CAAC,GAAG,IAAI,CAACoC,YAAY,CAAClC,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACpD,IAAI,IAAI,CAACoC,YAAY,CAACpC,CAAC,CAAC,GAAGwE,CAAC,CAACR,cAAc,EAAE;QACzC;MACJ;MACA,IAAI,IAAI,CAAC5B,YAAY,CAACpC,CAAC,CAAC,IAAIwE,CAAC,CAACP,YAAY,EAAE;QACxC;QACA,IAAI,CAAC7B,YAAY,CAACpC,CAAC,CAAC,GAAGzC,IAAI,CAACe,GAAG,CAAC,CAAC,EAAEkG,CAAC,CAACR,cAAc,GAAG,CAAC,CAAC;QACxDU,gBAAgB,GAAGnH,IAAI,CAACkB,GAAG,CAACiG,gBAAgB,EAAE1E,CAAC,CAAC;QAChD2E,cAAc,GAAGpH,IAAI,CAACe,GAAG,CAACqG,cAAc,EAAE3E,CAAC,CAAC;MAChD,CAAC,MACI;QACD,IAAI,CAACoC,YAAY,CAACpC,CAAC,CAAC,IAAIyE,gBAAgB;MAC5C;IACJ;IACA,OAAO,CAACC,gBAAgB,EAAEC,cAAc,CAAC;EAC7C;EACAjE,eAAeA,CAAC8D,CAAC,EAAE;IACf;IACA,MAAMI,iBAAiB,GAAGJ,CAAC,CAACP,YAAY,GAAGO,CAAC,CAACR,cAAc,GAAG,CAAC;IAC/D,KAAK,IAAIhE,CAAC,GAAG,IAAI,CAACoC,YAAY,CAAClC,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACpD,IAAI,IAAI,CAACoC,YAAY,CAACpC,CAAC,CAAC,GAAGwE,CAAC,CAACR,cAAc,EAAE;QACzC;MACJ;MACA,IAAI,CAAC5B,YAAY,CAACpC,CAAC,CAAC,IAAI4E,iBAAiB;IAC7C;EACJ;AACJ;AACA,OAAO,MAAMC,OAAO,SAAS7M,QAAQ,CAAC;EAClCuB,WAAWA,CAACuL,OAAO,EAAE;IACjB,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACpL,kBAAkB,GAAGrB,yBAAyB,CAAC0M,WAAW,CAAC,CAAC;IACjE,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAACtL,OAAO,GAAG,IAAIL,cAAc,CAAC,IAAI,CAAC4L,QAAQ,CAAC1L,aAAa,EAAE,IAAI,CAAC0L,QAAQ,CAACzL,KAAK,EAAE,IAAI,CAACC,kBAAkB,CAAC;IAC5G,MAAM,CAACyL,aAAa,CAAE,GAAGjD,oBAAoB,CAACG,OAAO,CAAC,IAAI,CAAC1I,OAAO,EAAE,IAAI,CAACuL,QAAQ,CAACE,KAAK,CAACC,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC;IAC7G,IAAI,CAACC,cAAc,GAAGH,aAAa;IACnC,IAAI,CAACI,oBAAoB,GAAG,KAAK;IACjC,IAAI,CAACC,OAAO,GAAG,IAAIC,YAAY,CAACX,OAAO,CAACrL,KAAK,EAAE,IAAI,CAAC;EACxD;EACAiM,OAAOA,CAAA,EAAG;IACN,IAAI,CAACF,OAAO,CAACE,OAAO,CAAC,CAAC;IACtB,KAAK,CAACA,OAAO,CAAC,CAAC;EACnB;EACAC,UAAUA,CAAA,EAAG;IACT,OAAO,IAAI,CAACH,OAAO,CAACG,UAAU,CAAC,CAAC;EACpC;EACAC,sBAAsBA,CAAA,EAAG;IACrB,MAAMC,IAAI,GAAG,IAAIvM,cAAc,CAAC,IAAI,CAAC4L,QAAQ,CAAC1L,aAAa,EAAE,IAAI,CAAC0L,QAAQ,CAACzL,KAAK,EAAE,IAAI,CAACC,kBAAkB,CAAC;IAC1G,IAAI,IAAI,CAACC,OAAO,CAAC8C,MAAM,CAACoJ,IAAI,CAAC,EAAE;MAC3B,OAAO,KAAK;IAChB;IACA,IAAI,CAAClM,OAAO,GAAGkM,IAAI;IACnB,IAAI,CAACC,qBAAqB,CAAC,CAAC;IAC5B,IAAI,CAACN,OAAO,CAACO,kBAAkB,CAAC,CAAC;IACjC,OAAO,IAAI;EACf;EACA;EACAC,sBAAsBA,CAACxB,CAAC,EAAE;IACtB,OAAO,IAAI,CAACoB,sBAAsB,CAAC,CAAC;EACxC;EACAK,oBAAoBA,CAACzB,CAAC,EAAE;IACpB,IAAI,CAACQ,WAAW,GAAGR,CAAC,CAAC0B,UAAU;IAC/B,IAAI,CAACjB,kBAAkB,GAAG,IAAI;IAC9B,OAAO,IAAI,CAACO,OAAO,CAACW,kBAAkB,CAAC,CAAC;EAC5C;EACAC,oBAAoBA,CAAC5B,CAAC,EAAE;IACpB,IAAIA,CAAC,CAAC6B,cAAc,EAAE;MAClB,OAAO,IAAI,CAACb,OAAO,CAACY,oBAAoB,CAAC,CAAC;IAC9C;IACA,OAAO,KAAK;EAChB;EACAE,SAASA,CAAC9B,CAAC,EAAE;IACT,IAAI,IAAI,CAACc,cAAc,EAAE;MACrB,IAAI,CAACC,oBAAoB,GAAG,IAAI;IACpC;IACA,OAAO,IAAI,CAACC,OAAO,CAACc,SAAS,CAAC,CAAC;EACnC;EACAlG,cAAcA,CAACoE,CAAC,EAAE;IACd,IAAI,IAAI,CAACc,cAAc,EAAE;MACrB,MAAMiB,gBAAgB,GAAG,IAAI,CAACjB,cAAc,CAACvB,gCAAgC,CAACS,CAAC,CAACR,cAAc,EAAEQ,CAAC,CAACP,YAAY,CAAC;MAC/G,IAAIsC,gBAAgB,EAAE;QAClB,OAAO,IAAI,CAACf,OAAO,CAACpF,cAAc,CAACmG,gBAAgB,CAAC,CAAC,CAAC,EAAEA,gBAAgB,CAAC,CAAC,CAAC,CAAC;MAChF,CAAC,MACI;QACD,OAAO,KAAK;MAChB;IACJ,CAAC,MACI;MACD,OAAO,IAAI,CAACf,OAAO,CAACpF,cAAc,CAACoE,CAAC,CAACR,cAAc,EAAEQ,CAAC,CAACP,YAAY,CAAC;IACxE;EACJ;EACA1D,cAAcA,CAACiE,CAAC,EAAE;IACd,IAAI,IAAI,CAACc,cAAc,EAAE;MACrB,MAAM,CAACZ,gBAAgB,EAAEC,cAAc,CAAC,GAAG,IAAI,CAACW,cAAc,CAAC/E,cAAc,CAACiE,CAAC,CAAC;MAChF,IAAIE,gBAAgB,IAAIC,cAAc,EAAE;QACpC,IAAI,CAACa,OAAO,CAACpF,cAAc,CAACsE,gBAAgB,GAAG,CAAC,EAAEC,cAAc,GAAG,CAAC,CAAC;MACzE;MACA,IAAI,CAACY,oBAAoB,GAAG,IAAI;MAChC,OAAO,IAAI;IACf,CAAC,MACI;MACD,OAAO,IAAI,CAACC,OAAO,CAACjF,cAAc,CAACiE,CAAC,CAACR,cAAc,EAAEQ,CAAC,CAACP,YAAY,CAAC;IACxE;EACJ;EACAvD,eAAeA,CAAC8D,CAAC,EAAE;IACf,IAAI,IAAI,CAACc,cAAc,EAAE;MACrB,IAAI,CAACA,cAAc,CAAC5E,eAAe,CAAC8D,CAAC,CAAC;MACtC,IAAI,CAACe,oBAAoB,GAAG,IAAI;MAChC,OAAO,IAAI;IACf,CAAC,MACI;MACD,OAAO,IAAI,CAACC,OAAO,CAAC9E,eAAe,CAAC8D,CAAC,CAACR,cAAc,EAAEQ,CAAC,CAACP,YAAY,CAAC;IACzE;EACJ;EACAuC,eAAeA,CAAChC,CAAC,EAAE;IACf,OAAO,IAAI,CAACgB,OAAO,CAACgB,eAAe,CAAC,CAAC;EACzC;EACAC,cAAcA,CAACjC,CAAC,EAAE;IACd,IAAI,CAACU,QAAQ,CAACE,KAAK,CAACsB,2BAA2B,CAAC,CAAC;IACjD,IAAI,CAAClB,OAAO,CAACiB,cAAc,CAAC,CAAC;IAC7B,IAAI,CAACb,sBAAsB,CAAC,CAAC;IAC7B,OAAO,IAAI;EACf;EACA1G,eAAeA,CAACsF,CAAC,EAAE;IACf,IAAI,IAAI,CAACc,cAAc,EAAE;MACrB,IAAIzE,MAAM,GAAG,EAAE;MACf,KAAK,MAAM8F,KAAK,IAAInC,CAAC,CAAC3D,MAAM,EAAE;QAC1B,MAAM0F,gBAAgB,GAAG,IAAI,CAACjB,cAAc,CAACvB,gCAAgC,CAAC4C,KAAK,CAAC3C,cAAc,EAAE2C,KAAK,CAAC1C,YAAY,CAAC;QACvH,IAAIsC,gBAAgB,EAAE;UAClB1F,MAAM,CAAC6C,IAAI,CAAC;YAAEM,cAAc,EAAEuC,gBAAgB,CAAC,CAAC,CAAC;YAAEtC,YAAY,EAAEsC,gBAAgB,CAAC,CAAC;UAAE,CAAC,CAAC;QAC3F;MACJ;MACA,IAAI1F,MAAM,CAACX,MAAM,EAAE;QACf,OAAO,IAAI,CAACsF,OAAO,CAACtG,eAAe,CAAC2B,MAAM,CAAC;MAC/C,CAAC,MACI;QACD,OAAO,KAAK;MAChB;IACJ,CAAC,MACI;MACD,OAAO,IAAI,CAAC2E,OAAO,CAACtG,eAAe,CAACsF,CAAC,CAAC3D,MAAM,CAAC;IACjD;EACJ;EACA+F,qBAAqBA,CAACpC,CAAC,EAAE;IACrB,IAAI,CAACoB,sBAAsB,CAAC,CAAC;IAC7B,OAAO,IAAI,CAACJ,OAAO,CAACoB,qBAAqB,CAAC,CAAC;EAC/C;EACAC,cAAcA,CAACrC,CAAC,EAAE;IACd,OAAO,IAAI,CAACgB,OAAO,CAACqB,cAAc,CAAC,CAAC;EACxC;EACA;EACAC,aAAaA,CAAC/F,GAAG,EAAE;IACf,IAAI,IAAI,CAACwE,oBAAoB,EAAE;MAC3B,IAAI,CAACA,oBAAoB,GAAG,KAAK;MACjC,IAAI,CAACO,qBAAqB,CAAC,CAAC;IAChC;EACJ;EACAiB,MAAMA,CAAChG,GAAG,EAAE;IACR,IAAIpD,uBAAuB,GAAGoD,GAAG,CAACiG,YAAY,CAAC9J,eAAe;IAC9D,IAAIU,qBAAqB,GAAGmD,GAAG,CAACiG,YAAY,CAAC7J,aAAa;IAC1D,IAAI,IAAI,CAACmI,cAAc,EAAE;MACrB3H,uBAAuB,GAAG,IAAI,CAAC2H,cAAc,CAACzB,sBAAsB,CAAClG,uBAAuB,CAAC;MAC7FC,qBAAqB,GAAG,IAAI,CAAC0H,cAAc,CAACzB,sBAAsB,CAACjG,qBAAqB,CAAC;IAC7F;IACA,MAAMqJ,UAAU,GAAG;MACflJ,8BAA8B,EAAGgD,GAAG,CAACmG,YAAY,CAACC,sBAAsB,CAACjH,MAAM,GAAG,CAAE;MACpFkH,WAAW,EAAErG,GAAG,CAACqG,WAAW;MAC5BvK,YAAY,EAAEkE,GAAG,CAAClE,YAAY;MAC9Bc,uBAAuB,EAAEA,uBAAuB;MAChDC,qBAAqB,EAAEA,qBAAqB;MAC5CC,qCAAqC,EAAEkD,GAAG,CAACsG,8BAA8B,CAAC1J,uBAAuB,CAAC;MAClGf,SAAS,EAAEmE,GAAG,CAACnE,SAAS;MACxB0K,UAAU,EAAEvG,GAAG,CAACuG,UAAU;MAC1BC,aAAa,EAAExG,GAAG,CAACwG,aAAa;MAChCzJ,cAAc,EAAEiD,GAAG,CAACjD;IACxB,CAAC;IACD,IAAI,CAAC0H,OAAO,CAACuB,MAAM,CAACE,UAAU,CAAC;EACnC;EACA;EACAnB,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAACb,kBAAkB,GAAG,IAAI;IAC9B,MAAMuC,WAAW,GAAGC,OAAO,CAAC,IAAI,CAACnC,cAAc,CAAC;IAChD,MAAM,CAACH,aAAa,EAAEhC,MAAM,CAAC,GAAGjB,oBAAoB,CAACG,OAAO,CAAC,IAAI,CAAC1I,OAAO,EAAE,IAAI,CAACuL,QAAQ,CAACE,KAAK,CAACC,YAAY,CAAC,CAAC,EAAE,IAAI,CAACC,cAAc,CAAC;IACnI,IAAI,CAACA,cAAc,GAAGH,aAAa;IACnC,IAAIqC,WAAW,IAAI,IAAI,CAAClC,cAAc,EAAE;MACpC;MACA,KAAK,MAAMoC,KAAK,IAAIvE,MAAM,EAAE;QACxB,QAAQuE,KAAK,CAAClE,IAAI;UACd,KAAK,SAAS;YACV,IAAI,CAACgC,OAAO,CAACjF,cAAc,CAACmH,KAAK,CAAClH,oBAAoB,EAAEkH,KAAK,CAACjH,kBAAkB,CAAC;YACjF;UACJ,KAAK,UAAU;YACX,IAAI,CAAC+E,OAAO,CAAC9E,eAAe,CAACgH,KAAK,CAAC/G,oBAAoB,EAAE+G,KAAK,CAAC9G,kBAAkB,CAAC;YAClF;UACJ,KAAK,OAAO;YACR,IAAI,CAAC4E,OAAO,CAACc,SAAS,CAAC,CAAC;YACxB;QACR;MACJ;IACJ;EACJ;EACAjB,YAAYA,CAAA,EAAG;IACX,IAAI,IAAI,CAACC,cAAc,EAAE;MACrB,OAAO,IAAI,CAACA,cAAc,CAAClD,YAAY,CAAClC,MAAM;IAClD;IACA,OAAO,IAAI,CAACgF,QAAQ,CAACE,KAAK,CAACC,YAAY,CAAC,CAAC;EAC7C;EACAsC,gBAAgBA,CAAA,EAAG;IACf,OAAO,IAAI,CAACzC,QAAQ,CAACE,KAAK,CAACC,YAAY,CAAC,CAAC;EAC7C;EACAuC,cAAcA,CAAC9D,UAAU,EAAE;IACvB,IAAI,IAAI,CAACwB,cAAc,EAAE;MACrB,OAAO,IAAI,CAACJ,QAAQ,CAACE,KAAK,CAACwC,cAAc,CAAC,IAAI,CAACtC,cAAc,CAAClD,YAAY,CAAC0B,UAAU,GAAG,CAAC,CAAC,CAAC;IAC/F;IACA,OAAO,IAAI,CAACoB,QAAQ,CAACE,KAAK,CAACwC,cAAc,CAAC9D,UAAU,CAAC;EACzD;EACA+D,4BAA4BA,CAAC3K,eAAe,EAAEC,aAAa,EAAE2K,MAAM,EAAE;IACjE,IAAI,IAAI,CAACxC,cAAc,EAAE;MACrB,IAAI7D,MAAM,GAAG,EAAE;MACf,KAAK,IAAIsG,SAAS,GAAG,CAAC,EAAE/J,SAAS,GAAGb,aAAa,GAAGD,eAAe,GAAG,CAAC,EAAE6K,SAAS,GAAG/J,SAAS,EAAE+J,SAAS,EAAE,EAAE;QACzG,IAAID,MAAM,CAACC,SAAS,CAAC,EAAE;UACnBtG,MAAM,CAACsG,SAAS,CAAC,GAAG,IAAI,CAAC7C,QAAQ,CAACE,KAAK,CAAC4C,eAAe,CAAC,IAAI,CAAC1C,cAAc,CAAClD,YAAY,CAAClF,eAAe,GAAG6K,SAAS,GAAG,CAAC,CAAC,CAAC;QAC9H,CAAC,MACI;UACDtG,MAAM,CAACsG,SAAS,CAAC,GAAG,IAAI;QAC5B;MACJ;MACA,OAAOtG,MAAM;IACjB;IACA,OAAO,IAAI,CAACyD,QAAQ,CAACE,KAAK,CAACyC,4BAA4B,CAAC3K,eAAe,EAAEC,aAAa,EAAE2K,MAAM,CAAC,CAACpG,IAAI;EACxG;EACAuG,aAAaA,CAAA,EAAG;IACZ,IAAI,IAAI,CAAChD,kBAAkB,KAAK,IAAI,EAAE;MAClC,IAAI,IAAI,CAACK,cAAc,EAAE;QACrB,IAAI,CAACL,kBAAkB,GAAG,EAAE;QAC5B,KAAK,MAAMiD,SAAS,IAAI,IAAI,CAAClD,WAAW,EAAE;UACtC,MAAM,CAACV,gBAAgB,EAAEC,cAAc,CAAC,GAAG,IAAI,CAACe,cAAc,CAACjB,qCAAqC,CAAC6D,SAAS,CAAChL,eAAe,EAAEgL,SAAS,CAAC/K,aAAa,CAAC;UACxJ,IAAI,CAAC8H,kBAAkB,CAACvB,IAAI,CAAC,IAAI5K,SAAS,CAACwL,gBAAgB,EAAE4D,SAAS,CAACC,WAAW,EAAE5D,cAAc,EAAE2D,SAAS,CAACE,SAAS,CAAC,CAAC;QAC7H;MACJ,CAAC,MACI;QACD,IAAI,CAACnD,kBAAkB,GAAG,IAAI,CAACD,WAAW;MAC9C;IACJ;IACA,OAAO,IAAI,CAACC,kBAAkB;EAClC;EACAoD,+BAA+BA,CAACnL,eAAe,EAAEC,aAAa,EAAE;IAC5D,IAAI6J,YAAY;IAChB,IAAI,IAAI,CAAC1B,cAAc,EAAE;MACrB,MAAMgD,oBAAoB,GAAG,IAAI,CAAChD,cAAc,CAAClD,YAAY,CAAClF,eAAe,GAAG,CAAC,CAAC;MAClF,MAAMqL,kBAAkB,GAAG,IAAI,CAACjD,cAAc,CAAClD,YAAY,CAACjF,aAAa,GAAG,CAAC,CAAC;MAC9E6J,YAAY,GAAG,IAAI7O,KAAK,CAACmQ,oBAAoB,EAAE,CAAC,EAAEC,kBAAkB,EAAE,IAAI,CAACrD,QAAQ,CAACE,KAAK,CAACoD,gBAAgB,CAACD,kBAAkB,CAAC,CAAC;IACnI,CAAC,MACI;MACDvB,YAAY,GAAG,IAAI7O,KAAK,CAAC+E,eAAe,EAAE,CAAC,EAAEC,aAAa,EAAE,IAAI,CAAC+H,QAAQ,CAACE,KAAK,CAACoD,gBAAgB,CAACrL,aAAa,CAAC,CAAC;IACpH;IACA,MAAMsL,WAAW,GAAG,IAAI,CAACvD,QAAQ,CAACE,KAAK,CAACsD,wBAAwB,CAAC1B,YAAY,CAAC;IAC9E,IAAI,IAAI,CAAC1B,cAAc,EAAE;MACrB,IAAI7D,MAAM,GAAG,EAAE;MACf,KAAK,MAAMkH,UAAU,IAAIF,WAAW,EAAE;QAClC,IAAI,CAACE,UAAU,CAAChP,OAAO,CAACK,OAAO,EAAE;UAC7B;QACJ;QACA,MAAM2M,KAAK,GAAGgC,UAAU,CAAChC,KAAK;QAC9B,MAAMiC,sBAAsB,GAAG,IAAI,CAACtD,cAAc,CAACzB,sBAAsB,CAAC8C,KAAK,CAACzJ,eAAe,CAAC;QAChG,MAAM2L,oBAAoB,GAAG,IAAI,CAACvD,cAAc,CAACzB,sBAAsB,CAAC8C,KAAK,CAACxJ,aAAa,CAAC;QAC5FsE,MAAM,CAACiC,IAAI,CAAC,IAAIpL,mBAAmB,CAAC,IAAIH,KAAK,CAACyQ,sBAAsB,EAAEjC,KAAK,CAACwB,WAAW,EAAEU,oBAAoB,EAAElC,KAAK,CAACyB,SAAS,CAAC,EAAEO,UAAU,CAAChP,OAAO,CAAC,CAAC;MACzJ;MACA,OAAO8H,MAAM;IACjB;IACA,OAAOgH,WAAW;EACtB;EACAK,UAAUA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC5D,QAAQ,CAACE,KAAK,CAAC2D,mBAAmB,CAAC,CAAC;EACpD;EACAC,gBAAgBA,CAAClF,UAAU,EAAE;IACzB,IAAI,IAAI,CAACwB,cAAc,EAAE;MACrBxB,UAAU,GAAG,IAAI,CAACwB,cAAc,CAAClD,YAAY,CAAC0B,UAAU,GAAG,CAAC,CAAC;IACjE;IACA,IAAI,CAACoB,QAAQ,CAACE,KAAK,CAAC6D,WAAW,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI9Q,KAAK,CAAC2L,UAAU,EAAE,CAAC,EAAEA,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,YAAY,CAAC;EAC5H;;EACAoF,YAAYA,CAACtM,SAAS,EAAE;IACpB,IAAI,CAACsI,QAAQ,CAACE,KAAK,CAAC+D,iBAAiB,CAAC;MAClCvM,SAAS,EAAEA;IACf,CAAC,EAAE,CAAC,CAAC,eAAe,CAAC;EACzB;AACJ;;AACA,MAAM6I,YAAY,SAAS9N,UAAU,CAAC;EAClC4B,WAAWA,CAACE,KAAK,EAAE2L,KAAK,EAAE;IACtB,KAAK,CAAC,CAAC;IACP,IAAI,CAACgE,kBAAkB,GAAG,KAAK;IAC/B,IAAI,CAACC,kBAAkB,GAAG,KAAK;IAC/B,IAAI,CAACC,MAAM,GAAG7P,KAAK;IACnB,IAAI,CAAC8P,MAAM,GAAGnE,KAAK;IACnB,IAAI,CAACoE,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACnI,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACoI,eAAe,GAAG,IAAI,CAACH,MAAM,CAACnN,QAAQ,CAAC5D,gBAAgB,CAAC;IAC7D,IAAI,CAACmR,QAAQ,GAAGlS,iBAAiB,CAACmS,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC,CAAC;IAChE7R,gBAAgB,CAAC8R,KAAK,CAAC,IAAI,CAACH,QAAQ,EAAE,CAAC,CAAC,aAAa,CAAC;IACtD,IAAI,CAACA,QAAQ,CAACI,YAAY,CAAC,IAAI,CAACC,2BAA2B,CAAC,CAAC,CAAC;IAC9D,IAAI,CAACL,QAAQ,CAACM,WAAW,CAAC,UAAU,CAAC;IACrC,IAAI,CAACN,QAAQ,CAACO,YAAY,CAAC,MAAM,EAAE,cAAc,CAAC;IAClD,IAAI,CAACP,QAAQ,CAACO,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC;IACjD,IAAI,CAACC,OAAO,GAAG1S,iBAAiB,CAACmS,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC,CAAC;IAC/D,IAAI,CAACM,OAAO,CAACJ,YAAY,CAAC,uBAAuB,CAAC;IAClD,IAAI,CAACJ,QAAQ,CAACS,WAAW,CAAC,IAAI,CAACD,OAAO,CAAC;IACvC,IAAI,CAACE,OAAO,GAAG5S,iBAAiB,CAACmS,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC,CAAC;IAClE,IAAI,CAACQ,OAAO,CAACJ,WAAW,CAAC,UAAU,CAAC;IACpC,IAAI,CAACI,OAAO,CAACC,OAAO,CAAC,CAAC,CAAC;IACvB,IAAI,CAACX,QAAQ,CAACS,WAAW,CAAC,IAAI,CAACC,OAAO,CAAC;IACvC,IAAI,CAACE,kBAAkB,GAAG9S,iBAAiB,CAACmS,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC,CAAC;IAC7E,IAAI,CAACU,kBAAkB,CAACN,WAAW,CAAC,UAAU,CAAC;IAC/C,IAAI,CAACM,kBAAkB,CAACR,YAAY,CAAC,2BAA2B,CAAC;IACjE,IAAI,CAACQ,kBAAkB,CAACD,OAAO,CAAC,CAAC,CAAC;IAClC,IAAI,CAACX,QAAQ,CAACS,WAAW,CAAC,IAAI,CAACG,kBAAkB,CAAC;IAClD,IAAI,CAACC,OAAO,GAAG/S,iBAAiB,CAACmS,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC,CAAC;IAC/D,IAAI,CAACW,OAAO,CAACP,WAAW,CAAC,UAAU,CAAC;IACpC,IAAI,CAACO,OAAO,CAACT,YAAY,CAAC,gBAAgB,CAAC;IAC3C,IAAI,CAACS,OAAO,CAACC,eAAe,CAAC,IAAI,CAAC;IAClC,IAAI,CAACD,OAAO,CAACE,UAAU,CAAC,QAAQ,CAAC;IACjC,IAAI,CAACf,QAAQ,CAACS,WAAW,CAAC,IAAI,CAACI,OAAO,CAAC;IACvC,IAAI,CAACG,iBAAiB,GAAGlT,iBAAiB,CAACmS,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC,CAAC;IACzE,IAAI,CAACc,iBAAiB,CAACV,WAAW,CAAC,UAAU,CAAC;IAC9C,IAAI,CAACU,iBAAiB,CAACZ,YAAY,CAAC,2BAA2B,CAAC;IAChE,IAAI,CAACS,OAAO,CAACJ,WAAW,CAAC,IAAI,CAACO,iBAAiB,CAAC;IAChD,IAAI,CAACC,YAAY,CAAC,CAAC;IACnB,IAAI,CAACC,kBAAkB,GAAGrT,GAAG,CAACsT,6BAA6B,CAAC,IAAI,CAACnB,QAAQ,CAACoB,OAAO,EAAE,WAAW,EAAGtG,CAAC,IAAK;MACnGA,CAAC,CAACuG,cAAc,CAAC,CAAC;MAClB,MAAM5Q,aAAa,GAAG,IAAI,CAACoP,MAAM,CAAC5P,OAAO,CAACQ,aAAa;MACvD,IAAIA,aAAa,KAAK,CAAC,CAAC,YAAY;QAChC;MACJ;MACA,IAAI,CAAC,IAAI,CAACqP,eAAe,EAAE;QACvB;MACJ;MACA,IAAI,IAAI,CAACD,MAAM,CAAC5P,OAAO,CAACS,IAAI,KAAK,cAAc,EAAE;QAC7C,IAAIoK,CAAC,CAACwG,UAAU,IAAI,IAAI,CAACxB,eAAe,EAAE;UACtC;UACA,MAAMyB,QAAQ,GAAG1T,GAAG,CAAC2T,sBAAsB,CAAC,IAAI,CAACX,OAAO,CAACO,OAAO,CAAC;UACjE,MAAMK,WAAW,GAAGF,QAAQ,CAACG,GAAG,GAAGH,QAAQ,CAACpQ,MAAM,GAAG,CAAC;UACtD,IAAI,CAACwQ,oBAAoB,CAAC7G,CAAC,CAAC8G,OAAO,EAAE9G,CAAC,CAAC+G,IAAI,EAAEJ,WAAW,EAAE3G,CAAC,CAACgH,IAAI,EAAE,IAAI,CAAChC,eAAe,CAACnK,cAAc,CAAC;QAC1G;QACA;MACJ;MACA,MAAM1D,iBAAiB,GAAG,IAAI,CAAC4N,MAAM,CAAC5P,OAAO,CAACgC,iBAAiB;MAC/D,MAAM8P,eAAe,GAAI,IAAI,CAAClC,MAAM,CAAC5P,OAAO,CAACqB,iBAAiB,GAAG,IAAI,CAACuO,MAAM,CAAC5P,OAAO,CAACyB,iBAAiB,GAAIoJ,CAAC,CAACkH,YAAY,CAACC,OAAO;MAChI,MAAM5D,SAAS,GAAGxK,IAAI,CAACa,KAAK,CAACqN,eAAe,GAAG9P,iBAAiB,CAAC;MACjE,IAAImI,UAAU,GAAGiE,SAAS,GAAG,IAAI,CAACyB,eAAe,CAACnK,cAAc,CAACnC,eAAe;MAChF4G,UAAU,GAAGvG,IAAI,CAACkB,GAAG,CAACqF,UAAU,EAAE,IAAI,CAACyF,MAAM,CAAClE,YAAY,CAAC,CAAC,CAAC;MAC7D,IAAI,CAACkE,MAAM,CAACP,gBAAgB,CAAClF,UAAU,CAAC;IAC5C,CAAC,CAAC;IACF,IAAI,CAAC8H,uBAAuB,GAAG,IAAInU,sBAAsB,CAAC,CAAC;IAC3D,IAAI,CAACoU,wBAAwB,GAAGtU,GAAG,CAACsT,6BAA6B,CAAC,IAAI,CAACN,OAAO,CAACO,OAAO,EAAE,WAAW,EAAGtG,CAAC,IAAK;MACxGA,CAAC,CAACuG,cAAc,CAAC,CAAC;MAClBvG,CAAC,CAACsH,eAAe,CAAC,CAAC;MACnB,IAAItH,CAAC,CAACwG,UAAU,IAAI,IAAI,CAACxB,eAAe,EAAE;QACtC,IAAI,CAAC6B,oBAAoB,CAAC7G,CAAC,CAAC8G,OAAO,EAAE9G,CAAC,CAAC+G,IAAI,EAAE/G,CAAC,CAACgH,IAAI,EAAEhH,CAAC,CAACgH,IAAI,EAAE,IAAI,CAAChC,eAAe,CAACnK,cAAc,CAAC;MACrG;IACJ,CAAC,CAAC;IACF,IAAI,CAAC0M,kBAAkB,GAAG/S,OAAO,CAACgT,SAAS,CAAC,IAAI,CAACtC,QAAQ,CAACoB,OAAO,CAAC;IAClE,IAAI,CAACmB,yBAAyB,GAAG1U,GAAG,CAAC2U,qBAAqB,CAAC,IAAI,CAACxC,QAAQ,CAACoB,OAAO,EAAE/R,SAAS,CAACoT,KAAK,EAAG3H,CAAC,IAAK;MACtGA,CAAC,CAACuG,cAAc,CAAC,CAAC;MAClBvG,CAAC,CAACsH,eAAe,CAAC,CAAC;MACnB,IAAI,IAAI,CAACtC,eAAe,EAAE;QACtB,IAAI,CAACe,OAAO,CAAC6B,eAAe,CAAC,QAAQ,EAAE,IAAI,CAAC;QAC5C,IAAI,CAAC/C,kBAAkB,GAAG,IAAI;QAC9B,IAAI,CAACgD,qBAAqB,CAAC7H,CAAC,CAAC;MACjC;IACJ,CAAC,EAAE;MAAE8H,OAAO,EAAE;IAAM,CAAC,CAAC;IACtB,IAAI,CAACC,wBAAwB,GAAGhV,GAAG,CAAC2U,qBAAqB,CAAC,IAAI,CAACxC,QAAQ,CAACoB,OAAO,EAAE/R,SAAS,CAACyT,MAAM,EAAGhI,CAAC,IAAK;MACtGA,CAAC,CAACuG,cAAc,CAAC,CAAC;MAClBvG,CAAC,CAACsH,eAAe,CAAC,CAAC;MACnB,IAAI,IAAI,CAACtC,eAAe,IAAI,IAAI,CAACH,kBAAkB,EAAE;QACjD,IAAI,CAACgD,qBAAqB,CAAC7H,CAAC,CAAC;MACjC;IACJ,CAAC,EAAE;MAAE8H,OAAO,EAAE;IAAM,CAAC,CAAC;IACtB,IAAI,CAACG,uBAAuB,GAAGlV,GAAG,CAACsT,6BAA6B,CAAC,IAAI,CAACnB,QAAQ,CAACoB,OAAO,EAAE/R,SAAS,CAAC2T,GAAG,EAAGlI,CAAC,IAAK;MAC1GA,CAAC,CAACuG,cAAc,CAAC,CAAC;MAClBvG,CAAC,CAACsH,eAAe,CAAC,CAAC;MACnB,IAAI,CAACzC,kBAAkB,GAAG,KAAK;MAC/B,IAAI,CAACkB,OAAO,CAAC6B,eAAe,CAAC,QAAQ,EAAE,KAAK,CAAC;IACjD,CAAC,CAAC;EACN;EACAf,oBAAoBA,CAACsB,cAAc,EAAEC,WAAW,EAAEzB,WAAW,EAAEK,IAAI,EAAEqB,kBAAkB,EAAE;IACrF,IAAI,CAACtC,OAAO,CAAC6B,eAAe,CAAC,QAAQ,EAAE,IAAI,CAAC;IAC5C,MAAMU,eAAe,GAAGA,CAACtB,IAAI,EAAED,IAAI,KAAK;MACpC,MAAMwB,oBAAoB,GAAGxP,IAAI,CAACyP,GAAG,CAACzB,IAAI,GAAGqB,WAAW,CAAC;MACzD,IAAIhV,QAAQ,CAACqV,SAAS,IAAIF,oBAAoB,GAAG3T,yBAAyB,EAAE;QACxE;QACA,IAAI,CAACmQ,MAAM,CAACL,YAAY,CAAC2D,kBAAkB,CAACjQ,SAAS,CAAC;QACtD;MACJ;MACA,MAAMsQ,UAAU,GAAG1B,IAAI,GAAGL,WAAW;MACrC,IAAI,CAAC5B,MAAM,CAACL,YAAY,CAAC2D,kBAAkB,CAACxP,4BAA4B,CAAC6P,UAAU,CAAC,CAAC;IACzF,CAAC;IACD,IAAI1B,IAAI,KAAKL,WAAW,EAAE;MACtB2B,eAAe,CAACtB,IAAI,EAAEoB,WAAW,CAAC;IACtC;IACA,IAAI,CAAChB,uBAAuB,CAACuB,eAAe,CAAC,IAAI,CAAC5C,OAAO,CAACO,OAAO,EAAE6B,cAAc,EAAEjV,uBAAuB,EAAG0V,aAAa,IAAKN,eAAe,CAACM,aAAa,CAAC5B,IAAI,EAAE4B,aAAa,CAAC7B,IAAI,CAAC,EAAE,MAAM;MAC1L,IAAI,CAAChB,OAAO,CAAC6B,eAAe,CAAC,QAAQ,EAAE,KAAK,CAAC;IACjD,CAAC,CAAC;EACN;EACAC,qBAAqBA,CAACgB,KAAK,EAAE;IACzB,MAAMC,MAAM,GAAG,IAAI,CAAC5D,QAAQ,CAACoB,OAAO,CAACyC,qBAAqB,CAAC,CAAC,CAACnC,GAAG;IAChE,MAAMxO,SAAS,GAAG,IAAI,CAAC4M,eAAe,CAACnK,cAAc,CAAC5B,oCAAoC,CAAC4P,KAAK,CAAC3P,KAAK,GAAG4P,MAAM,CAAC;IAChH,IAAI,CAAC/D,MAAM,CAACL,YAAY,CAACtM,SAAS,CAAC;EACvC;EACA8I,OAAOA,CAAA,EAAG;IACN,IAAI,CAACkF,kBAAkB,CAAClF,OAAO,CAAC,CAAC;IACjC,IAAI,CAACkG,uBAAuB,CAAClG,OAAO,CAAC,CAAC;IACtC,IAAI,CAACmG,wBAAwB,CAACnG,OAAO,CAAC,CAAC;IACvC,IAAI,CAACqG,kBAAkB,CAACrG,OAAO,CAAC,CAAC;IACjC,IAAI,CAACuG,yBAAyB,CAACvG,OAAO,CAAC,CAAC;IACxC,IAAI,CAAC6G,wBAAwB,CAAC7G,OAAO,CAAC,CAAC;IACvC,IAAI,CAAC+G,uBAAuB,CAAC/G,OAAO,CAAC,CAAC;IACtC,KAAK,CAACA,OAAO,CAAC,CAAC;EACnB;EACAqE,2BAA2BA,CAAA,EAAG;IAC1B,IAAI,IAAI,CAACR,MAAM,CAAC5P,OAAO,CAACY,UAAU,KAAK,QAAQ,EAAE;MAC7C,OAAO,uBAAuB;IAClC;IACA,OAAO,0BAA0B;EACrC;EACAoL,UAAUA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC+D,QAAQ;EACxB;EACAiB,YAAYA,CAAA,EAAG;IACX,IAAI,CAACjB,QAAQ,CAACW,OAAO,CAAC,IAAI,CAACd,MAAM,CAAC5P,OAAO,CAACe,WAAW,CAAC;IACtD,IAAI,CAACgP,QAAQ,CAAC8D,QAAQ,CAAC,IAAI,CAACjE,MAAM,CAAC5P,OAAO,CAACgB,YAAY,CAAC;IACxD,IAAI,CAAC+O,QAAQ,CAAC+D,SAAS,CAAC,IAAI,CAAClE,MAAM,CAAC5P,OAAO,CAACiB,aAAa,CAAC;IAC1D,IAAI,CAACsP,OAAO,CAACuD,SAAS,CAAC,IAAI,CAAClE,MAAM,CAAC5P,OAAO,CAACiB,aAAa,CAAC;IACzD,IAAI,CAACwP,OAAO,CAACoD,QAAQ,CAAC,IAAI,CAACjE,MAAM,CAAC5P,OAAO,CAACuB,gBAAgB,CAAC;IAC3D,IAAI,CAACkP,OAAO,CAACqD,SAAS,CAAC,IAAI,CAAClE,MAAM,CAAC5P,OAAO,CAACyB,iBAAiB,CAAC;IAC7D,IAAI,CAACgP,OAAO,CAACU,OAAO,CAAC4C,KAAK,GAAG,IAAI,CAACnE,MAAM,CAAC5P,OAAO,CAACmB,gBAAgB;IACjE,IAAI,CAACsP,OAAO,CAACU,OAAO,CAACjQ,MAAM,GAAG,IAAI,CAAC0O,MAAM,CAAC5P,OAAO,CAACqB,iBAAiB;IACnE,IAAI,CAACsP,kBAAkB,CAACkD,QAAQ,CAAC,IAAI,CAACjE,MAAM,CAAC5P,OAAO,CAACuB,gBAAgB,CAAC;IACtE,IAAI,CAACoP,kBAAkB,CAACmD,SAAS,CAAC,IAAI,CAAClE,MAAM,CAAC5P,OAAO,CAACyB,iBAAiB,CAAC;IACxE,IAAI,CAACkP,kBAAkB,CAACQ,OAAO,CAAC4C,KAAK,GAAG,IAAI,CAACnE,MAAM,CAAC5P,OAAO,CAACmB,gBAAgB;IAC5E,IAAI,CAACwP,kBAAkB,CAACQ,OAAO,CAACjQ,MAAM,GAAG,IAAI,CAAC0O,MAAM,CAAC5P,OAAO,CAACqB,iBAAiB;IAC9E,IAAI,CAACuP,OAAO,CAACiD,QAAQ,CAAC,IAAI,CAACjE,MAAM,CAAC5P,OAAO,CAACgB,YAAY,CAAC;EAC3D;EACAgT,UAAUA,CAAA,EAAG;IACT,IAAI,CAAC,IAAI,CAACtM,QAAQ,EAAE;MAChB,IAAI,IAAI,CAACkI,MAAM,CAAC5P,OAAO,CAACmB,gBAAgB,GAAG,CAAC,IAAI,IAAI,CAACyO,MAAM,CAAC5P,OAAO,CAACqB,iBAAiB,GAAG,CAAC,EAAE;QACvF,IAAI,CAACqG,QAAQ,GAAG,IAAIP,cAAc,CAAC,IAAI,CAACsJ,OAAO,CAACU,OAAO,CAAC8C,UAAU,CAAC,IAAI,CAAC,EAAE,IAAI,CAACrE,MAAM,CAAC5P,OAAO,CAACmB,gBAAgB,EAAE,IAAI,CAACyO,MAAM,CAAC5P,OAAO,CAACqB,iBAAiB,EAAE,IAAI,CAACuO,MAAM,CAAC5P,OAAO,CAACqC,eAAe,CAAC;MAC/L;IACJ;IACA,OAAO,IAAI,CAACqF,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACG,SAAS,CAAC,CAAC,GAAG,IAAI;EAC3D;EACA;EACAuE,kBAAkBA,CAAA,EAAG;IACjB,IAAI,CAACyD,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACnI,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACsJ,YAAY,CAAC,CAAC;IACnB,IAAI,CAACjB,QAAQ,CAACI,YAAY,CAAC,IAAI,CAACC,2BAA2B,CAAC,CAAC,CAAC;EAClE;EACA5D,kBAAkBA,CAAA,EAAG;IACjB,IAAI,CAACiD,kBAAkB,GAAG,IAAI;IAC9B,OAAO,IAAI;EACf;EACAhD,oBAAoBA,CAAA,EAAG;IACnB,IAAI,CAACgD,kBAAkB,GAAG,IAAI;IAC9B,OAAO,IAAI;EACf;EACA9C,SAASA,CAAA,EAAG;IACR,IAAI,CAACkD,eAAe,GAAG,IAAI;IAC3B,OAAO,IAAI;EACf;EACApJ,cAAcA,CAACC,oBAAoB,EAAEC,kBAAkB,EAAE;IACrD,IAAI,IAAI,CAACkJ,eAAe,EAAE;MACtB,OAAO,IAAI,CAACA,eAAe,CAACpJ,cAAc,CAACC,oBAAoB,EAAEC,kBAAkB,CAAC;IACxF;IACA,OAAO,KAAK;EAChB;EACAC,cAAcA,CAACC,oBAAoB,EAAEC,kBAAkB,EAAE;IACrD,IAAI,IAAI,CAAC+I,eAAe,EAAE;MACtB,IAAI,CAACA,eAAe,CAACjJ,cAAc,CAACC,oBAAoB,EAAEC,kBAAkB,CAAC;IACjF;IACA,OAAO,IAAI;EACf;EACAC,eAAeA,CAACC,oBAAoB,EAAEC,kBAAkB,EAAE;IACtD,IAAI,IAAI,CAAC4I,eAAe,EAAE;MACtB,IAAI,CAACA,eAAe,CAAC9I,eAAe,CAACC,oBAAoB,EAAEC,kBAAkB,CAAC;IAClF;IACA,OAAO,IAAI;EACf;EACA4F,eAAeA,CAAA,EAAG;IACd,IAAI,CAAC4C,kBAAkB,GAAG,IAAI;IAC9B,OAAO,IAAI;EACf;EACA3C,cAAcA,CAAA,EAAG;IACb,IAAI,CAACgD,eAAe,GAAG,IAAI,CAACH,MAAM,CAACnN,QAAQ,CAAC5D,gBAAgB,CAAC;IAC7D,IAAI,CAAC6Q,kBAAkB,GAAG,IAAI;IAC9B,OAAO,IAAI;EACf;EACAlK,eAAeA,CAAC2B,MAAM,EAAE;IACpB,IAAI,IAAI,CAAC2I,eAAe,EAAE;MACtB,OAAO,IAAI,CAACA,eAAe,CAACtK,eAAe,CAAC2B,MAAM,CAAC;IACvD;IACA,OAAO,KAAK;EAChB;EACA+F,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAAC4C,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACnI,QAAQ,GAAG,IAAI;IACpB,OAAO,IAAI;EACf;EACAwF,cAAcA,CAAA,EAAG;IACb,IAAI,CAAC2C,eAAe,GAAG,IAAI;IAC3B,OAAO,IAAI;EACf;EACA;EACAzC,MAAMA,CAAC8G,YAAY,EAAE;IACjB,MAAM1T,aAAa,GAAG,IAAI,CAACoP,MAAM,CAAC5P,OAAO,CAACQ,aAAa;IACvD,IAAIA,aAAa,KAAK,CAAC,CAAC,YAAY;MAChC,IAAI,CAAC+P,OAAO,CAACJ,YAAY,CAAC,uBAAuB,CAAC;MAClD,IAAI,CAACY,iBAAiB,CAAC8C,QAAQ,CAAC,CAAC,CAAC;MAClC,IAAI,CAAC9C,iBAAiB,CAAC+C,SAAS,CAAC,CAAC,CAAC;MACnC;IACJ;IACA,IAAII,YAAY,CAACvG,UAAU,GAAGuG,YAAY,CAACtG,aAAa,IAAIsG,YAAY,CAACzG,WAAW,EAAE;MAClF,IAAI,CAAC8C,OAAO,CAACJ,YAAY,CAAC,uBAAuB,CAAC;IACtD,CAAC,MACI;MACD,IAAI,CAACI,OAAO,CAACJ,YAAY,CAAC,wBAAwB,CAAC;IACvD;IACA,MAAMlK,MAAM,GAAGjD,aAAa,CAACb,MAAM,CAAC,IAAI,CAACyN,MAAM,CAAC5P,OAAO,EAAEkU,YAAY,CAAClQ,uBAAuB,EAAEkQ,YAAY,CAACjQ,qBAAqB,EAAEiQ,YAAY,CAAChQ,qCAAqC,EAAEgQ,YAAY,CAAC/P,cAAc,EAAE+P,YAAY,CAAC9P,8BAA8B,EAAE,IAAI,CAACwL,MAAM,CAAClE,YAAY,CAAC,CAAC,EAAE,IAAI,CAACkE,MAAM,CAAC5B,gBAAgB,CAAC,CAAC,EAAEkG,YAAY,CAACjR,SAAS,EAAEiR,YAAY,CAAChR,YAAY,EAAE,IAAI,CAAC2M,eAAe,GAAG,IAAI,CAACA,eAAe,CAACnK,cAAc,GAAG,IAAI,CAAC;IAClb,IAAI,CAACkL,OAAO,CAACuD,UAAU,CAAClO,MAAM,CAAC9C,YAAY,GAAG,OAAO,GAAG,MAAM,CAAC;IAC/D,IAAI,CAACyN,OAAO,CAACwD,MAAM,CAACnO,MAAM,CAAC5C,SAAS,CAAC;IACrC,IAAI,CAACuN,OAAO,CAACkD,SAAS,CAAC7N,MAAM,CAAC3C,YAAY,CAAC;IAC3C;IACA,MAAM+Q,eAAe,GAAGH,YAAY,CAACvG,UAAU,GAAG,IAAI,CAACiC,MAAM,CAAC5P,OAAO,CAACa,8BAA8B;IACpG,MAAMyT,oBAAoB,GAAG1Q,IAAI,CAACkB,GAAG,CAAC,IAAI,CAAC8K,MAAM,CAAC5P,OAAO,CAACgB,YAAY,EAAE4C,IAAI,CAACC,KAAK,CAACwQ,eAAe,GAAG,IAAI,CAACzE,MAAM,CAAC5P,OAAO,CAACiC,gBAAgB,GAAG,IAAI,CAAC2N,MAAM,CAAC5P,OAAO,CAACC,UAAU,CAAC,CAAC;IAC5K,IAAI,CAAC8Q,iBAAiB,CAACL,OAAO,CAAC4D,oBAAoB,CAAC;IACpD,IAAI,CAACvD,iBAAiB,CAAC8C,QAAQ,CAAC,IAAI,CAACjE,MAAM,CAAC5P,OAAO,CAACgB,YAAY,GAAGsT,oBAAoB,CAAC;IACxF,IAAI,CAACvD,iBAAiB,CAACqD,MAAM,CAAC,CAAC,CAAC;IAChC,IAAI,CAACrD,iBAAiB,CAAC+C,SAAS,CAAC7N,MAAM,CAAC3C,YAAY,CAAC;IACrD,IAAI,CAACiR,iBAAiB,CAACtO,MAAM,CAAC;IAC9B,IAAI,CAAC4J,eAAe,GAAG,IAAI,CAAC2E,WAAW,CAACvO,MAAM,CAAC;EACnD;EACAsO,iBAAiBA,CAACtO,MAAM,EAAE;IACtB,IAAI,IAAI,CAACwJ,kBAAkB,EAAE;MACzB,IAAI,CAACA,kBAAkB,GAAG,KAAK;MAC/B,MAAMlD,UAAU,GAAG,IAAI,CAACqD,MAAM,CAACtB,aAAa,CAAC,CAAC;MAC9C,MAAMQ,WAAW,GAAG,IAAI,CAACc,MAAM,CAAClB,+BAA+B,CAACzI,MAAM,CAAC1C,eAAe,EAAE0C,MAAM,CAACzC,aAAa,CAAC;MAC7G,MAAM;QAAErC,gBAAgB;QAAEE;MAAkB,CAAC,GAAG,IAAI,CAACuO,MAAM,CAAC5P,OAAO;MACnE,MAAMc,UAAU,GAAG,IAAI,CAAC8O,MAAM,CAAC5P,OAAO,CAACgC,iBAAiB;MACxD,MAAMyS,cAAc,GAAG,IAAI,CAAC7E,MAAM,CAAC5P,OAAO,CAACiC,gBAAgB;MAC3D,MAAMyS,OAAO,GAAG,IAAI,CAAC9E,MAAM,CAACT,UAAU,CAAC,CAAC,CAACuF,OAAO;MAChD,MAAMC,aAAa,GAAG,IAAI,CAAChE,kBAAkB,CAACQ,OAAO,CAAC8C,UAAU,CAAC,IAAI,CAAC;MACtEU,aAAa,CAACC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEzT,gBAAgB,EAAEE,iBAAiB,CAAC;MAClE,MAAMwT,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;MAC/B,KAAK,IAAIzO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkG,UAAU,CAAChG,MAAM,EAAEF,CAAC,EAAE,EAAE;QACxC,MAAMkI,SAAS,GAAGhC,UAAU,CAAClG,CAAC,CAAC;QAC/B,KAAK,IAAI0O,IAAI,GAAGxG,SAAS,CAAChL,eAAe,EAAEwR,IAAI,IAAIxG,SAAS,CAAC/K,aAAa,EAAEuR,IAAI,EAAE,EAAE;UAChF,IAAI,CAACC,sBAAsB,CAACL,aAAa,EAAEE,aAAa,EAAEtG,SAAS,EAAE,IAAI,CAACuB,eAAe,EAAE7J,MAAM,EAAE8O,IAAI,EAAEjU,UAAU,EAAEA,UAAU,EAAE4T,OAAO,EAAED,cAAc,CAAC;QAC7J;MACJ;MACA;MACA,KAAK,IAAIpO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyI,WAAW,CAACvI,MAAM,EAAEF,CAAC,EAAE,EAAE;QACzC,MAAM2I,UAAU,GAAGF,WAAW,CAACzI,CAAC,CAAC;QACjC,IAAI,CAAC2I,UAAU,CAAChP,OAAO,CAACK,OAAO,EAAE;UAC7B;QACJ;QACA,MAAM4U,eAAe,GAAGjG,UAAU,CAAChP,OAAO,CAACK,OAAO,CAACmC,QAAQ,CAAC,IAAI,CAACmN,MAAM,CAAC;QACxE,KAAK,IAAIoF,IAAI,GAAG/F,UAAU,CAAChC,KAAK,CAACzJ,eAAe,EAAEwR,IAAI,IAAI/F,UAAU,CAAChC,KAAK,CAACxJ,aAAa,EAAEuR,IAAI,EAAE,EAAE;UAC9F,QAAQ/F,UAAU,CAAChP,OAAO,CAACK,OAAO,CAACiR,QAAQ;YACvC,KAAK/R,eAAe,CAAC2V,MAAM;cACvB,IAAI,CAACF,sBAAsB,CAACL,aAAa,EAAEE,aAAa,EAAE7F,UAAU,CAAChC,KAAK,EAAEiI,eAAe,EAAEhP,MAAM,EAAE8O,IAAI,EAAEjU,UAAU,EAAEA,UAAU,EAAE4T,OAAO,EAAED,cAAc,CAAC;cAC3J;YACJ,KAAKlV,eAAe,CAAC4V,MAAM;cACvB,MAAMC,CAAC,GAAG,CAACL,IAAI,GAAG9O,MAAM,CAAC1C,eAAe,IAAIzC,UAAU;cACtD,MAAMuU,CAAC,GAAG,CAAC;cACX,IAAI,CAACC,gBAAgB,CAACX,aAAa,EAAEM,eAAe,EAAEI,CAAC,EAAED,CAAC,EAAE1V,uBAAuB,EAAEoB,UAAU,CAAC;cAChG;UACR;QACJ;MACJ;IACJ;EACJ;EACAkU,sBAAsBA,CAACL,aAAa,EAAEE,aAAa,EAAEU,eAAe,EAAEN,eAAe,EAAEhP,MAAM,EAAEkE,UAAU,EAAEjJ,MAAM,EAAEJ,UAAU,EAAE4T,OAAO,EAAEc,SAAS,EAAE;IAC/I,MAAMJ,CAAC,GAAG,CAACjL,UAAU,GAAGlE,MAAM,CAAC1C,eAAe,IAAIzC,UAAU;IAC5D;IACA,IAAIsU,CAAC,GAAGlU,MAAM,GAAG,CAAC,IAAIkU,CAAC,GAAG,IAAI,CAACxF,MAAM,CAAC5P,OAAO,CAACqB,iBAAiB,EAAE;MAC7D;IACJ;IACA;IACA,IAAIoU,kBAAkB,GAAGZ,aAAa,CAAC3U,GAAG,CAACiK,UAAU,CAAC;IACtD,MAAMuL,wBAAwB,GAAG,CAACD,kBAAkB;IACpD,IAAI,CAACA,kBAAkB,EAAE;MACrB,MAAME,QAAQ,GAAG,IAAI,CAAC/F,MAAM,CAAC3B,cAAc,CAAC9D,UAAU,CAAC;MACvDsL,kBAAkB,GAAG,CAACnX,oBAAoB,CAAC;MAC3C,KAAK,IAAI+H,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsP,QAAQ,CAACpP,MAAM,GAAG,CAAC,EAAEF,CAAC,EAAE,EAAE;QAC1C,MAAMuP,QAAQ,GAAGD,QAAQ,CAACE,UAAU,CAACxP,CAAC,GAAG,CAAC,CAAC;QAC3C,MAAMyP,EAAE,GAAGF,QAAQ,KAAK,CAAC,CAAC,YACpBlB,OAAO,GAAGc,SAAS,GACnBtX,OAAO,CAAC6X,oBAAoB,CAACH,QAAQ,CAAC,GAClC,CAAC,GAAGJ,SAAS,GACbA,SAAS;QACnBC,kBAAkB,CAACpP,CAAC,CAAC,GAAGoP,kBAAkB,CAACpP,CAAC,GAAG,CAAC,CAAC,GAAGyP,EAAE;MAC1D;MACAjB,aAAa,CAAC7M,GAAG,CAACmC,UAAU,EAAEsL,kBAAkB,CAAC;IACrD;IACA,MAAM;MAAEjH,WAAW;MAAEC,SAAS;MAAElL,eAAe;MAAEC;IAAc,CAAC,GAAG+R,eAAe;IAClF,MAAMF,CAAC,GAAG9R,eAAe,KAAK4G,UAAU,GAAGsL,kBAAkB,CAACjH,WAAW,GAAG,CAAC,CAAC,GAAGlQ,oBAAoB;IACrG,MAAM0X,gBAAgB,GAAGxS,aAAa,GAAG2G,UAAU,GAAGsL,kBAAkB,CAAClP,MAAM,GAAG,CAAC,GAAGkI,SAAS,GAAG,CAAC;IACnG,IAAIuH,gBAAgB,GAAG,CAAC,EAAE;MACtB;MACA,MAAMjC,KAAK,GAAG0B,kBAAkB,CAACO,gBAAgB,CAAC,GAAGX,CAAC,IAAI,CAAC;MAC3D,IAAI,CAACC,gBAAgB,CAACX,aAAa,EAAEM,eAAe,EAAEI,CAAC,EAAED,CAAC,EAAErB,KAAK,EAAE7S,MAAM,CAAC;IAC9E;IACA,IAAIwU,wBAAwB,EAAE;MAC1B,IAAI,CAACO,mBAAmB,CAACtB,aAAa,EAAEM,eAAe,EAAEG,CAAC,EAAElU,MAAM,CAAC;IACvE;EACJ;EACA+U,mBAAmBA,CAACtB,aAAa,EAAEM,eAAe,EAAEG,CAAC,EAAElU,MAAM,EAAE;IAC3DyT,aAAa,CAACuB,SAAS,GAAGjB,eAAe,IAAIA,eAAe,CAACkB,WAAW,CAAC,GAAG,CAAC,CAACC,QAAQ,CAAC,CAAC,IAAI,EAAE;IAC9FzB,aAAa,CAAC0B,QAAQ,CAAC/X,oBAAoB,EAAE8W,CAAC,EAAET,aAAa,CAAC2B,MAAM,CAACvC,KAAK,EAAE7S,MAAM,CAAC;EACvF;EACAoU,gBAAgBA,CAACX,aAAa,EAAEM,eAAe,EAAEI,CAAC,EAAED,CAAC,EAAErB,KAAK,EAAE7S,MAAM,EAAE;IAClEyT,aAAa,CAACuB,SAAS,GAAGjB,eAAe,IAAIA,eAAe,CAACmB,QAAQ,CAAC,CAAC,IAAI,EAAE;IAC7EzB,aAAa,CAAC0B,QAAQ,CAAChB,CAAC,EAAED,CAAC,EAAErB,KAAK,EAAE7S,MAAM,CAAC;EAC/C;EACAsT,WAAWA,CAACvO,MAAM,EAAE;IAChB,MAAM1C,eAAe,GAAG0C,MAAM,CAAC1C,eAAe;IAC9C,MAAMC,aAAa,GAAGyC,MAAM,CAACzC,aAAa;IAC1C,MAAMxB,iBAAiB,GAAG,IAAI,CAAC4N,MAAM,CAAC5P,OAAO,CAACgC,iBAAiB;IAC/D;IACA,IAAI,IAAI,CAAC6N,eAAe,IAAI,IAAI,CAACA,eAAe,CAAC7J,WAAW,CAACC,MAAM,CAAC,EAAE;MAClE,MAAMsQ,SAAS,GAAG,IAAI,CAAC1G,eAAe,CAACzJ,IAAI,CAAC,CAAC;MAC7C;MACA,OAAO,IAAIX,UAAU,CAACQ,MAAM,EAAEsQ,SAAS,CAAC5Q,SAAS,EAAE4Q,SAAS,CAAC3Q,KAAK,CAAC;IACvE;IACA;IACA,MAAMD,SAAS,GAAG,IAAI,CAACqO,UAAU,CAAC,CAAC;IACnC,IAAI,CAACrO,SAAS,EAAE;MACZ;MACA,OAAO,IAAI;IACf;IACA;IACA,IAAI,CAAC6Q,QAAQ,EAAEC,QAAQ,EAAEtI,MAAM,CAAC,GAAGrC,YAAY,CAAC4K,qBAAqB,CAAC/Q,SAAS,EAAEpC,eAAe,EAAEC,aAAa,EAAExB,iBAAiB,EAAE,IAAI,CAAC6N,eAAe,CAAC;IACzJ;IACA,MAAM8G,QAAQ,GAAG,IAAI,CAAC/G,MAAM,CAAC1B,4BAA4B,CAAC3K,eAAe,EAAEC,aAAa,EAAE2K,MAAM,CAAC;IACjG,MAAMuG,OAAO,GAAG,IAAI,CAAC9E,MAAM,CAACT,UAAU,CAAC,CAAC,CAACuF,OAAO;IAChD,MAAMnN,UAAU,GAAG,IAAI,CAACqI,MAAM,CAAC5P,OAAO,CAACqC,eAAe;IACtD,MAAMtC,kBAAkB,GAAG,IAAI,CAAC6P,MAAM,CAAC7P,kBAAkB;IACzD,MAAM6W,cAAc,GAAG7W,kBAAkB,CAAC8W,iBAAiB,CAAC,CAAC;IAC7D,MAAMrW,aAAa,GAAG,IAAI,CAACoP,MAAM,CAAC5P,OAAO,CAACQ,aAAa;IACvD,MAAM0B,YAAY,GAAG,IAAI,CAAC0N,MAAM,CAAC5P,OAAO,CAACkC,YAAY,CAAC,CAAC;IACvD,MAAMJ,SAAS,GAAG,IAAI,CAAC8N,MAAM,CAAC5P,OAAO,CAAC8B,SAAS;IAC/C,MAAMG,gBAAgB,GAAG,IAAI,CAAC2N,MAAM,CAAC5P,OAAO,CAACiC,gBAAgB;IAC7D,MAAM6U,cAAc,GAAItW,aAAa,KAAK,CAAC,CAAC,aAAa,CAAC,CAAC,yBAAyB,CAAC,CAAC,yBAAyB,CAAE;IACjH,MAAMuW,uBAAuB,GAAGD,cAAc,GAAGhV,SAAS;IAC1D,MAAMkV,gBAAgB,GAAIhV,iBAAiB,GAAG+U,uBAAuB,GAAGnT,IAAI,CAACa,KAAK,CAAC,CAACzC,iBAAiB,GAAG+U,uBAAuB,IAAI,CAAC,CAAC,GAAG,CAAE;IAC1I;IACA,IAAI1R,EAAE,GAAG,CAAC;IACV,MAAM4R,aAAa,GAAG,EAAE;IACxB,KAAK,IAAI7I,SAAS,GAAG,CAAC,EAAE/J,SAAS,GAAGb,aAAa,GAAGD,eAAe,GAAG,CAAC,EAAE6K,SAAS,GAAG/J,SAAS,EAAE+J,SAAS,EAAE,EAAE;MACzG,IAAID,MAAM,CAACC,SAAS,CAAC,EAAE;QACnBtC,YAAY,CAACoL,WAAW,CAACvR,SAAS,EAAE4B,UAAU,EAAEqP,cAAc,EAAEpW,aAAa,EAAEyB,gBAAgB,EAAElC,kBAAkB,EAAEmC,YAAY,EAAEmD,EAAE,EAAE2R,gBAAgB,EAAEtC,OAAO,EAAEiC,QAAQ,CAACvI,SAAS,CAAC,EAAEtM,SAAS,EAAEE,iBAAiB,CAAC;MACxN;MACAiV,aAAa,CAAC7I,SAAS,CAAC,GAAG,IAAIhJ,WAAW,CAACC,EAAE,CAAC;MAC9CA,EAAE,IAAIrD,iBAAiB;IAC3B;IACA,MAAMmV,OAAO,GAAIX,QAAQ,KAAK,CAAC,CAAC,GAAG,CAAC,GAAGA,QAAS;IAChD,MAAMY,OAAO,GAAIX,QAAQ,KAAK,CAAC,CAAC,GAAG9Q,SAAS,CAACzE,MAAM,GAAGuV,QAAS;IAC/D,MAAMY,WAAW,GAAGD,OAAO,GAAGD,OAAO;IACrC;IACA,MAAM/P,GAAG,GAAG,IAAI,CAACqJ,OAAO,CAACU,OAAO,CAAC8C,UAAU,CAAC,IAAI,CAAC;IACjD7M,GAAG,CAACkQ,YAAY,CAAC3R,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEwR,OAAO,EAAExR,SAAS,CAACoO,KAAK,EAAEsD,WAAW,CAAC;IAC3E;IACA,OAAO,IAAI5R,UAAU,CAACQ,MAAM,EAAEN,SAAS,EAAEsR,aAAa,CAAC;EAC3D;EACA,OAAOP,qBAAqBA,CAACa,MAAM,EAAEhU,eAAe,EAAEC,aAAa,EAAExB,iBAAiB,EAAEwV,cAAc,EAAE;IACpG,MAAMrJ,MAAM,GAAG,EAAE;IACjB,IAAI,CAACqJ,cAAc,EAAE;MACjB,KAAK,IAAInR,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG9C,aAAa,GAAGD,eAAe,GAAG,CAAC,EAAE8C,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QACrE8H,MAAM,CAAC9H,CAAC,CAAC,GAAG,IAAI;MACpB;MACA,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE8H,MAAM,CAAC;IAC3B;IACA,MAAMoI,SAAS,GAAGiB,cAAc,CAACpR,IAAI,CAAC,CAAC;IACvC,MAAMqR,cAAc,GAAGlB,SAAS,CAAC5Q,SAAS,CAACoC,IAAI;IAC/C,MAAM2P,mBAAmB,GAAGnB,SAAS,CAAC/P,mBAAmB;IACzD,MAAMmR,SAAS,GAAGpB,SAAS,CAAC3Q,KAAK;IACjC,MAAMgS,eAAe,GAAGD,SAAS,CAACpR,MAAM;IACxC,MAAMc,KAAK,GAAGkQ,MAAM,CAACxD,KAAK;IAC1B,MAAM8D,UAAU,GAAGN,MAAM,CAACxP,IAAI;IAC9B,MAAM+P,YAAY,GAAG,CAACtU,aAAa,GAAGD,eAAe,GAAG,CAAC,IAAIvB,iBAAiB,GAAGqF,KAAK,GAAG,CAAC;IAC1F,IAAI0Q,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;IACtB,IAAIC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC;IACtB,IAAIC,eAAe,GAAG,CAAC,CAAC;IACxB,IAAIC,aAAa,GAAG,CAAC,CAAC;IACtB,IAAIC,aAAa,GAAG,CAAC,CAAC;IACtB,IAAIC,WAAW,GAAG,CAAC,CAAC;IACpB,IAAIC,OAAO,GAAG,CAAC;IACf,KAAK,IAAIlO,UAAU,GAAG5G,eAAe,EAAE4G,UAAU,IAAI3G,aAAa,EAAE2G,UAAU,EAAE,EAAE;MAC9E,MAAMiE,SAAS,GAAGjE,UAAU,GAAG5G,eAAe;MAC9C,MAAM+U,aAAa,GAAGnO,UAAU,GAAGuN,mBAAmB;MACtD,MAAMa,SAAS,GAAID,aAAa,IAAI,CAAC,IAAIA,aAAa,GAAGV,eAAe,GAAGD,SAAS,CAACW,aAAa,CAAC,CAACjT,EAAE,GAAG,CAAC,CAAE;MAC5G,IAAIkT,SAAS,KAAK,CAAC,CAAC,EAAE;QAClBpK,MAAM,CAACC,SAAS,CAAC,GAAG,IAAI;QACxBiK,OAAO,IAAIrW,iBAAiB;QAC5B;MACJ;MACA,MAAMwW,WAAW,GAAGD,SAAS,GAAGlR,KAAK,GAAG,CAAC;MACzC,MAAMoR,SAAS,GAAG,CAACF,SAAS,GAAGvW,iBAAiB,IAAIqF,KAAK,GAAG,CAAC;MAC7D,MAAMqR,SAAS,GAAGL,OAAO,GAAGhR,KAAK,GAAG,CAAC;MACrC,MAAMsR,OAAO,GAAG,CAACN,OAAO,GAAGrW,iBAAiB,IAAIqF,KAAK,GAAG,CAAC;MACzD,IAAI6Q,aAAa,KAAKM,WAAW,IAAIJ,WAAW,KAAKM,SAAS,EAAE;QAC5D;QACAR,aAAa,GAAGO,SAAS;QACzBL,WAAW,GAAGO,OAAO;MACzB,CAAC,MACI;QACD,IAAIV,eAAe,KAAK,CAAC,CAAC,EAAE;UACxB;UACAJ,UAAU,CAAC7P,GAAG,CAACyP,cAAc,CAACmB,QAAQ,CAACX,eAAe,EAAEC,aAAa,CAAC,EAAEC,aAAa,CAAC;UACtF,IAAIJ,WAAW,KAAK,CAAC,CAAC,IAAIE,eAAe,KAAK,CAAC,IAAIA,eAAe,KAAKE,aAAa,EAAE;YAClFJ,WAAW,GAAGG,aAAa;UAC/B;UACA,IAAIF,WAAW,KAAK,CAAC,CAAC,IAAIE,aAAa,KAAKJ,YAAY,IAAIG,eAAe,KAAKE,aAAa,EAAE;YAC3FH,WAAW,GAAGC,eAAe;UACjC;QACJ;QACAA,eAAe,GAAGO,WAAW;QAC7BN,aAAa,GAAGO,SAAS;QACzBN,aAAa,GAAGO,SAAS;QACzBN,WAAW,GAAGO,OAAO;MACzB;MACAxK,MAAM,CAACC,SAAS,CAAC,GAAG,KAAK;MACzBiK,OAAO,IAAIrW,iBAAiB;IAChC;IACA,IAAIiW,eAAe,KAAK,CAAC,CAAC,EAAE;MACxB;MACAJ,UAAU,CAAC7P,GAAG,CAACyP,cAAc,CAACmB,QAAQ,CAACX,eAAe,EAAEC,aAAa,CAAC,EAAEC,aAAa,CAAC;MACtF,IAAIJ,WAAW,KAAK,CAAC,CAAC,IAAIE,eAAe,KAAK,CAAC,IAAIA,eAAe,KAAKE,aAAa,EAAE;QAClFJ,WAAW,GAAGG,aAAa;MAC/B;MACA,IAAIF,WAAW,KAAK,CAAC,CAAC,IAAIE,aAAa,KAAKJ,YAAY,IAAIG,eAAe,KAAKE,aAAa,EAAE;QAC3FH,WAAW,GAAGC,eAAe;MACjC;IACJ;IACA,MAAMd,OAAO,GAAIY,WAAW,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGA,WAAW,IAAI1Q,KAAK,GAAG,CAAC,CAAE;IACrE,MAAM+P,OAAO,GAAIY,WAAW,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGA,WAAW,IAAI3Q,KAAK,GAAG,CAAC,CAAE;IACrE,OAAO,CAAC8P,OAAO,EAAEC,OAAO,EAAEjJ,MAAM,CAAC;EACrC;EACA,OAAO+I,WAAWA,CAACK,MAAM,EAAElV,eAAe,EAAEuU,cAAc,EAAEpW,aAAa,EAAEgV,SAAS,EAAEqD,YAAY,EAAEC,mBAAmB,EAAEzT,EAAE,EAAE2R,gBAAgB,EAAEtC,OAAO,EAAEiB,QAAQ,EAAE7T,SAAS,EAAEE,iBAAiB,EAAE;IAC5L,MAAM+W,OAAO,GAAGpD,QAAQ,CAACoD,OAAO;IAChC,MAAMC,MAAM,GAAGrD,QAAQ,CAACqD,MAAM;IAC9B,MAAMC,KAAK,GAAG1B,MAAM,CAACxD,KAAK,GAAGyB,SAAS;IACtC,MAAM0D,cAAc,GAAIlX,iBAAiB,KAAK,CAAE;IAChD,IAAI8T,EAAE,GAAGxX,oBAAoB;IAC7B,IAAI6a,SAAS,GAAG,CAAC;IACjB,IAAIC,aAAa,GAAG,CAAC;IACrB,KAAK,IAAIC,UAAU,GAAG,CAAC,EAAEC,SAAS,GAAGN,MAAM,CAACO,QAAQ,CAAC,CAAC,EAAEF,UAAU,GAAGC,SAAS,EAAED,UAAU,EAAE,EAAE;MAC1F,MAAMG,aAAa,GAAGR,MAAM,CAACS,YAAY,CAACJ,UAAU,CAAC;MACrD,MAAMK,YAAY,GAAGV,MAAM,CAACW,aAAa,CAACN,UAAU,CAAC;MACrD,MAAMO,UAAU,GAAGf,YAAY,CAACrW,QAAQ,CAACkX,YAAY,CAAC;MACtD,OAAOP,SAAS,GAAGK,aAAa,EAAEL,SAAS,EAAE,EAAE;QAC3C,IAAIrD,EAAE,GAAGmD,KAAK,EAAE;UACZ;UACA;QACJ;QACA,MAAMrD,QAAQ,GAAGmD,OAAO,CAAClD,UAAU,CAACsD,SAAS,CAAC;QAC9C,IAAIvD,QAAQ,KAAK,CAAC,CAAC,WAAW;UAC1B,MAAMiE,iBAAiB,GAAGnF,OAAO,GAAG,CAACyE,SAAS,GAAGC,aAAa,IAAI1E,OAAO;UACzE0E,aAAa,IAAIS,iBAAiB,GAAG,CAAC;UACtC;UACA/D,EAAE,IAAI+D,iBAAiB,GAAGrE,SAAS;QACvC,CAAC,MACI,IAAII,QAAQ,KAAK,EAAE,CAAC,aAAa;UAClC;UACAE,EAAE,IAAIN,SAAS;QACnB,CAAC,MACI;UACD;UACA,MAAMsE,KAAK,GAAG5b,OAAO,CAAC6X,oBAAoB,CAACH,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC;UAC5D,KAAK,IAAIvP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyT,KAAK,EAAEzT,CAAC,EAAE,EAAE;YAC5B,IAAI7F,aAAa,KAAK,CAAC,CAAC,cAAc;cAClCsY,mBAAmB,CAACiB,eAAe,CAACxC,MAAM,EAAEzB,EAAE,EAAEzQ,EAAE,GAAG2R,gBAAgB,EAAE4C,UAAU,EAAEvX,eAAe,EAAEuU,cAAc,EAAEsC,cAAc,CAAC;YACvI,CAAC,MACI;cAAE;cACHJ,mBAAmB,CAACkB,UAAU,CAACzC,MAAM,EAAEzB,EAAE,EAAEzQ,EAAE,GAAG2R,gBAAgB,EAAEpB,QAAQ,EAAEgE,UAAU,EAAEvX,eAAe,EAAEP,SAAS,EAAE8U,cAAc,EAAEsC,cAAc,CAAC;YACvJ;YACApD,EAAE,IAAIN,SAAS;YACf,IAAIM,EAAE,GAAGmD,KAAK,EAAE;cACZ;cACA;YACJ;UACJ;QACJ;MACJ;IACJ;EACJ;AACJ;AACA/Z,0BAA0B,CAAC,CAACY,KAAK,EAAEma,SAAS,KAAK;EAC7C,MAAMC,sBAAsB,GAAGpa,KAAK,CAAC0C,QAAQ,CAAC1D,iBAAiB,CAAC;EAChE,IAAIob,sBAAsB,EAAE;IACxBD,SAAS,CAACE,OAAO,gDAAAC,MAAA,CAAgDF,sBAAsB,CAACzX,IAAI,CAACI,CAAC,8BAA2B,CAAC;EAC9H;EACA,MAAMwX,gBAAgB,GAAGva,KAAK,CAAC0C,QAAQ,CAACzD,uBAAuB,CAAC;EAChE,IAAIsb,gBAAgB,EAAE;IAClBJ,SAAS,CAACE,OAAO,4EAAAC,MAAA,CAA4EC,gBAAgB,QAAK,CAAC;EACvH;EACA,MAAMC,qBAAqB,GAAGxa,KAAK,CAAC0C,QAAQ,CAACxD,4BAA4B,CAAC;EAC1E,IAAIsb,qBAAqB,EAAE;IACvBL,SAAS,CAACE,OAAO,kFAAAC,MAAA,CAAkFE,qBAAqB,QAAK,CAAC;EAClI;EACA,MAAMC,sBAAsB,GAAGza,KAAK,CAAC0C,QAAQ,CAACvD,6BAA6B,CAAC;EAC5E,IAAIsb,sBAAsB,EAAE;IACxBN,SAAS,CAACE,OAAO,mFAAAC,MAAA,CAAmFG,sBAAsB,QAAK,CAAC;EACpI;EACA,MAAMC,MAAM,GAAG1a,KAAK,CAAC0C,QAAQ,CAAC3D,eAAe,CAAC;EAC9C,IAAI2b,MAAM,EAAE;IACRP,SAAS,CAACE,OAAO,yDAAAC,MAAA,CAAyDI,MAAM,8BAA2B,CAAC;EAChH;AACJ,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}