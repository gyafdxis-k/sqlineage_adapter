{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from './strings.js';\nimport * as extpath from './extpath.js';\nimport * as paths from './path.js';\nimport { LRUCache } from './map.js';\nimport { isThenable } from './async.js';\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount) {\n  switch (starCount) {\n    case 0:\n      return '';\n    case 1:\n      return \"\".concat(NO_PATH_REGEX, \"*?\");\n    // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n    default:\n      // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n      // Group is non capturing because we don't need to capture at all (?:...)\n      // Overall we use non-greedy matching because it could be that we match too much\n      return \"(?:\".concat(PATH_REGEX, \"|\").concat(NO_PATH_REGEX, \"+\").concat(PATH_REGEX, \"|\").concat(PATH_REGEX).concat(NO_PATH_REGEX, \"+)*?\");\n  }\n}\nexport function splitGlobAware(pattern, splitChar) {\n  if (!pattern) {\n    return [];\n  }\n  const segments = [];\n  let inBraces = false;\n  let inBrackets = false;\n  let curVal = '';\n  for (const char of pattern) {\n    switch (char) {\n      case splitChar:\n        if (!inBraces && !inBrackets) {\n          segments.push(curVal);\n          curVal = '';\n          continue;\n        }\n        break;\n      case '{':\n        inBraces = true;\n        break;\n      case '}':\n        inBraces = false;\n        break;\n      case '[':\n        inBrackets = true;\n        break;\n      case ']':\n        inBrackets = false;\n        break;\n    }\n    curVal += char;\n  }\n  // Tail\n  if (curVal) {\n    segments.push(curVal);\n  }\n  return segments;\n}\nfunction parseRegExp(pattern) {\n  if (!pattern) {\n    return '';\n  }\n  let regEx = '';\n  // Split up into segments for each slash found\n  const segments = splitGlobAware(pattern, GLOB_SPLIT);\n  // Special case where we only have globstars\n  if (segments.every(s => s === GLOBSTAR)) {\n    regEx = '.*';\n  }\n  // Build regex over segments\n  else {\n    let previousSegmentWasGlobStar = false;\n    segments.forEach((segment, index) => {\n      // Globstar is special\n      if (segment === GLOBSTAR) {\n        // if we have more than one globstar after another, just ignore it\n        if (!previousSegmentWasGlobStar) {\n          regEx += starsToRegExp(2);\n          previousSegmentWasGlobStar = true;\n        }\n        return;\n      }\n      // States\n      let inBraces = false;\n      let braceVal = '';\n      let inBrackets = false;\n      let bracketVal = '';\n      for (const char of segment) {\n        // Support brace expansion\n        if (char !== '}' && inBraces) {\n          braceVal += char;\n          continue;\n        }\n        // Support brackets\n        if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n          let res;\n          // range operator\n          if (char === '-') {\n            res = char;\n          }\n          // negation operator (only valid on first index in bracket)\n          else if ((char === '^' || char === '!') && !bracketVal) {\n            res = '^';\n          }\n          // glob split matching is not allowed within character ranges\n          // see http://man7.org/linux/man-pages/man7/glob.7.html\n          else if (char === GLOB_SPLIT) {\n            res = '';\n          }\n          // anything else gets escaped\n          else {\n            res = strings.escapeRegExpCharacters(char);\n          }\n          bracketVal += res;\n          continue;\n        }\n        switch (char) {\n          case '{':\n            inBraces = true;\n            continue;\n          case '[':\n            inBrackets = true;\n            continue;\n          case '}':\n            const choices = splitGlobAware(braceVal, ',');\n            // Converts {foo,bar} => [foo|bar]\n            const braceRegExp = \"(?:\".concat(choices.map(c => parseRegExp(c)).join('|'), \")\");\n            regEx += braceRegExp;\n            inBraces = false;\n            braceVal = '';\n            break;\n          case ']':\n            regEx += '[' + bracketVal + ']';\n            inBrackets = false;\n            bracketVal = '';\n            break;\n          case '?':\n            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n            continue;\n          case '*':\n            regEx += starsToRegExp(1);\n            continue;\n          default:\n            regEx += strings.escapeRegExpCharacters(char);\n        }\n      }\n      // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n      // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n      // a folder called \"something\" to match as well.\n      // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n      // is to match 0-N segments.\n      if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n        regEx += PATH_REGEX;\n      }\n      // reset state\n      previousSegmentWasGlobStar = false;\n    });\n  }\n  return regEx;\n}\n// regexes to check for trival glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n  return false;\n};\nconst NULL = function () {\n  return null;\n};\nfunction parsePattern(arg1, options) {\n  if (!arg1) {\n    return NULL;\n  }\n  // Handle IRelativePattern\n  let pattern;\n  if (typeof arg1 !== 'string') {\n    pattern = arg1.pattern;\n  } else {\n    pattern = arg1;\n  }\n  // Whitespace trimming\n  pattern = pattern.trim();\n  // Check cache\n  const patternKey = \"\".concat(pattern, \"_\").concat(!!options.trimForExclusions);\n  let parsedPattern = CACHE.get(patternKey);\n  if (parsedPattern) {\n    return wrapRelativePattern(parsedPattern, arg1);\n  }\n  // Check for Trivias\n  let match;\n  if (T1.test(pattern)) {\n    // common pattern: **/*.txt just need endsWith check\n    const base = pattern.substr(4); // '**/*'.length === 4\n    parsedPattern = function (path, basename) {\n      return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n  } else if (match = T2.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/some.txt just need basename check\n    parsedPattern = trivia2(match[1], pattern);\n  } else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {\n    // repetition of common patterns (see above) {**/*.txt,**/*.png}\n    parsedPattern = trivia3(pattern, options);\n  } else if (match = T4.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/something/else just need endsWith check\n    parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n  } else if (match = T5.exec(trimForExclusions(pattern, options))) {\n    // common pattern: something/else just need equals check\n    parsedPattern = trivia4and5(match[1], pattern, false);\n  }\n  // Otherwise convert to pattern\n  else {\n    parsedPattern = toRegExp(pattern);\n  }\n  // Cache\n  CACHE.set(patternKey, parsedPattern);\n  return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n  if (typeof arg2 === 'string') {\n    return parsedPattern;\n  }\n  return function (path, basename) {\n    if (!extpath.isEqualOrParent(path, arg2.base)) {\n      return null;\n    }\n    return parsedPattern(paths.relative(arg2.base, path), basename);\n  };\n}\nfunction trimForExclusions(pattern, options) {\n  return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, originalPattern) {\n  const slashBase = \"/\".concat(base);\n  const backslashBase = \"\\\\\".concat(base);\n  const parsedPattern = function (path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n    if (basename) {\n      return basename === base ? originalPattern : null;\n    }\n    return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\n  };\n  const basenames = [base];\n  parsedPattern.basenames = basenames;\n  parsedPattern.patterns = [originalPattern];\n  parsedPattern.allBasenames = basenames;\n  return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n  const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',').map(pattern => parsePattern(pattern, options)).filter(pattern => pattern !== NULL), pattern);\n  const n = parsedPatterns.length;\n  if (!n) {\n    return NULL;\n  }\n  if (n === 1) {\n    return parsedPatterns[0];\n  }\n  const parsedPattern = function (path, basename) {\n    for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n      if (parsedPatterns[i](path, basename)) {\n        return pattern;\n      }\n    }\n    return null;\n  };\n  const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n  if (withBasenames) {\n    parsedPattern.allBasenames = withBasenames.allBasenames;\n  }\n  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n  if (allPaths.length) {\n    parsedPattern.allPaths = allPaths;\n  }\n  return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n  const usingPosixSep = paths.sep === paths.posix.sep;\n  const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, paths.sep);\n  const nativePathEnd = paths.sep + nativePath;\n  const targetPathEnd = paths.posix.sep + targetPath;\n  const parsedPattern = matchPathEnds ? function (testPath, basename) {\n    return typeof testPath === 'string' && (testPath === nativePath || testPath.endsWith(nativePathEnd) || !usingPosixSep && (testPath === targetPath || testPath.endsWith(targetPathEnd))) ? pattern : null;\n  } : function (testPath, basename) {\n    return typeof testPath === 'string' && (testPath === nativePath || !usingPosixSep && testPath === targetPath) ? pattern : null;\n  };\n  parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n  return parsedPattern;\n}\nfunction toRegExp(pattern) {\n  try {\n    const regExp = new RegExp(\"^\".concat(parseRegExp(pattern), \"$\"));\n    return function (path) {\n      regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n      return typeof path === 'string' && regExp.test(path) ? pattern : null;\n    };\n  } catch (error) {\n    return NULL;\n  }\n}\nexport function match(arg1, path, hasSibling) {\n  if (!arg1 || typeof path !== 'string') {\n    return false;\n  }\n  return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!arg1) {\n    return FALSE;\n  }\n  // Glob with String\n  if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n    const parsedPattern = parsePattern(arg1, options);\n    if (parsedPattern === NULL) {\n      return FALSE;\n    }\n    const resultPattern = function (path, basename) {\n      return !!parsedPattern(path, basename);\n    };\n    if (parsedPattern.allBasenames) {\n      resultPattern.allBasenames = parsedPattern.allBasenames;\n    }\n    if (parsedPattern.allPaths) {\n      resultPattern.allPaths = parsedPattern.allPaths;\n    }\n    return resultPattern;\n  }\n  // Glob with Expression\n  return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n  const rp = obj;\n  return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n  const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map(pattern => parseExpressionPattern(pattern, expression[pattern], options)).filter(pattern => pattern !== NULL));\n  const n = parsedPatterns.length;\n  if (!n) {\n    return NULL;\n  }\n  if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n    if (n === 1) {\n      return parsedPatterns[0];\n    }\n    const resultExpression = function (path, basename) {\n      for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n        // Pattern matches path\n        const result = parsedPatterns[i](path, basename);\n        if (result) {\n          return result;\n        }\n      }\n      return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n      resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n      resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n  }\n  const resultExpression = function (path, basename, hasSibling) {\n    let name = undefined;\n    for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n      // Pattern matches path\n      const parsedPattern = parsedPatterns[i];\n      if (parsedPattern.requiresSiblings && hasSibling) {\n        if (!basename) {\n          basename = paths.basename(path);\n        }\n        if (!name) {\n          name = basename.substr(0, basename.length - paths.extname(path).length);\n        }\n      }\n      const result = parsedPattern(path, basename, name, hasSibling);\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  };\n  const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n  if (withBasenames) {\n    resultExpression.allBasenames = withBasenames.allBasenames;\n  }\n  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n  if (allPaths.length) {\n    resultExpression.allPaths = allPaths;\n  }\n  return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n  if (value === false) {\n    return NULL; // pattern is disabled\n  }\n\n  const parsedPattern = parsePattern(pattern, options);\n  if (parsedPattern === NULL) {\n    return NULL;\n  }\n  // Expression Pattern is <boolean>\n  if (typeof value === 'boolean') {\n    return parsedPattern;\n  }\n  // Expression Pattern is <SiblingClause>\n  if (value) {\n    const when = value.when;\n    if (typeof when === 'string') {\n      const result = (path, basename, name, hasSibling) => {\n        if (!hasSibling || !parsedPattern(path, basename)) {\n          return null;\n        }\n        const clausePattern = when.replace('$(basename)', name);\n        const matched = hasSibling(clausePattern);\n        return isThenable(matched) ? matched.then(m => m ? pattern : null) : matched ? pattern : null;\n      };\n      result.requiresSiblings = true;\n      return result;\n    }\n  }\n  // Expression is Anything\n  return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n  const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n  if (basenamePatterns.length < 2) {\n    return parsedPatterns;\n  }\n  const basenames = basenamePatterns.reduce((all, current) => {\n    const basenames = current.basenames;\n    return basenames ? all.concat(basenames) : all;\n  }, []);\n  let patterns;\n  if (result) {\n    patterns = [];\n    for (let i = 0, n = basenames.length; i < n; i++) {\n      patterns.push(result);\n    }\n  } else {\n    patterns = basenamePatterns.reduce((all, current) => {\n      const patterns = current.patterns;\n      return patterns ? all.concat(patterns) : all;\n    }, []);\n  }\n  const aggregate = function (path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n    if (!basename) {\n      let i;\n      for (i = path.length; i > 0; i--) {\n        const ch = path.charCodeAt(i - 1);\n        if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {\n          break;\n        }\n      }\n      basename = path.substr(i);\n    }\n    const index = basenames.indexOf(basename);\n    return index !== -1 ? patterns[index] : null;\n  };\n  aggregate.basenames = basenames;\n  aggregate.patterns = patterns;\n  aggregate.allBasenames = basenames;\n  const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n  aggregatedPatterns.push(aggregate);\n  return aggregatedPatterns;\n}","map":{"version":3,"names":["strings","extpath","paths","LRUCache","isThenable","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","concat","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","char","push","parseRegExp","regEx","every","s","previousSegmentWasGlobStar","forEach","segment","index","braceVal","bracketVal","res","escapeRegExpCharacters","choices","braceRegExp","map","c","join","length","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","arg1","options","trim","patternKey","trimForExclusions","parsedPattern","get","wrapRelativePattern","match","test","base","substr","path","basename","endsWith","exec","trivia2","trivia3","trivia4and5","toRegExp","set","arg2","isEqualOrParent","relative","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","parsedPatterns","aggregateBasenameMatches","slice","split","filter","n","i","withBasenames","find","allPaths","reduce","all","current","targetPath","matchPathEnds","usingPosixSep","sep","posix","nativePath","replace","nativePathEnd","targetPathEnd","testPath","regExp","RegExp","lastIndex","error","hasSibling","parse","undefined","arguments","isRelativePattern","resultPattern","parsedExpression","obj","rp","expression","Object","getOwnPropertyNames","parseExpressionPattern","some","requiresSiblings","resultExpression","result","name","extname","value","when","clausePattern","matched","then","m","basenamePatterns","aggregate","ch","charCodeAt","indexOf","aggregatedPatterns"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/glob.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from './strings.js';\r\nimport * as extpath from './extpath.js';\r\nimport * as paths from './path.js';\r\nimport { LRUCache } from './map.js';\r\nimport { isThenable } from './async.js';\r\nconst GLOBSTAR = '**';\r\nconst GLOB_SPLIT = '/';\r\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\r\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\r\nconst ALL_FORWARD_SLASHES = /\\//g;\r\nfunction starsToRegExp(starCount) {\r\n    switch (starCount) {\r\n        case 0:\r\n            return '';\r\n        case 1:\r\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\r\n        default:\r\n            // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\r\n            // Group is non capturing because we don't need to capture at all (?:...)\r\n            // Overall we use non-greedy matching because it could be that we match too much\r\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\r\n    }\r\n}\r\nexport function splitGlobAware(pattern, splitChar) {\r\n    if (!pattern) {\r\n        return [];\r\n    }\r\n    const segments = [];\r\n    let inBraces = false;\r\n    let inBrackets = false;\r\n    let curVal = '';\r\n    for (const char of pattern) {\r\n        switch (char) {\r\n            case splitChar:\r\n                if (!inBraces && !inBrackets) {\r\n                    segments.push(curVal);\r\n                    curVal = '';\r\n                    continue;\r\n                }\r\n                break;\r\n            case '{':\r\n                inBraces = true;\r\n                break;\r\n            case '}':\r\n                inBraces = false;\r\n                break;\r\n            case '[':\r\n                inBrackets = true;\r\n                break;\r\n            case ']':\r\n                inBrackets = false;\r\n                break;\r\n        }\r\n        curVal += char;\r\n    }\r\n    // Tail\r\n    if (curVal) {\r\n        segments.push(curVal);\r\n    }\r\n    return segments;\r\n}\r\nfunction parseRegExp(pattern) {\r\n    if (!pattern) {\r\n        return '';\r\n    }\r\n    let regEx = '';\r\n    // Split up into segments for each slash found\r\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\r\n    // Special case where we only have globstars\r\n    if (segments.every(s => s === GLOBSTAR)) {\r\n        regEx = '.*';\r\n    }\r\n    // Build regex over segments\r\n    else {\r\n        let previousSegmentWasGlobStar = false;\r\n        segments.forEach((segment, index) => {\r\n            // Globstar is special\r\n            if (segment === GLOBSTAR) {\r\n                // if we have more than one globstar after another, just ignore it\r\n                if (!previousSegmentWasGlobStar) {\r\n                    regEx += starsToRegExp(2);\r\n                    previousSegmentWasGlobStar = true;\r\n                }\r\n                return;\r\n            }\r\n            // States\r\n            let inBraces = false;\r\n            let braceVal = '';\r\n            let inBrackets = false;\r\n            let bracketVal = '';\r\n            for (const char of segment) {\r\n                // Support brace expansion\r\n                if (char !== '}' && inBraces) {\r\n                    braceVal += char;\r\n                    continue;\r\n                }\r\n                // Support brackets\r\n                if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\r\n                    let res;\r\n                    // range operator\r\n                    if (char === '-') {\r\n                        res = char;\r\n                    }\r\n                    // negation operator (only valid on first index in bracket)\r\n                    else if ((char === '^' || char === '!') && !bracketVal) {\r\n                        res = '^';\r\n                    }\r\n                    // glob split matching is not allowed within character ranges\r\n                    // see http://man7.org/linux/man-pages/man7/glob.7.html\r\n                    else if (char === GLOB_SPLIT) {\r\n                        res = '';\r\n                    }\r\n                    // anything else gets escaped\r\n                    else {\r\n                        res = strings.escapeRegExpCharacters(char);\r\n                    }\r\n                    bracketVal += res;\r\n                    continue;\r\n                }\r\n                switch (char) {\r\n                    case '{':\r\n                        inBraces = true;\r\n                        continue;\r\n                    case '[':\r\n                        inBrackets = true;\r\n                        continue;\r\n                    case '}':\r\n                        const choices = splitGlobAware(braceVal, ',');\r\n                        // Converts {foo,bar} => [foo|bar]\r\n                        const braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\r\n                        regEx += braceRegExp;\r\n                        inBraces = false;\r\n                        braceVal = '';\r\n                        break;\r\n                    case ']':\r\n                        regEx += ('[' + bracketVal + ']');\r\n                        inBrackets = false;\r\n                        bracketVal = '';\r\n                        break;\r\n                    case '?':\r\n                        regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\r\n                        continue;\r\n                    case '*':\r\n                        regEx += starsToRegExp(1);\r\n                        continue;\r\n                    default:\r\n                        regEx += strings.escapeRegExpCharacters(char);\r\n                }\r\n            }\r\n            // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\r\n            // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\r\n            // a folder called \"something\" to match as well.\r\n            // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\r\n            // is to match 0-N segments.\r\n            if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\r\n                regEx += PATH_REGEX;\r\n            }\r\n            // reset state\r\n            previousSegmentWasGlobStar = false;\r\n        });\r\n    }\r\n    return regEx;\r\n}\r\n// regexes to check for trival glob patterns that just check for String#endsWith\r\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\r\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\r\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\r\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\r\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\r\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\r\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\r\nconst FALSE = function () {\r\n    return false;\r\n};\r\nconst NULL = function () {\r\n    return null;\r\n};\r\nfunction parsePattern(arg1, options) {\r\n    if (!arg1) {\r\n        return NULL;\r\n    }\r\n    // Handle IRelativePattern\r\n    let pattern;\r\n    if (typeof arg1 !== 'string') {\r\n        pattern = arg1.pattern;\r\n    }\r\n    else {\r\n        pattern = arg1;\r\n    }\r\n    // Whitespace trimming\r\n    pattern = pattern.trim();\r\n    // Check cache\r\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\r\n    let parsedPattern = CACHE.get(patternKey);\r\n    if (parsedPattern) {\r\n        return wrapRelativePattern(parsedPattern, arg1);\r\n    }\r\n    // Check for Trivias\r\n    let match;\r\n    if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\r\n        const base = pattern.substr(4); // '**/*'.length === 4\r\n        parsedPattern = function (path, basename) {\r\n            return typeof path === 'string' && path.endsWith(base) ? pattern : null;\r\n        };\r\n    }\r\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\r\n        parsedPattern = trivia2(match[1], pattern);\r\n    }\r\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\r\n        parsedPattern = trivia3(pattern, options);\r\n    }\r\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\r\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\r\n    }\r\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\r\n        parsedPattern = trivia4and5(match[1], pattern, false);\r\n    }\r\n    // Otherwise convert to pattern\r\n    else {\r\n        parsedPattern = toRegExp(pattern);\r\n    }\r\n    // Cache\r\n    CACHE.set(patternKey, parsedPattern);\r\n    return wrapRelativePattern(parsedPattern, arg1);\r\n}\r\nfunction wrapRelativePattern(parsedPattern, arg2) {\r\n    if (typeof arg2 === 'string') {\r\n        return parsedPattern;\r\n    }\r\n    return function (path, basename) {\r\n        if (!extpath.isEqualOrParent(path, arg2.base)) {\r\n            return null;\r\n        }\r\n        return parsedPattern(paths.relative(arg2.base, path), basename);\r\n    };\r\n}\r\nfunction trimForExclusions(pattern, options) {\r\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\r\n}\r\n// common pattern: **/some.txt just need basename check\r\nfunction trivia2(base, originalPattern) {\r\n    const slashBase = `/${base}`;\r\n    const backslashBase = `\\\\${base}`;\r\n    const parsedPattern = function (path, basename) {\r\n        if (typeof path !== 'string') {\r\n            return null;\r\n        }\r\n        if (basename) {\r\n            return basename === base ? originalPattern : null;\r\n        }\r\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\r\n    };\r\n    const basenames = [base];\r\n    parsedPattern.basenames = basenames;\r\n    parsedPattern.patterns = [originalPattern];\r\n    parsedPattern.allBasenames = basenames;\r\n    return parsedPattern;\r\n}\r\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\r\nfunction trivia3(pattern, options) {\r\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\r\n        .map(pattern => parsePattern(pattern, options))\r\n        .filter(pattern => pattern !== NULL), pattern);\r\n    const n = parsedPatterns.length;\r\n    if (!n) {\r\n        return NULL;\r\n    }\r\n    if (n === 1) {\r\n        return parsedPatterns[0];\r\n    }\r\n    const parsedPattern = function (path, basename) {\r\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\r\n            if (parsedPatterns[i](path, basename)) {\r\n                return pattern;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\r\n    if (withBasenames) {\r\n        parsedPattern.allBasenames = withBasenames.allBasenames;\r\n    }\r\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\r\n    if (allPaths.length) {\r\n        parsedPattern.allPaths = allPaths;\r\n    }\r\n    return parsedPattern;\r\n}\r\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\r\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\r\n    const usingPosixSep = paths.sep === paths.posix.sep;\r\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, paths.sep);\r\n    const nativePathEnd = paths.sep + nativePath;\r\n    const targetPathEnd = paths.posix.sep + targetPath;\r\n    const parsedPattern = matchPathEnds ? function (testPath, basename) {\r\n        return typeof testPath === 'string' &&\r\n            ((testPath === nativePath || testPath.endsWith(nativePathEnd))\r\n                || !usingPosixSep && (testPath === targetPath || testPath.endsWith(targetPathEnd)))\r\n            ? pattern : null;\r\n    } : function (testPath, basename) {\r\n        return typeof testPath === 'string' &&\r\n            (testPath === nativePath\r\n                || (!usingPosixSep && testPath === targetPath))\r\n            ? pattern : null;\r\n    };\r\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\r\n    return parsedPattern;\r\n}\r\nfunction toRegExp(pattern) {\r\n    try {\r\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\r\n        return function (path) {\r\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\r\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\r\n        };\r\n    }\r\n    catch (error) {\r\n        return NULL;\r\n    }\r\n}\r\nexport function match(arg1, path, hasSibling) {\r\n    if (!arg1 || typeof path !== 'string') {\r\n        return false;\r\n    }\r\n    return parse(arg1)(path, undefined, hasSibling);\r\n}\r\nexport function parse(arg1, options = {}) {\r\n    if (!arg1) {\r\n        return FALSE;\r\n    }\r\n    // Glob with String\r\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\r\n        const parsedPattern = parsePattern(arg1, options);\r\n        if (parsedPattern === NULL) {\r\n            return FALSE;\r\n        }\r\n        const resultPattern = function (path, basename) {\r\n            return !!parsedPattern(path, basename);\r\n        };\r\n        if (parsedPattern.allBasenames) {\r\n            resultPattern.allBasenames = parsedPattern.allBasenames;\r\n        }\r\n        if (parsedPattern.allPaths) {\r\n            resultPattern.allPaths = parsedPattern.allPaths;\r\n        }\r\n        return resultPattern;\r\n    }\r\n    // Glob with Expression\r\n    return parsedExpression(arg1, options);\r\n}\r\nexport function isRelativePattern(obj) {\r\n    const rp = obj;\r\n    return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\r\n}\r\nfunction parsedExpression(expression, options) {\r\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\r\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\r\n        .filter(pattern => pattern !== NULL));\r\n    const n = parsedPatterns.length;\r\n    if (!n) {\r\n        return NULL;\r\n    }\r\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\r\n        if (n === 1) {\r\n            return parsedPatterns[0];\r\n        }\r\n        const resultExpression = function (path, basename) {\r\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\r\n                // Pattern matches path\r\n                const result = parsedPatterns[i](path, basename);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\r\n        if (withBasenames) {\r\n            resultExpression.allBasenames = withBasenames.allBasenames;\r\n        }\r\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\r\n        if (allPaths.length) {\r\n            resultExpression.allPaths = allPaths;\r\n        }\r\n        return resultExpression;\r\n    }\r\n    const resultExpression = function (path, basename, hasSibling) {\r\n        let name = undefined;\r\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\r\n            // Pattern matches path\r\n            const parsedPattern = parsedPatterns[i];\r\n            if (parsedPattern.requiresSiblings && hasSibling) {\r\n                if (!basename) {\r\n                    basename = paths.basename(path);\r\n                }\r\n                if (!name) {\r\n                    name = basename.substr(0, basename.length - paths.extname(path).length);\r\n                }\r\n            }\r\n            const result = parsedPattern(path, basename, name, hasSibling);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\r\n    if (withBasenames) {\r\n        resultExpression.allBasenames = withBasenames.allBasenames;\r\n    }\r\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\r\n    if (allPaths.length) {\r\n        resultExpression.allPaths = allPaths;\r\n    }\r\n    return resultExpression;\r\n}\r\nfunction parseExpressionPattern(pattern, value, options) {\r\n    if (value === false) {\r\n        return NULL; // pattern is disabled\r\n    }\r\n    const parsedPattern = parsePattern(pattern, options);\r\n    if (parsedPattern === NULL) {\r\n        return NULL;\r\n    }\r\n    // Expression Pattern is <boolean>\r\n    if (typeof value === 'boolean') {\r\n        return parsedPattern;\r\n    }\r\n    // Expression Pattern is <SiblingClause>\r\n    if (value) {\r\n        const when = value.when;\r\n        if (typeof when === 'string') {\r\n            const result = (path, basename, name, hasSibling) => {\r\n                if (!hasSibling || !parsedPattern(path, basename)) {\r\n                    return null;\r\n                }\r\n                const clausePattern = when.replace('$(basename)', name);\r\n                const matched = hasSibling(clausePattern);\r\n                return isThenable(matched) ?\r\n                    matched.then(m => m ? pattern : null) :\r\n                    matched ? pattern : null;\r\n            };\r\n            result.requiresSiblings = true;\r\n            return result;\r\n        }\r\n    }\r\n    // Expression is Anything\r\n    return parsedPattern;\r\n}\r\nfunction aggregateBasenameMatches(parsedPatterns, result) {\r\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\r\n    if (basenamePatterns.length < 2) {\r\n        return parsedPatterns;\r\n    }\r\n    const basenames = basenamePatterns.reduce((all, current) => {\r\n        const basenames = current.basenames;\r\n        return basenames ? all.concat(basenames) : all;\r\n    }, []);\r\n    let patterns;\r\n    if (result) {\r\n        patterns = [];\r\n        for (let i = 0, n = basenames.length; i < n; i++) {\r\n            patterns.push(result);\r\n        }\r\n    }\r\n    else {\r\n        patterns = basenamePatterns.reduce((all, current) => {\r\n            const patterns = current.patterns;\r\n            return patterns ? all.concat(patterns) : all;\r\n        }, []);\r\n    }\r\n    const aggregate = function (path, basename) {\r\n        if (typeof path !== 'string') {\r\n            return null;\r\n        }\r\n        if (!basename) {\r\n            let i;\r\n            for (i = path.length; i > 0; i--) {\r\n                const ch = path.charCodeAt(i - 1);\r\n                if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {\r\n                    break;\r\n                }\r\n            }\r\n            basename = path.substr(i);\r\n        }\r\n        const index = basenames.indexOf(basename);\r\n        return index !== -1 ? patterns[index] : null;\r\n    };\r\n    aggregate.basenames = basenames;\r\n    aggregate.patterns = patterns;\r\n    aggregate.allBasenames = basenames;\r\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\r\n    aggregatedPatterns.push(aggregate);\r\n    return aggregatedPatterns;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}