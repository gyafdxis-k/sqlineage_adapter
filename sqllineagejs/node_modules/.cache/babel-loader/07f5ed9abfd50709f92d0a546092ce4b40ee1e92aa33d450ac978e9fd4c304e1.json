{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport * as nls from '../../../nls.js';\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource } from './undoRedo.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport Severity from '../../../base/common/severity.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { Disposable, isDisposable } from '../../../base/common/lifecycle.js';\nconst DEBUG = false;\nfunction getResourceLabel(resource) {\n  return resource.scheme === Schemas.file ? resource.fsPath : resource.path;\n}\nlet stackElementCounter = 0;\nclass ResourceStackElement {\n  constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {\n    this.id = ++stackElementCounter;\n    this.type = 0 /* Resource */;\n    this.actual = actual;\n    this.label = actual.label;\n    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n    this.resourceLabel = resourceLabel;\n    this.strResource = strResource;\n    this.resourceLabels = [this.resourceLabel];\n    this.strResources = [this.strResource];\n    this.groupId = groupId;\n    this.groupOrder = groupOrder;\n    this.sourceId = sourceId;\n    this.sourceOrder = sourceOrder;\n    this.isValid = true;\n  }\n  setValid(isValid) {\n    this.isValid = isValid;\n  }\n  toString() {\n    return \"[id:\".concat(this.id, \"] [group:\").concat(this.groupId, \"] [\").concat(this.isValid ? '  VALID' : 'INVALID', \"] \").concat(this.actual.constructor.name, \" - \").concat(this.actual);\n  }\n}\nclass ResourceReasonPair {\n  constructor(resourceLabel, reason) {\n    this.resourceLabel = resourceLabel;\n    this.reason = reason;\n  }\n}\nclass RemovedResources {\n  constructor() {\n    this.elements = new Map();\n  }\n  createMessage() {\n    const externalRemoval = [];\n    const noParallelUniverses = [];\n    for (const [, element] of this.elements) {\n      const dest = element.reason === 0 /* ExternalRemoval */ ? externalRemoval : noParallelUniverses;\n      dest.push(element.resourceLabel);\n    }\n    let messages = [];\n    if (externalRemoval.length > 0) {\n      messages.push(nls.localize({\n        key: 'externalRemoval',\n        comment: ['{0} is a list of filenames']\n      }, \"The following files have been closed and modified on disk: {0}.\", externalRemoval.join(', ')));\n    }\n    if (noParallelUniverses.length > 0) {\n      messages.push(nls.localize({\n        key: 'noParallelUniverses',\n        comment: ['{0} is a list of filenames']\n      }, \"The following files have been modified in an incompatible way: {0}.\", noParallelUniverses.join(', ')));\n    }\n    return messages.join('\\n');\n  }\n  get size() {\n    return this.elements.size;\n  }\n  has(strResource) {\n    return this.elements.has(strResource);\n  }\n  set(strResource, value) {\n    this.elements.set(strResource, value);\n  }\n  delete(strResource) {\n    return this.elements.delete(strResource);\n  }\n}\nclass WorkspaceStackElement {\n  constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {\n    this.id = ++stackElementCounter;\n    this.type = 1 /* Workspace */;\n    this.actual = actual;\n    this.label = actual.label;\n    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n    this.resourceLabels = resourceLabels;\n    this.strResources = strResources;\n    this.groupId = groupId;\n    this.groupOrder = groupOrder;\n    this.sourceId = sourceId;\n    this.sourceOrder = sourceOrder;\n    this.removedResources = null;\n    this.invalidatedResources = null;\n  }\n  canSplit() {\n    return typeof this.actual.split === 'function';\n  }\n  removeResource(resourceLabel, strResource, reason) {\n    if (!this.removedResources) {\n      this.removedResources = new RemovedResources();\n    }\n    if (!this.removedResources.has(strResource)) {\n      this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));\n    }\n  }\n  setValid(resourceLabel, strResource, isValid) {\n    if (isValid) {\n      if (this.invalidatedResources) {\n        this.invalidatedResources.delete(strResource);\n        if (this.invalidatedResources.size === 0) {\n          this.invalidatedResources = null;\n        }\n      }\n    } else {\n      if (!this.invalidatedResources) {\n        this.invalidatedResources = new RemovedResources();\n      }\n      if (!this.invalidatedResources.has(strResource)) {\n        this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0 /* ExternalRemoval */));\n      }\n    }\n  }\n\n  toString() {\n    return \"[id:\".concat(this.id, \"] [group:\").concat(this.groupId, \"] [\").concat(this.invalidatedResources ? 'INVALID' : '  VALID', \"] \").concat(this.actual.constructor.name, \" - \").concat(this.actual);\n  }\n}\nclass ResourceEditStack {\n  constructor(resourceLabel, strResource) {\n    this.resourceLabel = resourceLabel;\n    this.strResource = strResource;\n    this._past = [];\n    this._future = [];\n    this.locked = false;\n    this.versionId = 1;\n  }\n  dispose() {\n    for (const element of this._past) {\n      if (element.type === 1 /* Workspace */) {\n        element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\n      }\n    }\n\n    for (const element of this._future) {\n      if (element.type === 1 /* Workspace */) {\n        element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\n      }\n    }\n\n    this.versionId++;\n  }\n  toString() {\n    let result = [];\n    result.push(\"* \".concat(this.strResource, \":\"));\n    for (let i = 0; i < this._past.length; i++) {\n      result.push(\"   * [UNDO] \".concat(this._past[i]));\n    }\n    for (let i = this._future.length - 1; i >= 0; i--) {\n      result.push(\"   * [REDO] \".concat(this._future[i]));\n    }\n    return result.join('\\n');\n  }\n  flushAllElements() {\n    this._past = [];\n    this._future = [];\n    this.versionId++;\n  }\n  _setElementValidFlag(element, isValid) {\n    if (element.type === 1 /* Workspace */) {\n      element.setValid(this.resourceLabel, this.strResource, isValid);\n    } else {\n      element.setValid(isValid);\n    }\n  }\n  setElementsValidFlag(isValid, filter) {\n    for (const element of this._past) {\n      if (filter(element.actual)) {\n        this._setElementValidFlag(element, isValid);\n      }\n    }\n    for (const element of this._future) {\n      if (filter(element.actual)) {\n        this._setElementValidFlag(element, isValid);\n      }\n    }\n  }\n  pushElement(element) {\n    // remove the future\n    for (const futureElement of this._future) {\n      if (futureElement.type === 1 /* Workspace */) {\n        futureElement.removeResource(this.resourceLabel, this.strResource, 1 /* NoParallelUniverses */);\n      }\n    }\n\n    this._future = [];\n    this._past.push(element);\n    this.versionId++;\n  }\n  createSnapshot(resource) {\n    const elements = [];\n    for (let i = 0, len = this._past.length; i < len; i++) {\n      elements.push(this._past[i].id);\n    }\n    for (let i = this._future.length - 1; i >= 0; i--) {\n      elements.push(this._future[i].id);\n    }\n    return new ResourceEditStackSnapshot(resource, elements);\n  }\n  restoreSnapshot(snapshot) {\n    const snapshotLength = snapshot.elements.length;\n    let isOK = true;\n    let snapshotIndex = 0;\n    let removePastAfter = -1;\n    for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {\n      const element = this._past[i];\n      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n        isOK = false;\n        removePastAfter = 0;\n      }\n      if (!isOK && element.type === 1 /* Workspace */) {\n        element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\n      }\n    }\n\n    let removeFutureBefore = -1;\n    for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {\n      const element = this._future[i];\n      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n        isOK = false;\n        removeFutureBefore = i;\n      }\n      if (!isOK && element.type === 1 /* Workspace */) {\n        element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\n      }\n    }\n\n    if (removePastAfter !== -1) {\n      this._past = this._past.slice(0, removePastAfter);\n    }\n    if (removeFutureBefore !== -1) {\n      this._future = this._future.slice(removeFutureBefore + 1);\n    }\n    this.versionId++;\n  }\n  getElements() {\n    const past = [];\n    const future = [];\n    for (const element of this._past) {\n      past.push(element.actual);\n    }\n    for (const element of this._future) {\n      future.push(element.actual);\n    }\n    return {\n      past,\n      future\n    };\n  }\n  getClosestPastElement() {\n    if (this._past.length === 0) {\n      return null;\n    }\n    return this._past[this._past.length - 1];\n  }\n  getSecondClosestPastElement() {\n    if (this._past.length < 2) {\n      return null;\n    }\n    return this._past[this._past.length - 2];\n  }\n  getClosestFutureElement() {\n    if (this._future.length === 0) {\n      return null;\n    }\n    return this._future[this._future.length - 1];\n  }\n  hasPastElements() {\n    return this._past.length > 0;\n  }\n  hasFutureElements() {\n    return this._future.length > 0;\n  }\n  splitPastWorkspaceElement(toRemove, individualMap) {\n    for (let j = this._past.length - 1; j >= 0; j--) {\n      if (this._past[j] === toRemove) {\n        if (individualMap.has(this.strResource)) {\n          // gets replaced\n          this._past[j] = individualMap.get(this.strResource);\n        } else {\n          // gets deleted\n          this._past.splice(j, 1);\n        }\n        break;\n      }\n    }\n    this.versionId++;\n  }\n  splitFutureWorkspaceElement(toRemove, individualMap) {\n    for (let j = this._future.length - 1; j >= 0; j--) {\n      if (this._future[j] === toRemove) {\n        if (individualMap.has(this.strResource)) {\n          // gets replaced\n          this._future[j] = individualMap.get(this.strResource);\n        } else {\n          // gets deleted\n          this._future.splice(j, 1);\n        }\n        break;\n      }\n    }\n    this.versionId++;\n  }\n  moveBackward(element) {\n    this._past.pop();\n    this._future.push(element);\n    this.versionId++;\n  }\n  moveForward(element) {\n    this._future.pop();\n    this._past.push(element);\n    this.versionId++;\n  }\n}\nclass EditStackSnapshot {\n  constructor(editStacks) {\n    this.editStacks = editStacks;\n    this._versionIds = [];\n    for (let i = 0, len = this.editStacks.length; i < len; i++) {\n      this._versionIds[i] = this.editStacks[i].versionId;\n    }\n  }\n  isValid() {\n    for (let i = 0, len = this.editStacks.length; i < len; i++) {\n      if (this._versionIds[i] !== this.editStacks[i].versionId) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nconst missingEditStack = new ResourceEditStack('', '');\nmissingEditStack.locked = true;\nlet UndoRedoService = class UndoRedoService {\n  constructor(_dialogService, _notificationService) {\n    this._dialogService = _dialogService;\n    this._notificationService = _notificationService;\n    this._editStacks = new Map();\n    this._uriComparisonKeyComputers = [];\n  }\n  getUriComparisonKey(resource) {\n    for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {\n      if (uriComparisonKeyComputer[0] === resource.scheme) {\n        return uriComparisonKeyComputer[1].getComparisonKey(resource);\n      }\n    }\n    return resource.toString();\n  }\n  _print(label) {\n    console.log(\"------------------------------------\");\n    console.log(\"AFTER \".concat(label, \": \"));\n    let str = [];\n    for (const element of this._editStacks) {\n      str.push(element[1].toString());\n    }\n    console.log(str.join('\\n'));\n  }\n  pushElement(element) {\n    let group = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UndoRedoGroup.None;\n    let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : UndoRedoSource.None;\n    if (element.type === 0 /* Resource */) {\n      const resourceLabel = getResourceLabel(element.resource);\n      const strResource = this.getUriComparisonKey(element.resource);\n      this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));\n    } else {\n      const seen = new Set();\n      const resourceLabels = [];\n      const strResources = [];\n      for (const resource of element.resources) {\n        const resourceLabel = getResourceLabel(resource);\n        const strResource = this.getUriComparisonKey(resource);\n        if (seen.has(strResource)) {\n          continue;\n        }\n        seen.add(strResource);\n        resourceLabels.push(resourceLabel);\n        strResources.push(strResource);\n      }\n      if (resourceLabels.length === 1) {\n        this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));\n      } else {\n        this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));\n      }\n    }\n    if (DEBUG) {\n      this._print('pushElement');\n    }\n  }\n  _pushElement(element) {\n    for (let i = 0, len = element.strResources.length; i < len; i++) {\n      const resourceLabel = element.resourceLabels[i];\n      const strResource = element.strResources[i];\n      let editStack;\n      if (this._editStacks.has(strResource)) {\n        editStack = this._editStacks.get(strResource);\n      } else {\n        editStack = new ResourceEditStack(resourceLabel, strResource);\n        this._editStacks.set(strResource, editStack);\n      }\n      editStack.pushElement(element);\n    }\n  }\n  getLastElement(resource) {\n    const strResource = this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      if (editStack.hasFutureElements()) {\n        return null;\n      }\n      const closestPastElement = editStack.getClosestPastElement();\n      return closestPastElement ? closestPastElement.actual : null;\n    }\n    return null;\n  }\n  _splitPastWorkspaceElement(toRemove, ignoreResources) {\n    const individualArr = toRemove.actual.split();\n    const individualMap = new Map();\n    for (const _element of individualArr) {\n      const resourceLabel = getResourceLabel(_element.resource);\n      const strResource = this.getUriComparisonKey(_element.resource);\n      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n      individualMap.set(element.strResource, element);\n    }\n    for (const strResource of toRemove.strResources) {\n      if (ignoreResources && ignoreResources.has(strResource)) {\n        continue;\n      }\n      const editStack = this._editStacks.get(strResource);\n      editStack.splitPastWorkspaceElement(toRemove, individualMap);\n    }\n  }\n  _splitFutureWorkspaceElement(toRemove, ignoreResources) {\n    const individualArr = toRemove.actual.split();\n    const individualMap = new Map();\n    for (const _element of individualArr) {\n      const resourceLabel = getResourceLabel(_element.resource);\n      const strResource = this.getUriComparisonKey(_element.resource);\n      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n      individualMap.set(element.strResource, element);\n    }\n    for (const strResource of toRemove.strResources) {\n      if (ignoreResources && ignoreResources.has(strResource)) {\n        continue;\n      }\n      const editStack = this._editStacks.get(strResource);\n      editStack.splitFutureWorkspaceElement(toRemove, individualMap);\n    }\n  }\n  removeElements(resource) {\n    const strResource = typeof resource === 'string' ? resource : this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      editStack.dispose();\n      this._editStacks.delete(strResource);\n    }\n    if (DEBUG) {\n      this._print('removeElements');\n    }\n  }\n  setElementsValidFlag(resource, isValid, filter) {\n    const strResource = this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      editStack.setElementsValidFlag(isValid, filter);\n    }\n    if (DEBUG) {\n      this._print('setElementsValidFlag');\n    }\n  }\n  createSnapshot(resource) {\n    const strResource = this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      return editStack.createSnapshot(resource);\n    }\n    return new ResourceEditStackSnapshot(resource, []);\n  }\n  restoreSnapshot(snapshot) {\n    const strResource = this.getUriComparisonKey(snapshot.resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      editStack.restoreSnapshot(snapshot);\n      if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {\n        // the edit stack is now empty, just remove it entirely\n        editStack.dispose();\n        this._editStacks.delete(strResource);\n      }\n    }\n    if (DEBUG) {\n      this._print('restoreSnapshot');\n    }\n  }\n  getElements(resource) {\n    const strResource = this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      return editStack.getElements();\n    }\n    return {\n      past: [],\n      future: []\n    };\n  }\n  _findClosestUndoElementWithSource(sourceId) {\n    if (!sourceId) {\n      return [null, null];\n    }\n    // find an element with the sourceId and with the highest sourceOrder ready to be undone\n    let matchedElement = null;\n    let matchedStrResource = null;\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestPastElement();\n      if (!candidate) {\n        continue;\n      }\n      if (candidate.sourceId === sourceId) {\n        if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n    return [matchedElement, matchedStrResource];\n  }\n  canUndo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n      return matchedStrResource ? true : false;\n    }\n    const strResource = this.getUriComparisonKey(resourceOrSource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      return editStack.hasPastElements();\n    }\n    return false;\n  }\n  _onError(err, element) {\n    onUnexpectedError(err);\n    // An error occured while undoing or redoing => drop the undo/redo stack for all affected resources\n    for (const strResource of element.strResources) {\n      this.removeElements(strResource);\n    }\n    this._notificationService.error(err);\n  }\n  _acquireLocks(editStackSnapshot) {\n    // first, check if all locks can be acquired\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.locked) {\n        throw new Error('Cannot acquire edit stack lock');\n      }\n    }\n    // can acquire all locks\n    for (const editStack of editStackSnapshot.editStacks) {\n      editStack.locked = true;\n    }\n    return () => {\n      // release all locks\n      for (const editStack of editStackSnapshot.editStacks) {\n        editStack.locked = false;\n      }\n    };\n  }\n  _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {\n    const releaseLocks = this._acquireLocks(editStackSnapshot);\n    let result;\n    try {\n      result = invoke();\n    } catch (err) {\n      releaseLocks();\n      cleanup.dispose();\n      return this._onError(err, element);\n    }\n    if (result) {\n      // result is Promise<void>\n      return result.then(() => {\n        releaseLocks();\n        cleanup.dispose();\n        return continuation();\n      }, err => {\n        releaseLocks();\n        cleanup.dispose();\n        return this._onError(err, element);\n      });\n    } else {\n      // result is void\n      releaseLocks();\n      cleanup.dispose();\n      return continuation();\n    }\n  }\n  _invokeWorkspacePrepare(element) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof element.actual.prepareUndoRedo === 'undefined') {\n        return Disposable.None;\n      }\n      const result = element.actual.prepareUndoRedo();\n      if (typeof result === 'undefined') {\n        return Disposable.None;\n      }\n      return result;\n    });\n  }\n  _invokeResourcePrepare(element, callback) {\n    if (element.actual.type !== 1 /* Workspace */ || typeof element.actual.prepareUndoRedo === 'undefined') {\n      // no preparation needed\n      return callback(Disposable.None);\n    }\n    const r = element.actual.prepareUndoRedo();\n    if (!r) {\n      // nothing to clean up\n      return callback(Disposable.None);\n    }\n    if (isDisposable(r)) {\n      return callback(r);\n    }\n    return r.then(disposable => {\n      return callback(disposable);\n    });\n  }\n  _getAffectedEditStacks(element) {\n    const affectedEditStacks = [];\n    for (const strResource of element.strResources) {\n      affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);\n    }\n    return new EditStackSnapshot(affectedEditStacks);\n  }\n  _tryToSplitAndUndo(strResource, element, ignoreResources, message) {\n    if (element.canSplit()) {\n      this._splitPastWorkspaceElement(element, ignoreResources);\n      this._notificationService.info(message);\n      return new WorkspaceVerificationError(this._undo(strResource, 0, true));\n    } else {\n      // Cannot safely split this workspace element => flush all undo/redo stacks\n      for (const strResource of element.strResources) {\n        this.removeElements(strResource);\n      }\n      this._notificationService.info(message);\n      return new WorkspaceVerificationError();\n    }\n  }\n  _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n    if (element.removedResources) {\n      return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({\n        key: 'cannotWorkspaceUndo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not undo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n    }\n    if (checkInvalidatedResources && element.invalidatedResources) {\n      return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({\n        key: 'cannotWorkspaceUndo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not undo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n    }\n    // this must be the last past element in all the impacted resources!\n    const cannotUndoDueToResources = [];\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.getClosestPastElement() !== element) {\n        cannotUndoDueToResources.push(editStack.resourceLabel);\n      }\n    }\n    if (cannotUndoDueToResources.length > 0) {\n      return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceUndoDueToChanges',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not undo '{0}' across all files because changes were made to {1}\", element.label, cannotUndoDueToResources.join(', ')));\n    }\n    const cannotLockDueToResources = [];\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.locked) {\n        cannotLockDueToResources.push(editStack.resourceLabel);\n      }\n    }\n    if (cannotLockDueToResources.length > 0) {\n      return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceUndoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n    }\n    // check if new stack elements were added in the meantime...\n    if (!editStackSnapshot.isValid()) {\n      return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n    }\n    return null;\n  }\n  _workspaceUndo(strResource, element, undoConfirmed) {\n    const affectedEditStacks = this._getAffectedEditStacks(element);\n    const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/false);\n    if (verificationError) {\n      return verificationError.returnValue;\n    }\n    return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);\n  }\n  _isPartOfUndoGroup(element) {\n    if (!element.groupId) {\n      return false;\n    }\n    // check that there is at least another element with the same groupId ready to be undone\n    for (const [, editStack] of this._editStacks) {\n      const pastElement = editStack.getClosestPastElement();\n      if (!pastElement) {\n        continue;\n      }\n      if (pastElement === element) {\n        const secondPastElement = editStack.getSecondClosestPastElement();\n        if (secondPastElement && secondPastElement.groupId === element.groupId) {\n          // there is another element with the same group id in the same stack!\n          return true;\n        }\n      }\n      if (pastElement.groupId === element.groupId) {\n        // there is another element with the same group id in another stack!\n        return true;\n      }\n    }\n    return false;\n  }\n  _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (element.canSplit() && !this._isPartOfUndoGroup(element)) {\n        // this element can be split\n        const result = yield this._dialogService.show(Severity.Info, nls.localize('confirmWorkspace', \"Would you like to undo '{0}' across all files?\", element.label), [nls.localize({\n          key: 'ok',\n          comment: ['{0} denotes a number that is > 1']\n        }, \"Undo in {0} Files\", editStackSnapshot.editStacks.length), nls.localize('nok', \"Undo this File\"), nls.localize('cancel', \"Cancel\")], {\n          cancelId: 2\n        });\n        if (result.choice === 2) {\n          // choice: cancel\n          return;\n        }\n        if (result.choice === 1) {\n          // choice: undo this file\n          this._splitPastWorkspaceElement(element, null);\n          return this._undo(strResource, 0, true);\n        }\n        // choice: undo in all files\n        // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)\n        const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*invalidated resources will be checked after the prepare call*/false);\n        if (verificationError1) {\n          return verificationError1.returnValue;\n        }\n        undoConfirmed = true;\n      }\n      // prepare\n      let cleanup;\n      try {\n        cleanup = yield this._invokeWorkspacePrepare(element);\n      } catch (err) {\n        return this._onError(err, element);\n      }\n      // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n      const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/true);\n      if (verificationError2) {\n        cleanup.dispose();\n        return verificationError2.returnValue;\n      }\n      for (const editStack of editStackSnapshot.editStacks) {\n        editStack.moveBackward(element);\n      }\n      return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n    });\n  }\n  _resourceUndo(editStack, element, undoConfirmed) {\n    if (!element.isValid) {\n      // invalid element => immediately flush edit stack!\n      editStack.flushAllElements();\n      return;\n    }\n    if (editStack.locked) {\n      const message = nls.localize({\n        key: 'cannotResourceUndoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation.']\n      }, \"Could not undo '{0}' because there is already an undo or redo operation running.\", element.label);\n      this._notificationService.info(message);\n      return;\n    }\n    return this._invokeResourcePrepare(element, cleanup => {\n      editStack.moveBackward(element);\n      return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n    });\n  }\n  _findClosestUndoElementInGroup(groupId) {\n    if (!groupId) {\n      return [null, null];\n    }\n    // find another element with the same groupId and with the highest groupOrder ready to be undone\n    let matchedElement = null;\n    let matchedStrResource = null;\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestPastElement();\n      if (!candidate) {\n        continue;\n      }\n      if (candidate.groupId === groupId) {\n        if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n    return [matchedElement, matchedStrResource];\n  }\n  _continueUndoInGroup(groupId, undoConfirmed) {\n    if (!groupId) {\n      return;\n    }\n    const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);\n    if (matchedStrResource) {\n      return this._undo(matchedStrResource, 0, undoConfirmed);\n    }\n  }\n  undo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n      return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : undefined;\n    }\n    if (typeof resourceOrSource === 'string') {\n      return this._undo(resourceOrSource, 0, false);\n    }\n    return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);\n  }\n  _undo(strResource) {\n    let sourceId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let undoConfirmed = arguments.length > 2 ? arguments[2] : undefined;\n    if (!this._editStacks.has(strResource)) {\n      return;\n    }\n    const editStack = this._editStacks.get(strResource);\n    const element = editStack.getClosestPastElement();\n    if (!element) {\n      return;\n    }\n    if (element.groupId) {\n      // this element is a part of a group, we need to make sure undoing in a group is in order\n      const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);\n      if (element !== matchedElement && matchedStrResource) {\n        // there is an element in the same group that should be undone before this one\n        return this._undo(matchedStrResource, sourceId, undoConfirmed);\n      }\n    }\n    const shouldPromptForConfirmation = element.sourceId !== sourceId || element.confirmBeforeUndo;\n    if (shouldPromptForConfirmation && !undoConfirmed) {\n      // Hit a different source or the element asks for prompt before undo, prompt for confirmation\n      return this._confirmAndContinueUndo(strResource, sourceId, element);\n    }\n    try {\n      if (element.type === 1 /* Workspace */) {\n        return this._workspaceUndo(strResource, element, undoConfirmed);\n      } else {\n        return this._resourceUndo(editStack, element, undoConfirmed);\n      }\n    } finally {\n      if (DEBUG) {\n        this._print('undo');\n      }\n    }\n  }\n  _confirmAndContinueUndo(strResource, sourceId, element) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield this._dialogService.show(Severity.Info, nls.localize('confirmDifferentSource', \"Would you like to undo '{0}'?\", element.label), [nls.localize('confirmDifferentSource.ok', \"Undo\"), nls.localize('cancel', \"Cancel\")], {\n        cancelId: 1\n      });\n      if (result.choice === 1) {\n        // choice: cancel\n        return;\n      }\n      // choice: undo\n      return this._undo(strResource, sourceId, true);\n    });\n  }\n  _findClosestRedoElementWithSource(sourceId) {\n    if (!sourceId) {\n      return [null, null];\n    }\n    // find an element with sourceId and with the lowest sourceOrder ready to be redone\n    let matchedElement = null;\n    let matchedStrResource = null;\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestFutureElement();\n      if (!candidate) {\n        continue;\n      }\n      if (candidate.sourceId === sourceId) {\n        if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n    return [matchedElement, matchedStrResource];\n  }\n  canRedo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n      return matchedStrResource ? true : false;\n    }\n    const strResource = this.getUriComparisonKey(resourceOrSource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      return editStack.hasFutureElements();\n    }\n    return false;\n  }\n  _tryToSplitAndRedo(strResource, element, ignoreResources, message) {\n    if (element.canSplit()) {\n      this._splitFutureWorkspaceElement(element, ignoreResources);\n      this._notificationService.info(message);\n      return new WorkspaceVerificationError(this._redo(strResource));\n    } else {\n      // Cannot safely split this workspace element => flush all undo/redo stacks\n      for (const strResource of element.strResources) {\n        this.removeElements(strResource);\n      }\n      this._notificationService.info(message);\n      return new WorkspaceVerificationError();\n    }\n  }\n  _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n    if (element.removedResources) {\n      return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({\n        key: 'cannotWorkspaceRedo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not redo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n    }\n    if (checkInvalidatedResources && element.invalidatedResources) {\n      return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({\n        key: 'cannotWorkspaceRedo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not redo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n    }\n    // this must be the last future element in all the impacted resources!\n    const cannotRedoDueToResources = [];\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.getClosestFutureElement() !== element) {\n        cannotRedoDueToResources.push(editStack.resourceLabel);\n      }\n    }\n    if (cannotRedoDueToResources.length > 0) {\n      return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceRedoDueToChanges',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not redo '{0}' across all files because changes were made to {1}\", element.label, cannotRedoDueToResources.join(', ')));\n    }\n    const cannotLockDueToResources = [];\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.locked) {\n        cannotLockDueToResources.push(editStack.resourceLabel);\n      }\n    }\n    if (cannotLockDueToResources.length > 0) {\n      return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceRedoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n    }\n    // check if new stack elements were added in the meantime...\n    if (!editStackSnapshot.isValid()) {\n      return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n    }\n    return null;\n  }\n  _workspaceRedo(strResource, element) {\n    const affectedEditStacks = this._getAffectedEditStacks(element);\n    const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/false);\n    if (verificationError) {\n      return verificationError.returnValue;\n    }\n    return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);\n  }\n  _executeWorkspaceRedo(strResource, element, editStackSnapshot) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // prepare\n      let cleanup;\n      try {\n        cleanup = yield this._invokeWorkspacePrepare(element);\n      } catch (err) {\n        return this._onError(err, element);\n      }\n      // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n      const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/true);\n      if (verificationError) {\n        cleanup.dispose();\n        return verificationError.returnValue;\n      }\n      for (const editStack of editStackSnapshot.editStacks) {\n        editStack.moveForward(element);\n      }\n      return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));\n    });\n  }\n  _resourceRedo(editStack, element) {\n    if (!element.isValid) {\n      // invalid element => immediately flush edit stack!\n      editStack.flushAllElements();\n      return;\n    }\n    if (editStack.locked) {\n      const message = nls.localize({\n        key: 'cannotResourceRedoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation.']\n      }, \"Could not redo '{0}' because there is already an undo or redo operation running.\", element.label);\n      this._notificationService.info(message);\n      return;\n    }\n    return this._invokeResourcePrepare(element, cleanup => {\n      editStack.moveForward(element);\n      return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));\n    });\n  }\n  _findClosestRedoElementInGroup(groupId) {\n    if (!groupId) {\n      return [null, null];\n    }\n    // find another element with the same groupId and with the lowest groupOrder ready to be redone\n    let matchedElement = null;\n    let matchedStrResource = null;\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestFutureElement();\n      if (!candidate) {\n        continue;\n      }\n      if (candidate.groupId === groupId) {\n        if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n    return [matchedElement, matchedStrResource];\n  }\n  _continueRedoInGroup(groupId) {\n    if (!groupId) {\n      return;\n    }\n    const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);\n    if (matchedStrResource) {\n      return this._redo(matchedStrResource);\n    }\n  }\n  redo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n      return matchedStrResource ? this._redo(matchedStrResource) : undefined;\n    }\n    if (typeof resourceOrSource === 'string') {\n      return this._redo(resourceOrSource);\n    }\n    return this._redo(this.getUriComparisonKey(resourceOrSource));\n  }\n  _redo(strResource) {\n    if (!this._editStacks.has(strResource)) {\n      return;\n    }\n    const editStack = this._editStacks.get(strResource);\n    const element = editStack.getClosestFutureElement();\n    if (!element) {\n      return;\n    }\n    if (element.groupId) {\n      // this element is a part of a group, we need to make sure redoing in a group is in order\n      const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);\n      if (element !== matchedElement && matchedStrResource) {\n        // there is an element in the same group that should be redone before this one\n        return this._redo(matchedStrResource);\n      }\n    }\n    try {\n      if (element.type === 1 /* Workspace */) {\n        return this._workspaceRedo(strResource, element);\n      } else {\n        return this._resourceRedo(editStack, element);\n      }\n    } finally {\n      if (DEBUG) {\n        this._print('redo');\n      }\n    }\n  }\n};\nUndoRedoService = __decorate([__param(0, IDialogService), __param(1, INotificationService)], UndoRedoService);\nexport { UndoRedoService };\nclass WorkspaceVerificationError {\n  constructor(returnValue) {\n    this.returnValue = returnValue;\n  }\n}\nregisterSingleton(IUndoRedoService, UndoRedoService);","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","nls","IUndoRedoService","ResourceEditStackSnapshot","UndoRedoGroup","UndoRedoSource","onUnexpectedError","registerSingleton","IDialogService","Severity","Schemas","INotificationService","Disposable","isDisposable","DEBUG","getResourceLabel","resource","scheme","file","fsPath","path","stackElementCounter","ResourceStackElement","constructor","actual","resourceLabel","strResource","groupId","groupOrder","sourceId","sourceOrder","id","type","label","confirmBeforeUndo","resourceLabels","strResources","isValid","setValid","toString","concat","name","ResourceReasonPair","reason","RemovedResources","elements","Map","createMessage","externalRemoval","noParallelUniverses","element","dest","push","messages","localize","comment","join","size","has","set","delete","WorkspaceStackElement","removedResources","invalidatedResources","canSplit","split","removeResource","ResourceEditStack","_past","_future","locked","versionId","dispose","flushAllElements","_setElementValidFlag","setElementsValidFlag","filter","pushElement","futureElement","createSnapshot","len","restoreSnapshot","snapshot","snapshotLength","isOK","snapshotIndex","removePastAfter","removeFutureBefore","slice","getElements","past","future","getClosestPastElement","getSecondClosestPastElement","getClosestFutureElement","hasPastElements","hasFutureElements","splitPastWorkspaceElement","toRemove","individualMap","j","get","splice","splitFutureWorkspaceElement","moveBackward","pop","moveForward","EditStackSnapshot","editStacks","_versionIds","missingEditStack","UndoRedoService","_dialogService","_notificationService","_editStacks","_uriComparisonKeyComputers","getUriComparisonKey","uriComparisonKeyComputer","getComparisonKey","_print","console","log","str","group","undefined","None","source","_pushElement","nextOrder","seen","Set","resources","add","editStack","getLastElement","closestPastElement","_splitPastWorkspaceElement","ignoreResources","individualArr","_element","_splitFutureWorkspaceElement","removeElements","_findClosestUndoElementWithSource","matchedElement","matchedStrResource","candidate","canUndo","resourceOrSource","_onError","err","error","_acquireLocks","editStackSnapshot","Error","_safeInvokeWithLocks","invoke","cleanup","continuation","releaseLocks","_invokeWorkspacePrepare","prepareUndoRedo","_invokeResourcePrepare","callback","disposable","_getAffectedEditStacks","affectedEditStacks","_tryToSplitAndUndo","message","info","WorkspaceVerificationError","_undo","_checkWorkspaceUndo","checkInvalidatedResources","cannotUndoDueToResources","cannotLockDueToResources","_workspaceUndo","undoConfirmed","verificationError","returnValue","_confirmAndExecuteWorkspaceUndo","_isPartOfUndoGroup","pastElement","secondPastElement","show","Info","cancelId","choice","verificationError1","verificationError2","undo","_continueUndoInGroup","_resourceUndo","_findClosestUndoElementInGroup","shouldPromptForConfirmation","_confirmAndContinueUndo","_findClosestRedoElementWithSource","canRedo","_tryToSplitAndRedo","_redo","_checkWorkspaceRedo","cannotRedoDueToResources","_workspaceRedo","_executeWorkspaceRedo","redo","_continueRedoInGroup","_resourceRedo","_findClosestRedoElementInGroup"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport * as nls from '../../../nls.js';\r\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource } from './undoRedo.js';\r\nimport { onUnexpectedError } from '../../../base/common/errors.js';\r\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\r\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\r\nimport Severity from '../../../base/common/severity.js';\r\nimport { Schemas } from '../../../base/common/network.js';\r\nimport { INotificationService } from '../../notification/common/notification.js';\r\nimport { Disposable, isDisposable } from '../../../base/common/lifecycle.js';\r\nconst DEBUG = false;\r\nfunction getResourceLabel(resource) {\r\n    return resource.scheme === Schemas.file ? resource.fsPath : resource.path;\r\n}\r\nlet stackElementCounter = 0;\r\nclass ResourceStackElement {\r\n    constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {\r\n        this.id = (++stackElementCounter);\r\n        this.type = 0 /* Resource */;\r\n        this.actual = actual;\r\n        this.label = actual.label;\r\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\r\n        this.resourceLabel = resourceLabel;\r\n        this.strResource = strResource;\r\n        this.resourceLabels = [this.resourceLabel];\r\n        this.strResources = [this.strResource];\r\n        this.groupId = groupId;\r\n        this.groupOrder = groupOrder;\r\n        this.sourceId = sourceId;\r\n        this.sourceOrder = sourceOrder;\r\n        this.isValid = true;\r\n    }\r\n    setValid(isValid) {\r\n        this.isValid = isValid;\r\n    }\r\n    toString() {\r\n        return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? '  VALID' : 'INVALID'}] ${this.actual.constructor.name} - ${this.actual}`;\r\n    }\r\n}\r\nclass ResourceReasonPair {\r\n    constructor(resourceLabel, reason) {\r\n        this.resourceLabel = resourceLabel;\r\n        this.reason = reason;\r\n    }\r\n}\r\nclass RemovedResources {\r\n    constructor() {\r\n        this.elements = new Map();\r\n    }\r\n    createMessage() {\r\n        const externalRemoval = [];\r\n        const noParallelUniverses = [];\r\n        for (const [, element] of this.elements) {\r\n            const dest = (element.reason === 0 /* ExternalRemoval */\r\n                ? externalRemoval\r\n                : noParallelUniverses);\r\n            dest.push(element.resourceLabel);\r\n        }\r\n        let messages = [];\r\n        if (externalRemoval.length > 0) {\r\n            messages.push(nls.localize({ key: 'externalRemoval', comment: ['{0} is a list of filenames'] }, \"The following files have been closed and modified on disk: {0}.\", externalRemoval.join(', ')));\r\n        }\r\n        if (noParallelUniverses.length > 0) {\r\n            messages.push(nls.localize({ key: 'noParallelUniverses', comment: ['{0} is a list of filenames'] }, \"The following files have been modified in an incompatible way: {0}.\", noParallelUniverses.join(', ')));\r\n        }\r\n        return messages.join('\\n');\r\n    }\r\n    get size() {\r\n        return this.elements.size;\r\n    }\r\n    has(strResource) {\r\n        return this.elements.has(strResource);\r\n    }\r\n    set(strResource, value) {\r\n        this.elements.set(strResource, value);\r\n    }\r\n    delete(strResource) {\r\n        return this.elements.delete(strResource);\r\n    }\r\n}\r\nclass WorkspaceStackElement {\r\n    constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {\r\n        this.id = (++stackElementCounter);\r\n        this.type = 1 /* Workspace */;\r\n        this.actual = actual;\r\n        this.label = actual.label;\r\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\r\n        this.resourceLabels = resourceLabels;\r\n        this.strResources = strResources;\r\n        this.groupId = groupId;\r\n        this.groupOrder = groupOrder;\r\n        this.sourceId = sourceId;\r\n        this.sourceOrder = sourceOrder;\r\n        this.removedResources = null;\r\n        this.invalidatedResources = null;\r\n    }\r\n    canSplit() {\r\n        return (typeof this.actual.split === 'function');\r\n    }\r\n    removeResource(resourceLabel, strResource, reason) {\r\n        if (!this.removedResources) {\r\n            this.removedResources = new RemovedResources();\r\n        }\r\n        if (!this.removedResources.has(strResource)) {\r\n            this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));\r\n        }\r\n    }\r\n    setValid(resourceLabel, strResource, isValid) {\r\n        if (isValid) {\r\n            if (this.invalidatedResources) {\r\n                this.invalidatedResources.delete(strResource);\r\n                if (this.invalidatedResources.size === 0) {\r\n                    this.invalidatedResources = null;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (!this.invalidatedResources) {\r\n                this.invalidatedResources = new RemovedResources();\r\n            }\r\n            if (!this.invalidatedResources.has(strResource)) {\r\n                this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0 /* ExternalRemoval */));\r\n            }\r\n        }\r\n    }\r\n    toString() {\r\n        return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? 'INVALID' : '  VALID'}] ${this.actual.constructor.name} - ${this.actual}`;\r\n    }\r\n}\r\nclass ResourceEditStack {\r\n    constructor(resourceLabel, strResource) {\r\n        this.resourceLabel = resourceLabel;\r\n        this.strResource = strResource;\r\n        this._past = [];\r\n        this._future = [];\r\n        this.locked = false;\r\n        this.versionId = 1;\r\n    }\r\n    dispose() {\r\n        for (const element of this._past) {\r\n            if (element.type === 1 /* Workspace */) {\r\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\r\n            }\r\n        }\r\n        for (const element of this._future) {\r\n            if (element.type === 1 /* Workspace */) {\r\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\r\n            }\r\n        }\r\n        this.versionId++;\r\n    }\r\n    toString() {\r\n        let result = [];\r\n        result.push(`* ${this.strResource}:`);\r\n        for (let i = 0; i < this._past.length; i++) {\r\n            result.push(`   * [UNDO] ${this._past[i]}`);\r\n        }\r\n        for (let i = this._future.length - 1; i >= 0; i--) {\r\n            result.push(`   * [REDO] ${this._future[i]}`);\r\n        }\r\n        return result.join('\\n');\r\n    }\r\n    flushAllElements() {\r\n        this._past = [];\r\n        this._future = [];\r\n        this.versionId++;\r\n    }\r\n    _setElementValidFlag(element, isValid) {\r\n        if (element.type === 1 /* Workspace */) {\r\n            element.setValid(this.resourceLabel, this.strResource, isValid);\r\n        }\r\n        else {\r\n            element.setValid(isValid);\r\n        }\r\n    }\r\n    setElementsValidFlag(isValid, filter) {\r\n        for (const element of this._past) {\r\n            if (filter(element.actual)) {\r\n                this._setElementValidFlag(element, isValid);\r\n            }\r\n        }\r\n        for (const element of this._future) {\r\n            if (filter(element.actual)) {\r\n                this._setElementValidFlag(element, isValid);\r\n            }\r\n        }\r\n    }\r\n    pushElement(element) {\r\n        // remove the future\r\n        for (const futureElement of this._future) {\r\n            if (futureElement.type === 1 /* Workspace */) {\r\n                futureElement.removeResource(this.resourceLabel, this.strResource, 1 /* NoParallelUniverses */);\r\n            }\r\n        }\r\n        this._future = [];\r\n        this._past.push(element);\r\n        this.versionId++;\r\n    }\r\n    createSnapshot(resource) {\r\n        const elements = [];\r\n        for (let i = 0, len = this._past.length; i < len; i++) {\r\n            elements.push(this._past[i].id);\r\n        }\r\n        for (let i = this._future.length - 1; i >= 0; i--) {\r\n            elements.push(this._future[i].id);\r\n        }\r\n        return new ResourceEditStackSnapshot(resource, elements);\r\n    }\r\n    restoreSnapshot(snapshot) {\r\n        const snapshotLength = snapshot.elements.length;\r\n        let isOK = true;\r\n        let snapshotIndex = 0;\r\n        let removePastAfter = -1;\r\n        for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {\r\n            const element = this._past[i];\r\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\r\n                isOK = false;\r\n                removePastAfter = 0;\r\n            }\r\n            if (!isOK && element.type === 1 /* Workspace */) {\r\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\r\n            }\r\n        }\r\n        let removeFutureBefore = -1;\r\n        for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {\r\n            const element = this._future[i];\r\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\r\n                isOK = false;\r\n                removeFutureBefore = i;\r\n            }\r\n            if (!isOK && element.type === 1 /* Workspace */) {\r\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\r\n            }\r\n        }\r\n        if (removePastAfter !== -1) {\r\n            this._past = this._past.slice(0, removePastAfter);\r\n        }\r\n        if (removeFutureBefore !== -1) {\r\n            this._future = this._future.slice(removeFutureBefore + 1);\r\n        }\r\n        this.versionId++;\r\n    }\r\n    getElements() {\r\n        const past = [];\r\n        const future = [];\r\n        for (const element of this._past) {\r\n            past.push(element.actual);\r\n        }\r\n        for (const element of this._future) {\r\n            future.push(element.actual);\r\n        }\r\n        return { past, future };\r\n    }\r\n    getClosestPastElement() {\r\n        if (this._past.length === 0) {\r\n            return null;\r\n        }\r\n        return this._past[this._past.length - 1];\r\n    }\r\n    getSecondClosestPastElement() {\r\n        if (this._past.length < 2) {\r\n            return null;\r\n        }\r\n        return this._past[this._past.length - 2];\r\n    }\r\n    getClosestFutureElement() {\r\n        if (this._future.length === 0) {\r\n            return null;\r\n        }\r\n        return this._future[this._future.length - 1];\r\n    }\r\n    hasPastElements() {\r\n        return (this._past.length > 0);\r\n    }\r\n    hasFutureElements() {\r\n        return (this._future.length > 0);\r\n    }\r\n    splitPastWorkspaceElement(toRemove, individualMap) {\r\n        for (let j = this._past.length - 1; j >= 0; j--) {\r\n            if (this._past[j] === toRemove) {\r\n                if (individualMap.has(this.strResource)) {\r\n                    // gets replaced\r\n                    this._past[j] = individualMap.get(this.strResource);\r\n                }\r\n                else {\r\n                    // gets deleted\r\n                    this._past.splice(j, 1);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        this.versionId++;\r\n    }\r\n    splitFutureWorkspaceElement(toRemove, individualMap) {\r\n        for (let j = this._future.length - 1; j >= 0; j--) {\r\n            if (this._future[j] === toRemove) {\r\n                if (individualMap.has(this.strResource)) {\r\n                    // gets replaced\r\n                    this._future[j] = individualMap.get(this.strResource);\r\n                }\r\n                else {\r\n                    // gets deleted\r\n                    this._future.splice(j, 1);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        this.versionId++;\r\n    }\r\n    moveBackward(element) {\r\n        this._past.pop();\r\n        this._future.push(element);\r\n        this.versionId++;\r\n    }\r\n    moveForward(element) {\r\n        this._future.pop();\r\n        this._past.push(element);\r\n        this.versionId++;\r\n    }\r\n}\r\nclass EditStackSnapshot {\r\n    constructor(editStacks) {\r\n        this.editStacks = editStacks;\r\n        this._versionIds = [];\r\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\r\n            this._versionIds[i] = this.editStacks[i].versionId;\r\n        }\r\n    }\r\n    isValid() {\r\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\r\n            if (this._versionIds[i] !== this.editStacks[i].versionId) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nconst missingEditStack = new ResourceEditStack('', '');\r\nmissingEditStack.locked = true;\r\nlet UndoRedoService = class UndoRedoService {\r\n    constructor(_dialogService, _notificationService) {\r\n        this._dialogService = _dialogService;\r\n        this._notificationService = _notificationService;\r\n        this._editStacks = new Map();\r\n        this._uriComparisonKeyComputers = [];\r\n    }\r\n    getUriComparisonKey(resource) {\r\n        for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {\r\n            if (uriComparisonKeyComputer[0] === resource.scheme) {\r\n                return uriComparisonKeyComputer[1].getComparisonKey(resource);\r\n            }\r\n        }\r\n        return resource.toString();\r\n    }\r\n    _print(label) {\r\n        console.log(`------------------------------------`);\r\n        console.log(`AFTER ${label}: `);\r\n        let str = [];\r\n        for (const element of this._editStacks) {\r\n            str.push(element[1].toString());\r\n        }\r\n        console.log(str.join('\\n'));\r\n    }\r\n    pushElement(element, group = UndoRedoGroup.None, source = UndoRedoSource.None) {\r\n        if (element.type === 0 /* Resource */) {\r\n            const resourceLabel = getResourceLabel(element.resource);\r\n            const strResource = this.getUriComparisonKey(element.resource);\r\n            this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));\r\n        }\r\n        else {\r\n            const seen = new Set();\r\n            const resourceLabels = [];\r\n            const strResources = [];\r\n            for (const resource of element.resources) {\r\n                const resourceLabel = getResourceLabel(resource);\r\n                const strResource = this.getUriComparisonKey(resource);\r\n                if (seen.has(strResource)) {\r\n                    continue;\r\n                }\r\n                seen.add(strResource);\r\n                resourceLabels.push(resourceLabel);\r\n                strResources.push(strResource);\r\n            }\r\n            if (resourceLabels.length === 1) {\r\n                this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));\r\n            }\r\n            else {\r\n                this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));\r\n            }\r\n        }\r\n        if (DEBUG) {\r\n            this._print('pushElement');\r\n        }\r\n    }\r\n    _pushElement(element) {\r\n        for (let i = 0, len = element.strResources.length; i < len; i++) {\r\n            const resourceLabel = element.resourceLabels[i];\r\n            const strResource = element.strResources[i];\r\n            let editStack;\r\n            if (this._editStacks.has(strResource)) {\r\n                editStack = this._editStacks.get(strResource);\r\n            }\r\n            else {\r\n                editStack = new ResourceEditStack(resourceLabel, strResource);\r\n                this._editStacks.set(strResource, editStack);\r\n            }\r\n            editStack.pushElement(element);\r\n        }\r\n    }\r\n    getLastElement(resource) {\r\n        const strResource = this.getUriComparisonKey(resource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            if (editStack.hasFutureElements()) {\r\n                return null;\r\n            }\r\n            const closestPastElement = editStack.getClosestPastElement();\r\n            return closestPastElement ? closestPastElement.actual : null;\r\n        }\r\n        return null;\r\n    }\r\n    _splitPastWorkspaceElement(toRemove, ignoreResources) {\r\n        const individualArr = toRemove.actual.split();\r\n        const individualMap = new Map();\r\n        for (const _element of individualArr) {\r\n            const resourceLabel = getResourceLabel(_element.resource);\r\n            const strResource = this.getUriComparisonKey(_element.resource);\r\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\r\n            individualMap.set(element.strResource, element);\r\n        }\r\n        for (const strResource of toRemove.strResources) {\r\n            if (ignoreResources && ignoreResources.has(strResource)) {\r\n                continue;\r\n            }\r\n            const editStack = this._editStacks.get(strResource);\r\n            editStack.splitPastWorkspaceElement(toRemove, individualMap);\r\n        }\r\n    }\r\n    _splitFutureWorkspaceElement(toRemove, ignoreResources) {\r\n        const individualArr = toRemove.actual.split();\r\n        const individualMap = new Map();\r\n        for (const _element of individualArr) {\r\n            const resourceLabel = getResourceLabel(_element.resource);\r\n            const strResource = this.getUriComparisonKey(_element.resource);\r\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\r\n            individualMap.set(element.strResource, element);\r\n        }\r\n        for (const strResource of toRemove.strResources) {\r\n            if (ignoreResources && ignoreResources.has(strResource)) {\r\n                continue;\r\n            }\r\n            const editStack = this._editStacks.get(strResource);\r\n            editStack.splitFutureWorkspaceElement(toRemove, individualMap);\r\n        }\r\n    }\r\n    removeElements(resource) {\r\n        const strResource = typeof resource === 'string' ? resource : this.getUriComparisonKey(resource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            editStack.dispose();\r\n            this._editStacks.delete(strResource);\r\n        }\r\n        if (DEBUG) {\r\n            this._print('removeElements');\r\n        }\r\n    }\r\n    setElementsValidFlag(resource, isValid, filter) {\r\n        const strResource = this.getUriComparisonKey(resource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            editStack.setElementsValidFlag(isValid, filter);\r\n        }\r\n        if (DEBUG) {\r\n            this._print('setElementsValidFlag');\r\n        }\r\n    }\r\n    createSnapshot(resource) {\r\n        const strResource = this.getUriComparisonKey(resource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            return editStack.createSnapshot(resource);\r\n        }\r\n        return new ResourceEditStackSnapshot(resource, []);\r\n    }\r\n    restoreSnapshot(snapshot) {\r\n        const strResource = this.getUriComparisonKey(snapshot.resource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            editStack.restoreSnapshot(snapshot);\r\n            if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {\r\n                // the edit stack is now empty, just remove it entirely\r\n                editStack.dispose();\r\n                this._editStacks.delete(strResource);\r\n            }\r\n        }\r\n        if (DEBUG) {\r\n            this._print('restoreSnapshot');\r\n        }\r\n    }\r\n    getElements(resource) {\r\n        const strResource = this.getUriComparisonKey(resource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            return editStack.getElements();\r\n        }\r\n        return { past: [], future: [] };\r\n    }\r\n    _findClosestUndoElementWithSource(sourceId) {\r\n        if (!sourceId) {\r\n            return [null, null];\r\n        }\r\n        // find an element with the sourceId and with the highest sourceOrder ready to be undone\r\n        let matchedElement = null;\r\n        let matchedStrResource = null;\r\n        for (const [strResource, editStack] of this._editStacks) {\r\n            const candidate = editStack.getClosestPastElement();\r\n            if (!candidate) {\r\n                continue;\r\n            }\r\n            if (candidate.sourceId === sourceId) {\r\n                if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {\r\n                    matchedElement = candidate;\r\n                    matchedStrResource = strResource;\r\n                }\r\n            }\r\n        }\r\n        return [matchedElement, matchedStrResource];\r\n    }\r\n    canUndo(resourceOrSource) {\r\n        if (resourceOrSource instanceof UndoRedoSource) {\r\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\r\n            return matchedStrResource ? true : false;\r\n        }\r\n        const strResource = this.getUriComparisonKey(resourceOrSource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            return editStack.hasPastElements();\r\n        }\r\n        return false;\r\n    }\r\n    _onError(err, element) {\r\n        onUnexpectedError(err);\r\n        // An error occured while undoing or redoing => drop the undo/redo stack for all affected resources\r\n        for (const strResource of element.strResources) {\r\n            this.removeElements(strResource);\r\n        }\r\n        this._notificationService.error(err);\r\n    }\r\n    _acquireLocks(editStackSnapshot) {\r\n        // first, check if all locks can be acquired\r\n        for (const editStack of editStackSnapshot.editStacks) {\r\n            if (editStack.locked) {\r\n                throw new Error('Cannot acquire edit stack lock');\r\n            }\r\n        }\r\n        // can acquire all locks\r\n        for (const editStack of editStackSnapshot.editStacks) {\r\n            editStack.locked = true;\r\n        }\r\n        return () => {\r\n            // release all locks\r\n            for (const editStack of editStackSnapshot.editStacks) {\r\n                editStack.locked = false;\r\n            }\r\n        };\r\n    }\r\n    _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {\r\n        const releaseLocks = this._acquireLocks(editStackSnapshot);\r\n        let result;\r\n        try {\r\n            result = invoke();\r\n        }\r\n        catch (err) {\r\n            releaseLocks();\r\n            cleanup.dispose();\r\n            return this._onError(err, element);\r\n        }\r\n        if (result) {\r\n            // result is Promise<void>\r\n            return result.then(() => {\r\n                releaseLocks();\r\n                cleanup.dispose();\r\n                return continuation();\r\n            }, (err) => {\r\n                releaseLocks();\r\n                cleanup.dispose();\r\n                return this._onError(err, element);\r\n            });\r\n        }\r\n        else {\r\n            // result is void\r\n            releaseLocks();\r\n            cleanup.dispose();\r\n            return continuation();\r\n        }\r\n    }\r\n    _invokeWorkspacePrepare(element) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (typeof element.actual.prepareUndoRedo === 'undefined') {\r\n                return Disposable.None;\r\n            }\r\n            const result = element.actual.prepareUndoRedo();\r\n            if (typeof result === 'undefined') {\r\n                return Disposable.None;\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    _invokeResourcePrepare(element, callback) {\r\n        if (element.actual.type !== 1 /* Workspace */ || typeof element.actual.prepareUndoRedo === 'undefined') {\r\n            // no preparation needed\r\n            return callback(Disposable.None);\r\n        }\r\n        const r = element.actual.prepareUndoRedo();\r\n        if (!r) {\r\n            // nothing to clean up\r\n            return callback(Disposable.None);\r\n        }\r\n        if (isDisposable(r)) {\r\n            return callback(r);\r\n        }\r\n        return r.then((disposable) => {\r\n            return callback(disposable);\r\n        });\r\n    }\r\n    _getAffectedEditStacks(element) {\r\n        const affectedEditStacks = [];\r\n        for (const strResource of element.strResources) {\r\n            affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);\r\n        }\r\n        return new EditStackSnapshot(affectedEditStacks);\r\n    }\r\n    _tryToSplitAndUndo(strResource, element, ignoreResources, message) {\r\n        if (element.canSplit()) {\r\n            this._splitPastWorkspaceElement(element, ignoreResources);\r\n            this._notificationService.info(message);\r\n            return new WorkspaceVerificationError(this._undo(strResource, 0, true));\r\n        }\r\n        else {\r\n            // Cannot safely split this workspace element => flush all undo/redo stacks\r\n            for (const strResource of element.strResources) {\r\n                this.removeElements(strResource);\r\n            }\r\n            this._notificationService.info(message);\r\n            return new WorkspaceVerificationError();\r\n        }\r\n    }\r\n    _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\r\n        if (element.removedResources) {\r\n            return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\r\n        }\r\n        if (checkInvalidatedResources && element.invalidatedResources) {\r\n            return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\r\n        }\r\n        // this must be the last past element in all the impacted resources!\r\n        const cannotUndoDueToResources = [];\r\n        for (const editStack of editStackSnapshot.editStacks) {\r\n            if (editStack.getClosestPastElement() !== element) {\r\n                cannotUndoDueToResources.push(editStack.resourceLabel);\r\n            }\r\n        }\r\n        if (cannotUndoDueToResources.length > 0) {\r\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because changes were made to {1}\", element.label, cannotUndoDueToResources.join(', ')));\r\n        }\r\n        const cannotLockDueToResources = [];\r\n        for (const editStack of editStackSnapshot.editStacks) {\r\n            if (editStack.locked) {\r\n                cannotLockDueToResources.push(editStack.resourceLabel);\r\n            }\r\n        }\r\n        if (cannotLockDueToResources.length > 0) {\r\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\r\n        }\r\n        // check if new stack elements were added in the meantime...\r\n        if (!editStackSnapshot.isValid()) {\r\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\r\n        }\r\n        return null;\r\n    }\r\n    _workspaceUndo(strResource, element, undoConfirmed) {\r\n        const affectedEditStacks = this._getAffectedEditStacks(element);\r\n        const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\r\n        if (verificationError) {\r\n            return verificationError.returnValue;\r\n        }\r\n        return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);\r\n    }\r\n    _isPartOfUndoGroup(element) {\r\n        if (!element.groupId) {\r\n            return false;\r\n        }\r\n        // check that there is at least another element with the same groupId ready to be undone\r\n        for (const [, editStack] of this._editStacks) {\r\n            const pastElement = editStack.getClosestPastElement();\r\n            if (!pastElement) {\r\n                continue;\r\n            }\r\n            if (pastElement === element) {\r\n                const secondPastElement = editStack.getSecondClosestPastElement();\r\n                if (secondPastElement && secondPastElement.groupId === element.groupId) {\r\n                    // there is another element with the same group id in the same stack!\r\n                    return true;\r\n                }\r\n            }\r\n            if (pastElement.groupId === element.groupId) {\r\n                // there is another element with the same group id in another stack!\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (element.canSplit() && !this._isPartOfUndoGroup(element)) {\r\n                // this element can be split\r\n                const result = yield this._dialogService.show(Severity.Info, nls.localize('confirmWorkspace', \"Would you like to undo '{0}' across all files?\", element.label), [\r\n                    nls.localize({ key: 'ok', comment: ['{0} denotes a number that is > 1'] }, \"Undo in {0} Files\", editStackSnapshot.editStacks.length),\r\n                    nls.localize('nok', \"Undo this File\"),\r\n                    nls.localize('cancel', \"Cancel\"),\r\n                ], {\r\n                    cancelId: 2\r\n                });\r\n                if (result.choice === 2) {\r\n                    // choice: cancel\r\n                    return;\r\n                }\r\n                if (result.choice === 1) {\r\n                    // choice: undo this file\r\n                    this._splitPastWorkspaceElement(element, null);\r\n                    return this._undo(strResource, 0, true);\r\n                }\r\n                // choice: undo in all files\r\n                // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)\r\n                const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*invalidated resources will be checked after the prepare call*/ false);\r\n                if (verificationError1) {\r\n                    return verificationError1.returnValue;\r\n                }\r\n                undoConfirmed = true;\r\n            }\r\n            // prepare\r\n            let cleanup;\r\n            try {\r\n                cleanup = yield this._invokeWorkspacePrepare(element);\r\n            }\r\n            catch (err) {\r\n                return this._onError(err, element);\r\n            }\r\n            // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\r\n            const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\r\n            if (verificationError2) {\r\n                cleanup.dispose();\r\n                return verificationError2.returnValue;\r\n            }\r\n            for (const editStack of editStackSnapshot.editStacks) {\r\n                editStack.moveBackward(element);\r\n            }\r\n            return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\r\n        });\r\n    }\r\n    _resourceUndo(editStack, element, undoConfirmed) {\r\n        if (!element.isValid) {\r\n            // invalid element => immediately flush edit stack!\r\n            editStack.flushAllElements();\r\n            return;\r\n        }\r\n        if (editStack.locked) {\r\n            const message = nls.localize({ key: 'cannotResourceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not undo '{0}' because there is already an undo or redo operation running.\", element.label);\r\n            this._notificationService.info(message);\r\n            return;\r\n        }\r\n        return this._invokeResourcePrepare(element, (cleanup) => {\r\n            editStack.moveBackward(element);\r\n            return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\r\n        });\r\n    }\r\n    _findClosestUndoElementInGroup(groupId) {\r\n        if (!groupId) {\r\n            return [null, null];\r\n        }\r\n        // find another element with the same groupId and with the highest groupOrder ready to be undone\r\n        let matchedElement = null;\r\n        let matchedStrResource = null;\r\n        for (const [strResource, editStack] of this._editStacks) {\r\n            const candidate = editStack.getClosestPastElement();\r\n            if (!candidate) {\r\n                continue;\r\n            }\r\n            if (candidate.groupId === groupId) {\r\n                if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {\r\n                    matchedElement = candidate;\r\n                    matchedStrResource = strResource;\r\n                }\r\n            }\r\n        }\r\n        return [matchedElement, matchedStrResource];\r\n    }\r\n    _continueUndoInGroup(groupId, undoConfirmed) {\r\n        if (!groupId) {\r\n            return;\r\n        }\r\n        const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);\r\n        if (matchedStrResource) {\r\n            return this._undo(matchedStrResource, 0, undoConfirmed);\r\n        }\r\n    }\r\n    undo(resourceOrSource) {\r\n        if (resourceOrSource instanceof UndoRedoSource) {\r\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\r\n            return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : undefined;\r\n        }\r\n        if (typeof resourceOrSource === 'string') {\r\n            return this._undo(resourceOrSource, 0, false);\r\n        }\r\n        return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);\r\n    }\r\n    _undo(strResource, sourceId = 0, undoConfirmed) {\r\n        if (!this._editStacks.has(strResource)) {\r\n            return;\r\n        }\r\n        const editStack = this._editStacks.get(strResource);\r\n        const element = editStack.getClosestPastElement();\r\n        if (!element) {\r\n            return;\r\n        }\r\n        if (element.groupId) {\r\n            // this element is a part of a group, we need to make sure undoing in a group is in order\r\n            const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);\r\n            if (element !== matchedElement && matchedStrResource) {\r\n                // there is an element in the same group that should be undone before this one\r\n                return this._undo(matchedStrResource, sourceId, undoConfirmed);\r\n            }\r\n        }\r\n        const shouldPromptForConfirmation = (element.sourceId !== sourceId || element.confirmBeforeUndo);\r\n        if (shouldPromptForConfirmation && !undoConfirmed) {\r\n            // Hit a different source or the element asks for prompt before undo, prompt for confirmation\r\n            return this._confirmAndContinueUndo(strResource, sourceId, element);\r\n        }\r\n        try {\r\n            if (element.type === 1 /* Workspace */) {\r\n                return this._workspaceUndo(strResource, element, undoConfirmed);\r\n            }\r\n            else {\r\n                return this._resourceUndo(editStack, element, undoConfirmed);\r\n            }\r\n        }\r\n        finally {\r\n            if (DEBUG) {\r\n                this._print('undo');\r\n            }\r\n        }\r\n    }\r\n    _confirmAndContinueUndo(strResource, sourceId, element) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = yield this._dialogService.show(Severity.Info, nls.localize('confirmDifferentSource', \"Would you like to undo '{0}'?\", element.label), [\r\n                nls.localize('confirmDifferentSource.ok', \"Undo\"),\r\n                nls.localize('cancel', \"Cancel\"),\r\n            ], {\r\n                cancelId: 1\r\n            });\r\n            if (result.choice === 1) {\r\n                // choice: cancel\r\n                return;\r\n            }\r\n            // choice: undo\r\n            return this._undo(strResource, sourceId, true);\r\n        });\r\n    }\r\n    _findClosestRedoElementWithSource(sourceId) {\r\n        if (!sourceId) {\r\n            return [null, null];\r\n        }\r\n        // find an element with sourceId and with the lowest sourceOrder ready to be redone\r\n        let matchedElement = null;\r\n        let matchedStrResource = null;\r\n        for (const [strResource, editStack] of this._editStacks) {\r\n            const candidate = editStack.getClosestFutureElement();\r\n            if (!candidate) {\r\n                continue;\r\n            }\r\n            if (candidate.sourceId === sourceId) {\r\n                if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {\r\n                    matchedElement = candidate;\r\n                    matchedStrResource = strResource;\r\n                }\r\n            }\r\n        }\r\n        return [matchedElement, matchedStrResource];\r\n    }\r\n    canRedo(resourceOrSource) {\r\n        if (resourceOrSource instanceof UndoRedoSource) {\r\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\r\n            return matchedStrResource ? true : false;\r\n        }\r\n        const strResource = this.getUriComparisonKey(resourceOrSource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            return editStack.hasFutureElements();\r\n        }\r\n        return false;\r\n    }\r\n    _tryToSplitAndRedo(strResource, element, ignoreResources, message) {\r\n        if (element.canSplit()) {\r\n            this._splitFutureWorkspaceElement(element, ignoreResources);\r\n            this._notificationService.info(message);\r\n            return new WorkspaceVerificationError(this._redo(strResource));\r\n        }\r\n        else {\r\n            // Cannot safely split this workspace element => flush all undo/redo stacks\r\n            for (const strResource of element.strResources) {\r\n                this.removeElements(strResource);\r\n            }\r\n            this._notificationService.info(message);\r\n            return new WorkspaceVerificationError();\r\n        }\r\n    }\r\n    _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\r\n        if (element.removedResources) {\r\n            return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\r\n        }\r\n        if (checkInvalidatedResources && element.invalidatedResources) {\r\n            return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\r\n        }\r\n        // this must be the last future element in all the impacted resources!\r\n        const cannotRedoDueToResources = [];\r\n        for (const editStack of editStackSnapshot.editStacks) {\r\n            if (editStack.getClosestFutureElement() !== element) {\r\n                cannotRedoDueToResources.push(editStack.resourceLabel);\r\n            }\r\n        }\r\n        if (cannotRedoDueToResources.length > 0) {\r\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because changes were made to {1}\", element.label, cannotRedoDueToResources.join(', ')));\r\n        }\r\n        const cannotLockDueToResources = [];\r\n        for (const editStack of editStackSnapshot.editStacks) {\r\n            if (editStack.locked) {\r\n                cannotLockDueToResources.push(editStack.resourceLabel);\r\n            }\r\n        }\r\n        if (cannotLockDueToResources.length > 0) {\r\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\r\n        }\r\n        // check if new stack elements were added in the meantime...\r\n        if (!editStackSnapshot.isValid()) {\r\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\r\n        }\r\n        return null;\r\n    }\r\n    _workspaceRedo(strResource, element) {\r\n        const affectedEditStacks = this._getAffectedEditStacks(element);\r\n        const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\r\n        if (verificationError) {\r\n            return verificationError.returnValue;\r\n        }\r\n        return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);\r\n    }\r\n    _executeWorkspaceRedo(strResource, element, editStackSnapshot) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // prepare\r\n            let cleanup;\r\n            try {\r\n                cleanup = yield this._invokeWorkspacePrepare(element);\r\n            }\r\n            catch (err) {\r\n                return this._onError(err, element);\r\n            }\r\n            // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\r\n            const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\r\n            if (verificationError) {\r\n                cleanup.dispose();\r\n                return verificationError.returnValue;\r\n            }\r\n            for (const editStack of editStackSnapshot.editStacks) {\r\n                editStack.moveForward(element);\r\n            }\r\n            return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));\r\n        });\r\n    }\r\n    _resourceRedo(editStack, element) {\r\n        if (!element.isValid) {\r\n            // invalid element => immediately flush edit stack!\r\n            editStack.flushAllElements();\r\n            return;\r\n        }\r\n        if (editStack.locked) {\r\n            const message = nls.localize({ key: 'cannotResourceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not redo '{0}' because there is already an undo or redo operation running.\", element.label);\r\n            this._notificationService.info(message);\r\n            return;\r\n        }\r\n        return this._invokeResourcePrepare(element, (cleanup) => {\r\n            editStack.moveForward(element);\r\n            return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));\r\n        });\r\n    }\r\n    _findClosestRedoElementInGroup(groupId) {\r\n        if (!groupId) {\r\n            return [null, null];\r\n        }\r\n        // find another element with the same groupId and with the lowest groupOrder ready to be redone\r\n        let matchedElement = null;\r\n        let matchedStrResource = null;\r\n        for (const [strResource, editStack] of this._editStacks) {\r\n            const candidate = editStack.getClosestFutureElement();\r\n            if (!candidate) {\r\n                continue;\r\n            }\r\n            if (candidate.groupId === groupId) {\r\n                if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {\r\n                    matchedElement = candidate;\r\n                    matchedStrResource = strResource;\r\n                }\r\n            }\r\n        }\r\n        return [matchedElement, matchedStrResource];\r\n    }\r\n    _continueRedoInGroup(groupId) {\r\n        if (!groupId) {\r\n            return;\r\n        }\r\n        const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);\r\n        if (matchedStrResource) {\r\n            return this._redo(matchedStrResource);\r\n        }\r\n    }\r\n    redo(resourceOrSource) {\r\n        if (resourceOrSource instanceof UndoRedoSource) {\r\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\r\n            return matchedStrResource ? this._redo(matchedStrResource) : undefined;\r\n        }\r\n        if (typeof resourceOrSource === 'string') {\r\n            return this._redo(resourceOrSource);\r\n        }\r\n        return this._redo(this.getUriComparisonKey(resourceOrSource));\r\n    }\r\n    _redo(strResource) {\r\n        if (!this._editStacks.has(strResource)) {\r\n            return;\r\n        }\r\n        const editStack = this._editStacks.get(strResource);\r\n        const element = editStack.getClosestFutureElement();\r\n        if (!element) {\r\n            return;\r\n        }\r\n        if (element.groupId) {\r\n            // this element is a part of a group, we need to make sure redoing in a group is in order\r\n            const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);\r\n            if (element !== matchedElement && matchedStrResource) {\r\n                // there is an element in the same group that should be redone before this one\r\n                return this._redo(matchedStrResource);\r\n            }\r\n        }\r\n        try {\r\n            if (element.type === 1 /* Workspace */) {\r\n                return this._workspaceRedo(strResource, element);\r\n            }\r\n            else {\r\n                return this._resourceRedo(editStack, element);\r\n            }\r\n        }\r\n        finally {\r\n            if (DEBUG) {\r\n                this._print('redo');\r\n            }\r\n        }\r\n    }\r\n};\r\nUndoRedoService = __decorate([\r\n    __param(0, IDialogService),\r\n    __param(1, INotificationService)\r\n], UndoRedoService);\r\nexport { UndoRedoService };\r\nclass WorkspaceVerificationError {\r\n    constructor(returnValue) {\r\n        this.returnValue = returnValue;\r\n    }\r\n}\r\nregisterSingleton(IUndoRedoService, UndoRedoService);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}