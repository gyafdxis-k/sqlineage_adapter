{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport * as paths from './path.js';\nimport { URI, uriToFsPath } from './uri.js';\nimport { compare as strCompare } from './strings.js';\nimport { Schemas } from './network.js';\nexport function originalFSPath(uri) {\n  return uriToFsPath(uri, true);\n}\nexport class ExtUri {\n  constructor(_ignorePathCasing) {\n    this._ignorePathCasing = _ignorePathCasing;\n  }\n  compare(uri1, uri2) {\n    let ignoreFragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (uri1 === uri2) {\n      return 0;\n    }\n    return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n  }\n  isEqual(uri1, uri2) {\n    let ignoreFragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (uri1 === uri2) {\n      return true;\n    }\n    if (!uri1 || !uri2) {\n      return false;\n    }\n    return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n  }\n  getComparisonKey(uri) {\n    let ignoreFragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return uri.with({\n      path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n      fragment: ignoreFragment ? null : undefined\n    }).toString();\n  }\n  // --- path math\n  joinPath(resource) {\n    for (var _len = arguments.length, pathFragment = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      pathFragment[_key - 1] = arguments[_key];\n    }\n    return URI.joinPath(resource, ...pathFragment);\n  }\n  basenameOrAuthority(resource) {\n    return basename(resource) || resource.authority;\n  }\n  basename(resource) {\n    return paths.posix.basename(resource.path);\n  }\n  dirname(resource) {\n    if (resource.path.length === 0) {\n      return resource;\n    }\n    let dirname;\n    if (resource.scheme === Schemas.file) {\n      dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n    } else {\n      dirname = paths.posix.dirname(resource.path);\n      if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* Slash */) {\n        console.error(\"dirname(\\\"\".concat(resource.toString, \")) resulted in a relative path\"));\n        dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n      }\n    }\n\n    return resource.with({\n      path: dirname\n    });\n  }\n  normalizePath(resource) {\n    if (!resource.path.length) {\n      return resource;\n    }\n    let normalizedPath;\n    if (resource.scheme === Schemas.file) {\n      normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n    } else {\n      normalizedPath = paths.posix.normalize(resource.path);\n    }\n    return resource.with({\n      path: normalizedPath\n    });\n  }\n  resolvePath(base, path) {\n    if (base.scheme === Schemas.file) {\n      const newURI = URI.file(paths.resolve(originalFSPath(base), path));\n      return base.with({\n        authority: newURI.authority,\n        path: newURI.path\n      });\n    }\n    if (path.indexOf('/') === -1) {\n      // no slashes? it's likely a Windows path\n      path = extpath.toSlashes(path);\n      if (/^[a-zA-Z]:(\\/|$)/.test(path)) {\n        // starts with a drive letter\n        path = '/' + path;\n      }\n    }\n    return base.with({\n      path: paths.posix.resolve(base.path, path)\n    });\n  }\n}\n/**\r\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\r\n * uri#toString() usages. The following is true\r\n * ```\r\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\r\n * ```\r\n */\nexport const extUri = new ExtUri(() => false);\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\n/**\r\n * Data URI related helpers.\r\n */\nexport var DataUri;\n(function (DataUri) {\n  DataUri.META_DATA_LABEL = 'label';\n  DataUri.META_DATA_DESCRIPTION = 'description';\n  DataUri.META_DATA_SIZE = 'size';\n  DataUri.META_DATA_MIME = 'mime';\n  function parseMetaData(dataUri) {\n    const metadata = new Map();\n    // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n    const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n    meta.split(';').forEach(property => {\n      const [key, value] = property.split(':');\n      if (key && value) {\n        metadata.set(key, value);\n      }\n    });\n    // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the mime is: image/png\n    const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n    if (mime) {\n      metadata.set(DataUri.META_DATA_MIME, mime);\n    }\n    return metadata;\n  }\n  DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));","map":{"version":3,"names":["extpath","paths","URI","uriToFsPath","compare","strCompare","Schemas","originalFSPath","uri","ExtUri","constructor","_ignorePathCasing","uri1","uri2","ignoreFragment","arguments","length","undefined","getComparisonKey","isEqual","with","path","toLowerCase","fragment","toString","joinPath","resource","_len","pathFragment","Array","_key","basenameOrAuthority","basename","authority","posix","dirname","scheme","file","charCodeAt","console","error","concat","normalizePath","normalizedPath","normalize","resolvePath","base","newURI","resolve","indexOf","toSlashes","test","extUri","bind","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","Map","meta","substring","lastIndexOf","split","forEach","property","key","value","set","mime"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/resources.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as extpath from './extpath.js';\r\nimport * as paths from './path.js';\r\nimport { URI, uriToFsPath } from './uri.js';\r\nimport { compare as strCompare } from './strings.js';\r\nimport { Schemas } from './network.js';\r\nexport function originalFSPath(uri) {\r\n    return uriToFsPath(uri, true);\r\n}\r\nexport class ExtUri {\r\n    constructor(_ignorePathCasing) {\r\n        this._ignorePathCasing = _ignorePathCasing;\r\n    }\r\n    compare(uri1, uri2, ignoreFragment = false) {\r\n        if (uri1 === uri2) {\r\n            return 0;\r\n        }\r\n        return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\r\n    }\r\n    isEqual(uri1, uri2, ignoreFragment = false) {\r\n        if (uri1 === uri2) {\r\n            return true;\r\n        }\r\n        if (!uri1 || !uri2) {\r\n            return false;\r\n        }\r\n        return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\r\n    }\r\n    getComparisonKey(uri, ignoreFragment = false) {\r\n        return uri.with({\r\n            path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\r\n            fragment: ignoreFragment ? null : undefined\r\n        }).toString();\r\n    }\r\n    // --- path math\r\n    joinPath(resource, ...pathFragment) {\r\n        return URI.joinPath(resource, ...pathFragment);\r\n    }\r\n    basenameOrAuthority(resource) {\r\n        return basename(resource) || resource.authority;\r\n    }\r\n    basename(resource) {\r\n        return paths.posix.basename(resource.path);\r\n    }\r\n    dirname(resource) {\r\n        if (resource.path.length === 0) {\r\n            return resource;\r\n        }\r\n        let dirname;\r\n        if (resource.scheme === Schemas.file) {\r\n            dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\r\n        }\r\n        else {\r\n            dirname = paths.posix.dirname(resource.path);\r\n            if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* Slash */) {\r\n                console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\r\n                dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\r\n            }\r\n        }\r\n        return resource.with({\r\n            path: dirname\r\n        });\r\n    }\r\n    normalizePath(resource) {\r\n        if (!resource.path.length) {\r\n            return resource;\r\n        }\r\n        let normalizedPath;\r\n        if (resource.scheme === Schemas.file) {\r\n            normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\r\n        }\r\n        else {\r\n            normalizedPath = paths.posix.normalize(resource.path);\r\n        }\r\n        return resource.with({\r\n            path: normalizedPath\r\n        });\r\n    }\r\n    resolvePath(base, path) {\r\n        if (base.scheme === Schemas.file) {\r\n            const newURI = URI.file(paths.resolve(originalFSPath(base), path));\r\n            return base.with({\r\n                authority: newURI.authority,\r\n                path: newURI.path\r\n            });\r\n        }\r\n        if (path.indexOf('/') === -1) { // no slashes? it's likely a Windows path\r\n            path = extpath.toSlashes(path);\r\n            if (/^[a-zA-Z]:(\\/|$)/.test(path)) { // starts with a drive letter\r\n                path = '/' + path;\r\n            }\r\n        }\r\n        return base.with({\r\n            path: paths.posix.resolve(base.path, path)\r\n        });\r\n    }\r\n}\r\n/**\r\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\r\n * uri#toString() usages. The following is true\r\n * ```\r\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\r\n * ```\r\n */\r\nexport const extUri = new ExtUri(() => false);\r\nexport const isEqual = extUri.isEqual.bind(extUri);\r\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\r\nexport const basename = extUri.basename.bind(extUri);\r\nexport const dirname = extUri.dirname.bind(extUri);\r\nexport const joinPath = extUri.joinPath.bind(extUri);\r\nexport const normalizePath = extUri.normalizePath.bind(extUri);\r\nexport const resolvePath = extUri.resolvePath.bind(extUri);\r\n/**\r\n * Data URI related helpers.\r\n */\r\nexport var DataUri;\r\n(function (DataUri) {\r\n    DataUri.META_DATA_LABEL = 'label';\r\n    DataUri.META_DATA_DESCRIPTION = 'description';\r\n    DataUri.META_DATA_SIZE = 'size';\r\n    DataUri.META_DATA_MIME = 'mime';\r\n    function parseMetaData(dataUri) {\r\n        const metadata = new Map();\r\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\r\n        // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\r\n        const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\r\n        meta.split(';').forEach(property => {\r\n            const [key, value] = property.split(':');\r\n            if (key && value) {\r\n                metadata.set(key, value);\r\n            }\r\n        });\r\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\r\n        // the mime is: image/png\r\n        const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\r\n        if (mime) {\r\n            metadata.set(DataUri.META_DATA_MIME, mime);\r\n        }\r\n        return metadata;\r\n    }\r\n    DataUri.parseMetaData = parseMetaData;\r\n})(DataUri || (DataUri = {}));\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}