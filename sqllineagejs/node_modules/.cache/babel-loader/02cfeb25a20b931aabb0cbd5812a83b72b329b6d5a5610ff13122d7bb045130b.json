{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { localize } from '../../../nls.js';\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { DisposableStore, Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { Range } from '../../common/core/range.js';\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\nimport { SymbolKinds, DocumentSymbolProviderRegistry } from '../../common/modes.js';\nimport { OutlineModel } from '../documentSymbols/outlineModel.js';\nimport { trim, format } from '../../../base/common/strings.js';\nimport { prepareQuery, pieceToQuery, scoreFuzzy2 } from '../../../base/common/fuzzyScorer.js';\nimport { Codicon } from '../../../base/common/codicons.js';\nexport class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.create(null);\n    super(options);\n    this.options = options;\n    options.canAcceptInBackground = true;\n  }\n  provideWithoutTextEditor(picker) {\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\n    return Disposable.None;\n  }\n  provideWithTextEditor(context, picker, token) {\n    const editor = context.editor;\n    const model = this.getModel(editor);\n    if (!model) {\n      return Disposable.None;\n    }\n    // Provide symbols from model if available in registry\n    if (DocumentSymbolProviderRegistry.has(model)) {\n      return this.doProvideWithEditorSymbols(context, model, picker, token);\n    }\n    // Otherwise show an entry for a model without registry\n    // But give a chance to resolve the symbols at a later\n    // point if possible\n    return this.doProvideWithoutEditorSymbols(context, model, picker, token);\n  }\n  doProvideWithoutEditorSymbols(context, model, picker, token) {\n    const disposables = new DisposableStore();\n    // Generic pick for not having any symbol information\n    this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\n    // Wait for changes to the registry and see if eventually\n    // we do get symbols. This can happen if the picker is opened\n    // very early after the model has loaded but before the\n    // language registry is ready.\n    // https://github.com/microsoft/vscode/issues/70607\n    (() => __awaiter(this, void 0, void 0, function* () {\n      const result = yield this.waitForLanguageSymbolRegistry(model, disposables);\n      if (!result || token.isCancellationRequested) {\n        return;\n      }\n      disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\n    }))();\n    return disposables;\n  }\n  provideLabelPick(picker, label) {\n    picker.items = [{\n      label,\n      index: 0,\n      kind: 14 /* String */\n    }];\n    picker.ariaLabel = label;\n  }\n  waitForLanguageSymbolRegistry(model, disposables) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (DocumentSymbolProviderRegistry.has(model)) {\n        return true;\n      }\n      let symbolProviderRegistryPromiseResolve;\n      const symbolProviderRegistryPromise = new Promise(resolve => symbolProviderRegistryPromiseResolve = resolve);\n      // Resolve promise when registry knows model\n      const symbolProviderListener = disposables.add(DocumentSymbolProviderRegistry.onDidChange(() => {\n        if (DocumentSymbolProviderRegistry.has(model)) {\n          symbolProviderListener.dispose();\n          symbolProviderRegistryPromiseResolve(true);\n        }\n      }));\n      // Resolve promise when we get disposed too\n      disposables.add(toDisposable(() => symbolProviderRegistryPromiseResolve(false)));\n      return symbolProviderRegistryPromise;\n    });\n  }\n  doProvideWithEditorSymbols(context, model, picker, token) {\n    const editor = context.editor;\n    const disposables = new DisposableStore();\n    // Goto symbol once picked\n    disposables.add(picker.onDidAccept(event => {\n      const [item] = picker.selectedItems;\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          preserveFocus: event.inBackground\n        });\n        if (!event.inBackground) {\n          picker.hide();\n        }\n      }\n    }));\n    // Goto symbol side by side if enabled\n    disposables.add(picker.onDidTriggerItemButton(_ref => {\n      let {\n        item\n      } = _ref;\n      if (item && item.range) {\n        this.gotoLocation(context, {\n          range: item.range.selection,\n          keyMods: picker.keyMods,\n          forceSideBySide: true\n        });\n        picker.hide();\n      }\n    }));\n    // Resolve symbols from document once and reuse this\n    // request for all filtering and typing then on\n    const symbolsPromise = this.getDocumentSymbols(model, token);\n    // Set initial picks and update on type\n    let picksCts = undefined;\n    const updatePickerItems = () => __awaiter(this, void 0, void 0, function* () {\n      // Cancel any previous ask for picks and busy\n      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n      picker.busy = false;\n      // Create new cancellation source for this run\n      picksCts = new CancellationTokenSource(token);\n      // Collect symbol picks\n      picker.busy = true;\n      try {\n        const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider.PREFIX.length).trim());\n        const items = yield this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token);\n        if (token.isCancellationRequested) {\n          return;\n        }\n        if (items.length > 0) {\n          picker.items = items;\n        } else {\n          if (query.original.length > 0) {\n            this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\n          } else {\n            this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\n          }\n        }\n      } finally {\n        if (!token.isCancellationRequested) {\n          picker.busy = false;\n        }\n      }\n    });\n    disposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n    updatePickerItems();\n    // Reveal and decorate when active item changes\n    // However, ignore the very first event so that\n    // opening the picker is not immediately revealing\n    // and decorating the first entry.\n    let ignoreFirstActiveEvent = true;\n    disposables.add(picker.onDidChangeActive(() => {\n      const [item] = picker.activeItems;\n      if (item && item.range) {\n        if (ignoreFirstActiveEvent) {\n          ignoreFirstActiveEvent = false;\n          return;\n        }\n        // Reveal\n        editor.revealRangeInCenter(item.range.selection, 0 /* Smooth */);\n        // Decorate\n        this.addDecorations(editor, item.range.decoration);\n      }\n    }));\n    return disposables;\n  }\n  doGetSymbolPicks(symbolsPromise, query, options, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const symbols = yield symbolsPromise;\n      if (token.isCancellationRequested) {\n        return [];\n      }\n      const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX) === 0;\n      const filterPos = filterBySymbolKind ? 1 : 0;\n      // Split between symbol and container query\n      let symbolQuery;\n      let containerQuery;\n      if (query.values && query.values.length > 1) {\n        symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\n        containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\n      } else {\n        symbolQuery = query;\n      }\n      // Convert to symbol picks and apply filtering\n      const filteredSymbolPicks = [];\n      for (let index = 0; index < symbols.length; index++) {\n        const symbol = symbols[index];\n        const symbolLabel = trim(symbol.name);\n        const symbolLabelWithIcon = \"$(symbol-\".concat(SymbolKinds.toString(symbol.kind) || 'property', \") \").concat(symbolLabel);\n        const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\n        let containerLabel = symbol.containerName;\n        if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {\n          if (containerLabel) {\n            containerLabel = \"\".concat(options.extraContainerLabel, \" \\u2022 \").concat(containerLabel);\n          } else {\n            containerLabel = options.extraContainerLabel;\n          }\n        }\n        let symbolScore = undefined;\n        let symbolMatches = undefined;\n        let containerScore = undefined;\n        let containerMatches = undefined;\n        if (query.original.length > filterPos) {\n          // First: try to score on the entire query, it is possible that\n          // the symbol matches perfectly (e.g. searching for \"change log\"\n          // can be a match on a markdown symbol \"change log\"). In that\n          // case we want to skip the container query altogether.\n          let skipContainerQuery = false;\n          if (symbolQuery !== query) {\n            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), {\n              values: undefined /* disable multi-query support */\n            }), filterPos, symbolLabelIconOffset);\n            if (typeof symbolScore === 'number') {\n              skipContainerQuery = true; // since we consumed the query, skip any container matching\n            }\n          }\n          // Otherwise: score on the symbol query and match on the container later\n          if (typeof symbolScore !== 'number') {\n            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\n            if (typeof symbolScore !== 'number') {\n              continue;\n            }\n          }\n          // Score by container if specified\n          if (!skipContainerQuery && containerQuery) {\n            if (containerLabel && containerQuery.original.length > 0) {\n              [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\n            }\n            if (typeof containerScore !== 'number') {\n              continue;\n            }\n            if (typeof symbolScore === 'number') {\n              symbolScore += containerScore; // boost symbolScore by containerScore\n            }\n          }\n        }\n\n        const deprecated = symbol.tags && symbol.tags.indexOf(1 /* Deprecated */) >= 0;\n        filteredSymbolPicks.push({\n          index,\n          kind: symbol.kind,\n          score: symbolScore,\n          label: symbolLabelWithIcon,\n          ariaLabel: symbolLabel,\n          description: containerLabel,\n          highlights: deprecated ? undefined : {\n            label: symbolMatches,\n            description: containerMatches\n          },\n          range: {\n            selection: Range.collapseToStart(symbol.selectionRange),\n            decoration: symbol.range\n          },\n          strikethrough: deprecated,\n          buttons: (() => {\n            var _a, _b;\n            const openSideBySideDirection = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.openSideBySideDirection) ? (_b = this.options) === null || _b === void 0 ? void 0 : _b.openSideBySideDirection() : undefined;\n            if (!openSideBySideDirection) {\n              return undefined;\n            }\n            return [{\n              iconClass: openSideBySideDirection === 'right' ? Codicon.splitHorizontal.classNames : Codicon.splitVertical.classNames,\n              tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\n            }];\n          })()\n        });\n      }\n      // Sort by score\n      const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB));\n      // Add separator for types\n      // - @  only total number of symbols\n      // - @: grouped by symbol kind\n      let symbolPicks = [];\n      if (filterBySymbolKind) {\n        let lastSymbolKind = undefined;\n        let lastSeparator = undefined;\n        let lastSymbolKindCounter = 0;\n        function updateLastSeparatorLabel() {\n          if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\n            lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\n          }\n        }\n        for (const symbolPick of sortedFilteredSymbolPicks) {\n          // Found new kind\n          if (lastSymbolKind !== symbolPick.kind) {\n            // Update last separator with number of symbols we found for kind\n            updateLastSeparatorLabel();\n            lastSymbolKind = symbolPick.kind;\n            lastSymbolKindCounter = 1;\n            // Add new separator for new kind\n            lastSeparator = {\n              type: 'separator'\n            };\n            symbolPicks.push(lastSeparator);\n          }\n          // Existing kind, keep counting\n          else {\n            lastSymbolKindCounter++;\n          }\n          // Add to final result\n          symbolPicks.push(symbolPick);\n        }\n        // Update last separator with number of symbols we found for kind\n        updateLastSeparatorLabel();\n      } else if (sortedFilteredSymbolPicks.length > 0) {\n        symbolPicks = [{\n          label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length),\n          type: 'separator'\n        }, ...sortedFilteredSymbolPicks];\n      }\n      return symbolPicks;\n    });\n  }\n  compareByScore(symbolA, symbolB) {\n    if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\n      return 1;\n    } else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\n      return -1;\n    }\n    if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\n      if (symbolA.score > symbolB.score) {\n        return -1;\n      } else if (symbolA.score < symbolB.score) {\n        return 1;\n      }\n    }\n    if (symbolA.index < symbolB.index) {\n      return -1;\n    } else if (symbolA.index > symbolB.index) {\n      return 1;\n    }\n    return 0;\n  }\n  compareByKindAndScore(symbolA, symbolB) {\n    const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\n    // Sort by type first if scoped search\n    const result = kindA.localeCompare(kindB);\n    if (result === 0) {\n      return this.compareByScore(symbolA, symbolB);\n    }\n    return result;\n  }\n  getDocumentSymbols(document, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const model = yield OutlineModel.create(document, token);\n      return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\n    });\n  }\n}\nAbstractGotoSymbolQuickAccessProvider.PREFIX = '@';\nAbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':';\nAbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = \"\".concat(AbstractGotoSymbolQuickAccessProvider.PREFIX).concat(AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX);\n// #region NLS Helpers\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\nconst NLS_SYMBOL_KIND_CACHE = {\n  [5 /* Method */]: localize('method', \"methods ({0})\"),\n  [11 /* Function */]: localize('function', \"functions ({0})\"),\n  [8 /* Constructor */]: localize('_constructor', \"constructors ({0})\"),\n  [12 /* Variable */]: localize('variable', \"variables ({0})\"),\n  [4 /* Class */]: localize('class', \"classes ({0})\"),\n  [22 /* Struct */]: localize('struct', \"structs ({0})\"),\n  [23 /* Event */]: localize('event', \"events ({0})\"),\n  [24 /* Operator */]: localize('operator', \"operators ({0})\"),\n  [10 /* Interface */]: localize('interface', \"interfaces ({0})\"),\n  [2 /* Namespace */]: localize('namespace', \"namespaces ({0})\"),\n  [3 /* Package */]: localize('package', \"packages ({0})\"),\n  [25 /* TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\n  [1 /* Module */]: localize('modules', \"modules ({0})\"),\n  [6 /* Property */]: localize('property', \"properties ({0})\"),\n  [9 /* Enum */]: localize('enum', \"enumerations ({0})\"),\n  [21 /* EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\n  [14 /* String */]: localize('string', \"strings ({0})\"),\n  [0 /* File */]: localize('file', \"files ({0})\"),\n  [17 /* Array */]: localize('array', \"arrays ({0})\"),\n  [15 /* Number */]: localize('number', \"numbers ({0})\"),\n  [16 /* Boolean */]: localize('boolean', \"booleans ({0})\"),\n  [18 /* Object */]: localize('object', \"objects ({0})\"),\n  [19 /* Key */]: localize('key', \"keys ({0})\"),\n  [7 /* Field */]: localize('field', \"fields ({0})\"),\n  [13 /* Constant */]: localize('constant', \"constants ({0})\")\n};\n//#endregion","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","localize","CancellationTokenSource","DisposableStore","Disposable","toDisposable","Range","AbstractEditorNavigationQuickAccessProvider","SymbolKinds","DocumentSymbolProviderRegistry","OutlineModel","trim","format","prepareQuery","pieceToQuery","scoreFuzzy2","Codicon","AbstractGotoSymbolQuickAccessProvider","constructor","options","arguments","length","undefined","Object","create","canAcceptInBackground","provideWithoutTextEditor","picker","provideLabelPick","None","provideWithTextEditor","context","token","editor","model","getModel","has","doProvideWithEditorSymbols","doProvideWithoutEditorSymbols","disposables","waitForLanguageSymbolRegistry","isCancellationRequested","add","label","items","index","kind","ariaLabel","symbolProviderRegistryPromiseResolve","symbolProviderRegistryPromise","symbolProviderListener","onDidChange","dispose","onDidAccept","event","item","selectedItems","range","gotoLocation","selection","keyMods","preserveFocus","inBackground","hide","onDidTriggerItemButton","_ref","forceSideBySide","symbolsPromise","getDocumentSymbols","picksCts","updatePickerItems","busy","query","substr","PREFIX","doGetSymbolPicks","original","onDidChangeValue","ignoreFirstActiveEvent","onDidChangeActive","activeItems","revealRangeInCenter","addDecorations","decoration","symbols","filterBySymbolKind","indexOf","SCOPE_PREFIX","filterPos","symbolQuery","containerQuery","values","slice","filteredSymbolPicks","symbol","symbolLabel","name","symbolLabelWithIcon","concat","toString","symbolLabelIconOffset","containerLabel","containerName","extraContainerLabel","symbolScore","symbolMatches","containerScore","containerMatches","skipContainerQuery","assign","deprecated","tags","push","score","description","highlights","collapseToStart","selectionRange","strikethrough","buttons","_a","_b","openSideBySideDirection","iconClass","splitHorizontal","classNames","splitVertical","tooltip","sortedFilteredSymbolPicks","sort","symbolA","symbolB","compareByKindAndScore","compareByScore","symbolPicks","lastSymbolKind","lastSeparator","lastSymbolKindCounter","updateLastSeparatorLabel","NLS_SYMBOL_KIND_CACHE","FALLBACK_NLS_SYMBOL_KIND","symbolPick","type","kindA","kindB","localeCompare","document","asListOfDocumentSymbols","PREFIX_BY_CATEGORY"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/gotoSymbolQuickAccess.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { localize } from '../../../nls.js';\r\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\r\nimport { DisposableStore, Disposable, toDisposable } from '../../../base/common/lifecycle.js';\r\nimport { Range } from '../../common/core/range.js';\r\nimport { AbstractEditorNavigationQuickAccessProvider } from './editorNavigationQuickAccess.js';\r\nimport { SymbolKinds, DocumentSymbolProviderRegistry } from '../../common/modes.js';\r\nimport { OutlineModel } from '../documentSymbols/outlineModel.js';\r\nimport { trim, format } from '../../../base/common/strings.js';\r\nimport { prepareQuery, pieceToQuery, scoreFuzzy2 } from '../../../base/common/fuzzyScorer.js';\r\nimport { Codicon } from '../../../base/common/codicons.js';\r\nexport class AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {\r\n    constructor(options = Object.create(null)) {\r\n        super(options);\r\n        this.options = options;\r\n        options.canAcceptInBackground = true;\r\n    }\r\n    provideWithoutTextEditor(picker) {\r\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutEditor', \"To go to a symbol, first open a text editor with symbol information.\"));\r\n        return Disposable.None;\r\n    }\r\n    provideWithTextEditor(context, picker, token) {\r\n        const editor = context.editor;\r\n        const model = this.getModel(editor);\r\n        if (!model) {\r\n            return Disposable.None;\r\n        }\r\n        // Provide symbols from model if available in registry\r\n        if (DocumentSymbolProviderRegistry.has(model)) {\r\n            return this.doProvideWithEditorSymbols(context, model, picker, token);\r\n        }\r\n        // Otherwise show an entry for a model without registry\r\n        // But give a chance to resolve the symbols at a later\r\n        // point if possible\r\n        return this.doProvideWithoutEditorSymbols(context, model, picker, token);\r\n    }\r\n    doProvideWithoutEditorSymbols(context, model, picker, token) {\r\n        const disposables = new DisposableStore();\r\n        // Generic pick for not having any symbol information\r\n        this.provideLabelPick(picker, localize('cannotRunGotoSymbolWithoutSymbolProvider', \"The active text editor does not provide symbol information.\"));\r\n        // Wait for changes to the registry and see if eventually\r\n        // we do get symbols. This can happen if the picker is opened\r\n        // very early after the model has loaded but before the\r\n        // language registry is ready.\r\n        // https://github.com/microsoft/vscode/issues/70607\r\n        (() => __awaiter(this, void 0, void 0, function* () {\r\n            const result = yield this.waitForLanguageSymbolRegistry(model, disposables);\r\n            if (!result || token.isCancellationRequested) {\r\n                return;\r\n            }\r\n            disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));\r\n        }))();\r\n        return disposables;\r\n    }\r\n    provideLabelPick(picker, label) {\r\n        picker.items = [{ label, index: 0, kind: 14 /* String */ }];\r\n        picker.ariaLabel = label;\r\n    }\r\n    waitForLanguageSymbolRegistry(model, disposables) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (DocumentSymbolProviderRegistry.has(model)) {\r\n                return true;\r\n            }\r\n            let symbolProviderRegistryPromiseResolve;\r\n            const symbolProviderRegistryPromise = new Promise(resolve => symbolProviderRegistryPromiseResolve = resolve);\r\n            // Resolve promise when registry knows model\r\n            const symbolProviderListener = disposables.add(DocumentSymbolProviderRegistry.onDidChange(() => {\r\n                if (DocumentSymbolProviderRegistry.has(model)) {\r\n                    symbolProviderListener.dispose();\r\n                    symbolProviderRegistryPromiseResolve(true);\r\n                }\r\n            }));\r\n            // Resolve promise when we get disposed too\r\n            disposables.add(toDisposable(() => symbolProviderRegistryPromiseResolve(false)));\r\n            return symbolProviderRegistryPromise;\r\n        });\r\n    }\r\n    doProvideWithEditorSymbols(context, model, picker, token) {\r\n        const editor = context.editor;\r\n        const disposables = new DisposableStore();\r\n        // Goto symbol once picked\r\n        disposables.add(picker.onDidAccept(event => {\r\n            const [item] = picker.selectedItems;\r\n            if (item && item.range) {\r\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });\r\n                if (!event.inBackground) {\r\n                    picker.hide();\r\n                }\r\n            }\r\n        }));\r\n        // Goto symbol side by side if enabled\r\n        disposables.add(picker.onDidTriggerItemButton(({ item }) => {\r\n            if (item && item.range) {\r\n                this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });\r\n                picker.hide();\r\n            }\r\n        }));\r\n        // Resolve symbols from document once and reuse this\r\n        // request for all filtering and typing then on\r\n        const symbolsPromise = this.getDocumentSymbols(model, token);\r\n        // Set initial picks and update on type\r\n        let picksCts = undefined;\r\n        const updatePickerItems = () => __awaiter(this, void 0, void 0, function* () {\r\n            // Cancel any previous ask for picks and busy\r\n            picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\r\n            picker.busy = false;\r\n            // Create new cancellation source for this run\r\n            picksCts = new CancellationTokenSource(token);\r\n            // Collect symbol picks\r\n            picker.busy = true;\r\n            try {\r\n                const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider.PREFIX.length).trim());\r\n                const items = yield this.doGetSymbolPicks(symbolsPromise, query, undefined, picksCts.token);\r\n                if (token.isCancellationRequested) {\r\n                    return;\r\n                }\r\n                if (items.length > 0) {\r\n                    picker.items = items;\r\n                }\r\n                else {\r\n                    if (query.original.length > 0) {\r\n                        this.provideLabelPick(picker, localize('noMatchingSymbolResults', \"No matching editor symbols\"));\r\n                    }\r\n                    else {\r\n                        this.provideLabelPick(picker, localize('noSymbolResults', \"No editor symbols\"));\r\n                    }\r\n                }\r\n            }\r\n            finally {\r\n                if (!token.isCancellationRequested) {\r\n                    picker.busy = false;\r\n                }\r\n            }\r\n        });\r\n        disposables.add(picker.onDidChangeValue(() => updatePickerItems()));\r\n        updatePickerItems();\r\n        // Reveal and decorate when active item changes\r\n        // However, ignore the very first event so that\r\n        // opening the picker is not immediately revealing\r\n        // and decorating the first entry.\r\n        let ignoreFirstActiveEvent = true;\r\n        disposables.add(picker.onDidChangeActive(() => {\r\n            const [item] = picker.activeItems;\r\n            if (item && item.range) {\r\n                if (ignoreFirstActiveEvent) {\r\n                    ignoreFirstActiveEvent = false;\r\n                    return;\r\n                }\r\n                // Reveal\r\n                editor.revealRangeInCenter(item.range.selection, 0 /* Smooth */);\r\n                // Decorate\r\n                this.addDecorations(editor, item.range.decoration);\r\n            }\r\n        }));\r\n        return disposables;\r\n    }\r\n    doGetSymbolPicks(symbolsPromise, query, options, token) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const symbols = yield symbolsPromise;\r\n            if (token.isCancellationRequested) {\r\n                return [];\r\n            }\r\n            const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX) === 0;\r\n            const filterPos = filterBySymbolKind ? 1 : 0;\r\n            // Split between symbol and container query\r\n            let symbolQuery;\r\n            let containerQuery;\r\n            if (query.values && query.values.length > 1) {\r\n                symbolQuery = pieceToQuery(query.values[0]); // symbol: only match on first part\r\n                containerQuery = pieceToQuery(query.values.slice(1)); // container: match on all but first parts\r\n            }\r\n            else {\r\n                symbolQuery = query;\r\n            }\r\n            // Convert to symbol picks and apply filtering\r\n            const filteredSymbolPicks = [];\r\n            for (let index = 0; index < symbols.length; index++) {\r\n                const symbol = symbols[index];\r\n                const symbolLabel = trim(symbol.name);\r\n                const symbolLabelWithIcon = `$(symbol-${SymbolKinds.toString(symbol.kind) || 'property'}) ${symbolLabel}`;\r\n                const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;\r\n                let containerLabel = symbol.containerName;\r\n                if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {\r\n                    if (containerLabel) {\r\n                        containerLabel = `${options.extraContainerLabel} â€¢ ${containerLabel}`;\r\n                    }\r\n                    else {\r\n                        containerLabel = options.extraContainerLabel;\r\n                    }\r\n                }\r\n                let symbolScore = undefined;\r\n                let symbolMatches = undefined;\r\n                let containerScore = undefined;\r\n                let containerMatches = undefined;\r\n                if (query.original.length > filterPos) {\r\n                    // First: try to score on the entire query, it is possible that\r\n                    // the symbol matches perfectly (e.g. searching for \"change log\"\r\n                    // can be a match on a markdown symbol \"change log\"). In that\r\n                    // case we want to skip the container query altogether.\r\n                    let skipContainerQuery = false;\r\n                    if (symbolQuery !== query) {\r\n                        [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), { values: undefined /* disable multi-query support */ }), filterPos, symbolLabelIconOffset);\r\n                        if (typeof symbolScore === 'number') {\r\n                            skipContainerQuery = true; // since we consumed the query, skip any container matching\r\n                        }\r\n                    }\r\n                    // Otherwise: score on the symbol query and match on the container later\r\n                    if (typeof symbolScore !== 'number') {\r\n                        [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);\r\n                        if (typeof symbolScore !== 'number') {\r\n                            continue;\r\n                        }\r\n                    }\r\n                    // Score by container if specified\r\n                    if (!skipContainerQuery && containerQuery) {\r\n                        if (containerLabel && containerQuery.original.length > 0) {\r\n                            [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);\r\n                        }\r\n                        if (typeof containerScore !== 'number') {\r\n                            continue;\r\n                        }\r\n                        if (typeof symbolScore === 'number') {\r\n                            symbolScore += containerScore; // boost symbolScore by containerScore\r\n                        }\r\n                    }\r\n                }\r\n                const deprecated = symbol.tags && symbol.tags.indexOf(1 /* Deprecated */) >= 0;\r\n                filteredSymbolPicks.push({\r\n                    index,\r\n                    kind: symbol.kind,\r\n                    score: symbolScore,\r\n                    label: symbolLabelWithIcon,\r\n                    ariaLabel: symbolLabel,\r\n                    description: containerLabel,\r\n                    highlights: deprecated ? undefined : {\r\n                        label: symbolMatches,\r\n                        description: containerMatches\r\n                    },\r\n                    range: {\r\n                        selection: Range.collapseToStart(symbol.selectionRange),\r\n                        decoration: symbol.range\r\n                    },\r\n                    strikethrough: deprecated,\r\n                    buttons: (() => {\r\n                        var _a, _b;\r\n                        const openSideBySideDirection = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.openSideBySideDirection) ? (_b = this.options) === null || _b === void 0 ? void 0 : _b.openSideBySideDirection() : undefined;\r\n                        if (!openSideBySideDirection) {\r\n                            return undefined;\r\n                        }\r\n                        return [\r\n                            {\r\n                                iconClass: openSideBySideDirection === 'right' ? Codicon.splitHorizontal.classNames : Codicon.splitVertical.classNames,\r\n                                tooltip: openSideBySideDirection === 'right' ? localize('openToSide', \"Open to the Side\") : localize('openToBottom', \"Open to the Bottom\")\r\n                            }\r\n                        ];\r\n                    })()\r\n                });\r\n            }\r\n            // Sort by score\r\n            const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ?\r\n                this.compareByKindAndScore(symbolA, symbolB) :\r\n                this.compareByScore(symbolA, symbolB));\r\n            // Add separator for types\r\n            // - @  only total number of symbols\r\n            // - @: grouped by symbol kind\r\n            let symbolPicks = [];\r\n            if (filterBySymbolKind) {\r\n                let lastSymbolKind = undefined;\r\n                let lastSeparator = undefined;\r\n                let lastSymbolKindCounter = 0;\r\n                function updateLastSeparatorLabel() {\r\n                    if (lastSeparator && typeof lastSymbolKind === 'number' && lastSymbolKindCounter > 0) {\r\n                        lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);\r\n                    }\r\n                }\r\n                for (const symbolPick of sortedFilteredSymbolPicks) {\r\n                    // Found new kind\r\n                    if (lastSymbolKind !== symbolPick.kind) {\r\n                        // Update last separator with number of symbols we found for kind\r\n                        updateLastSeparatorLabel();\r\n                        lastSymbolKind = symbolPick.kind;\r\n                        lastSymbolKindCounter = 1;\r\n                        // Add new separator for new kind\r\n                        lastSeparator = { type: 'separator' };\r\n                        symbolPicks.push(lastSeparator);\r\n                    }\r\n                    // Existing kind, keep counting\r\n                    else {\r\n                        lastSymbolKindCounter++;\r\n                    }\r\n                    // Add to final result\r\n                    symbolPicks.push(symbolPick);\r\n                }\r\n                // Update last separator with number of symbols we found for kind\r\n                updateLastSeparatorLabel();\r\n            }\r\n            else if (sortedFilteredSymbolPicks.length > 0) {\r\n                symbolPicks = [\r\n                    { label: localize('symbols', \"symbols ({0})\", filteredSymbolPicks.length), type: 'separator' },\r\n                    ...sortedFilteredSymbolPicks\r\n                ];\r\n            }\r\n            return symbolPicks;\r\n        });\r\n    }\r\n    compareByScore(symbolA, symbolB) {\r\n        if (typeof symbolA.score !== 'number' && typeof symbolB.score === 'number') {\r\n            return 1;\r\n        }\r\n        else if (typeof symbolA.score === 'number' && typeof symbolB.score !== 'number') {\r\n            return -1;\r\n        }\r\n        if (typeof symbolA.score === 'number' && typeof symbolB.score === 'number') {\r\n            if (symbolA.score > symbolB.score) {\r\n                return -1;\r\n            }\r\n            else if (symbolA.score < symbolB.score) {\r\n                return 1;\r\n            }\r\n        }\r\n        if (symbolA.index < symbolB.index) {\r\n            return -1;\r\n        }\r\n        else if (symbolA.index > symbolB.index) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n    compareByKindAndScore(symbolA, symbolB) {\r\n        const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;\r\n        const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;\r\n        // Sort by type first if scoped search\r\n        const result = kindA.localeCompare(kindB);\r\n        if (result === 0) {\r\n            return this.compareByScore(symbolA, symbolB);\r\n        }\r\n        return result;\r\n    }\r\n    getDocumentSymbols(document, token) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const model = yield OutlineModel.create(document, token);\r\n            return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();\r\n        });\r\n    }\r\n}\r\nAbstractGotoSymbolQuickAccessProvider.PREFIX = '@';\r\nAbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ':';\r\nAbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider.PREFIX}${AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`;\r\n// #region NLS Helpers\r\nconst FALLBACK_NLS_SYMBOL_KIND = localize('property', \"properties ({0})\");\r\nconst NLS_SYMBOL_KIND_CACHE = {\r\n    [5 /* Method */]: localize('method', \"methods ({0})\"),\r\n    [11 /* Function */]: localize('function', \"functions ({0})\"),\r\n    [8 /* Constructor */]: localize('_constructor', \"constructors ({0})\"),\r\n    [12 /* Variable */]: localize('variable', \"variables ({0})\"),\r\n    [4 /* Class */]: localize('class', \"classes ({0})\"),\r\n    [22 /* Struct */]: localize('struct', \"structs ({0})\"),\r\n    [23 /* Event */]: localize('event', \"events ({0})\"),\r\n    [24 /* Operator */]: localize('operator', \"operators ({0})\"),\r\n    [10 /* Interface */]: localize('interface', \"interfaces ({0})\"),\r\n    [2 /* Namespace */]: localize('namespace', \"namespaces ({0})\"),\r\n    [3 /* Package */]: localize('package', \"packages ({0})\"),\r\n    [25 /* TypeParameter */]: localize('typeParameter', \"type parameters ({0})\"),\r\n    [1 /* Module */]: localize('modules', \"modules ({0})\"),\r\n    [6 /* Property */]: localize('property', \"properties ({0})\"),\r\n    [9 /* Enum */]: localize('enum', \"enumerations ({0})\"),\r\n    [21 /* EnumMember */]: localize('enumMember', \"enumeration members ({0})\"),\r\n    [14 /* String */]: localize('string', \"strings ({0})\"),\r\n    [0 /* File */]: localize('file', \"files ({0})\"),\r\n    [17 /* Array */]: localize('array', \"arrays ({0})\"),\r\n    [15 /* Number */]: localize('number', \"numbers ({0})\"),\r\n    [16 /* Boolean */]: localize('boolean', \"booleans ({0})\"),\r\n    [18 /* Object */]: localize('object', \"objects ({0})\"),\r\n    [19 /* Key */]: localize('key', \"keys ({0})\"),\r\n    [7 /* Field */]: localize('field', \"fields ({0})\"),\r\n    [13 /* Constant */]: localize('constant', \"constants ({0})\")\r\n};\r\n//#endregion\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}