{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Schemas } from '../../../base/common/network.js';\nimport { DataUri, basenameOrAuthority } from '../../../base/common/resources.js';\nimport { PLAINTEXT_MODE_ID } from '../modes/modesRegistry.js';\nimport { FileKind } from '../../../platform/files/common/files.js';\nexport function getIconClasses(modelService, modeService, resource, fileKind) {\n  // we always set these base classes even if we do not have a path\n  const classes = fileKind === FileKind.ROOT_FOLDER ? ['rootfolder-icon'] : fileKind === FileKind.FOLDER ? ['folder-icon'] : ['file-icon'];\n  if (resource) {\n    // Get the path and name of the resource. For data-URIs, we need to parse specially\n    let name;\n    if (resource.scheme === Schemas.data) {\n      const metadata = DataUri.parseMetaData(resource);\n      name = metadata.get(DataUri.META_DATA_LABEL);\n    } else {\n      name = cssEscape(basenameOrAuthority(resource).toLowerCase());\n    }\n    // Folders\n    if (fileKind === FileKind.FOLDER) {\n      classes.push(\"\".concat(name, \"-name-folder-icon\"));\n    }\n    // Files\n    else {\n      // Name & Extension(s)\n      if (name) {\n        classes.push(\"\".concat(name, \"-name-file-icon\"));\n        const dotSegments = name.split('.');\n        for (let i = 1; i < dotSegments.length; i++) {\n          classes.push(\"\".concat(dotSegments.slice(i).join('.'), \"-ext-file-icon\")); // add each combination of all found extensions if more than one\n        }\n\n        classes.push(\"ext-file-icon\"); // extra segment to increase file-ext score\n      }\n      // Detected Mode\n      const detectedModeId = detectModeId(modelService, modeService, resource);\n      if (detectedModeId) {\n        classes.push(\"\".concat(cssEscape(detectedModeId), \"-lang-file-icon\"));\n      }\n    }\n  }\n  return classes;\n}\nexport function detectModeId(modelService, modeService, resource) {\n  if (!resource) {\n    return null; // we need a resource at least\n  }\n\n  let modeId = null;\n  // Data URI: check for encoded metadata\n  if (resource.scheme === Schemas.data) {\n    const metadata = DataUri.parseMetaData(resource);\n    const mime = metadata.get(DataUri.META_DATA_MIME);\n    if (mime) {\n      modeId = modeService.getModeId(mime);\n    }\n  }\n  // Any other URI: check for model if existing\n  else {\n    const model = modelService.getModel(resource);\n    if (model) {\n      modeId = model.getModeId();\n    }\n  }\n  // only take if the mode is specific (aka no just plain text)\n  if (modeId && modeId !== PLAINTEXT_MODE_ID) {\n    return modeId;\n  }\n  // otherwise fallback to path based detection\n  return modeService.getModeIdByFilepathOrFirstLine(resource);\n}\nexport function cssEscape(str) {\n  return str.replace(/[\\11\\12\\14\\15\\40]/g, '/'); // HTML class names can not contain certain whitespace characters, use / instead, which doesn't exist in file names.\n}","map":{"version":3,"names":["Schemas","DataUri","basenameOrAuthority","PLAINTEXT_MODE_ID","FileKind","getIconClasses","modelService","modeService","resource","fileKind","classes","ROOT_FOLDER","FOLDER","name","scheme","data","metadata","parseMetaData","get","META_DATA_LABEL","cssEscape","toLowerCase","push","concat","dotSegments","split","i","length","slice","join","detectedModeId","detectModeId","modeId","mime","META_DATA_MIME","getModeId","model","getModel","getModeIdByFilepathOrFirstLine","str","replace"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Schemas } from '../../../base/common/network.js';\r\nimport { DataUri, basenameOrAuthority } from '../../../base/common/resources.js';\r\nimport { PLAINTEXT_MODE_ID } from '../modes/modesRegistry.js';\r\nimport { FileKind } from '../../../platform/files/common/files.js';\r\nexport function getIconClasses(modelService, modeService, resource, fileKind) {\r\n    // we always set these base classes even if we do not have a path\r\n    const classes = fileKind === FileKind.ROOT_FOLDER ? ['rootfolder-icon'] : fileKind === FileKind.FOLDER ? ['folder-icon'] : ['file-icon'];\r\n    if (resource) {\r\n        // Get the path and name of the resource. For data-URIs, we need to parse specially\r\n        let name;\r\n        if (resource.scheme === Schemas.data) {\r\n            const metadata = DataUri.parseMetaData(resource);\r\n            name = metadata.get(DataUri.META_DATA_LABEL);\r\n        }\r\n        else {\r\n            name = cssEscape(basenameOrAuthority(resource).toLowerCase());\r\n        }\r\n        // Folders\r\n        if (fileKind === FileKind.FOLDER) {\r\n            classes.push(`${name}-name-folder-icon`);\r\n        }\r\n        // Files\r\n        else {\r\n            // Name & Extension(s)\r\n            if (name) {\r\n                classes.push(`${name}-name-file-icon`);\r\n                const dotSegments = name.split('.');\r\n                for (let i = 1; i < dotSegments.length; i++) {\r\n                    classes.push(`${dotSegments.slice(i).join('.')}-ext-file-icon`); // add each combination of all found extensions if more than one\r\n                }\r\n                classes.push(`ext-file-icon`); // extra segment to increase file-ext score\r\n            }\r\n            // Detected Mode\r\n            const detectedModeId = detectModeId(modelService, modeService, resource);\r\n            if (detectedModeId) {\r\n                classes.push(`${cssEscape(detectedModeId)}-lang-file-icon`);\r\n            }\r\n        }\r\n    }\r\n    return classes;\r\n}\r\nexport function detectModeId(modelService, modeService, resource) {\r\n    if (!resource) {\r\n        return null; // we need a resource at least\r\n    }\r\n    let modeId = null;\r\n    // Data URI: check for encoded metadata\r\n    if (resource.scheme === Schemas.data) {\r\n        const metadata = DataUri.parseMetaData(resource);\r\n        const mime = metadata.get(DataUri.META_DATA_MIME);\r\n        if (mime) {\r\n            modeId = modeService.getModeId(mime);\r\n        }\r\n    }\r\n    // Any other URI: check for model if existing\r\n    else {\r\n        const model = modelService.getModel(resource);\r\n        if (model) {\r\n            modeId = model.getModeId();\r\n        }\r\n    }\r\n    // only take if the mode is specific (aka no just plain text)\r\n    if (modeId && modeId !== PLAINTEXT_MODE_ID) {\r\n        return modeId;\r\n    }\r\n    // otherwise fallback to path based detection\r\n    return modeService.getModeIdByFilepathOrFirstLine(resource);\r\n}\r\nexport function cssEscape(str) {\r\n    return str.replace(/[\\11\\12\\14\\15\\40]/g, '/'); // HTML class names can not contain certain whitespace characters, use / instead, which doesn't exist in file names.\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}