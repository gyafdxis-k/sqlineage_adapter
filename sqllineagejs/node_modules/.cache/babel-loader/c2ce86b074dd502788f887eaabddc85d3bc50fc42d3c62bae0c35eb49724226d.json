{"ast":null,"code":"import { fuzzyScore, createMatches as createFuzzyMatches } from './filters.js';\nimport { sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { stripWildcards } from './strings.js';\nconst NO_SCORE2 = [undefined, []];\nexport function scoreFuzzy2(target, query) {\n  let patternStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let wordStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  // Score: multiple inputs\n  const preparedQuery = query;\n  if (preparedQuery.values && preparedQuery.values.length > 1) {\n    return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n  }\n  // Score: single input\n  return doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\nfunction doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {\n  let totalScore = 0;\n  const totalMatches = [];\n  for (const queryPiece of query) {\n    const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n    if (typeof score !== 'number') {\n      // if a single query value does not match, return with\n      // no score entirely, we require all queries to match\n      return NO_SCORE2;\n    }\n    totalScore += score;\n    totalMatches.push(...matches);\n  }\n  // if we have a score, ensure that the positions are\n  // sorted in ascending order and distinct\n  return [totalScore, normalizeMatches(totalMatches)];\n}\nfunction doScoreFuzzy2Single(target, query, patternStart, wordStart) {\n  const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, true);\n  if (!score) {\n    return NO_SCORE2;\n  }\n  return [score[0], createFuzzyMatches(score)];\n}\nfunction normalizeMatches(matches) {\n  // sort matches by start to be able to normalize\n  const sortedMatches = matches.sort((matchA, matchB) => {\n    return matchA.start - matchB.start;\n  });\n  // merge matches that overlap\n  const normalizedMatches = [];\n  let currentMatch = undefined;\n  for (const match of sortedMatches) {\n    // if we have no current match or the matches\n    // do not overlap, we take it as is and remember\n    // it for future merging\n    if (!currentMatch || !matchOverlaps(currentMatch, match)) {\n      currentMatch = match;\n      normalizedMatches.push(match);\n    }\n    // otherwise we merge the matches\n    else {\n      currentMatch.start = Math.min(currentMatch.start, match.start);\n      currentMatch.end = Math.max(currentMatch.end, match.end);\n    }\n  }\n  return normalizedMatches;\n}\nfunction matchOverlaps(matchA, matchB) {\n  if (matchA.end < matchB.start) {\n    return false; // A ends before B starts\n  }\n\n  if (matchB.end < matchA.start) {\n    return false; // B ends before A starts\n  }\n\n  return true;\n}\n/**\r\n * Helper function to prepare a search value for scoring by removing unwanted characters\r\n * and allowing to score on multiple pieces separated by whitespace character.\r\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original) {\n  if (typeof original !== 'string') {\n    original = '';\n  }\n  const originalLowercase = original.toLowerCase();\n  const {\n    pathNormalized,\n    normalized,\n    normalizedLowercase\n  } = normalizeQuery(original);\n  const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n  let values = undefined;\n  const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n  if (originalSplit.length > 1) {\n    for (const originalPiece of originalSplit) {\n      const {\n        pathNormalized: pathNormalizedPiece,\n        normalized: normalizedPiece,\n        normalizedLowercase: normalizedLowercasePiece\n      } = normalizeQuery(originalPiece);\n      if (normalizedPiece) {\n        if (!values) {\n          values = [];\n        }\n        values.push({\n          original: originalPiece,\n          originalLowercase: originalPiece.toLowerCase(),\n          pathNormalized: pathNormalizedPiece,\n          normalized: normalizedPiece,\n          normalizedLowercase: normalizedLowercasePiece\n        });\n      }\n    }\n  }\n  return {\n    original,\n    originalLowercase,\n    pathNormalized,\n    normalized,\n    normalizedLowercase,\n    values,\n    containsPathSeparator\n  };\n}\nfunction normalizeQuery(original) {\n  let pathNormalized;\n  if (isWindows) {\n    pathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n  } else {\n    pathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n  }\n\n  const normalized = stripWildcards(pathNormalized).replace(/\\s/g, '');\n  return {\n    pathNormalized,\n    normalized,\n    normalizedLowercase: normalized.toLowerCase()\n  };\n}\nexport function pieceToQuery(arg1) {\n  if (Array.isArray(arg1)) {\n    return prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n  }\n  return prepareQuery(arg1.original);\n}\n//#endregion","map":{"version":3,"names":["fuzzyScore","createMatches","createFuzzyMatches","sep","isWindows","stripWildcards","NO_SCORE2","undefined","scoreFuzzy2","target","query","patternStart","arguments","length","wordStart","preparedQuery","values","doScoreFuzzy2Multiple","doScoreFuzzy2Single","totalScore","totalMatches","queryPiece","score","matches","push","normalizeMatches","original","originalLowercase","toLowerCase","sortedMatches","sort","matchA","matchB","start","normalizedMatches","currentMatch","match","matchOverlaps","Math","min","end","max","MULTIPLE_QUERY_VALUES_SEPARATOR","prepareQuery","pathNormalized","normalized","normalizedLowercase","normalizeQuery","containsPathSeparator","indexOf","originalSplit","split","originalPiece","pathNormalizedPiece","normalizedPiece","normalizedLowercasePiece","replace","pieceToQuery","arg1","Array","isArray","map","piece","join"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/fuzzyScorer.js"],"sourcesContent":["import { fuzzyScore, createMatches as createFuzzyMatches } from './filters.js';\r\nimport { sep } from './path.js';\r\nimport { isWindows } from './platform.js';\r\nimport { stripWildcards } from './strings.js';\r\nconst NO_SCORE2 = [undefined, []];\r\nexport function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {\r\n    // Score: multiple inputs\r\n    const preparedQuery = query;\r\n    if (preparedQuery.values && preparedQuery.values.length > 1) {\r\n        return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\r\n    }\r\n    // Score: single input\r\n    return doScoreFuzzy2Single(target, query, patternStart, wordStart);\r\n}\r\nfunction doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {\r\n    let totalScore = 0;\r\n    const totalMatches = [];\r\n    for (const queryPiece of query) {\r\n        const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\r\n        if (typeof score !== 'number') {\r\n            // if a single query value does not match, return with\r\n            // no score entirely, we require all queries to match\r\n            return NO_SCORE2;\r\n        }\r\n        totalScore += score;\r\n        totalMatches.push(...matches);\r\n    }\r\n    // if we have a score, ensure that the positions are\r\n    // sorted in ascending order and distinct\r\n    return [totalScore, normalizeMatches(totalMatches)];\r\n}\r\nfunction doScoreFuzzy2Single(target, query, patternStart, wordStart) {\r\n    const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, true);\r\n    if (!score) {\r\n        return NO_SCORE2;\r\n    }\r\n    return [score[0], createFuzzyMatches(score)];\r\n}\r\nfunction normalizeMatches(matches) {\r\n    // sort matches by start to be able to normalize\r\n    const sortedMatches = matches.sort((matchA, matchB) => {\r\n        return matchA.start - matchB.start;\r\n    });\r\n    // merge matches that overlap\r\n    const normalizedMatches = [];\r\n    let currentMatch = undefined;\r\n    for (const match of sortedMatches) {\r\n        // if we have no current match or the matches\r\n        // do not overlap, we take it as is and remember\r\n        // it for future merging\r\n        if (!currentMatch || !matchOverlaps(currentMatch, match)) {\r\n            currentMatch = match;\r\n            normalizedMatches.push(match);\r\n        }\r\n        // otherwise we merge the matches\r\n        else {\r\n            currentMatch.start = Math.min(currentMatch.start, match.start);\r\n            currentMatch.end = Math.max(currentMatch.end, match.end);\r\n        }\r\n    }\r\n    return normalizedMatches;\r\n}\r\nfunction matchOverlaps(matchA, matchB) {\r\n    if (matchA.end < matchB.start) {\r\n        return false; // A ends before B starts\r\n    }\r\n    if (matchB.end < matchA.start) {\r\n        return false; // B ends before A starts\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Helper function to prepare a search value for scoring by removing unwanted characters\r\n * and allowing to score on multiple pieces separated by whitespace character.\r\n */\r\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\r\nexport function prepareQuery(original) {\r\n    if (typeof original !== 'string') {\r\n        original = '';\r\n    }\r\n    const originalLowercase = original.toLowerCase();\r\n    const { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);\r\n    const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\r\n    let values = undefined;\r\n    const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\r\n    if (originalSplit.length > 1) {\r\n        for (const originalPiece of originalSplit) {\r\n            const { pathNormalized: pathNormalizedPiece, normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece } = normalizeQuery(originalPiece);\r\n            if (normalizedPiece) {\r\n                if (!values) {\r\n                    values = [];\r\n                }\r\n                values.push({\r\n                    original: originalPiece,\r\n                    originalLowercase: originalPiece.toLowerCase(),\r\n                    pathNormalized: pathNormalizedPiece,\r\n                    normalized: normalizedPiece,\r\n                    normalizedLowercase: normalizedLowercasePiece\r\n                });\r\n            }\r\n        }\r\n    }\r\n    return { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator };\r\n}\r\nfunction normalizeQuery(original) {\r\n    let pathNormalized;\r\n    if (isWindows) {\r\n        pathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\r\n    }\r\n    else {\r\n        pathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\r\n    }\r\n    const normalized = stripWildcards(pathNormalized).replace(/\\s/g, '');\r\n    return {\r\n        pathNormalized,\r\n        normalized,\r\n        normalizedLowercase: normalized.toLowerCase()\r\n    };\r\n}\r\nexport function pieceToQuery(arg1) {\r\n    if (Array.isArray(arg1)) {\r\n        return prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\r\n    }\r\n    return prepareQuery(arg1.original);\r\n}\r\n//#endregion\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}