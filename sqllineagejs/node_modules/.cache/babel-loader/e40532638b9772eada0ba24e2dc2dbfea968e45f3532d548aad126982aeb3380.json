{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { FoldingRegions } from './foldingRanges.js';\nexport class FoldingModel {\n  constructor(textModel, decorationProvider) {\n    this._updateEventEmitter = new Emitter();\n    this.onDidChange = this._updateEventEmitter.event;\n    this._textModel = textModel;\n    this._decorationProvider = decorationProvider;\n    this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n    this._editorDecorationIds = [];\n    this._isInitialized = false;\n  }\n  get regions() {\n    return this._regions;\n  }\n  get textModel() {\n    return this._textModel;\n  }\n  get isInitialized() {\n    return this._isInitialized;\n  }\n  toggleCollapseState(toggledRegions) {\n    if (!toggledRegions.length) {\n      return;\n    }\n    toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);\n    const processed = {};\n    this._decorationProvider.changeDecorations(accessor => {\n      let k = 0; // index from [0 ... this.regions.length]\n      let dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\n      let lastHiddenLine = -1; // the end of the last hidden lines\n      const updateDecorationsUntil = index => {\n        while (k < index) {\n          const endLineNumber = this._regions.getEndLineNumber(k);\n          const isCollapsed = this._regions.isCollapsed(k);\n          if (endLineNumber <= dirtyRegionEndLine) {\n            accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine));\n          }\n          if (isCollapsed && endLineNumber > lastHiddenLine) {\n            lastHiddenLine = endLineNumber;\n          }\n          k++;\n        }\n      };\n      for (let region of toggledRegions) {\n        let index = region.regionIndex;\n        let editorDecorationId = this._editorDecorationIds[index];\n        if (editorDecorationId && !processed[editorDecorationId]) {\n          processed[editorDecorationId] = true;\n          updateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\n          let newCollapseState = !this._regions.isCollapsed(index);\n          this._regions.setCollapsed(index, newCollapseState);\n          dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));\n        }\n      }\n      updateDecorationsUntil(this._regions.length);\n    });\n    this._updateEventEmitter.fire({\n      model: this,\n      collapseStateChanged: toggledRegions\n    });\n  }\n  update(newRegions) {\n    let blockedLineNumers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let newEditorDecorations = [];\n    let isBlocked = (startLineNumber, endLineNumber) => {\n      for (let blockedLineNumber of blockedLineNumers) {\n        if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {\n          // first line is visible\n          return true;\n        }\n      }\n      return false;\n    };\n    let lastHiddenLine = -1;\n    let initRange = (index, isCollapsed) => {\n      const startLineNumber = newRegions.getStartLineNumber(index);\n      const endLineNumber = newRegions.getEndLineNumber(index);\n      if (isCollapsed && isBlocked(startLineNumber, endLineNumber)) {\n        isCollapsed = false;\n      }\n      newRegions.setCollapsed(index, isCollapsed);\n      const maxColumn = this._textModel.getLineMaxColumn(startLineNumber);\n      const decorationRange = {\n        startLineNumber: startLineNumber,\n        startColumn: Math.max(maxColumn - 1, 1),\n        endLineNumber: startLineNumber,\n        endColumn: maxColumn\n      };\n      newEditorDecorations.push({\n        range: decorationRange,\n        options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine)\n      });\n      if (isCollapsed && endLineNumber > lastHiddenLine) {\n        lastHiddenLine = endLineNumber;\n      }\n    };\n    let i = 0;\n    let nextCollapsed = () => {\n      while (i < this._regions.length) {\n        let isCollapsed = this._regions.isCollapsed(i);\n        i++;\n        if (isCollapsed) {\n          return i - 1;\n        }\n      }\n      return -1;\n    };\n    let k = 0;\n    let collapsedIndex = nextCollapsed();\n    while (collapsedIndex !== -1 && k < newRegions.length) {\n      // get the latest range\n      let decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\n      if (decRange) {\n        let collapsedStartLineNumber = decRange.startLineNumber;\n        if (decRange.startColumn === Math.max(decRange.endColumn - 1, 1) && this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.endColumn) {\n          // test that the decoration is still covering the full line else it got deleted\n          while (k < newRegions.length) {\n            let startLineNumber = newRegions.getStartLineNumber(k);\n            if (collapsedStartLineNumber >= startLineNumber) {\n              initRange(k, collapsedStartLineNumber === startLineNumber);\n              k++;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      collapsedIndex = nextCollapsed();\n    }\n    while (k < newRegions.length) {\n      initRange(k, false);\n      k++;\n    }\n    this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\n    this._regions = newRegions;\n    this._isInitialized = true;\n    this._updateEventEmitter.fire({\n      model: this\n    });\n  }\n  /**\r\n   * Collapse state memento, for persistence only\r\n   */\n  getMemento() {\n    let collapsedRanges = [];\n    for (let i = 0; i < this._regions.length; i++) {\n      if (this._regions.isCollapsed(i)) {\n        let range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n        if (range) {\n          let startLineNumber = range.startLineNumber;\n          let endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\n          collapsedRanges.push({\n            startLineNumber,\n            endLineNumber\n          });\n        }\n      }\n    }\n    if (collapsedRanges.length > 0) {\n      return collapsedRanges;\n    }\n    return undefined;\n  }\n  /**\r\n   * Apply persisted state, for persistence only\r\n   */\n  applyMemento(state) {\n    if (!Array.isArray(state)) {\n      return;\n    }\n    let toToogle = [];\n    for (let range of state) {\n      let region = this.getRegionAtLine(range.startLineNumber);\n      if (region && !region.isCollapsed) {\n        toToogle.push(region);\n      }\n    }\n    this.toggleCollapseState(toToogle);\n  }\n  dispose() {\n    this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\n  }\n  getAllRegionsAtLine(lineNumber, filter) {\n    let result = [];\n    if (this._regions) {\n      let index = this._regions.findRange(lineNumber);\n      let level = 1;\n      while (index >= 0) {\n        let current = this._regions.toRegion(index);\n        if (!filter || filter(current, level)) {\n          result.push(current);\n        }\n        level++;\n        index = current.parentIndex;\n      }\n    }\n    return result;\n  }\n  getRegionAtLine(lineNumber) {\n    if (this._regions) {\n      let index = this._regions.findRange(lineNumber);\n      if (index >= 0) {\n        return this._regions.toRegion(index);\n      }\n    }\n    return null;\n  }\n  getRegionsInside(region, filter) {\n    let result = [];\n    let index = region ? region.regionIndex + 1 : 0;\n    let endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n    if (filter && filter.length === 2) {\n      const levelStack = [];\n      for (let i = index, len = this._regions.length; i < len; i++) {\n        let current = this._regions.toRegion(i);\n        if (this._regions.getStartLineNumber(i) < endLineNumber) {\n          while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n            levelStack.pop();\n          }\n          levelStack.push(current);\n          if (filter(current, levelStack.length)) {\n            result.push(current);\n          }\n        } else {\n          break;\n        }\n      }\n    } else {\n      for (let i = index, len = this._regions.length; i < len; i++) {\n        let current = this._regions.toRegion(i);\n        if (this._regions.getStartLineNumber(i) < endLineNumber) {\n          if (!filter || filter(current)) {\n            result.push(current);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n}\n/**\r\n * Collapse or expand the regions at the given locations\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\r\n */\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\n  let toToggle = [];\n  for (let lineNumber of lineNumbers) {\n    let region = foldingModel.getRegionAtLine(lineNumber);\n    if (region) {\n      const doCollapse = !region.isCollapsed;\n      toToggle.push(region);\n      if (levels > 1) {\n        let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n        toToggle.push(...regionsInside);\n      }\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Collapse or expand the regions at the given locations including all children.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\r\n */\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse) {\n  let levels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.MAX_VALUE;\n  let lineNumbers = arguments.length > 3 ? arguments[3] : undefined;\n  let toToggle = [];\n  if (lineNumbers && lineNumbers.length > 0) {\n    for (let lineNumber of lineNumbers) {\n      let region = foldingModel.getRegionAtLine(lineNumber);\n      if (region) {\n        if (region.isCollapsed !== doCollapse) {\n          toToggle.push(region);\n        }\n        if (levels > 1) {\n          let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n          toToggle.push(...regionsInside);\n        }\n      }\n    }\n  } else {\n    let regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n    toToggle.push(...regionsInside);\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Collapse or expand the regions at the given locations including all parents.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand.\r\n */\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n  let toToggle = [];\n  for (let lineNumber of lineNumbers) {\n    let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\n    toToggle.push(...regions);\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param lineNumbers the location of the regions to collapse or expand.\r\n */\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\n  let toToggle = [];\n  for (let lineNumber of lineNumbers) {\n    let regions = foldingModel.getAllRegionsAtLine(lineNumber, region => region.isCollapsed !== doCollapse);\n    if (regions.length > 0) {\n      toToggle.push(regions[0]);\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\r\n * @param foldLevel level. Level == 1 is the top level\r\n * @param doCollapse Wheter to collase or expand\r\n*/\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n  let filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\n  let toToggle = foldingModel.getRegionsInside(null, filter);\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Folds all regions for which the lines start with a given regex\r\n * @param foldingModel the folding model\r\n */\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n  let editorModel = foldingModel.textModel;\n  let regions = foldingModel.regions;\n  let toToggle = [];\n  for (let i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i)) {\n      let startLineNumber = regions.getStartLineNumber(i);\n      if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n        toToggle.push(regions.toRegion(i));\n      }\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Folds all regions of the given type\r\n * @param foldingModel the folding model\r\n */\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\n  let regions = foldingModel.regions;\n  let toToggle = [];\n  for (let i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n      toToggle.push(regions.toRegion(i));\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}","map":{"version":3,"names":["Emitter","FoldingRegions","FoldingModel","constructor","textModel","decorationProvider","_updateEventEmitter","onDidChange","event","_textModel","_decorationProvider","_regions","Uint32Array","_editorDecorationIds","_isInitialized","regions","isInitialized","toggleCollapseState","toggledRegions","length","sort","r1","r2","regionIndex","processed","changeDecorations","accessor","k","dirtyRegionEndLine","lastHiddenLine","updateDecorationsUntil","index","endLineNumber","getEndLineNumber","isCollapsed","changeDecorationOptions","getDecorationOption","region","editorDecorationId","newCollapseState","setCollapsed","Math","max","fire","model","collapseStateChanged","update","newRegions","blockedLineNumers","arguments","undefined","newEditorDecorations","isBlocked","startLineNumber","blockedLineNumber","initRange","getStartLineNumber","maxColumn","getLineMaxColumn","decorationRange","startColumn","endColumn","push","range","options","i","nextCollapsed","collapsedIndex","decRange","getDecorationRange","collapsedStartLineNumber","deltaDecorations","getMemento","collapsedRanges","applyMemento","state","Array","isArray","toToogle","getRegionAtLine","dispose","getAllRegionsAtLine","lineNumber","filter","result","findRange","level","current","toRegion","parentIndex","getRegionsInside","Number","MAX_VALUE","levelStack","len","containedBy","pop","foldingModel","levels","lineNumbers","toToggle","doCollapse","regionsInside","r","setCollapseStateLevelsDown","setCollapseStateLevelsUp","setCollapseStateUp","setCollapseStateAtLevel","foldLevel","blockedLineNumbers","some","line","containsLine","setCollapseStateForMatchingLines","regExp","editorModel","test","getLineContent","setCollapseStateForType","type","getType"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Emitter } from '../../../base/common/event.js';\r\nimport { FoldingRegions } from './foldingRanges.js';\r\nexport class FoldingModel {\r\n    constructor(textModel, decorationProvider) {\r\n        this._updateEventEmitter = new Emitter();\r\n        this.onDidChange = this._updateEventEmitter.event;\r\n        this._textModel = textModel;\r\n        this._decorationProvider = decorationProvider;\r\n        this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\r\n        this._editorDecorationIds = [];\r\n        this._isInitialized = false;\r\n    }\r\n    get regions() { return this._regions; }\r\n    get textModel() { return this._textModel; }\r\n    get isInitialized() { return this._isInitialized; }\r\n    toggleCollapseState(toggledRegions) {\r\n        if (!toggledRegions.length) {\r\n            return;\r\n        }\r\n        toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);\r\n        const processed = {};\r\n        this._decorationProvider.changeDecorations(accessor => {\r\n            let k = 0; // index from [0 ... this.regions.length]\r\n            let dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\r\n            let lastHiddenLine = -1; // the end of the last hidden lines\r\n            const updateDecorationsUntil = (index) => {\r\n                while (k < index) {\r\n                    const endLineNumber = this._regions.getEndLineNumber(k);\r\n                    const isCollapsed = this._regions.isCollapsed(k);\r\n                    if (endLineNumber <= dirtyRegionEndLine) {\r\n                        accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine));\r\n                    }\r\n                    if (isCollapsed && endLineNumber > lastHiddenLine) {\r\n                        lastHiddenLine = endLineNumber;\r\n                    }\r\n                    k++;\r\n                }\r\n            };\r\n            for (let region of toggledRegions) {\r\n                let index = region.regionIndex;\r\n                let editorDecorationId = this._editorDecorationIds[index];\r\n                if (editorDecorationId && !processed[editorDecorationId]) {\r\n                    processed[editorDecorationId] = true;\r\n                    updateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\r\n                    let newCollapseState = !this._regions.isCollapsed(index);\r\n                    this._regions.setCollapsed(index, newCollapseState);\r\n                    dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));\r\n                }\r\n            }\r\n            updateDecorationsUntil(this._regions.length);\r\n        });\r\n        this._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });\r\n    }\r\n    update(newRegions, blockedLineNumers = []) {\r\n        let newEditorDecorations = [];\r\n        let isBlocked = (startLineNumber, endLineNumber) => {\r\n            for (let blockedLineNumber of blockedLineNumers) {\r\n                if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        let lastHiddenLine = -1;\r\n        let initRange = (index, isCollapsed) => {\r\n            const startLineNumber = newRegions.getStartLineNumber(index);\r\n            const endLineNumber = newRegions.getEndLineNumber(index);\r\n            if (isCollapsed && isBlocked(startLineNumber, endLineNumber)) {\r\n                isCollapsed = false;\r\n            }\r\n            newRegions.setCollapsed(index, isCollapsed);\r\n            const maxColumn = this._textModel.getLineMaxColumn(startLineNumber);\r\n            const decorationRange = {\r\n                startLineNumber: startLineNumber,\r\n                startColumn: Math.max(maxColumn - 1, 1),\r\n                endLineNumber: startLineNumber,\r\n                endColumn: maxColumn\r\n            };\r\n            newEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine) });\r\n            if (isCollapsed && endLineNumber > lastHiddenLine) {\r\n                lastHiddenLine = endLineNumber;\r\n            }\r\n        };\r\n        let i = 0;\r\n        let nextCollapsed = () => {\r\n            while (i < this._regions.length) {\r\n                let isCollapsed = this._regions.isCollapsed(i);\r\n                i++;\r\n                if (isCollapsed) {\r\n                    return i - 1;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n        let k = 0;\r\n        let collapsedIndex = nextCollapsed();\r\n        while (collapsedIndex !== -1 && k < newRegions.length) {\r\n            // get the latest range\r\n            let decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\r\n            if (decRange) {\r\n                let collapsedStartLineNumber = decRange.startLineNumber;\r\n                if (decRange.startColumn === Math.max(decRange.endColumn - 1, 1) && this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.endColumn) { // test that the decoration is still covering the full line else it got deleted\r\n                    while (k < newRegions.length) {\r\n                        let startLineNumber = newRegions.getStartLineNumber(k);\r\n                        if (collapsedStartLineNumber >= startLineNumber) {\r\n                            initRange(k, collapsedStartLineNumber === startLineNumber);\r\n                            k++;\r\n                        }\r\n                        else {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            collapsedIndex = nextCollapsed();\r\n        }\r\n        while (k < newRegions.length) {\r\n            initRange(k, false);\r\n            k++;\r\n        }\r\n        this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\r\n        this._regions = newRegions;\r\n        this._isInitialized = true;\r\n        this._updateEventEmitter.fire({ model: this });\r\n    }\r\n    /**\r\n     * Collapse state memento, for persistence only\r\n     */\r\n    getMemento() {\r\n        let collapsedRanges = [];\r\n        for (let i = 0; i < this._regions.length; i++) {\r\n            if (this._regions.isCollapsed(i)) {\r\n                let range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\r\n                if (range) {\r\n                    let startLineNumber = range.startLineNumber;\r\n                    let endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\r\n                    collapsedRanges.push({ startLineNumber, endLineNumber });\r\n                }\r\n            }\r\n        }\r\n        if (collapsedRanges.length > 0) {\r\n            return collapsedRanges;\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Apply persisted state, for persistence only\r\n     */\r\n    applyMemento(state) {\r\n        if (!Array.isArray(state)) {\r\n            return;\r\n        }\r\n        let toToogle = [];\r\n        for (let range of state) {\r\n            let region = this.getRegionAtLine(range.startLineNumber);\r\n            if (region && !region.isCollapsed) {\r\n                toToogle.push(region);\r\n            }\r\n        }\r\n        this.toggleCollapseState(toToogle);\r\n    }\r\n    dispose() {\r\n        this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\r\n    }\r\n    getAllRegionsAtLine(lineNumber, filter) {\r\n        let result = [];\r\n        if (this._regions) {\r\n            let index = this._regions.findRange(lineNumber);\r\n            let level = 1;\r\n            while (index >= 0) {\r\n                let current = this._regions.toRegion(index);\r\n                if (!filter || filter(current, level)) {\r\n                    result.push(current);\r\n                }\r\n                level++;\r\n                index = current.parentIndex;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    getRegionAtLine(lineNumber) {\r\n        if (this._regions) {\r\n            let index = this._regions.findRange(lineNumber);\r\n            if (index >= 0) {\r\n                return this._regions.toRegion(index);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    getRegionsInside(region, filter) {\r\n        let result = [];\r\n        let index = region ? region.regionIndex + 1 : 0;\r\n        let endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\r\n        if (filter && filter.length === 2) {\r\n            const levelStack = [];\r\n            for (let i = index, len = this._regions.length; i < len; i++) {\r\n                let current = this._regions.toRegion(i);\r\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\r\n                    while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\r\n                        levelStack.pop();\r\n                    }\r\n                    levelStack.push(current);\r\n                    if (filter(current, levelStack.length)) {\r\n                        result.push(current);\r\n                    }\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (let i = index, len = this._regions.length; i < len; i++) {\r\n                let current = this._regions.toRegion(i);\r\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\r\n                    if (!filter || filter(current)) {\r\n                        result.push(current);\r\n                    }\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * Collapse or expand the regions at the given locations\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\r\n */\r\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\r\n    let toToggle = [];\r\n    for (let lineNumber of lineNumbers) {\r\n        let region = foldingModel.getRegionAtLine(lineNumber);\r\n        if (region) {\r\n            const doCollapse = !region.isCollapsed;\r\n            toToggle.push(region);\r\n            if (levels > 1) {\r\n                let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\r\n                toToggle.push(...regionsInside);\r\n            }\r\n        }\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Collapse or expand the regions at the given locations including all children.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\r\n */\r\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {\r\n    let toToggle = [];\r\n    if (lineNumbers && lineNumbers.length > 0) {\r\n        for (let lineNumber of lineNumbers) {\r\n            let region = foldingModel.getRegionAtLine(lineNumber);\r\n            if (region) {\r\n                if (region.isCollapsed !== doCollapse) {\r\n                    toToggle.push(region);\r\n                }\r\n                if (levels > 1) {\r\n                    let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\r\n                    toToggle.push(...regionsInside);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        let regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);\r\n        toToggle.push(...regionsInside);\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Collapse or expand the regions at the given locations including all parents.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand.\r\n */\r\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\r\n    let toToggle = [];\r\n    for (let lineNumber of lineNumbers) {\r\n        let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\r\n        toToggle.push(...regions);\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param lineNumbers the location of the regions to collapse or expand.\r\n */\r\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\r\n    let toToggle = [];\r\n    for (let lineNumber of lineNumbers) {\r\n        let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);\r\n        if (regions.length > 0) {\r\n            toToggle.push(regions[0]);\r\n        }\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\r\n * @param foldLevel level. Level == 1 is the top level\r\n * @param doCollapse Wheter to collase or expand\r\n*/\r\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\r\n    let filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\r\n    let toToggle = foldingModel.getRegionsInside(null, filter);\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Folds all regions for which the lines start with a given regex\r\n * @param foldingModel the folding model\r\n */\r\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\r\n    let editorModel = foldingModel.textModel;\r\n    let regions = foldingModel.regions;\r\n    let toToggle = [];\r\n    for (let i = regions.length - 1; i >= 0; i--) {\r\n        if (doCollapse !== regions.isCollapsed(i)) {\r\n            let startLineNumber = regions.getStartLineNumber(i);\r\n            if (regExp.test(editorModel.getLineContent(startLineNumber))) {\r\n                toToggle.push(regions.toRegion(i));\r\n            }\r\n        }\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Folds all regions of the given type\r\n * @param foldingModel the folding model\r\n */\r\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\r\n    let regions = foldingModel.regions;\r\n    let toToggle = [];\r\n    for (let i = regions.length - 1; i >= 0; i--) {\r\n        if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\r\n            toToggle.push(regions.toRegion(i));\r\n        }\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}