{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\nexport class LineCommentCommand {\n  constructor(selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {\n    this._selection = selection;\n    this._tabSize = tabSize;\n    this._type = type;\n    this._insertSpace = insertSpace;\n    this._selectionId = null;\n    this._deltaColumn = 0;\n    this._moveEndPositionDown = false;\n    this._ignoreEmptyLines = ignoreEmptyLines;\n    this._ignoreFirstLine = ignoreFirstLine || false;\n  }\n  /**\r\n   * Do an initial pass over the lines and gather info about the line comment string.\r\n   * Returns null if any of the lines doesn't support a line comment string.\r\n   */\n  static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber) {\n    model.tokenizeIfCheap(startLineNumber);\n    const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n    const config = LanguageConfigurationRegistry.getComments(languageId);\n    const commentStr = config ? config.lineCommentToken : null;\n    if (!commentStr) {\n      // Mode does not support line comments\n      return null;\n    }\n    let lines = [];\n    for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n      lines[i] = {\n        ignore: false,\n        commentStr: commentStr,\n        commentStrOffset: 0,\n        commentStrLength: commentStr.length\n      };\n    }\n    return lines;\n  }\n  /**\r\n   * Analyze lines and decide which lines are relevant and what the toggle should do.\r\n   * Also, build up several offsets and lengths useful in the generation of editor operations.\r\n   */\n  static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine) {\n    let onlyWhitespaceLines = true;\n    let shouldRemoveComments;\n    if (type === 0 /* Toggle */) {\n      shouldRemoveComments = true;\n    } else if (type === 1 /* ForceAdd */) {\n      shouldRemoveComments = false;\n    } else {\n      shouldRemoveComments = true;\n    }\n    for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n      const lineData = lines[i];\n      const lineNumber = startLineNumber + i;\n      if (lineNumber === startLineNumber && ignoreFirstLine) {\n        // first line ignored\n        lineData.ignore = true;\n        continue;\n      }\n      const lineContent = model.getLineContent(lineNumber);\n      const lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n      if (lineContentStartOffset === -1) {\n        // Empty or whitespace only line\n        lineData.ignore = ignoreEmptyLines;\n        lineData.commentStrOffset = lineContent.length;\n        continue;\n      }\n      onlyWhitespaceLines = false;\n      lineData.ignore = false;\n      lineData.commentStrOffset = lineContentStartOffset;\n      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n        if (type === 0 /* Toggle */) {\n          // Every line so far has been a line comment, but this one is not\n          shouldRemoveComments = false;\n        } else if (type === 1 /* ForceAdd */) {\n          // Will not happen\n        } else {\n          lineData.ignore = true;\n        }\n      }\n      if (shouldRemoveComments && insertSpace) {\n        // Remove a following space if present\n        const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* Space */) {\n          lineData.commentStrLength += 1;\n        }\n      }\n    }\n    if (type === 0 /* Toggle */ && onlyWhitespaceLines) {\n      // For only whitespace lines, we insert comments\n      shouldRemoveComments = false;\n      // Also, no longer ignore them\n      for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n        lines[i].ignore = false;\n      }\n    }\n    return {\n      supported: true,\n      shouldRemoveComments: shouldRemoveComments,\n      lines: lines\n    };\n  }\n  /**\r\n   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\r\n   */\n  static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine) {\n    const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);\n    if (lines === null) {\n      return {\n        supported: false\n      };\n    }\n    return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine);\n  }\n  /**\r\n   * Given a successful analysis, execute either insert line comments, either remove line comments\r\n   */\n  _executeLineComments(model, builder, data, s) {\n    let ops;\n    if (data.shouldRemoveComments) {\n      ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n    } else {\n      LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n      ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n    }\n    const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n    for (let i = 0, len = ops.length; i < len; i++) {\n      builder.addEditOperation(ops[i].range, ops[i].text);\n      if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n        const lineContent = model.getLineContent(cursorPosition.lineNumber);\n        if (lineContent.length + 1 === cursorPosition.column) {\n          this._deltaColumn = (ops[i].text || '').length;\n        }\n      }\n    }\n    this._selectionId = builder.trackSelection(s);\n  }\n  _attemptRemoveBlockComment(model, s, startToken, endToken) {\n    let startLineNumber = s.startLineNumber;\n    let endLineNumber = s.endLineNumber;\n    let startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n    let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n    let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n    if (startTokenIndex !== -1 && endTokenIndex === -1) {\n      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      endLineNumber = startLineNumber;\n    }\n    if (startTokenIndex === -1 && endTokenIndex !== -1) {\n      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n      startLineNumber = endLineNumber;\n    }\n    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n      if (startTokenIndex !== -1) {\n        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      }\n    }\n    // We have to adjust to possible inner white space.\n    // For Space after startToken, add Space to startToken - range math will work out.\n    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* Space */) {\n      startToken += ' ';\n    }\n    // For Space before endToken, add Space before endToken and shift index one left.\n    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* Space */) {\n      endToken = ' ' + endToken;\n      endTokenIndex -= 1;\n    }\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n    }\n    return null;\n  }\n  /**\r\n   * Given an unsuccessful analysis, delegate to the block comment command\r\n   */\n  _executeBlockComment(model, builder, s) {\n    model.tokenizeIfCheap(s.startLineNumber);\n    let languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n    let config = LanguageConfigurationRegistry.getComments(languageId);\n    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n      // Mode does not support block comments\n      return;\n    }\n    const startToken = config.blockCommentStartToken;\n    const endToken = config.blockCommentEndToken;\n    let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n    if (!ops) {\n      if (s.isEmpty()) {\n        const lineContent = model.getLineContent(s.startLineNumber);\n        let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n        if (firstNonWhitespaceIndex === -1) {\n          // Line is empty or contains only whitespace\n          firstNonWhitespaceIndex = lineContent.length;\n        }\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n      } else {\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n      }\n      if (ops.length === 1) {\n        // Leave cursor after token and Space\n        this._deltaColumn = startToken.length + 1;\n      }\n    }\n    this._selectionId = builder.trackSelection(s);\n    for (const op of ops) {\n      builder.addEditOperation(op.range, op.text);\n    }\n  }\n  getEditOperations(model, builder) {\n    let s = this._selection;\n    this._moveEndPositionDown = false;\n    if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n      builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n      this._selectionId = builder.trackSelection(s);\n      return;\n    }\n    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n      this._moveEndPositionDown = true;\n      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n    }\n    const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine);\n    if (data.supported) {\n      return this._executeLineComments(model, builder, data, s);\n    }\n    return this._executeBlockComment(model, builder, s);\n  }\n  computeCursorState(model, helper) {\n    let result = helper.getTrackedSelection(this._selectionId);\n    if (this._moveEndPositionDown) {\n      result = result.setEndPosition(result.endLineNumber + 1, 1);\n    }\n    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n  }\n  /**\r\n   * Generate edit operations in the remove line comment case\r\n   */\n  static _createRemoveLineCommentsOperations(lines, startLineNumber) {\n    let res = [];\n    for (let i = 0, len = lines.length; i < len; i++) {\n      const lineData = lines[i];\n      if (lineData.ignore) {\n        continue;\n      }\n      res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n    }\n    return res;\n  }\n  /**\r\n   * Generate edit operations in the add line comment case\r\n   */\n  _createAddLineCommentsOperations(lines, startLineNumber) {\n    let res = [];\n    const afterCommentStr = this._insertSpace ? ' ' : '';\n    for (let i = 0, len = lines.length; i < len; i++) {\n      const lineData = lines[i];\n      if (lineData.ignore) {\n        continue;\n      }\n      res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n    }\n    return res;\n  }\n  static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {\n    if (isTab) {\n      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);\n    }\n    return currentVisibleColumn + columnSize;\n  }\n  /**\r\n   * Adjust insertion points to have them vertically aligned in the add line comment case\r\n   */\n  static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {\n    let minVisibleColumn = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n    let j;\n    let lenJ;\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n      const lineContent = model.getLineContent(startLineNumber + i);\n      let currentVisibleColumn = 0;\n      for (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);\n      }\n      if (currentVisibleColumn < minVisibleColumn) {\n        minVisibleColumn = currentVisibleColumn;\n      }\n    }\n    minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n      const lineContent = model.getLineContent(startLineNumber + i);\n      let currentVisibleColumn = 0;\n      for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);\n      }\n      if (currentVisibleColumn > minVisibleColumn) {\n        lines[i].commentStrOffset = j - 1;\n      } else {\n        lines[i].commentStrOffset = j;\n      }\n    }\n  }\n}","map":{"version":3,"names":["strings","EditOperation","Position","Range","Selection","LanguageConfigurationRegistry","BlockCommentCommand","LineCommentCommand","constructor","selection","tabSize","type","insertSpace","ignoreEmptyLines","ignoreFirstLine","_selection","_tabSize","_type","_insertSpace","_selectionId","_deltaColumn","_moveEndPositionDown","_ignoreEmptyLines","_ignoreFirstLine","_gatherPreflightCommentStrings","model","startLineNumber","endLineNumber","tokenizeIfCheap","languageId","getLanguageIdAtPosition","config","getComments","commentStr","lineCommentToken","lines","i","lineCount","ignore","commentStrOffset","commentStrLength","length","_analyzeLines","onlyWhitespaceLines","shouldRemoveComments","lineData","lineNumber","lineContent","getLineContent","lineContentStartOffset","firstNonWhitespaceIndex","_haystackHasNeedleAtOffset","commentStrEndOffset","charCodeAt","supported","_gatherPreflightData","_executeLineComments","builder","data","s","ops","_createRemoveLineCommentsOperations","_normalizeInsertionPoint","_createAddLineCommentsOperations","cursorPosition","positionLineNumber","positionColumn","len","addEditOperation","range","text","isEmpty","getStartPosition","equals","column","trackSelection","_attemptRemoveBlockComment","startToken","endToken","startTokenAllowedBeforeColumn","Math","max","getLineFirstNonWhitespaceColumn","startColumn","startTokenIndex","lastIndexOf","endTokenIndex","indexOf","endColumn","_createRemoveBlockCommentOperations","_executeBlockComment","blockCommentStartToken","blockCommentEndToken","_createAddBlockCommentOperations","getLineMaxColumn","op","getEditOperations","getLineCount","setEndPosition","computeCursorState","helper","result","getTrackedSelection","selectionStartLineNumber","selectionStartColumn","res","push","delete","afterCommentStr","insert","nextVisibleColumn","currentVisibleColumn","isTab","columnSize","minVisibleColumn","j","lenJ","floor"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/comment/lineCommentCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { EditOperation } from '../../common/core/editOperation.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Range } from '../../common/core/range.js';\r\nimport { Selection } from '../../common/core/selection.js';\r\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\r\nimport { BlockCommentCommand } from './blockCommentCommand.js';\r\nexport class LineCommentCommand {\r\n    constructor(selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {\r\n        this._selection = selection;\r\n        this._tabSize = tabSize;\r\n        this._type = type;\r\n        this._insertSpace = insertSpace;\r\n        this._selectionId = null;\r\n        this._deltaColumn = 0;\r\n        this._moveEndPositionDown = false;\r\n        this._ignoreEmptyLines = ignoreEmptyLines;\r\n        this._ignoreFirstLine = ignoreFirstLine || false;\r\n    }\r\n    /**\r\n     * Do an initial pass over the lines and gather info about the line comment string.\r\n     * Returns null if any of the lines doesn't support a line comment string.\r\n     */\r\n    static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber) {\r\n        model.tokenizeIfCheap(startLineNumber);\r\n        const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\r\n        const config = LanguageConfigurationRegistry.getComments(languageId);\r\n        const commentStr = (config ? config.lineCommentToken : null);\r\n        if (!commentStr) {\r\n            // Mode does not support line comments\r\n            return null;\r\n        }\r\n        let lines = [];\r\n        for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\r\n            lines[i] = {\r\n                ignore: false,\r\n                commentStr: commentStr,\r\n                commentStrOffset: 0,\r\n                commentStrLength: commentStr.length\r\n            };\r\n        }\r\n        return lines;\r\n    }\r\n    /**\r\n     * Analyze lines and decide which lines are relevant and what the toggle should do.\r\n     * Also, build up several offsets and lengths useful in the generation of editor operations.\r\n     */\r\n    static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine) {\r\n        let onlyWhitespaceLines = true;\r\n        let shouldRemoveComments;\r\n        if (type === 0 /* Toggle */) {\r\n            shouldRemoveComments = true;\r\n        }\r\n        else if (type === 1 /* ForceAdd */) {\r\n            shouldRemoveComments = false;\r\n        }\r\n        else {\r\n            shouldRemoveComments = true;\r\n        }\r\n        for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\r\n            const lineData = lines[i];\r\n            const lineNumber = startLineNumber + i;\r\n            if (lineNumber === startLineNumber && ignoreFirstLine) {\r\n                // first line ignored\r\n                lineData.ignore = true;\r\n                continue;\r\n            }\r\n            const lineContent = model.getLineContent(lineNumber);\r\n            const lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\r\n            if (lineContentStartOffset === -1) {\r\n                // Empty or whitespace only line\r\n                lineData.ignore = ignoreEmptyLines;\r\n                lineData.commentStrOffset = lineContent.length;\r\n                continue;\r\n            }\r\n            onlyWhitespaceLines = false;\r\n            lineData.ignore = false;\r\n            lineData.commentStrOffset = lineContentStartOffset;\r\n            if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\r\n                if (type === 0 /* Toggle */) {\r\n                    // Every line so far has been a line comment, but this one is not\r\n                    shouldRemoveComments = false;\r\n                }\r\n                else if (type === 1 /* ForceAdd */) {\r\n                    // Will not happen\r\n                }\r\n                else {\r\n                    lineData.ignore = true;\r\n                }\r\n            }\r\n            if (shouldRemoveComments && insertSpace) {\r\n                // Remove a following space if present\r\n                const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\r\n                if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* Space */) {\r\n                    lineData.commentStrLength += 1;\r\n                }\r\n            }\r\n        }\r\n        if (type === 0 /* Toggle */ && onlyWhitespaceLines) {\r\n            // For only whitespace lines, we insert comments\r\n            shouldRemoveComments = false;\r\n            // Also, no longer ignore them\r\n            for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\r\n                lines[i].ignore = false;\r\n            }\r\n        }\r\n        return {\r\n            supported: true,\r\n            shouldRemoveComments: shouldRemoveComments,\r\n            lines: lines\r\n        };\r\n    }\r\n    /**\r\n     * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\r\n     */\r\n    static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine) {\r\n        const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);\r\n        if (lines === null) {\r\n            return {\r\n                supported: false\r\n            };\r\n        }\r\n        return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine);\r\n    }\r\n    /**\r\n     * Given a successful analysis, execute either insert line comments, either remove line comments\r\n     */\r\n    _executeLineComments(model, builder, data, s) {\r\n        let ops;\r\n        if (data.shouldRemoveComments) {\r\n            ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\r\n        }\r\n        else {\r\n            LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\r\n            ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\r\n        }\r\n        const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\r\n        for (let i = 0, len = ops.length; i < len; i++) {\r\n            builder.addEditOperation(ops[i].range, ops[i].text);\r\n            if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\r\n                const lineContent = model.getLineContent(cursorPosition.lineNumber);\r\n                if (lineContent.length + 1 === cursorPosition.column) {\r\n                    this._deltaColumn = (ops[i].text || '').length;\r\n                }\r\n            }\r\n        }\r\n        this._selectionId = builder.trackSelection(s);\r\n    }\r\n    _attemptRemoveBlockComment(model, s, startToken, endToken) {\r\n        let startLineNumber = s.startLineNumber;\r\n        let endLineNumber = s.endLineNumber;\r\n        let startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\r\n        let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\r\n        let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\r\n        if (startTokenIndex !== -1 && endTokenIndex === -1) {\r\n            endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\r\n            endLineNumber = startLineNumber;\r\n        }\r\n        if (startTokenIndex === -1 && endTokenIndex !== -1) {\r\n            startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\r\n            startLineNumber = endLineNumber;\r\n        }\r\n        if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\r\n            startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\r\n            if (startTokenIndex !== -1) {\r\n                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\r\n            }\r\n        }\r\n        // We have to adjust to possible inner white space.\r\n        // For Space after startToken, add Space to startToken - range math will work out.\r\n        if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* Space */) {\r\n            startToken += ' ';\r\n        }\r\n        // For Space before endToken, add Space before endToken and shift index one left.\r\n        if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* Space */) {\r\n            endToken = ' ' + endToken;\r\n            endTokenIndex -= 1;\r\n        }\r\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\r\n            return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Given an unsuccessful analysis, delegate to the block comment command\r\n     */\r\n    _executeBlockComment(model, builder, s) {\r\n        model.tokenizeIfCheap(s.startLineNumber);\r\n        let languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\r\n        let config = LanguageConfigurationRegistry.getComments(languageId);\r\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\r\n            // Mode does not support block comments\r\n            return;\r\n        }\r\n        const startToken = config.blockCommentStartToken;\r\n        const endToken = config.blockCommentEndToken;\r\n        let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\r\n        if (!ops) {\r\n            if (s.isEmpty()) {\r\n                const lineContent = model.getLineContent(s.startLineNumber);\r\n                let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\r\n                if (firstNonWhitespaceIndex === -1) {\r\n                    // Line is empty or contains only whitespace\r\n                    firstNonWhitespaceIndex = lineContent.length;\r\n                }\r\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\r\n            }\r\n            else {\r\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\r\n            }\r\n            if (ops.length === 1) {\r\n                // Leave cursor after token and Space\r\n                this._deltaColumn = startToken.length + 1;\r\n            }\r\n        }\r\n        this._selectionId = builder.trackSelection(s);\r\n        for (const op of ops) {\r\n            builder.addEditOperation(op.range, op.text);\r\n        }\r\n    }\r\n    getEditOperations(model, builder) {\r\n        let s = this._selection;\r\n        this._moveEndPositionDown = false;\r\n        if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\r\n            builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\r\n            this._selectionId = builder.trackSelection(s);\r\n            return;\r\n        }\r\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\r\n            this._moveEndPositionDown = true;\r\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\r\n        }\r\n        const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine);\r\n        if (data.supported) {\r\n            return this._executeLineComments(model, builder, data, s);\r\n        }\r\n        return this._executeBlockComment(model, builder, s);\r\n    }\r\n    computeCursorState(model, helper) {\r\n        let result = helper.getTrackedSelection(this._selectionId);\r\n        if (this._moveEndPositionDown) {\r\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\r\n        }\r\n        return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\r\n    }\r\n    /**\r\n     * Generate edit operations in the remove line comment case\r\n     */\r\n    static _createRemoveLineCommentsOperations(lines, startLineNumber) {\r\n        let res = [];\r\n        for (let i = 0, len = lines.length; i < len; i++) {\r\n            const lineData = lines[i];\r\n            if (lineData.ignore) {\r\n                continue;\r\n            }\r\n            res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\r\n        }\r\n        return res;\r\n    }\r\n    /**\r\n     * Generate edit operations in the add line comment case\r\n     */\r\n    _createAddLineCommentsOperations(lines, startLineNumber) {\r\n        let res = [];\r\n        const afterCommentStr = this._insertSpace ? ' ' : '';\r\n        for (let i = 0, len = lines.length; i < len; i++) {\r\n            const lineData = lines[i];\r\n            if (lineData.ignore) {\r\n                continue;\r\n            }\r\n            res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\r\n        }\r\n        return res;\r\n    }\r\n    static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {\r\n        if (isTab) {\r\n            return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\r\n        }\r\n        return currentVisibleColumn + columnSize;\r\n    }\r\n    /**\r\n     * Adjust insertion points to have them vertically aligned in the add line comment case\r\n     */\r\n    static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {\r\n        let minVisibleColumn = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        let j;\r\n        let lenJ;\r\n        for (let i = 0, len = lines.length; i < len; i++) {\r\n            if (lines[i].ignore) {\r\n                continue;\r\n            }\r\n            const lineContent = model.getLineContent(startLineNumber + i);\r\n            let currentVisibleColumn = 0;\r\n            for (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\r\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);\r\n            }\r\n            if (currentVisibleColumn < minVisibleColumn) {\r\n                minVisibleColumn = currentVisibleColumn;\r\n            }\r\n        }\r\n        minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\r\n        for (let i = 0, len = lines.length; i < len; i++) {\r\n            if (lines[i].ignore) {\r\n                continue;\r\n            }\r\n            const lineContent = model.getLineContent(startLineNumber + i);\r\n            let currentVisibleColumn = 0;\r\n            for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\r\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);\r\n            }\r\n            if (currentVisibleColumn > minVisibleColumn) {\r\n                lines[i].commentStrOffset = j - 1;\r\n            }\r\n            else {\r\n                lines[i].commentStrOffset = j;\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}