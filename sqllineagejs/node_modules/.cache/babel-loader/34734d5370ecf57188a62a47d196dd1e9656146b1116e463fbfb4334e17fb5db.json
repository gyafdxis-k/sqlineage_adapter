{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, TokenizationResult2 } from '../../../common/core/token.js';\nimport * as modes from '../../../common/modes.js';\nimport { NULL_MODE_ID, NULL_STATE } from '../../../common/modes/nullMode.js';\nimport * as monarchCommon from './monarchCommon.js';\nconst CACHE_STACK_DEPTH = 5;\n/**\r\n * Reuse the same stack elements up to a certain depth.\r\n */\nclass MonarchStackElementFactory {\n  constructor(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n  static create(parent, state) {\n    return this._INSTANCE.create(parent, state);\n  }\n  create(parent, state) {\n    if (parent !== null && parent.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchStackElement(parent, state);\n    }\n    let stackElementId = MonarchStackElement.getStackElementId(parent);\n    if (stackElementId.length > 0) {\n      stackElementId += '|';\n    }\n    stackElementId += state;\n    let result = this._entries[stackElementId];\n    if (result) {\n      return result;\n    }\n    result = new MonarchStackElement(parent, state);\n    this._entries[stackElementId] = result;\n    return result;\n  }\n}\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\nclass MonarchStackElement {\n  constructor(parent, state) {\n    this.parent = parent;\n    this.state = state;\n    this.depth = (this.parent ? this.parent.depth : 0) + 1;\n  }\n  static getStackElementId(element) {\n    let result = '';\n    while (element !== null) {\n      if (result.length > 0) {\n        result += '|';\n      }\n      result += element.state;\n      element = element.parent;\n    }\n    return result;\n  }\n  static _equals(a, b) {\n    while (a !== null && b !== null) {\n      if (a === b) {\n        return true;\n      }\n      if (a.state !== b.state) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    }\n    if (a === null && b === null) {\n      return true;\n    }\n    return false;\n  }\n  equals(other) {\n    return MonarchStackElement._equals(this, other);\n  }\n  push(state) {\n    return MonarchStackElementFactory.create(this, state);\n  }\n  pop() {\n    return this.parent;\n  }\n  popall() {\n    let result = this;\n    while (result.parent) {\n      result = result.parent;\n    }\n    return result;\n  }\n  switchTo(state) {\n    return MonarchStackElementFactory.create(this.parent, state);\n  }\n}\nclass EmbeddedModeData {\n  constructor(modeId, state) {\n    this.modeId = modeId;\n    this.state = state;\n  }\n  equals(other) {\n    return this.modeId === other.modeId && this.state.equals(other.state);\n  }\n  clone() {\n    let stateClone = this.state.clone();\n    // save an object\n    if (stateClone === this.state) {\n      return this;\n    }\n    return new EmbeddedModeData(this.modeId, this.state);\n  }\n}\n/**\r\n * Reuse the same line states up to a certain depth.\r\n */\nclass MonarchLineStateFactory {\n  constructor(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n  static create(stack, embeddedModeData) {\n    return this._INSTANCE.create(stack, embeddedModeData);\n  }\n  create(stack, embeddedModeData) {\n    if (embeddedModeData !== null) {\n      // no caching when embedding\n      return new MonarchLineState(stack, embeddedModeData);\n    }\n    if (stack !== null && stack.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchLineState(stack, embeddedModeData);\n    }\n    let stackElementId = MonarchStackElement.getStackElementId(stack);\n    let result = this._entries[stackElementId];\n    if (result) {\n      return result;\n    }\n    result = new MonarchLineState(stack, null);\n    this._entries[stackElementId] = result;\n    return result;\n  }\n}\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\nclass MonarchLineState {\n  constructor(stack, embeddedModeData) {\n    this.stack = stack;\n    this.embeddedModeData = embeddedModeData;\n  }\n  clone() {\n    let embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null;\n    // save an object\n    if (embeddedModeDataClone === this.embeddedModeData) {\n      return this;\n    }\n    return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);\n  }\n  equals(other) {\n    if (!(other instanceof MonarchLineState)) {\n      return false;\n    }\n    if (!this.stack.equals(other.stack)) {\n      return false;\n    }\n    if (this.embeddedModeData === null && other.embeddedModeData === null) {\n      return true;\n    }\n    if (this.embeddedModeData === null || other.embeddedModeData === null) {\n      return false;\n    }\n    return this.embeddedModeData.equals(other.embeddedModeData);\n  }\n}\nclass MonarchClassicTokensCollector {\n  constructor() {\n    this._tokens = [];\n    this._language = null;\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n  }\n  enterMode(startOffset, modeId) {\n    this._language = modeId;\n  }\n  emit(startOffset, type) {\n    if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {\n      return;\n    }\n    this._lastTokenType = type;\n    this._lastTokenLanguage = this._language;\n    this._tokens.push(new Token(startOffset, type, this._language));\n  }\n  nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {\n    const nestedModeId = embeddedModeData.modeId;\n    const embeddedModeState = embeddedModeData.state;\n    const nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n    if (!nestedModeTokenizationSupport) {\n      this.enterMode(offsetDelta, nestedModeId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n    let nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);\n    this._tokens = this._tokens.concat(nestedResult.tokens);\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n    this._language = null;\n    return nestedResult.endState;\n  }\n  finalize(endState) {\n    return new TokenizationResult(this._tokens, endState);\n  }\n}\nclass MonarchModernTokensCollector {\n  constructor(modeService, theme) {\n    this._modeService = modeService;\n    this._theme = theme;\n    this._prependTokens = null;\n    this._tokens = [];\n    this._currentLanguageId = 0 /* Null */;\n    this._lastTokenMetadata = 0;\n  }\n  enterMode(startOffset, modeId) {\n    this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;\n  }\n  emit(startOffset, type) {\n    let metadata = this._theme.match(this._currentLanguageId, type);\n    if (this._lastTokenMetadata === metadata) {\n      return;\n    }\n    this._lastTokenMetadata = metadata;\n    this._tokens.push(startOffset);\n    this._tokens.push(metadata);\n  }\n  static _merge(a, b, c) {\n    let aLen = a !== null ? a.length : 0;\n    let bLen = b.length;\n    let cLen = c !== null ? c.length : 0;\n    if (aLen === 0 && bLen === 0 && cLen === 0) {\n      return new Uint32Array(0);\n    }\n    if (aLen === 0 && bLen === 0) {\n      return c;\n    }\n    if (bLen === 0 && cLen === 0) {\n      return a;\n    }\n    let result = new Uint32Array(aLen + bLen + cLen);\n    if (a !== null) {\n      result.set(a);\n    }\n    for (let i = 0; i < bLen; i++) {\n      result[aLen + i] = b[i];\n    }\n    if (c !== null) {\n      result.set(c, aLen + bLen);\n    }\n    return result;\n  }\n  nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {\n    const nestedModeId = embeddedModeData.modeId;\n    const embeddedModeState = embeddedModeData.state;\n    const nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n    if (!nestedModeTokenizationSupport) {\n      this.enterMode(offsetDelta, nestedModeId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n    let nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);\n    this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n    this._tokens = [];\n    this._currentLanguageId = 0;\n    this._lastTokenMetadata = 0;\n    return nestedResult.endState;\n  }\n  finalize(endState) {\n    return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n  }\n}\nexport class MonarchTokenizer {\n  constructor(modeService, standaloneThemeService, modeId, lexer) {\n    this._modeService = modeService;\n    this._standaloneThemeService = standaloneThemeService;\n    this._modeId = modeId;\n    this._lexer = lexer;\n    this._embeddedModes = Object.create(null);\n    this.embeddedLoaded = Promise.resolve(undefined);\n    // Set up listening for embedded modes\n    let emitting = false;\n    this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange(e => {\n      if (emitting) {\n        return;\n      }\n      let isOneOfMyEmbeddedModes = false;\n      for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\n        let language = e.changedLanguages[i];\n        if (this._embeddedModes[language]) {\n          isOneOfMyEmbeddedModes = true;\n          break;\n        }\n      }\n      if (isOneOfMyEmbeddedModes) {\n        emitting = true;\n        modes.TokenizationRegistry.fire([this._modeId]);\n        emitting = false;\n      }\n    });\n  }\n  dispose() {\n    this._tokenizationRegistryListener.dispose();\n  }\n  getLoadStatus() {\n    let promises = [];\n    for (let nestedModeId in this._embeddedModes) {\n      const tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n      if (tokenizationSupport) {\n        // The nested mode is already loaded\n        if (tokenizationSupport instanceof MonarchTokenizer) {\n          const nestedModeStatus = tokenizationSupport.getLoadStatus();\n          if (nestedModeStatus.loaded === false) {\n            promises.push(nestedModeStatus.promise);\n          }\n        }\n        continue;\n      }\n      const tokenizationSupportPromise = modes.TokenizationRegistry.getPromise(nestedModeId);\n      if (tokenizationSupportPromise) {\n        // The nested mode is in the process of being loaded\n        promises.push(tokenizationSupportPromise);\n      }\n    }\n    if (promises.length === 0) {\n      return {\n        loaded: true\n      };\n    }\n    return {\n      loaded: false,\n      promise: Promise.all(promises).then(_ => undefined)\n    };\n  }\n  getInitialState() {\n    let rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n    return MonarchLineStateFactory.create(rootState, null);\n  }\n  tokenize(line, hasEOL, lineState, offsetDelta) {\n    let tokensCollector = new MonarchClassicTokensCollector();\n    let endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);\n    return tokensCollector.finalize(endLineState);\n  }\n  tokenize2(line, hasEOL, lineState, offsetDelta) {\n    let tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getColorTheme().tokenTheme);\n    let endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);\n    return tokensCollector.finalize(endLineState);\n  }\n  _tokenize(line, hasEOL, lineState, offsetDelta, collector) {\n    if (lineState.embeddedModeData) {\n      return this._nestedTokenize(line, hasEOL, lineState, offsetDelta, collector);\n    } else {\n      return this._myTokenize(line, hasEOL, lineState, offsetDelta, collector);\n    }\n  }\n  _findLeavingNestedModeOffset(line, state) {\n    let rules = this._lexer.tokenizer[state.stack.state];\n    if (!rules) {\n      rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n      if (!rules) {\n        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n      }\n    }\n    let popOffset = -1;\n    let hasEmbeddedPopRule = false;\n    for (const rule of rules) {\n      if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n        continue;\n      }\n      hasEmbeddedPopRule = true;\n      let regex = rule.regex;\n      let regexSource = rule.regex.source;\n      if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n        let flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\n        regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\n      }\n      let result = line.search(regex);\n      if (result === -1 || result !== 0 && rule.matchOnlyAtLineStart) {\n        continue;\n      }\n      if (popOffset === -1 || result < popOffset) {\n        popOffset = result;\n      }\n    }\n    if (!hasEmbeddedPopRule) {\n      throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n    }\n    return popOffset;\n  }\n  _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\n    let popOffset = this._findLeavingNestedModeOffset(line, lineState);\n    if (popOffset === -1) {\n      // tokenization will not leave nested mode\n      let nestedEndState = tokensCollector.nestedModeTokenize(line, hasEOL, lineState.embeddedModeData, offsetDelta);\n      return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));\n    }\n    let nestedModeLine = line.substring(0, popOffset);\n    if (nestedModeLine.length > 0) {\n      // tokenize with the nested mode\n      tokensCollector.nestedModeTokenize(nestedModeLine, false, lineState.embeddedModeData, offsetDelta);\n    }\n    let restOfTheLine = line.substring(popOffset);\n    return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\n  }\n  _safeRuleName(rule) {\n    if (rule) {\n      return rule.name;\n    }\n    return '(unknown)';\n  }\n  _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\n    tokensCollector.enterMode(offsetDelta, this._modeId);\n    const lineWithoutLFLength = lineWithoutLF.length;\n    const line = hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF;\n    const lineLength = line.length;\n    let embeddedModeData = lineState.embeddedModeData;\n    let stack = lineState.stack;\n    let pos = 0;\n    let groupMatching = null;\n    // See https://github.com/microsoft/monaco-editor/issues/1235\n    // Evaluate rules at least once for an empty line\n    let forceEvaluation = true;\n    while (forceEvaluation || pos < lineLength) {\n      const pos0 = pos;\n      const stackLen0 = stack.depth;\n      const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n      const state = stack.state;\n      let matches = null;\n      let matched = null;\n      let action = null;\n      let rule = null;\n      let enteringEmbeddedMode = null;\n      // check if we need to process group matches first\n      if (groupMatching) {\n        matches = groupMatching.matches;\n        const groupEntry = groupMatching.groups.shift();\n        matched = groupEntry.matched;\n        action = groupEntry.action;\n        rule = groupMatching.rule;\n        // cleanup if necessary\n        if (groupMatching.groups.length === 0) {\n          groupMatching = null;\n        }\n      } else {\n        // otherwise we match on the token stream\n        if (!forceEvaluation && pos >= lineLength) {\n          // nothing to do\n          break;\n        }\n        forceEvaluation = false;\n        // get the rules for this state\n        let rules = this._lexer.tokenizer[state];\n        if (!rules) {\n          rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n          if (!rules) {\n            throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n          }\n        }\n        // try each rule until we match\n        let restOfLine = line.substr(pos);\n        for (const rule of rules) {\n          if (pos === 0 || !rule.matchOnlyAtLineStart) {\n            matches = restOfLine.match(rule.regex);\n            if (matches) {\n              matched = matches[0];\n              action = rule.action;\n              break;\n            }\n          }\n        }\n      }\n      // We matched 'rule' with 'matches' and 'action'\n      if (!matches) {\n        matches = [''];\n        matched = '';\n      }\n      if (!action) {\n        // bad: we didn't match anything, and there is no action to take\n        // we need to advance the stream or we get progress trouble\n        if (pos < lineLength) {\n          matches = [line.charAt(pos)];\n          matched = matches[0];\n        }\n        action = this._lexer.defaultToken;\n      }\n      if (matched === null) {\n        // should never happen, needed for strict null checking\n        break;\n      }\n      // advance stream\n      pos += matched.length;\n      // maybe call action function (used for 'cases')\n      while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n        action = action.test(matched, matches, state, pos === lineLength);\n      }\n      let result = null;\n      // set the result: either a string or an array of actions\n      if (typeof action === 'string' || Array.isArray(action)) {\n        result = action;\n      } else if (action.group) {\n        result = action.group;\n      } else if (action.token !== null && action.token !== undefined) {\n        // do $n replacements?\n        if (action.tokenSubst) {\n          result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n        } else {\n          result = action.token;\n        }\n        // enter embedded mode?\n        if (action.nextEmbedded) {\n          if (action.nextEmbedded === '@pop') {\n            if (!embeddedModeData) {\n              throw monarchCommon.createError(this._lexer, 'cannot pop embedded mode if not inside one');\n            }\n            embeddedModeData = null;\n          } else if (embeddedModeData) {\n            throw monarchCommon.createError(this._lexer, 'cannot enter embedded mode from within an embedded mode');\n          } else {\n            enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n          }\n        }\n        // state transformations\n        if (action.goBack) {\n          // back up the stream..\n          pos = Math.max(0, pos - action.goBack);\n        }\n        if (action.switchTo && typeof action.switchTo === 'string') {\n          let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n          if (nextState[0] === '@') {\n            nextState = nextState.substr(1); // peel off starting '@'\n          }\n\n          if (!monarchCommon.findRules(this._lexer, nextState)) {\n            throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n          } else {\n            stack = stack.switchTo(nextState);\n          }\n        } else if (action.transform && typeof action.transform === 'function') {\n          throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n        } else if (action.next) {\n          if (action.next === '@push') {\n            if (stack.depth >= this._lexer.maxStack) {\n              throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' + stack.state + ',' + stack.parent.state + ',...]');\n            } else {\n              stack = stack.push(state);\n            }\n          } else if (action.next === '@pop') {\n            if (stack.depth <= 1) {\n              throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.pop();\n            }\n          } else if (action.next === '@popall') {\n            stack = stack.popall();\n          } else {\n            let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n            if (nextState[0] === '@') {\n              nextState = nextState.substr(1); // peel off starting '@'\n            }\n\n            if (!monarchCommon.findRules(this._lexer, nextState)) {\n              throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.push(nextState);\n            }\n          }\n        }\n        if (action.log && typeof action.log === 'string') {\n          monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n        }\n      }\n      // check result\n      if (result === null) {\n        throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n      }\n      const computeNewStateForEmbeddedMode = enteringEmbeddedMode => {\n        // substitute language alias to known modes to support syntax highlighting\n        let enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);\n        if (enteringEmbeddedModeId) {\n          enteringEmbeddedMode = enteringEmbeddedModeId;\n        }\n        const embeddedModeData = this._getNestedEmbeddedModeData(enteringEmbeddedMode);\n        if (pos < lineLength) {\n          // there is content from the embedded mode on this line\n          const restOfLine = lineWithoutLF.substr(pos);\n          return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedModeData), offsetDelta + pos, tokensCollector);\n        } else {\n          return MonarchLineStateFactory.create(stack, embeddedModeData);\n        }\n      };\n      // is the result a group match?\n      if (Array.isArray(result)) {\n        if (groupMatching && groupMatching.groups.length > 0) {\n          throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n        }\n        if (matches.length !== result.length + 1) {\n          throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n        }\n        let totalLen = 0;\n        for (let i = 1; i < matches.length; i++) {\n          totalLen += matches[i].length;\n        }\n        if (totalLen !== matched.length) {\n          throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n        }\n        groupMatching = {\n          rule: rule,\n          matches: matches,\n          groups: []\n        };\n        for (let i = 0; i < result.length; i++) {\n          groupMatching.groups[i] = {\n            action: result[i],\n            matched: matches[i + 1]\n          };\n        }\n        pos -= matched.length;\n        // call recursively to initiate first result match\n        continue;\n      } else {\n        // regular result\n        // check for '@rematch'\n        if (result === '@rematch') {\n          pos -= matched.length;\n          matched = ''; // better set the next state too..\n          matches = null;\n          result = '';\n          // Even though `@rematch` was specified, if `nextEmbedded` also specified,\n          // a state transition should occur.\n          if (enteringEmbeddedMode !== null) {\n            return computeNewStateForEmbeddedMode(enteringEmbeddedMode);\n          }\n        }\n        // check progress\n        if (matched.length === 0) {\n          if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n            continue;\n          } else {\n            throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n          }\n        }\n        // return the result (and check for brace matching)\n        // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n        let tokenType = null;\n        if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n          let rest = result.substr('@brackets'.length);\n          let bracket = findBracket(this._lexer, matched);\n          if (!bracket) {\n            throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n          }\n          tokenType = monarchCommon.sanitize(bracket.token + rest);\n        } else {\n          let token = result === '' ? '' : result + this._lexer.tokenPostfix;\n          tokenType = monarchCommon.sanitize(token);\n        }\n        if (pos0 < lineWithoutLFLength) {\n          tokensCollector.emit(pos0 + offsetDelta, tokenType);\n        }\n      }\n      if (enteringEmbeddedMode !== null) {\n        return computeNewStateForEmbeddedMode(enteringEmbeddedMode);\n      }\n    }\n    return MonarchLineStateFactory.create(stack, embeddedModeData);\n  }\n  _getNestedEmbeddedModeData(mimetypeOrModeId) {\n    let nestedModeId = this._locateMode(mimetypeOrModeId);\n    if (nestedModeId) {\n      let tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n      if (tokenizationSupport) {\n        return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());\n      }\n    }\n    return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);\n  }\n  _locateMode(mimetypeOrModeId) {\n    if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {\n      return null;\n    }\n    if (mimetypeOrModeId === this._modeId) {\n      // embedding myself...\n      return mimetypeOrModeId;\n    }\n    let modeId = this._modeService.getModeId(mimetypeOrModeId);\n    if (modeId) {\n      // Fire mode loading event\n      this._modeService.triggerMode(modeId);\n      this._embeddedModes[modeId] = true;\n    }\n    return modeId;\n  }\n}\n/**\r\n * Searches for a bracket in the 'brackets' attribute that matches the input.\r\n */\nfunction findBracket(lexer, matched) {\n  if (!matched) {\n    return null;\n  }\n  matched = monarchCommon.fixCase(lexer, matched);\n  let brackets = lexer.brackets;\n  for (const bracket of brackets) {\n    if (bracket.open === matched) {\n      return {\n        token: bracket.token,\n        bracketType: 1 /* Open */\n      };\n    } else if (bracket.close === matched) {\n      return {\n        token: bracket.token,\n        bracketType: -1 /* Close */\n      };\n    }\n  }\n\n  return null;\n}\nexport function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {\n  return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);\n}","map":{"version":3,"names":["Token","TokenizationResult","TokenizationResult2","modes","NULL_MODE_ID","NULL_STATE","monarchCommon","CACHE_STACK_DEPTH","MonarchStackElementFactory","constructor","maxCacheDepth","_maxCacheDepth","_entries","Object","create","parent","state","_INSTANCE","depth","MonarchStackElement","stackElementId","getStackElementId","length","result","element","_equals","a","b","equals","other","push","pop","popall","switchTo","EmbeddedModeData","modeId","clone","stateClone","MonarchLineStateFactory","stack","embeddedModeData","MonarchLineState","embeddedModeDataClone","MonarchClassicTokensCollector","_tokens","_language","_lastTokenType","_lastTokenLanguage","enterMode","startOffset","emit","type","nestedModeTokenize","embeddedModeLine","hasEOL","offsetDelta","nestedModeId","embeddedModeState","nestedModeTokenizationSupport","TokenizationRegistry","get","nestedResult","tokenize","concat","tokens","endState","finalize","MonarchModernTokensCollector","modeService","theme","_modeService","_theme","_prependTokens","_currentLanguageId","_lastTokenMetadata","getLanguageIdentifier","id","metadata","match","_merge","c","aLen","bLen","cLen","Uint32Array","set","i","tokenize2","MonarchTokenizer","standaloneThemeService","lexer","_standaloneThemeService","_modeId","_lexer","_embeddedModes","embeddedLoaded","Promise","resolve","undefined","emitting","_tokenizationRegistryListener","onDidChange","e","isOneOfMyEmbeddedModes","len","changedLanguages","language","fire","dispose","getLoadStatus","promises","tokenizationSupport","nestedModeStatus","loaded","promise","tokenizationSupportPromise","getPromise","all","then","_","getInitialState","rootState","start","line","lineState","tokensCollector","endLineState","_tokenize","getColorTheme","tokenTheme","collector","_nestedTokenize","_myTokenize","_findLeavingNestedModeOffset","rules","tokenizer","findRules","createError","popOffset","hasEmbeddedPopRule","rule","isIAction","action","nextEmbedded","regex","regexSource","source","substr","flags","ignoreCase","unicode","RegExp","search","matchOnlyAtLineStart","nestedEndState","nestedModeLine","substring","restOfTheLine","_safeRuleName","name","lineWithoutLF","lineWithoutLFLength","includeLF","lineLength","pos","groupMatching","forceEvaluation","pos0","stackLen0","groupLen0","groups","matches","matched","enteringEmbeddedMode","groupEntry","shift","restOfLine","charAt","defaultToken","isFuzzyAction","test","Array","isArray","group","token","tokenSubst","substituteMatches","goBack","Math","max","nextState","transform","next","maxStack","log","languageId","computeNewStateForEmbeddedMode","enteringEmbeddedModeId","getModeIdForLanguageName","_getNestedEmbeddedModeData","totalLen","tokenType","isString","indexOf","rest","bracket","findBracket","sanitize","tokenPostfix","mimetypeOrModeId","_locateMode","isRegisteredMode","getModeId","triggerMode","fixCase","brackets","open","bracketType","close","createTokenizationSupport"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Token, TokenizationResult, TokenizationResult2 } from '../../../common/core/token.js';\r\nimport * as modes from '../../../common/modes.js';\r\nimport { NULL_MODE_ID, NULL_STATE } from '../../../common/modes/nullMode.js';\r\nimport * as monarchCommon from './monarchCommon.js';\r\nconst CACHE_STACK_DEPTH = 5;\r\n/**\r\n * Reuse the same stack elements up to a certain depth.\r\n */\r\nclass MonarchStackElementFactory {\r\n    constructor(maxCacheDepth) {\r\n        this._maxCacheDepth = maxCacheDepth;\r\n        this._entries = Object.create(null);\r\n    }\r\n    static create(parent, state) {\r\n        return this._INSTANCE.create(parent, state);\r\n    }\r\n    create(parent, state) {\r\n        if (parent !== null && parent.depth >= this._maxCacheDepth) {\r\n            // no caching above a certain depth\r\n            return new MonarchStackElement(parent, state);\r\n        }\r\n        let stackElementId = MonarchStackElement.getStackElementId(parent);\r\n        if (stackElementId.length > 0) {\r\n            stackElementId += '|';\r\n        }\r\n        stackElementId += state;\r\n        let result = this._entries[stackElementId];\r\n        if (result) {\r\n            return result;\r\n        }\r\n        result = new MonarchStackElement(parent, state);\r\n        this._entries[stackElementId] = result;\r\n        return result;\r\n    }\r\n}\r\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\r\nclass MonarchStackElement {\r\n    constructor(parent, state) {\r\n        this.parent = parent;\r\n        this.state = state;\r\n        this.depth = (this.parent ? this.parent.depth : 0) + 1;\r\n    }\r\n    static getStackElementId(element) {\r\n        let result = '';\r\n        while (element !== null) {\r\n            if (result.length > 0) {\r\n                result += '|';\r\n            }\r\n            result += element.state;\r\n            element = element.parent;\r\n        }\r\n        return result;\r\n    }\r\n    static _equals(a, b) {\r\n        while (a !== null && b !== null) {\r\n            if (a === b) {\r\n                return true;\r\n            }\r\n            if (a.state !== b.state) {\r\n                return false;\r\n            }\r\n            a = a.parent;\r\n            b = b.parent;\r\n        }\r\n        if (a === null && b === null) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    equals(other) {\r\n        return MonarchStackElement._equals(this, other);\r\n    }\r\n    push(state) {\r\n        return MonarchStackElementFactory.create(this, state);\r\n    }\r\n    pop() {\r\n        return this.parent;\r\n    }\r\n    popall() {\r\n        let result = this;\r\n        while (result.parent) {\r\n            result = result.parent;\r\n        }\r\n        return result;\r\n    }\r\n    switchTo(state) {\r\n        return MonarchStackElementFactory.create(this.parent, state);\r\n    }\r\n}\r\nclass EmbeddedModeData {\r\n    constructor(modeId, state) {\r\n        this.modeId = modeId;\r\n        this.state = state;\r\n    }\r\n    equals(other) {\r\n        return (this.modeId === other.modeId\r\n            && this.state.equals(other.state));\r\n    }\r\n    clone() {\r\n        let stateClone = this.state.clone();\r\n        // save an object\r\n        if (stateClone === this.state) {\r\n            return this;\r\n        }\r\n        return new EmbeddedModeData(this.modeId, this.state);\r\n    }\r\n}\r\n/**\r\n * Reuse the same line states up to a certain depth.\r\n */\r\nclass MonarchLineStateFactory {\r\n    constructor(maxCacheDepth) {\r\n        this._maxCacheDepth = maxCacheDepth;\r\n        this._entries = Object.create(null);\r\n    }\r\n    static create(stack, embeddedModeData) {\r\n        return this._INSTANCE.create(stack, embeddedModeData);\r\n    }\r\n    create(stack, embeddedModeData) {\r\n        if (embeddedModeData !== null) {\r\n            // no caching when embedding\r\n            return new MonarchLineState(stack, embeddedModeData);\r\n        }\r\n        if (stack !== null && stack.depth >= this._maxCacheDepth) {\r\n            // no caching above a certain depth\r\n            return new MonarchLineState(stack, embeddedModeData);\r\n        }\r\n        let stackElementId = MonarchStackElement.getStackElementId(stack);\r\n        let result = this._entries[stackElementId];\r\n        if (result) {\r\n            return result;\r\n        }\r\n        result = new MonarchLineState(stack, null);\r\n        this._entries[stackElementId] = result;\r\n        return result;\r\n    }\r\n}\r\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\r\nclass MonarchLineState {\r\n    constructor(stack, embeddedModeData) {\r\n        this.stack = stack;\r\n        this.embeddedModeData = embeddedModeData;\r\n    }\r\n    clone() {\r\n        let embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null;\r\n        // save an object\r\n        if (embeddedModeDataClone === this.embeddedModeData) {\r\n            return this;\r\n        }\r\n        return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);\r\n    }\r\n    equals(other) {\r\n        if (!(other instanceof MonarchLineState)) {\r\n            return false;\r\n        }\r\n        if (!this.stack.equals(other.stack)) {\r\n            return false;\r\n        }\r\n        if (this.embeddedModeData === null && other.embeddedModeData === null) {\r\n            return true;\r\n        }\r\n        if (this.embeddedModeData === null || other.embeddedModeData === null) {\r\n            return false;\r\n        }\r\n        return this.embeddedModeData.equals(other.embeddedModeData);\r\n    }\r\n}\r\nclass MonarchClassicTokensCollector {\r\n    constructor() {\r\n        this._tokens = [];\r\n        this._language = null;\r\n        this._lastTokenType = null;\r\n        this._lastTokenLanguage = null;\r\n    }\r\n    enterMode(startOffset, modeId) {\r\n        this._language = modeId;\r\n    }\r\n    emit(startOffset, type) {\r\n        if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {\r\n            return;\r\n        }\r\n        this._lastTokenType = type;\r\n        this._lastTokenLanguage = this._language;\r\n        this._tokens.push(new Token(startOffset, type, this._language));\r\n    }\r\n    nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {\r\n        const nestedModeId = embeddedModeData.modeId;\r\n        const embeddedModeState = embeddedModeData.state;\r\n        const nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n        if (!nestedModeTokenizationSupport) {\r\n            this.enterMode(offsetDelta, nestedModeId);\r\n            this.emit(offsetDelta, '');\r\n            return embeddedModeState;\r\n        }\r\n        let nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);\r\n        this._tokens = this._tokens.concat(nestedResult.tokens);\r\n        this._lastTokenType = null;\r\n        this._lastTokenLanguage = null;\r\n        this._language = null;\r\n        return nestedResult.endState;\r\n    }\r\n    finalize(endState) {\r\n        return new TokenizationResult(this._tokens, endState);\r\n    }\r\n}\r\nclass MonarchModernTokensCollector {\r\n    constructor(modeService, theme) {\r\n        this._modeService = modeService;\r\n        this._theme = theme;\r\n        this._prependTokens = null;\r\n        this._tokens = [];\r\n        this._currentLanguageId = 0 /* Null */;\r\n        this._lastTokenMetadata = 0;\r\n    }\r\n    enterMode(startOffset, modeId) {\r\n        this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;\r\n    }\r\n    emit(startOffset, type) {\r\n        let metadata = this._theme.match(this._currentLanguageId, type);\r\n        if (this._lastTokenMetadata === metadata) {\r\n            return;\r\n        }\r\n        this._lastTokenMetadata = metadata;\r\n        this._tokens.push(startOffset);\r\n        this._tokens.push(metadata);\r\n    }\r\n    static _merge(a, b, c) {\r\n        let aLen = (a !== null ? a.length : 0);\r\n        let bLen = b.length;\r\n        let cLen = (c !== null ? c.length : 0);\r\n        if (aLen === 0 && bLen === 0 && cLen === 0) {\r\n            return new Uint32Array(0);\r\n        }\r\n        if (aLen === 0 && bLen === 0) {\r\n            return c;\r\n        }\r\n        if (bLen === 0 && cLen === 0) {\r\n            return a;\r\n        }\r\n        let result = new Uint32Array(aLen + bLen + cLen);\r\n        if (a !== null) {\r\n            result.set(a);\r\n        }\r\n        for (let i = 0; i < bLen; i++) {\r\n            result[aLen + i] = b[i];\r\n        }\r\n        if (c !== null) {\r\n            result.set(c, aLen + bLen);\r\n        }\r\n        return result;\r\n    }\r\n    nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {\r\n        const nestedModeId = embeddedModeData.modeId;\r\n        const embeddedModeState = embeddedModeData.state;\r\n        const nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n        if (!nestedModeTokenizationSupport) {\r\n            this.enterMode(offsetDelta, nestedModeId);\r\n            this.emit(offsetDelta, '');\r\n            return embeddedModeState;\r\n        }\r\n        let nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);\r\n        this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\r\n        this._tokens = [];\r\n        this._currentLanguageId = 0;\r\n        this._lastTokenMetadata = 0;\r\n        return nestedResult.endState;\r\n    }\r\n    finalize(endState) {\r\n        return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\r\n    }\r\n}\r\nexport class MonarchTokenizer {\r\n    constructor(modeService, standaloneThemeService, modeId, lexer) {\r\n        this._modeService = modeService;\r\n        this._standaloneThemeService = standaloneThemeService;\r\n        this._modeId = modeId;\r\n        this._lexer = lexer;\r\n        this._embeddedModes = Object.create(null);\r\n        this.embeddedLoaded = Promise.resolve(undefined);\r\n        // Set up listening for embedded modes\r\n        let emitting = false;\r\n        this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange((e) => {\r\n            if (emitting) {\r\n                return;\r\n            }\r\n            let isOneOfMyEmbeddedModes = false;\r\n            for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\r\n                let language = e.changedLanguages[i];\r\n                if (this._embeddedModes[language]) {\r\n                    isOneOfMyEmbeddedModes = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (isOneOfMyEmbeddedModes) {\r\n                emitting = true;\r\n                modes.TokenizationRegistry.fire([this._modeId]);\r\n                emitting = false;\r\n            }\r\n        });\r\n    }\r\n    dispose() {\r\n        this._tokenizationRegistryListener.dispose();\r\n    }\r\n    getLoadStatus() {\r\n        let promises = [];\r\n        for (let nestedModeId in this._embeddedModes) {\r\n            const tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n            if (tokenizationSupport) {\r\n                // The nested mode is already loaded\r\n                if (tokenizationSupport instanceof MonarchTokenizer) {\r\n                    const nestedModeStatus = tokenizationSupport.getLoadStatus();\r\n                    if (nestedModeStatus.loaded === false) {\r\n                        promises.push(nestedModeStatus.promise);\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            const tokenizationSupportPromise = modes.TokenizationRegistry.getPromise(nestedModeId);\r\n            if (tokenizationSupportPromise) {\r\n                // The nested mode is in the process of being loaded\r\n                promises.push(tokenizationSupportPromise);\r\n            }\r\n        }\r\n        if (promises.length === 0) {\r\n            return {\r\n                loaded: true\r\n            };\r\n        }\r\n        return {\r\n            loaded: false,\r\n            promise: Promise.all(promises).then(_ => undefined)\r\n        };\r\n    }\r\n    getInitialState() {\r\n        let rootState = MonarchStackElementFactory.create(null, this._lexer.start);\r\n        return MonarchLineStateFactory.create(rootState, null);\r\n    }\r\n    tokenize(line, hasEOL, lineState, offsetDelta) {\r\n        let tokensCollector = new MonarchClassicTokensCollector();\r\n        let endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);\r\n        return tokensCollector.finalize(endLineState);\r\n    }\r\n    tokenize2(line, hasEOL, lineState, offsetDelta) {\r\n        let tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getColorTheme().tokenTheme);\r\n        let endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);\r\n        return tokensCollector.finalize(endLineState);\r\n    }\r\n    _tokenize(line, hasEOL, lineState, offsetDelta, collector) {\r\n        if (lineState.embeddedModeData) {\r\n            return this._nestedTokenize(line, hasEOL, lineState, offsetDelta, collector);\r\n        }\r\n        else {\r\n            return this._myTokenize(line, hasEOL, lineState, offsetDelta, collector);\r\n        }\r\n    }\r\n    _findLeavingNestedModeOffset(line, state) {\r\n        let rules = this._lexer.tokenizer[state.stack.state];\r\n        if (!rules) {\r\n            rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\r\n            if (!rules) {\r\n                throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\r\n            }\r\n        }\r\n        let popOffset = -1;\r\n        let hasEmbeddedPopRule = false;\r\n        for (const rule of rules) {\r\n            if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\r\n                continue;\r\n            }\r\n            hasEmbeddedPopRule = true;\r\n            let regex = rule.regex;\r\n            let regexSource = rule.regex.source;\r\n            if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\r\n                let flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\r\n                regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\r\n            }\r\n            let result = line.search(regex);\r\n            if (result === -1 || (result !== 0 && rule.matchOnlyAtLineStart)) {\r\n                continue;\r\n            }\r\n            if (popOffset === -1 || result < popOffset) {\r\n                popOffset = result;\r\n            }\r\n        }\r\n        if (!hasEmbeddedPopRule) {\r\n            throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\r\n        }\r\n        return popOffset;\r\n    }\r\n    _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\r\n        let popOffset = this._findLeavingNestedModeOffset(line, lineState);\r\n        if (popOffset === -1) {\r\n            // tokenization will not leave nested mode\r\n            let nestedEndState = tokensCollector.nestedModeTokenize(line, hasEOL, lineState.embeddedModeData, offsetDelta);\r\n            return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));\r\n        }\r\n        let nestedModeLine = line.substring(0, popOffset);\r\n        if (nestedModeLine.length > 0) {\r\n            // tokenize with the nested mode\r\n            tokensCollector.nestedModeTokenize(nestedModeLine, false, lineState.embeddedModeData, offsetDelta);\r\n        }\r\n        let restOfTheLine = line.substring(popOffset);\r\n        return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\r\n    }\r\n    _safeRuleName(rule) {\r\n        if (rule) {\r\n            return rule.name;\r\n        }\r\n        return '(unknown)';\r\n    }\r\n    _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\r\n        tokensCollector.enterMode(offsetDelta, this._modeId);\r\n        const lineWithoutLFLength = lineWithoutLF.length;\r\n        const line = (hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF);\r\n        const lineLength = line.length;\r\n        let embeddedModeData = lineState.embeddedModeData;\r\n        let stack = lineState.stack;\r\n        let pos = 0;\r\n        let groupMatching = null;\r\n        // See https://github.com/microsoft/monaco-editor/issues/1235\r\n        // Evaluate rules at least once for an empty line\r\n        let forceEvaluation = true;\r\n        while (forceEvaluation || pos < lineLength) {\r\n            const pos0 = pos;\r\n            const stackLen0 = stack.depth;\r\n            const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\r\n            const state = stack.state;\r\n            let matches = null;\r\n            let matched = null;\r\n            let action = null;\r\n            let rule = null;\r\n            let enteringEmbeddedMode = null;\r\n            // check if we need to process group matches first\r\n            if (groupMatching) {\r\n                matches = groupMatching.matches;\r\n                const groupEntry = groupMatching.groups.shift();\r\n                matched = groupEntry.matched;\r\n                action = groupEntry.action;\r\n                rule = groupMatching.rule;\r\n                // cleanup if necessary\r\n                if (groupMatching.groups.length === 0) {\r\n                    groupMatching = null;\r\n                }\r\n            }\r\n            else {\r\n                // otherwise we match on the token stream\r\n                if (!forceEvaluation && pos >= lineLength) {\r\n                    // nothing to do\r\n                    break;\r\n                }\r\n                forceEvaluation = false;\r\n                // get the rules for this state\r\n                let rules = this._lexer.tokenizer[state];\r\n                if (!rules) {\r\n                    rules = monarchCommon.findRules(this._lexer, state); // do parent matching\r\n                    if (!rules) {\r\n                        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\r\n                    }\r\n                }\r\n                // try each rule until we match\r\n                let restOfLine = line.substr(pos);\r\n                for (const rule of rules) {\r\n                    if (pos === 0 || !rule.matchOnlyAtLineStart) {\r\n                        matches = restOfLine.match(rule.regex);\r\n                        if (matches) {\r\n                            matched = matches[0];\r\n                            action = rule.action;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // We matched 'rule' with 'matches' and 'action'\r\n            if (!matches) {\r\n                matches = [''];\r\n                matched = '';\r\n            }\r\n            if (!action) {\r\n                // bad: we didn't match anything, and there is no action to take\r\n                // we need to advance the stream or we get progress trouble\r\n                if (pos < lineLength) {\r\n                    matches = [line.charAt(pos)];\r\n                    matched = matches[0];\r\n                }\r\n                action = this._lexer.defaultToken;\r\n            }\r\n            if (matched === null) {\r\n                // should never happen, needed for strict null checking\r\n                break;\r\n            }\r\n            // advance stream\r\n            pos += matched.length;\r\n            // maybe call action function (used for 'cases')\r\n            while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\r\n                action = action.test(matched, matches, state, pos === lineLength);\r\n            }\r\n            let result = null;\r\n            // set the result: either a string or an array of actions\r\n            if (typeof action === 'string' || Array.isArray(action)) {\r\n                result = action;\r\n            }\r\n            else if (action.group) {\r\n                result = action.group;\r\n            }\r\n            else if (action.token !== null && action.token !== undefined) {\r\n                // do $n replacements?\r\n                if (action.tokenSubst) {\r\n                    result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\r\n                }\r\n                else {\r\n                    result = action.token;\r\n                }\r\n                // enter embedded mode?\r\n                if (action.nextEmbedded) {\r\n                    if (action.nextEmbedded === '@pop') {\r\n                        if (!embeddedModeData) {\r\n                            throw monarchCommon.createError(this._lexer, 'cannot pop embedded mode if not inside one');\r\n                        }\r\n                        embeddedModeData = null;\r\n                    }\r\n                    else if (embeddedModeData) {\r\n                        throw monarchCommon.createError(this._lexer, 'cannot enter embedded mode from within an embedded mode');\r\n                    }\r\n                    else {\r\n                        enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\r\n                    }\r\n                }\r\n                // state transformations\r\n                if (action.goBack) { // back up the stream..\r\n                    pos = Math.max(0, pos - action.goBack);\r\n                }\r\n                if (action.switchTo && typeof action.switchTo === 'string') {\r\n                    let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\r\n                    if (nextState[0] === '@') {\r\n                        nextState = nextState.substr(1); // peel off starting '@'\r\n                    }\r\n                    if (!monarchCommon.findRules(this._lexer, nextState)) {\r\n                        throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\r\n                    }\r\n                    else {\r\n                        stack = stack.switchTo(nextState);\r\n                    }\r\n                }\r\n                else if (action.transform && typeof action.transform === 'function') {\r\n                    throw monarchCommon.createError(this._lexer, 'action.transform not supported');\r\n                }\r\n                else if (action.next) {\r\n                    if (action.next === '@push') {\r\n                        if (stack.depth >= this._lexer.maxStack) {\r\n                            throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' +\r\n                                stack.state + ',' + stack.parent.state + ',...]');\r\n                        }\r\n                        else {\r\n                            stack = stack.push(state);\r\n                        }\r\n                    }\r\n                    else if (action.next === '@pop') {\r\n                        if (stack.depth <= 1) {\r\n                            throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\r\n                        }\r\n                        else {\r\n                            stack = stack.pop();\r\n                        }\r\n                    }\r\n                    else if (action.next === '@popall') {\r\n                        stack = stack.popall();\r\n                    }\r\n                    else {\r\n                        let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\r\n                        if (nextState[0] === '@') {\r\n                            nextState = nextState.substr(1); // peel off starting '@'\r\n                        }\r\n                        if (!monarchCommon.findRules(this._lexer, nextState)) {\r\n                            throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\r\n                        }\r\n                        else {\r\n                            stack = stack.push(nextState);\r\n                        }\r\n                    }\r\n                }\r\n                if (action.log && typeof (action.log) === 'string') {\r\n                    monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\r\n                }\r\n            }\r\n            // check result\r\n            if (result === null) {\r\n                throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\r\n            }\r\n            const computeNewStateForEmbeddedMode = (enteringEmbeddedMode) => {\r\n                // substitute language alias to known modes to support syntax highlighting\r\n                let enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);\r\n                if (enteringEmbeddedModeId) {\r\n                    enteringEmbeddedMode = enteringEmbeddedModeId;\r\n                }\r\n                const embeddedModeData = this._getNestedEmbeddedModeData(enteringEmbeddedMode);\r\n                if (pos < lineLength) {\r\n                    // there is content from the embedded mode on this line\r\n                    const restOfLine = lineWithoutLF.substr(pos);\r\n                    return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedModeData), offsetDelta + pos, tokensCollector);\r\n                }\r\n                else {\r\n                    return MonarchLineStateFactory.create(stack, embeddedModeData);\r\n                }\r\n            };\r\n            // is the result a group match?\r\n            if (Array.isArray(result)) {\r\n                if (groupMatching && groupMatching.groups.length > 0) {\r\n                    throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\r\n                }\r\n                if (matches.length !== result.length + 1) {\r\n                    throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\r\n                }\r\n                let totalLen = 0;\r\n                for (let i = 1; i < matches.length; i++) {\r\n                    totalLen += matches[i].length;\r\n                }\r\n                if (totalLen !== matched.length) {\r\n                    throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\r\n                }\r\n                groupMatching = {\r\n                    rule: rule,\r\n                    matches: matches,\r\n                    groups: []\r\n                };\r\n                for (let i = 0; i < result.length; i++) {\r\n                    groupMatching.groups[i] = {\r\n                        action: result[i],\r\n                        matched: matches[i + 1]\r\n                    };\r\n                }\r\n                pos -= matched.length;\r\n                // call recursively to initiate first result match\r\n                continue;\r\n            }\r\n            else {\r\n                // regular result\r\n                // check for '@rematch'\r\n                if (result === '@rematch') {\r\n                    pos -= matched.length;\r\n                    matched = ''; // better set the next state too..\r\n                    matches = null;\r\n                    result = '';\r\n                    // Even though `@rematch` was specified, if `nextEmbedded` also specified,\r\n                    // a state transition should occur.\r\n                    if (enteringEmbeddedMode !== null) {\r\n                        return computeNewStateForEmbeddedMode(enteringEmbeddedMode);\r\n                    }\r\n                }\r\n                // check progress\r\n                if (matched.length === 0) {\r\n                    if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\r\n                    }\r\n                }\r\n                // return the result (and check for brace matching)\r\n                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\r\n                let tokenType = null;\r\n                if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\r\n                    let rest = result.substr('@brackets'.length);\r\n                    let bracket = findBracket(this._lexer, matched);\r\n                    if (!bracket) {\r\n                        throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\r\n                    }\r\n                    tokenType = monarchCommon.sanitize(bracket.token + rest);\r\n                }\r\n                else {\r\n                    let token = (result === '' ? '' : result + this._lexer.tokenPostfix);\r\n                    tokenType = monarchCommon.sanitize(token);\r\n                }\r\n                if (pos0 < lineWithoutLFLength) {\r\n                    tokensCollector.emit(pos0 + offsetDelta, tokenType);\r\n                }\r\n            }\r\n            if (enteringEmbeddedMode !== null) {\r\n                return computeNewStateForEmbeddedMode(enteringEmbeddedMode);\r\n            }\r\n        }\r\n        return MonarchLineStateFactory.create(stack, embeddedModeData);\r\n    }\r\n    _getNestedEmbeddedModeData(mimetypeOrModeId) {\r\n        let nestedModeId = this._locateMode(mimetypeOrModeId);\r\n        if (nestedModeId) {\r\n            let tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n            if (tokenizationSupport) {\r\n                return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());\r\n            }\r\n        }\r\n        return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);\r\n    }\r\n    _locateMode(mimetypeOrModeId) {\r\n        if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {\r\n            return null;\r\n        }\r\n        if (mimetypeOrModeId === this._modeId) {\r\n            // embedding myself...\r\n            return mimetypeOrModeId;\r\n        }\r\n        let modeId = this._modeService.getModeId(mimetypeOrModeId);\r\n        if (modeId) {\r\n            // Fire mode loading event\r\n            this._modeService.triggerMode(modeId);\r\n            this._embeddedModes[modeId] = true;\r\n        }\r\n        return modeId;\r\n    }\r\n}\r\n/**\r\n * Searches for a bracket in the 'brackets' attribute that matches the input.\r\n */\r\nfunction findBracket(lexer, matched) {\r\n    if (!matched) {\r\n        return null;\r\n    }\r\n    matched = monarchCommon.fixCase(lexer, matched);\r\n    let brackets = lexer.brackets;\r\n    for (const bracket of brackets) {\r\n        if (bracket.open === matched) {\r\n            return { token: bracket.token, bracketType: 1 /* Open */ };\r\n        }\r\n        else if (bracket.close === matched) {\r\n            return { token: bracket.token, bracketType: -1 /* Close */ };\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexport function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {\r\n    return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}