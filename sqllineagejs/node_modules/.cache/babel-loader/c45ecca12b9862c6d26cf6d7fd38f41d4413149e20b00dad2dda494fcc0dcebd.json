{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nexport const _debugComposition = false;\nexport class TextAreaState {\n  constructor(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {\n    this.value = value;\n    this.selectionStart = selectionStart;\n    this.selectionEnd = selectionEnd;\n    this.selectionStartPosition = selectionStartPosition;\n    this.selectionEndPosition = selectionEndPosition;\n  }\n  toString() {\n    return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ']';\n  }\n  static readFromTextArea(textArea) {\n    return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);\n  }\n  collapseSelection() {\n    return new TextAreaState(this.value, this.value.length, this.value.length, null, null);\n  }\n  writeToTextArea(reason, textArea, select) {\n    if (_debugComposition) {\n      console.log('writeToTextArea ' + reason + ': ' + this.toString());\n    }\n    textArea.setValue(reason, this.value);\n    if (select) {\n      textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\n    }\n  }\n  deduceEditorPosition(offset) {\n    if (offset <= this.selectionStart) {\n      const str = this.value.substring(offset, this.selectionStart);\n      return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);\n    }\n    if (offset >= this.selectionEnd) {\n      const str = this.value.substring(this.selectionEnd, offset);\n      return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);\n    }\n    const str1 = this.value.substring(this.selectionStart, offset);\n    if (str1.indexOf(String.fromCharCode(8230)) === -1) {\n      return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);\n    }\n    const str2 = this.value.substring(offset, this.selectionEnd);\n    return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);\n  }\n  _finishDeduceEditorPosition(anchor, deltaText, signum) {\n    let lineFeedCnt = 0;\n    let lastLineFeedIndex = -1;\n    while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\n      lineFeedCnt++;\n    }\n    return [anchor, signum * deltaText.length, lineFeedCnt];\n  }\n  static selectedText(text) {\n    return new TextAreaState(text, 0, text.length, null, null);\n  }\n  static deduceInput(previousState, currentState, couldBeEmojiInput) {\n    if (!previousState) {\n      // This is the EMPTY state\n      return {\n        text: '',\n        replaceCharCnt: 0\n      };\n    }\n    if (_debugComposition) {\n      console.log('------------------------deduceInput');\n      console.log('PREVIOUS STATE: ' + previousState.toString());\n      console.log('CURRENT STATE: ' + currentState.toString());\n    }\n    let previousValue = previousState.value;\n    let previousSelectionStart = previousState.selectionStart;\n    let previousSelectionEnd = previousState.selectionEnd;\n    let currentValue = currentState.value;\n    let currentSelectionStart = currentState.selectionStart;\n    let currentSelectionEnd = currentState.selectionEnd;\n    // Strip the previous suffix from the value (without interfering with the current selection)\n    const previousSuffix = previousValue.substring(previousSelectionEnd);\n    const currentSuffix = currentValue.substring(currentSelectionEnd);\n    const suffixLength = strings.commonSuffixLength(previousSuffix, currentSuffix);\n    currentValue = currentValue.substring(0, currentValue.length - suffixLength);\n    previousValue = previousValue.substring(0, previousValue.length - suffixLength);\n    const previousPrefix = previousValue.substring(0, previousSelectionStart);\n    const currentPrefix = currentValue.substring(0, currentSelectionStart);\n    const prefixLength = strings.commonPrefixLength(previousPrefix, currentPrefix);\n    currentValue = currentValue.substring(prefixLength);\n    previousValue = previousValue.substring(prefixLength);\n    currentSelectionStart -= prefixLength;\n    previousSelectionStart -= prefixLength;\n    currentSelectionEnd -= prefixLength;\n    previousSelectionEnd -= prefixLength;\n    if (_debugComposition) {\n      console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);\n      console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);\n    }\n    if (couldBeEmojiInput && currentSelectionStart === currentSelectionEnd && previousValue.length > 0) {\n      // on OSX, emojis from the emoji picker are inserted at random locations\n      // the only hints we can use is that the selection is immediately after the inserted emoji\n      // and that none of the old text has been deleted\n      let potentialEmojiInput = null;\n      if (currentSelectionStart === currentValue.length) {\n        // emoji potentially inserted \"somewhere\" after the previous selection => it should appear at the end of `currentValue`\n        if (currentValue.startsWith(previousValue)) {\n          // only if all of the old text is accounted for\n          potentialEmojiInput = currentValue.substring(previousValue.length);\n        }\n      } else {\n        // emoji potentially inserted \"somewhere\" before the previous selection => it should appear at the start of `currentValue`\n        if (currentValue.endsWith(previousValue)) {\n          // only if all of the old text is accounted for\n          potentialEmojiInput = currentValue.substring(0, currentValue.length - previousValue.length);\n        }\n      }\n      if (potentialEmojiInput !== null && potentialEmojiInput.length > 0) {\n        // now we check that this is indeed an emoji\n        // emojis can grow quite long, so a length check is of no help\n        // e.g. 1F3F4 E0067 E0062 E0065 E006E E0067 E007F  ; fully-qualified     # 🏴󠁧󠁢󠁥󠁮󠁧󠁿 England\n        // Oftentimes, emojis use Variation Selector-16 (U+FE0F), so that is a good hint\n        // http://emojipedia.org/variation-selector-16/\n        // > An invisible codepoint which specifies that the preceding character\n        // > should be displayed with emoji presentation. Only required if the\n        // > preceding character defaults to text presentation.\n        if (/\\uFE0F/.test(potentialEmojiInput) || strings.containsEmoji(potentialEmojiInput)) {\n          return {\n            text: potentialEmojiInput,\n            replaceCharCnt: 0\n          };\n        }\n      }\n    }\n    if (currentSelectionStart === currentSelectionEnd) {\n      // composition accept case (noticed in FF + Japanese)\n      // [blahblah] => blahblah|\n      if (previousValue === currentValue && previousSelectionStart === 0 && previousSelectionEnd === previousValue.length && currentSelectionStart === currentValue.length && currentValue.indexOf('\\n') === -1) {\n        if (strings.containsFullWidthCharacter(currentValue)) {\n          return {\n            text: '',\n            replaceCharCnt: 0\n          };\n        }\n      }\n      // no current selection\n      const replacePreviousCharacters = previousPrefix.length - prefixLength;\n      if (_debugComposition) {\n        console.log('REMOVE PREVIOUS: ' + (previousPrefix.length - prefixLength) + ' chars');\n      }\n      return {\n        text: currentValue,\n        replaceCharCnt: replacePreviousCharacters\n      };\n    }\n    // there is a current selection => composition case\n    const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\n    return {\n      text: currentValue,\n      replaceCharCnt: replacePreviousCharacters\n    };\n  }\n}\nTextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);\nexport class PagedScreenReaderStrategy {\n  static _getPageOfLine(lineNumber, linesPerPage) {\n    return Math.floor((lineNumber - 1) / linesPerPage);\n  }\n  static _getRangeForPage(page, linesPerPage) {\n    const offset = page * linesPerPage;\n    const startLineNumber = offset + 1;\n    const endLineNumber = offset + linesPerPage;\n    return new Range(startLineNumber, 1, endLineNumber + 1, 1);\n  }\n  static fromEditorSelection(previousState, model, selection, linesPerPage, trimLongText) {\n    const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\n    const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\n    const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\n    const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\n    const pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\n    let pretext = model.getValueInRange(pretextRange, 1 /* LF */);\n    const lastLine = model.getLineCount();\n    const lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n    const posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\n    let posttext = model.getValueInRange(posttextRange, 1 /* LF */);\n    let text;\n    if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\n      // take full selection\n      text = model.getValueInRange(selection, 1 /* LF */);\n    } else {\n      const selectionRange1 = selectionStartPageRange.intersectRanges(selection);\n      const selectionRange2 = selectionEndPageRange.intersectRanges(selection);\n      text = model.getValueInRange(selectionRange1, 1 /* LF */) + String.fromCharCode(8230) + model.getValueInRange(selectionRange2, 1 /* LF */);\n    }\n    // Chromium handles very poorly text even of a few thousand chars\n    // Cut text to avoid stalling the entire UI\n    if (trimLongText) {\n      const LIMIT_CHARS = 500;\n      if (pretext.length > LIMIT_CHARS) {\n        pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);\n      }\n      if (posttext.length > LIMIT_CHARS) {\n        posttext = posttext.substring(0, LIMIT_CHARS);\n      }\n      if (text.length > 2 * LIMIT_CHARS) {\n        text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\n      }\n    }\n    return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));\n  }\n}","map":{"version":3,"names":["strings","Position","Range","_debugComposition","TextAreaState","constructor","value","selectionStart","selectionEnd","selectionStartPosition","selectionEndPosition","toString","readFromTextArea","textArea","getValue","getSelectionStart","getSelectionEnd","collapseSelection","length","writeToTextArea","reason","select","console","log","setValue","setSelectionRange","deduceEditorPosition","offset","str","substring","_finishDeduceEditorPosition","str1","indexOf","String","fromCharCode","str2","anchor","deltaText","signum","lineFeedCnt","lastLineFeedIndex","selectedText","text","deduceInput","previousState","currentState","couldBeEmojiInput","replaceCharCnt","previousValue","previousSelectionStart","previousSelectionEnd","currentValue","currentSelectionStart","currentSelectionEnd","previousSuffix","currentSuffix","suffixLength","commonSuffixLength","previousPrefix","currentPrefix","prefixLength","commonPrefixLength","potentialEmojiInput","startsWith","endsWith","test","containsEmoji","containsFullWidthCharacter","replacePreviousCharacters","EMPTY","PagedScreenReaderStrategy","_getPageOfLine","lineNumber","linesPerPage","Math","floor","_getRangeForPage","page","startLineNumber","endLineNumber","fromEditorSelection","model","selection","trimLongText","selectionStartPage","selectionStartPageRange","selectionEndPage","selectionEndPageRange","pretextRange","intersectRanges","startColumn","pretext","getValueInRange","lastLine","getLineCount","lastLineMaxColumn","getLineMaxColumn","posttextRange","endColumn","posttext","selectionRange1","selectionRange2","LIMIT_CHARS"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaState.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Range } from '../../common/core/range.js';\r\nexport const _debugComposition = false;\r\nexport class TextAreaState {\r\n    constructor(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {\r\n        this.value = value;\r\n        this.selectionStart = selectionStart;\r\n        this.selectionEnd = selectionEnd;\r\n        this.selectionStartPosition = selectionStartPosition;\r\n        this.selectionEndPosition = selectionEndPosition;\r\n    }\r\n    toString() {\r\n        return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ']';\r\n    }\r\n    static readFromTextArea(textArea) {\r\n        return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);\r\n    }\r\n    collapseSelection() {\r\n        return new TextAreaState(this.value, this.value.length, this.value.length, null, null);\r\n    }\r\n    writeToTextArea(reason, textArea, select) {\r\n        if (_debugComposition) {\r\n            console.log('writeToTextArea ' + reason + ': ' + this.toString());\r\n        }\r\n        textArea.setValue(reason, this.value);\r\n        if (select) {\r\n            textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\r\n        }\r\n    }\r\n    deduceEditorPosition(offset) {\r\n        if (offset <= this.selectionStart) {\r\n            const str = this.value.substring(offset, this.selectionStart);\r\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);\r\n        }\r\n        if (offset >= this.selectionEnd) {\r\n            const str = this.value.substring(this.selectionEnd, offset);\r\n            return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);\r\n        }\r\n        const str1 = this.value.substring(this.selectionStart, offset);\r\n        if (str1.indexOf(String.fromCharCode(8230)) === -1) {\r\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);\r\n        }\r\n        const str2 = this.value.substring(offset, this.selectionEnd);\r\n        return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);\r\n    }\r\n    _finishDeduceEditorPosition(anchor, deltaText, signum) {\r\n        let lineFeedCnt = 0;\r\n        let lastLineFeedIndex = -1;\r\n        while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\r\n            lineFeedCnt++;\r\n        }\r\n        return [anchor, signum * deltaText.length, lineFeedCnt];\r\n    }\r\n    static selectedText(text) {\r\n        return new TextAreaState(text, 0, text.length, null, null);\r\n    }\r\n    static deduceInput(previousState, currentState, couldBeEmojiInput) {\r\n        if (!previousState) {\r\n            // This is the EMPTY state\r\n            return {\r\n                text: '',\r\n                replaceCharCnt: 0\r\n            };\r\n        }\r\n        if (_debugComposition) {\r\n            console.log('------------------------deduceInput');\r\n            console.log('PREVIOUS STATE: ' + previousState.toString());\r\n            console.log('CURRENT STATE: ' + currentState.toString());\r\n        }\r\n        let previousValue = previousState.value;\r\n        let previousSelectionStart = previousState.selectionStart;\r\n        let previousSelectionEnd = previousState.selectionEnd;\r\n        let currentValue = currentState.value;\r\n        let currentSelectionStart = currentState.selectionStart;\r\n        let currentSelectionEnd = currentState.selectionEnd;\r\n        // Strip the previous suffix from the value (without interfering with the current selection)\r\n        const previousSuffix = previousValue.substring(previousSelectionEnd);\r\n        const currentSuffix = currentValue.substring(currentSelectionEnd);\r\n        const suffixLength = strings.commonSuffixLength(previousSuffix, currentSuffix);\r\n        currentValue = currentValue.substring(0, currentValue.length - suffixLength);\r\n        previousValue = previousValue.substring(0, previousValue.length - suffixLength);\r\n        const previousPrefix = previousValue.substring(0, previousSelectionStart);\r\n        const currentPrefix = currentValue.substring(0, currentSelectionStart);\r\n        const prefixLength = strings.commonPrefixLength(previousPrefix, currentPrefix);\r\n        currentValue = currentValue.substring(prefixLength);\r\n        previousValue = previousValue.substring(prefixLength);\r\n        currentSelectionStart -= prefixLength;\r\n        previousSelectionStart -= prefixLength;\r\n        currentSelectionEnd -= prefixLength;\r\n        previousSelectionEnd -= prefixLength;\r\n        if (_debugComposition) {\r\n            console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);\r\n            console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);\r\n        }\r\n        if (couldBeEmojiInput && currentSelectionStart === currentSelectionEnd && previousValue.length > 0) {\r\n            // on OSX, emojis from the emoji picker are inserted at random locations\r\n            // the only hints we can use is that the selection is immediately after the inserted emoji\r\n            // and that none of the old text has been deleted\r\n            let potentialEmojiInput = null;\r\n            if (currentSelectionStart === currentValue.length) {\r\n                // emoji potentially inserted \"somewhere\" after the previous selection => it should appear at the end of `currentValue`\r\n                if (currentValue.startsWith(previousValue)) {\r\n                    // only if all of the old text is accounted for\r\n                    potentialEmojiInput = currentValue.substring(previousValue.length);\r\n                }\r\n            }\r\n            else {\r\n                // emoji potentially inserted \"somewhere\" before the previous selection => it should appear at the start of `currentValue`\r\n                if (currentValue.endsWith(previousValue)) {\r\n                    // only if all of the old text is accounted for\r\n                    potentialEmojiInput = currentValue.substring(0, currentValue.length - previousValue.length);\r\n                }\r\n            }\r\n            if (potentialEmojiInput !== null && potentialEmojiInput.length > 0) {\r\n                // now we check that this is indeed an emoji\r\n                // emojis can grow quite long, so a length check is of no help\r\n                // e.g. 1F3F4 E0067 E0062 E0065 E006E E0067 E007F  ; fully-qualified     # 🏴󠁧󠁢󠁥󠁮󠁧󠁿 England\r\n                // Oftentimes, emojis use Variation Selector-16 (U+FE0F), so that is a good hint\r\n                // http://emojipedia.org/variation-selector-16/\r\n                // > An invisible codepoint which specifies that the preceding character\r\n                // > should be displayed with emoji presentation. Only required if the\r\n                // > preceding character defaults to text presentation.\r\n                if (/\\uFE0F/.test(potentialEmojiInput) || strings.containsEmoji(potentialEmojiInput)) {\r\n                    return {\r\n                        text: potentialEmojiInput,\r\n                        replaceCharCnt: 0\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        if (currentSelectionStart === currentSelectionEnd) {\r\n            // composition accept case (noticed in FF + Japanese)\r\n            // [blahblah] => blahblah|\r\n            if (previousValue === currentValue\r\n                && previousSelectionStart === 0\r\n                && previousSelectionEnd === previousValue.length\r\n                && currentSelectionStart === currentValue.length\r\n                && currentValue.indexOf('\\n') === -1) {\r\n                if (strings.containsFullWidthCharacter(currentValue)) {\r\n                    return {\r\n                        text: '',\r\n                        replaceCharCnt: 0\r\n                    };\r\n                }\r\n            }\r\n            // no current selection\r\n            const replacePreviousCharacters = (previousPrefix.length - prefixLength);\r\n            if (_debugComposition) {\r\n                console.log('REMOVE PREVIOUS: ' + (previousPrefix.length - prefixLength) + ' chars');\r\n            }\r\n            return {\r\n                text: currentValue,\r\n                replaceCharCnt: replacePreviousCharacters\r\n            };\r\n        }\r\n        // there is a current selection => composition case\r\n        const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\r\n        return {\r\n            text: currentValue,\r\n            replaceCharCnt: replacePreviousCharacters\r\n        };\r\n    }\r\n}\r\nTextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);\r\nexport class PagedScreenReaderStrategy {\r\n    static _getPageOfLine(lineNumber, linesPerPage) {\r\n        return Math.floor((lineNumber - 1) / linesPerPage);\r\n    }\r\n    static _getRangeForPage(page, linesPerPage) {\r\n        const offset = page * linesPerPage;\r\n        const startLineNumber = offset + 1;\r\n        const endLineNumber = offset + linesPerPage;\r\n        return new Range(startLineNumber, 1, endLineNumber + 1, 1);\r\n    }\r\n    static fromEditorSelection(previousState, model, selection, linesPerPage, trimLongText) {\r\n        const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\r\n        const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\r\n        const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\r\n        const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\r\n        const pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\r\n        let pretext = model.getValueInRange(pretextRange, 1 /* LF */);\r\n        const lastLine = model.getLineCount();\r\n        const lastLineMaxColumn = model.getLineMaxColumn(lastLine);\r\n        const posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\r\n        let posttext = model.getValueInRange(posttextRange, 1 /* LF */);\r\n        let text;\r\n        if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\r\n            // take full selection\r\n            text = model.getValueInRange(selection, 1 /* LF */);\r\n        }\r\n        else {\r\n            const selectionRange1 = selectionStartPageRange.intersectRanges(selection);\r\n            const selectionRange2 = selectionEndPageRange.intersectRanges(selection);\r\n            text = (model.getValueInRange(selectionRange1, 1 /* LF */)\r\n                + String.fromCharCode(8230)\r\n                + model.getValueInRange(selectionRange2, 1 /* LF */));\r\n        }\r\n        // Chromium handles very poorly text even of a few thousand chars\r\n        // Cut text to avoid stalling the entire UI\r\n        if (trimLongText) {\r\n            const LIMIT_CHARS = 500;\r\n            if (pretext.length > LIMIT_CHARS) {\r\n                pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);\r\n            }\r\n            if (posttext.length > LIMIT_CHARS) {\r\n                posttext = posttext.substring(0, LIMIT_CHARS);\r\n            }\r\n            if (text.length > 2 * LIMIT_CHARS) {\r\n                text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\r\n            }\r\n        }\r\n        return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}