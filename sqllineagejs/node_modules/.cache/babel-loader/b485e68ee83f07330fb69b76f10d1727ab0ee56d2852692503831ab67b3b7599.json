{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { RunOnceScheduler, TimeoutTimer } from '../../../base/common/async.js';\nimport { dispose, DisposableStore } from '../../../base/common/lifecycle.js';\nimport { ReplaceCommand, ReplaceCommandThatPreservesSelection } from '../../common/commands/replaceCommand.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { SearchParams } from '../../common/model/textModelSearch.js';\nimport { FindDecorations } from './findDecorations.js';\nimport { ReplaceAllCommand } from './replaceAllCommand.js';\nimport { ReplacePattern, parseReplaceString } from './replacePattern.js';\nimport { RawContextKey } from '../../../platform/contextkey/common/contextkey.js';\nimport { findFirstInSorted } from '../../../base/common/arrays.js';\nexport const CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey('findWidgetVisible', false);\n// Keep ContextKey use of 'Focussed' to not break when clauses\nexport const CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey('findInputFocussed', false);\nexport const CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey('replaceInputFocussed', false);\nexport const ToggleCaseSensitiveKeybinding = {\n  primary: 512 /* Alt */ | 33 /* KEY_C */,\n  mac: {\n    primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 33 /* KEY_C */\n  }\n};\n\nexport const ToggleWholeWordKeybinding = {\n  primary: 512 /* Alt */ | 53 /* KEY_W */,\n  mac: {\n    primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 53 /* KEY_W */\n  }\n};\n\nexport const ToggleRegexKeybinding = {\n  primary: 512 /* Alt */ | 48 /* KEY_R */,\n  mac: {\n    primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 48 /* KEY_R */\n  }\n};\n\nexport const ToggleSearchScopeKeybinding = {\n  primary: 512 /* Alt */ | 42 /* KEY_L */,\n  mac: {\n    primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 42 /* KEY_L */\n  }\n};\n\nexport const TogglePreserveCaseKeybinding = {\n  primary: 512 /* Alt */ | 46 /* KEY_P */,\n  mac: {\n    primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 46 /* KEY_P */\n  }\n};\n\nexport const FIND_IDS = {\n  StartFindAction: 'actions.find',\n  StartFindWithSelection: 'actions.findWithSelection',\n  NextMatchFindAction: 'editor.action.nextMatchFindAction',\n  PreviousMatchFindAction: 'editor.action.previousMatchFindAction',\n  NextSelectionMatchFindAction: 'editor.action.nextSelectionMatchFindAction',\n  PreviousSelectionMatchFindAction: 'editor.action.previousSelectionMatchFindAction',\n  StartFindReplaceAction: 'editor.action.startFindReplaceAction',\n  CloseFindWidgetCommand: 'closeFindWidget',\n  ToggleCaseSensitiveCommand: 'toggleFindCaseSensitive',\n  ToggleWholeWordCommand: 'toggleFindWholeWord',\n  ToggleRegexCommand: 'toggleFindRegex',\n  ToggleSearchScopeCommand: 'toggleFindInSelection',\n  TogglePreserveCaseCommand: 'togglePreserveCase',\n  ReplaceOneAction: 'editor.action.replaceOne',\n  ReplaceAllAction: 'editor.action.replaceAll',\n  SelectAllMatchesAction: 'editor.action.selectAllMatches'\n};\nexport const MATCHES_LIMIT = 19999;\nconst RESEARCH_DELAY = 240;\nexport class FindModelBoundToEditorModel {\n  constructor(editor, state) {\n    this._toDispose = new DisposableStore();\n    this._editor = editor;\n    this._state = state;\n    this._isDisposed = false;\n    this._startSearchingTimer = new TimeoutTimer();\n    this._decorations = new FindDecorations(editor);\n    this._toDispose.add(this._decorations);\n    this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);\n    this._toDispose.add(this._updateDecorationsScheduler);\n    this._toDispose.add(this._editor.onDidChangeCursorPosition(e => {\n      if (e.reason === 3 /* Explicit */ || e.reason === 5 /* Undo */ || e.reason === 6 /* Redo */) {\n        this._decorations.setStartPosition(this._editor.getPosition());\n      }\n    }));\n    this._ignoreModelContentChanged = false;\n    this._toDispose.add(this._editor.onDidChangeModelContent(e => {\n      if (this._ignoreModelContentChanged) {\n        return;\n      }\n      if (e.isFlush) {\n        // a model.setValue() was called\n        this._decorations.reset();\n      }\n      this._decorations.setStartPosition(this._editor.getPosition());\n      this._updateDecorationsScheduler.schedule();\n    }));\n    this._toDispose.add(this._state.onFindReplaceStateChange(e => this._onStateChanged(e)));\n    this.research(false, this._state.searchScope);\n  }\n  dispose() {\n    this._isDisposed = true;\n    dispose(this._startSearchingTimer);\n    this._toDispose.dispose();\n  }\n  _onStateChanged(e) {\n    if (this._isDisposed) {\n      // The find model is disposed during a find state changed event\n      return;\n    }\n    if (!this._editor.hasModel()) {\n      // The find model will be disposed momentarily\n      return;\n    }\n    if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {\n      let model = this._editor.getModel();\n      if (model.isTooLargeForSyncing()) {\n        this._startSearchingTimer.cancel();\n        this._startSearchingTimer.setIfNotSet(() => {\n          if (e.searchScope) {\n            this.research(e.moveCursor, this._state.searchScope);\n          } else {\n            this.research(e.moveCursor);\n          }\n        }, RESEARCH_DELAY);\n      } else {\n        if (e.searchScope) {\n          this.research(e.moveCursor, this._state.searchScope);\n        } else {\n          this.research(e.moveCursor);\n        }\n      }\n    }\n  }\n  static _getSearchRange(model, findScope) {\n    // If we have set now or before a find scope, use it for computing the search range\n    if (findScope) {\n      return findScope;\n    }\n    return model.getFullModelRange();\n  }\n  research(moveCursor, newFindScope) {\n    let findScopes = null;\n    if (typeof newFindScope !== 'undefined') {\n      if (newFindScope !== null) {\n        if (!Array.isArray(newFindScope)) {\n          findScopes = [newFindScope];\n        } else {\n          findScopes = newFindScope;\n        }\n      }\n    } else {\n      findScopes = this._decorations.getFindScopes();\n    }\n    if (findScopes !== null) {\n      findScopes = findScopes.map(findScope => {\n        if (findScope.startLineNumber !== findScope.endLineNumber) {\n          let endLineNumber = findScope.endLineNumber;\n          if (findScope.endColumn === 1) {\n            endLineNumber = endLineNumber - 1;\n          }\n          return new Range(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));\n        }\n        return findScope;\n      });\n    }\n    let findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);\n    this._decorations.set(findMatches, findScopes);\n    const editorSelection = this._editor.getSelection();\n    let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);\n    if (currentMatchesPosition === 0 && findMatches.length > 0) {\n      // current selection is not on top of a match\n      // try to find its nearest result from the top of the document\n      const matchAfterSelection = findFirstInSorted(findMatches.map(match => match.range), range => Range.compareRangesUsingStarts(range, editorSelection) >= 0);\n      currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 /** match position is one based */ : currentMatchesPosition;\n    }\n    this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), undefined);\n    if (moveCursor && this._editor.getOption(31 /* find */).cursorMoveOnType) {\n      this._moveToNextMatch(this._decorations.getStartPosition());\n    }\n  }\n  _hasMatches() {\n    return this._state.matchesCount > 0;\n  }\n  _cannotFind() {\n    if (!this._hasMatches()) {\n      let findScope = this._decorations.getFindScope();\n      if (findScope) {\n        // Reveal the selection so user is reminded that 'selection find' is on.\n        this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0 /* Smooth */);\n      }\n\n      return true;\n    }\n    return false;\n  }\n  _setCurrentFindMatch(match) {\n    let matchesPosition = this._decorations.setCurrentFindMatch(match);\n    this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);\n    this._editor.setSelection(match);\n    this._editor.revealRangeInCenterIfOutsideViewport(match, 0 /* Smooth */);\n  }\n\n  _prevSearchPosition(before) {\n    let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0 || this._state.searchString.indexOf('$') >= 0);\n    let {\n      lineNumber,\n      column\n    } = before;\n    let model = this._editor.getModel();\n    if (isUsingLineStops || column === 1) {\n      if (lineNumber === 1) {\n        lineNumber = model.getLineCount();\n      } else {\n        lineNumber--;\n      }\n      column = model.getLineMaxColumn(lineNumber);\n    } else {\n      column--;\n    }\n    return new Position(lineNumber, column);\n  }\n  _moveToPrevMatch(before) {\n    let isRecursed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!this._state.canNavigateBack()) {\n      // we are beyond the first matched find result\n      // instead of doing nothing, we should refocus the first item\n      const nextMatchRange = this._decorations.matchAfterPosition(before);\n      if (nextMatchRange) {\n        this._setCurrentFindMatch(nextMatchRange);\n      }\n      return;\n    }\n    if (this._decorations.getCount() < MATCHES_LIMIT) {\n      let prevMatchRange = this._decorations.matchBeforePosition(before);\n      if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {\n        before = this._prevSearchPosition(before);\n        prevMatchRange = this._decorations.matchBeforePosition(before);\n      }\n      if (prevMatchRange) {\n        this._setCurrentFindMatch(prevMatchRange);\n      }\n      return;\n    }\n    if (this._cannotFind()) {\n      return;\n    }\n    let findScope = this._decorations.getFindScope();\n    let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n    // ...(----)...|...\n    if (searchRange.getEndPosition().isBefore(before)) {\n      before = searchRange.getEndPosition();\n    }\n    // ...|...(----)...\n    if (before.isBefore(searchRange.getStartPosition())) {\n      before = searchRange.getEndPosition();\n    }\n    let {\n      lineNumber,\n      column\n    } = before;\n    let model = this._editor.getModel();\n    let position = new Position(lineNumber, column);\n    let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(110 /* wordSeparators */) : null, false);\n    if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {\n      // Looks like we're stuck at this position, unacceptable!\n      position = this._prevSearchPosition(position);\n      prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(110 /* wordSeparators */) : null, false);\n    }\n    if (!prevMatch) {\n      // there is precisely one match and selection is on top of it\n      return;\n    }\n    if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {\n      return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);\n    }\n    this._setCurrentFindMatch(prevMatch.range);\n  }\n  moveToPrevMatch() {\n    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());\n  }\n  _nextSearchPosition(after) {\n    let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0 || this._state.searchString.indexOf('$') >= 0);\n    let {\n      lineNumber,\n      column\n    } = after;\n    let model = this._editor.getModel();\n    if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {\n      if (lineNumber === model.getLineCount()) {\n        lineNumber = 1;\n      } else {\n        lineNumber++;\n      }\n      column = 1;\n    } else {\n      column++;\n    }\n    return new Position(lineNumber, column);\n  }\n  _moveToNextMatch(after) {\n    if (!this._state.canNavigateForward()) {\n      // we are beyond the last matched find result\n      // instead of doing nothing, we should refocus the last item\n      const prevMatchRange = this._decorations.matchBeforePosition(after);\n      if (prevMatchRange) {\n        this._setCurrentFindMatch(prevMatchRange);\n      }\n      return;\n    }\n    if (this._decorations.getCount() < MATCHES_LIMIT) {\n      let nextMatchRange = this._decorations.matchAfterPosition(after);\n      if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {\n        // Looks like we're stuck at this position, unacceptable!\n        after = this._nextSearchPosition(after);\n        nextMatchRange = this._decorations.matchAfterPosition(after);\n      }\n      if (nextMatchRange) {\n        this._setCurrentFindMatch(nextMatchRange);\n      }\n      return;\n    }\n    let nextMatch = this._getNextMatch(after, false, true);\n    if (nextMatch) {\n      this._setCurrentFindMatch(nextMatch.range);\n    }\n  }\n  _getNextMatch(after, captureMatches, forceMove) {\n    let isRecursed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (this._cannotFind()) {\n      return null;\n    }\n    let findScope = this._decorations.getFindScope();\n    let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\n    // ...(----)...|...\n    if (searchRange.getEndPosition().isBefore(after)) {\n      after = searchRange.getStartPosition();\n    }\n    // ...|...(----)...\n    if (after.isBefore(searchRange.getStartPosition())) {\n      after = searchRange.getStartPosition();\n    }\n    let {\n      lineNumber,\n      column\n    } = after;\n    let model = this._editor.getModel();\n    let position = new Position(lineNumber, column);\n    let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(110 /* wordSeparators */) : null, captureMatches);\n    if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {\n      // Looks like we're stuck at this position, unacceptable!\n      position = this._nextSearchPosition(position);\n      nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(110 /* wordSeparators */) : null, captureMatches);\n    }\n    if (!nextMatch) {\n      // there is precisely one match and selection is on top of it\n      return null;\n    }\n    if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {\n      return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);\n    }\n    return nextMatch;\n  }\n  moveToNextMatch() {\n    this._moveToNextMatch(this._editor.getSelection().getEndPosition());\n  }\n  _getReplacePattern() {\n    if (this._state.isRegex) {\n      return parseReplaceString(this._state.replaceString);\n    }\n    return ReplacePattern.fromStaticValue(this._state.replaceString);\n  }\n  replace() {\n    if (!this._hasMatches()) {\n      return;\n    }\n    let replacePattern = this._getReplacePattern();\n    let selection = this._editor.getSelection();\n    let nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);\n    if (nextMatch) {\n      if (selection.equalsRange(nextMatch.range)) {\n        // selection sits on a find match => replace it!\n        let replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);\n        let command = new ReplaceCommand(selection, replaceString);\n        this._executeEditorCommand('replace', command);\n        this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));\n        this.research(true);\n      } else {\n        this._decorations.setStartPosition(this._editor.getPosition());\n        this._setCurrentFindMatch(nextMatch.range);\n      }\n    }\n  }\n  _findMatches(findScopes, captureMatches, limitResultCount) {\n    const searchRanges = (findScopes || [null]).map(scope => FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));\n    return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(110 /* wordSeparators */) : null, captureMatches, limitResultCount);\n  }\n  replaceAll() {\n    if (!this._hasMatches()) {\n      return;\n    }\n    const findScopes = this._decorations.getFindScopes();\n    if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {\n      // Doing a replace on the entire file that is over ${MATCHES_LIMIT} matches\n      this._largeReplaceAll();\n    } else {\n      this._regularReplaceAll(findScopes);\n    }\n    this.research(false);\n  }\n  _largeReplaceAll() {\n    const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(110 /* wordSeparators */) : null);\n    const searchData = searchParams.parseSearchRequest();\n    if (!searchData) {\n      return;\n    }\n    let searchRegex = searchData.regex;\n    if (!searchRegex.multiline) {\n      let mod = 'mu';\n      if (searchRegex.ignoreCase) {\n        mod += 'i';\n      }\n      if (searchRegex.global) {\n        mod += 'g';\n      }\n      searchRegex = new RegExp(searchRegex.source, mod);\n    }\n    const model = this._editor.getModel();\n    const modelText = model.getValue(1 /* LF */);\n    const fullModelRange = model.getFullModelRange();\n    const replacePattern = this._getReplacePattern();\n    let resultText;\n    const preserveCase = this._state.preserveCase;\n    if (replacePattern.hasReplacementPatterns || preserveCase) {\n      resultText = modelText.replace(searchRegex, function () {\n        return replacePattern.buildReplaceString(arguments, preserveCase);\n      });\n    } else {\n      resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));\n    }\n    let command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());\n    this._executeEditorCommand('replaceAll', command);\n  }\n  _regularReplaceAll(findScopes) {\n    const replacePattern = this._getReplacePattern();\n    // Get all the ranges (even more than the highlighted ones)\n    let matches = this._findMatches(findScopes, replacePattern.hasReplacementPatterns || this._state.preserveCase, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\n    let replaceStrings = [];\n    for (let i = 0, len = matches.length; i < len; i++) {\n      replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);\n    }\n    let command = new ReplaceAllCommand(this._editor.getSelection(), matches.map(m => m.range), replaceStrings);\n    this._executeEditorCommand('replaceAll', command);\n  }\n  selectAllMatches() {\n    if (!this._hasMatches()) {\n      return;\n    }\n    let findScopes = this._decorations.getFindScopes();\n    // Get all the ranges (even more than the highlighted ones)\n    let matches = this._findMatches(findScopes, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\n    let selections = matches.map(m => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));\n    // If one of the ranges is the editor selection, then maintain it as primary\n    let editorSelection = this._editor.getSelection();\n    for (let i = 0, len = selections.length; i < len; i++) {\n      let sel = selections[i];\n      if (sel.equalsRange(editorSelection)) {\n        selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));\n        break;\n      }\n    }\n    this._editor.setSelections(selections);\n  }\n  _executeEditorCommand(source, command) {\n    try {\n      this._ignoreModelContentChanged = true;\n      this._editor.pushUndoStop();\n      this._editor.executeCommand(source, command);\n      this._editor.pushUndoStop();\n    } finally {\n      this._ignoreModelContentChanged = false;\n    }\n  }\n}","map":{"version":3,"names":["RunOnceScheduler","TimeoutTimer","dispose","DisposableStore","ReplaceCommand","ReplaceCommandThatPreservesSelection","Position","Range","Selection","SearchParams","FindDecorations","ReplaceAllCommand","ReplacePattern","parseReplaceString","RawContextKey","findFirstInSorted","CONTEXT_FIND_WIDGET_VISIBLE","CONTEXT_FIND_INPUT_FOCUSED","CONTEXT_REPLACE_INPUT_FOCUSED","ToggleCaseSensitiveKeybinding","primary","mac","ToggleWholeWordKeybinding","ToggleRegexKeybinding","ToggleSearchScopeKeybinding","TogglePreserveCaseKeybinding","FIND_IDS","StartFindAction","StartFindWithSelection","NextMatchFindAction","PreviousMatchFindAction","NextSelectionMatchFindAction","PreviousSelectionMatchFindAction","StartFindReplaceAction","CloseFindWidgetCommand","ToggleCaseSensitiveCommand","ToggleWholeWordCommand","ToggleRegexCommand","ToggleSearchScopeCommand","TogglePreserveCaseCommand","ReplaceOneAction","ReplaceAllAction","SelectAllMatchesAction","MATCHES_LIMIT","RESEARCH_DELAY","FindModelBoundToEditorModel","constructor","editor","state","_toDispose","_editor","_state","_isDisposed","_startSearchingTimer","_decorations","add","_updateDecorationsScheduler","research","onDidChangeCursorPosition","e","reason","setStartPosition","getPosition","_ignoreModelContentChanged","onDidChangeModelContent","isFlush","reset","schedule","onFindReplaceStateChange","_onStateChanged","searchScope","hasModel","searchString","isReplaceRevealed","isRegex","wholeWord","matchCase","model","getModel","isTooLargeForSyncing","cancel","setIfNotSet","moveCursor","_getSearchRange","findScope","getFullModelRange","newFindScope","findScopes","Array","isArray","getFindScopes","map","startLineNumber","endLineNumber","endColumn","getLineMaxColumn","findMatches","_findMatches","set","editorSelection","getSelection","currentMatchesPosition","getCurrentMatchesPosition","length","matchAfterSelection","match","range","compareRangesUsingStarts","changeMatchInfo","getCount","undefined","getOption","cursorMoveOnType","_moveToNextMatch","getStartPosition","_hasMatches","matchesCount","_cannotFind","getFindScope","revealRangeInCenterIfOutsideViewport","_setCurrentFindMatch","matchesPosition","setCurrentFindMatch","setSelection","_prevSearchPosition","before","isUsingLineStops","indexOf","lineNumber","column","getLineCount","_moveToPrevMatch","isRecursed","arguments","canNavigateBack","nextMatchRange","matchAfterPosition","prevMatchRange","matchBeforePosition","isEmpty","equals","searchRange","getEndPosition","isBefore","position","prevMatch","findPreviousMatch","containsRange","moveToPrevMatch","_nextSearchPosition","after","canNavigateForward","nextMatch","_getNextMatch","captureMatches","forceMove","findNextMatch","moveToNextMatch","_getReplacePattern","replaceString","fromStaticValue","replace","replacePattern","selection","equalsRange","buildReplaceString","matches","preserveCase","command","_executeEditorCommand","startColumn","limitResultCount","searchRanges","scope","replaceAll","_largeReplaceAll","_regularReplaceAll","searchParams","searchData","parseSearchRequest","searchRegex","regex","multiline","mod","ignoreCase","global","RegExp","source","modelText","getValue","fullModelRange","resultText","hasReplacementPatterns","replaceStrings","i","len","m","selectAllMatches","selections","sel","concat","slice","setSelections","pushUndoStop","executeCommand"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/find/findModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { RunOnceScheduler, TimeoutTimer } from '../../../base/common/async.js';\r\nimport { dispose, DisposableStore } from '../../../base/common/lifecycle.js';\r\nimport { ReplaceCommand, ReplaceCommandThatPreservesSelection } from '../../common/commands/replaceCommand.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Range } from '../../common/core/range.js';\r\nimport { Selection } from '../../common/core/selection.js';\r\nimport { SearchParams } from '../../common/model/textModelSearch.js';\r\nimport { FindDecorations } from './findDecorations.js';\r\nimport { ReplaceAllCommand } from './replaceAllCommand.js';\r\nimport { ReplacePattern, parseReplaceString } from './replacePattern.js';\r\nimport { RawContextKey } from '../../../platform/contextkey/common/contextkey.js';\r\nimport { findFirstInSorted } from '../../../base/common/arrays.js';\r\nexport const CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey('findWidgetVisible', false);\r\n// Keep ContextKey use of 'Focussed' to not break when clauses\r\nexport const CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey('findInputFocussed', false);\r\nexport const CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey('replaceInputFocussed', false);\r\nexport const ToggleCaseSensitiveKeybinding = {\r\n    primary: 512 /* Alt */ | 33 /* KEY_C */,\r\n    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 33 /* KEY_C */ }\r\n};\r\nexport const ToggleWholeWordKeybinding = {\r\n    primary: 512 /* Alt */ | 53 /* KEY_W */,\r\n    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 53 /* KEY_W */ }\r\n};\r\nexport const ToggleRegexKeybinding = {\r\n    primary: 512 /* Alt */ | 48 /* KEY_R */,\r\n    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 48 /* KEY_R */ }\r\n};\r\nexport const ToggleSearchScopeKeybinding = {\r\n    primary: 512 /* Alt */ | 42 /* KEY_L */,\r\n    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 42 /* KEY_L */ }\r\n};\r\nexport const TogglePreserveCaseKeybinding = {\r\n    primary: 512 /* Alt */ | 46 /* KEY_P */,\r\n    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 46 /* KEY_P */ }\r\n};\r\nexport const FIND_IDS = {\r\n    StartFindAction: 'actions.find',\r\n    StartFindWithSelection: 'actions.findWithSelection',\r\n    NextMatchFindAction: 'editor.action.nextMatchFindAction',\r\n    PreviousMatchFindAction: 'editor.action.previousMatchFindAction',\r\n    NextSelectionMatchFindAction: 'editor.action.nextSelectionMatchFindAction',\r\n    PreviousSelectionMatchFindAction: 'editor.action.previousSelectionMatchFindAction',\r\n    StartFindReplaceAction: 'editor.action.startFindReplaceAction',\r\n    CloseFindWidgetCommand: 'closeFindWidget',\r\n    ToggleCaseSensitiveCommand: 'toggleFindCaseSensitive',\r\n    ToggleWholeWordCommand: 'toggleFindWholeWord',\r\n    ToggleRegexCommand: 'toggleFindRegex',\r\n    ToggleSearchScopeCommand: 'toggleFindInSelection',\r\n    TogglePreserveCaseCommand: 'togglePreserveCase',\r\n    ReplaceOneAction: 'editor.action.replaceOne',\r\n    ReplaceAllAction: 'editor.action.replaceAll',\r\n    SelectAllMatchesAction: 'editor.action.selectAllMatches'\r\n};\r\nexport const MATCHES_LIMIT = 19999;\r\nconst RESEARCH_DELAY = 240;\r\nexport class FindModelBoundToEditorModel {\r\n    constructor(editor, state) {\r\n        this._toDispose = new DisposableStore();\r\n        this._editor = editor;\r\n        this._state = state;\r\n        this._isDisposed = false;\r\n        this._startSearchingTimer = new TimeoutTimer();\r\n        this._decorations = new FindDecorations(editor);\r\n        this._toDispose.add(this._decorations);\r\n        this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);\r\n        this._toDispose.add(this._updateDecorationsScheduler);\r\n        this._toDispose.add(this._editor.onDidChangeCursorPosition((e) => {\r\n            if (e.reason === 3 /* Explicit */\r\n                || e.reason === 5 /* Undo */\r\n                || e.reason === 6 /* Redo */) {\r\n                this._decorations.setStartPosition(this._editor.getPosition());\r\n            }\r\n        }));\r\n        this._ignoreModelContentChanged = false;\r\n        this._toDispose.add(this._editor.onDidChangeModelContent((e) => {\r\n            if (this._ignoreModelContentChanged) {\r\n                return;\r\n            }\r\n            if (e.isFlush) {\r\n                // a model.setValue() was called\r\n                this._decorations.reset();\r\n            }\r\n            this._decorations.setStartPosition(this._editor.getPosition());\r\n            this._updateDecorationsScheduler.schedule();\r\n        }));\r\n        this._toDispose.add(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));\r\n        this.research(false, this._state.searchScope);\r\n    }\r\n    dispose() {\r\n        this._isDisposed = true;\r\n        dispose(this._startSearchingTimer);\r\n        this._toDispose.dispose();\r\n    }\r\n    _onStateChanged(e) {\r\n        if (this._isDisposed) {\r\n            // The find model is disposed during a find state changed event\r\n            return;\r\n        }\r\n        if (!this._editor.hasModel()) {\r\n            // The find model will be disposed momentarily\r\n            return;\r\n        }\r\n        if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {\r\n            let model = this._editor.getModel();\r\n            if (model.isTooLargeForSyncing()) {\r\n                this._startSearchingTimer.cancel();\r\n                this._startSearchingTimer.setIfNotSet(() => {\r\n                    if (e.searchScope) {\r\n                        this.research(e.moveCursor, this._state.searchScope);\r\n                    }\r\n                    else {\r\n                        this.research(e.moveCursor);\r\n                    }\r\n                }, RESEARCH_DELAY);\r\n            }\r\n            else {\r\n                if (e.searchScope) {\r\n                    this.research(e.moveCursor, this._state.searchScope);\r\n                }\r\n                else {\r\n                    this.research(e.moveCursor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static _getSearchRange(model, findScope) {\r\n        // If we have set now or before a find scope, use it for computing the search range\r\n        if (findScope) {\r\n            return findScope;\r\n        }\r\n        return model.getFullModelRange();\r\n    }\r\n    research(moveCursor, newFindScope) {\r\n        let findScopes = null;\r\n        if (typeof newFindScope !== 'undefined') {\r\n            if (newFindScope !== null) {\r\n                if (!Array.isArray(newFindScope)) {\r\n                    findScopes = [newFindScope];\r\n                }\r\n                else {\r\n                    findScopes = newFindScope;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            findScopes = this._decorations.getFindScopes();\r\n        }\r\n        if (findScopes !== null) {\r\n            findScopes = findScopes.map(findScope => {\r\n                if (findScope.startLineNumber !== findScope.endLineNumber) {\r\n                    let endLineNumber = findScope.endLineNumber;\r\n                    if (findScope.endColumn === 1) {\r\n                        endLineNumber = endLineNumber - 1;\r\n                    }\r\n                    return new Range(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));\r\n                }\r\n                return findScope;\r\n            });\r\n        }\r\n        let findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);\r\n        this._decorations.set(findMatches, findScopes);\r\n        const editorSelection = this._editor.getSelection();\r\n        let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);\r\n        if (currentMatchesPosition === 0 && findMatches.length > 0) {\r\n            // current selection is not on top of a match\r\n            // try to find its nearest result from the top of the document\r\n            const matchAfterSelection = findFirstInSorted(findMatches.map(match => match.range), range => Range.compareRangesUsingStarts(range, editorSelection) >= 0);\r\n            currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 /** match position is one based */ : currentMatchesPosition;\r\n        }\r\n        this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), undefined);\r\n        if (moveCursor && this._editor.getOption(31 /* find */).cursorMoveOnType) {\r\n            this._moveToNextMatch(this._decorations.getStartPosition());\r\n        }\r\n    }\r\n    _hasMatches() {\r\n        return (this._state.matchesCount > 0);\r\n    }\r\n    _cannotFind() {\r\n        if (!this._hasMatches()) {\r\n            let findScope = this._decorations.getFindScope();\r\n            if (findScope) {\r\n                // Reveal the selection so user is reminded that 'selection find' is on.\r\n                this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0 /* Smooth */);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    _setCurrentFindMatch(match) {\r\n        let matchesPosition = this._decorations.setCurrentFindMatch(match);\r\n        this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);\r\n        this._editor.setSelection(match);\r\n        this._editor.revealRangeInCenterIfOutsideViewport(match, 0 /* Smooth */);\r\n    }\r\n    _prevSearchPosition(before) {\r\n        let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0\r\n            || this._state.searchString.indexOf('$') >= 0);\r\n        let { lineNumber, column } = before;\r\n        let model = this._editor.getModel();\r\n        if (isUsingLineStops || column === 1) {\r\n            if (lineNumber === 1) {\r\n                lineNumber = model.getLineCount();\r\n            }\r\n            else {\r\n                lineNumber--;\r\n            }\r\n            column = model.getLineMaxColumn(lineNumber);\r\n        }\r\n        else {\r\n            column--;\r\n        }\r\n        return new Position(lineNumber, column);\r\n    }\r\n    _moveToPrevMatch(before, isRecursed = false) {\r\n        if (!this._state.canNavigateBack()) {\r\n            // we are beyond the first matched find result\r\n            // instead of doing nothing, we should refocus the first item\r\n            const nextMatchRange = this._decorations.matchAfterPosition(before);\r\n            if (nextMatchRange) {\r\n                this._setCurrentFindMatch(nextMatchRange);\r\n            }\r\n            return;\r\n        }\r\n        if (this._decorations.getCount() < MATCHES_LIMIT) {\r\n            let prevMatchRange = this._decorations.matchBeforePosition(before);\r\n            if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {\r\n                before = this._prevSearchPosition(before);\r\n                prevMatchRange = this._decorations.matchBeforePosition(before);\r\n            }\r\n            if (prevMatchRange) {\r\n                this._setCurrentFindMatch(prevMatchRange);\r\n            }\r\n            return;\r\n        }\r\n        if (this._cannotFind()) {\r\n            return;\r\n        }\r\n        let findScope = this._decorations.getFindScope();\r\n        let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\r\n        // ...(----)...|...\r\n        if (searchRange.getEndPosition().isBefore(before)) {\r\n            before = searchRange.getEndPosition();\r\n        }\r\n        // ...|...(----)...\r\n        if (before.isBefore(searchRange.getStartPosition())) {\r\n            before = searchRange.getEndPosition();\r\n        }\r\n        let { lineNumber, column } = before;\r\n        let model = this._editor.getModel();\r\n        let position = new Position(lineNumber, column);\r\n        let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(110 /* wordSeparators */) : null, false);\r\n        if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {\r\n            // Looks like we're stuck at this position, unacceptable!\r\n            position = this._prevSearchPosition(position);\r\n            prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(110 /* wordSeparators */) : null, false);\r\n        }\r\n        if (!prevMatch) {\r\n            // there is precisely one match and selection is on top of it\r\n            return;\r\n        }\r\n        if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {\r\n            return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);\r\n        }\r\n        this._setCurrentFindMatch(prevMatch.range);\r\n    }\r\n    moveToPrevMatch() {\r\n        this._moveToPrevMatch(this._editor.getSelection().getStartPosition());\r\n    }\r\n    _nextSearchPosition(after) {\r\n        let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0\r\n            || this._state.searchString.indexOf('$') >= 0);\r\n        let { lineNumber, column } = after;\r\n        let model = this._editor.getModel();\r\n        if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {\r\n            if (lineNumber === model.getLineCount()) {\r\n                lineNumber = 1;\r\n            }\r\n            else {\r\n                lineNumber++;\r\n            }\r\n            column = 1;\r\n        }\r\n        else {\r\n            column++;\r\n        }\r\n        return new Position(lineNumber, column);\r\n    }\r\n    _moveToNextMatch(after) {\r\n        if (!this._state.canNavigateForward()) {\r\n            // we are beyond the last matched find result\r\n            // instead of doing nothing, we should refocus the last item\r\n            const prevMatchRange = this._decorations.matchBeforePosition(after);\r\n            if (prevMatchRange) {\r\n                this._setCurrentFindMatch(prevMatchRange);\r\n            }\r\n            return;\r\n        }\r\n        if (this._decorations.getCount() < MATCHES_LIMIT) {\r\n            let nextMatchRange = this._decorations.matchAfterPosition(after);\r\n            if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {\r\n                // Looks like we're stuck at this position, unacceptable!\r\n                after = this._nextSearchPosition(after);\r\n                nextMatchRange = this._decorations.matchAfterPosition(after);\r\n            }\r\n            if (nextMatchRange) {\r\n                this._setCurrentFindMatch(nextMatchRange);\r\n            }\r\n            return;\r\n        }\r\n        let nextMatch = this._getNextMatch(after, false, true);\r\n        if (nextMatch) {\r\n            this._setCurrentFindMatch(nextMatch.range);\r\n        }\r\n    }\r\n    _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {\r\n        if (this._cannotFind()) {\r\n            return null;\r\n        }\r\n        let findScope = this._decorations.getFindScope();\r\n        let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);\r\n        // ...(----)...|...\r\n        if (searchRange.getEndPosition().isBefore(after)) {\r\n            after = searchRange.getStartPosition();\r\n        }\r\n        // ...|...(----)...\r\n        if (after.isBefore(searchRange.getStartPosition())) {\r\n            after = searchRange.getStartPosition();\r\n        }\r\n        let { lineNumber, column } = after;\r\n        let model = this._editor.getModel();\r\n        let position = new Position(lineNumber, column);\r\n        let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(110 /* wordSeparators */) : null, captureMatches);\r\n        if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {\r\n            // Looks like we're stuck at this position, unacceptable!\r\n            position = this._nextSearchPosition(position);\r\n            nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(110 /* wordSeparators */) : null, captureMatches);\r\n        }\r\n        if (!nextMatch) {\r\n            // there is precisely one match and selection is on top of it\r\n            return null;\r\n        }\r\n        if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {\r\n            return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);\r\n        }\r\n        return nextMatch;\r\n    }\r\n    moveToNextMatch() {\r\n        this._moveToNextMatch(this._editor.getSelection().getEndPosition());\r\n    }\r\n    _getReplacePattern() {\r\n        if (this._state.isRegex) {\r\n            return parseReplaceString(this._state.replaceString);\r\n        }\r\n        return ReplacePattern.fromStaticValue(this._state.replaceString);\r\n    }\r\n    replace() {\r\n        if (!this._hasMatches()) {\r\n            return;\r\n        }\r\n        let replacePattern = this._getReplacePattern();\r\n        let selection = this._editor.getSelection();\r\n        let nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);\r\n        if (nextMatch) {\r\n            if (selection.equalsRange(nextMatch.range)) {\r\n                // selection sits on a find match => replace it!\r\n                let replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);\r\n                let command = new ReplaceCommand(selection, replaceString);\r\n                this._executeEditorCommand('replace', command);\r\n                this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));\r\n                this.research(true);\r\n            }\r\n            else {\r\n                this._decorations.setStartPosition(this._editor.getPosition());\r\n                this._setCurrentFindMatch(nextMatch.range);\r\n            }\r\n        }\r\n    }\r\n    _findMatches(findScopes, captureMatches, limitResultCount) {\r\n        const searchRanges = (findScopes || [null]).map((scope) => FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));\r\n        return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(110 /* wordSeparators */) : null, captureMatches, limitResultCount);\r\n    }\r\n    replaceAll() {\r\n        if (!this._hasMatches()) {\r\n            return;\r\n        }\r\n        const findScopes = this._decorations.getFindScopes();\r\n        if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {\r\n            // Doing a replace on the entire file that is over ${MATCHES_LIMIT} matches\r\n            this._largeReplaceAll();\r\n        }\r\n        else {\r\n            this._regularReplaceAll(findScopes);\r\n        }\r\n        this.research(false);\r\n    }\r\n    _largeReplaceAll() {\r\n        const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(110 /* wordSeparators */) : null);\r\n        const searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return;\r\n        }\r\n        let searchRegex = searchData.regex;\r\n        if (!searchRegex.multiline) {\r\n            let mod = 'mu';\r\n            if (searchRegex.ignoreCase) {\r\n                mod += 'i';\r\n            }\r\n            if (searchRegex.global) {\r\n                mod += 'g';\r\n            }\r\n            searchRegex = new RegExp(searchRegex.source, mod);\r\n        }\r\n        const model = this._editor.getModel();\r\n        const modelText = model.getValue(1 /* LF */);\r\n        const fullModelRange = model.getFullModelRange();\r\n        const replacePattern = this._getReplacePattern();\r\n        let resultText;\r\n        const preserveCase = this._state.preserveCase;\r\n        if (replacePattern.hasReplacementPatterns || preserveCase) {\r\n            resultText = modelText.replace(searchRegex, function () {\r\n                return replacePattern.buildReplaceString(arguments, preserveCase);\r\n            });\r\n        }\r\n        else {\r\n            resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));\r\n        }\r\n        let command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());\r\n        this._executeEditorCommand('replaceAll', command);\r\n    }\r\n    _regularReplaceAll(findScopes) {\r\n        const replacePattern = this._getReplacePattern();\r\n        // Get all the ranges (even more than the highlighted ones)\r\n        let matches = this._findMatches(findScopes, replacePattern.hasReplacementPatterns || this._state.preserveCase, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\r\n        let replaceStrings = [];\r\n        for (let i = 0, len = matches.length; i < len; i++) {\r\n            replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);\r\n        }\r\n        let command = new ReplaceAllCommand(this._editor.getSelection(), matches.map(m => m.range), replaceStrings);\r\n        this._executeEditorCommand('replaceAll', command);\r\n    }\r\n    selectAllMatches() {\r\n        if (!this._hasMatches()) {\r\n            return;\r\n        }\r\n        let findScopes = this._decorations.getFindScopes();\r\n        // Get all the ranges (even more than the highlighted ones)\r\n        let matches = this._findMatches(findScopes, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\r\n        let selections = matches.map(m => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));\r\n        // If one of the ranges is the editor selection, then maintain it as primary\r\n        let editorSelection = this._editor.getSelection();\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            let sel = selections[i];\r\n            if (sel.equalsRange(editorSelection)) {\r\n                selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));\r\n                break;\r\n            }\r\n        }\r\n        this._editor.setSelections(selections);\r\n    }\r\n    _executeEditorCommand(source, command) {\r\n        try {\r\n            this._ignoreModelContentChanged = true;\r\n            this._editor.pushUndoStop();\r\n            this._editor.executeCommand(source, command);\r\n            this._editor.pushUndoStop();\r\n        }\r\n        finally {\r\n            this._ignoreModelContentChanged = false;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}