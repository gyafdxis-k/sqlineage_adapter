{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../model/wordHelper.js';\nimport { IndentAction, AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nexport class RichEditSupport {\n  constructor(languageIdentifier, previous, rawConf) {\n    this._languageIdentifier = languageIdentifier;\n    this._brackets = null;\n    this._electricCharacter = null;\n    let prev = null;\n    if (previous) {\n      prev = previous._conf;\n    }\n    this._conf = RichEditSupport._mergeConf(prev, rawConf);\n    this._onEnterSupport = this._conf.brackets || this._conf.indentationRules || this._conf.onEnterRules ? new OnEnterSupport(this._conf) : null;\n    this.comments = RichEditSupport._handleComments(this._conf);\n    this.characterPair = new CharacterPairSupport(this._conf);\n    this.wordDefinition = this._conf.wordPattern || DEFAULT_WORD_REGEXP;\n    this.indentationRules = this._conf.indentationRules;\n    if (this._conf.indentationRules) {\n      this.indentRulesSupport = new IndentRulesSupport(this._conf.indentationRules);\n    } else {\n      this.indentRulesSupport = null;\n    }\n    this.foldingRules = this._conf.folding || {};\n  }\n  get brackets() {\n    if (!this._brackets && this._conf.brackets) {\n      this._brackets = new RichEditBrackets(this._languageIdentifier, this._conf.brackets);\n    }\n    return this._brackets;\n  }\n  get electricCharacter() {\n    if (!this._electricCharacter) {\n      this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n    }\n    return this._electricCharacter;\n  }\n  onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n    if (!this._onEnterSupport) {\n      return null;\n    }\n    return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n  }\n  static _mergeConf(prev, current) {\n    return {\n      comments: prev ? current.comments || prev.comments : current.comments,\n      brackets: prev ? current.brackets || prev.brackets : current.brackets,\n      wordPattern: prev ? current.wordPattern || prev.wordPattern : current.wordPattern,\n      indentationRules: prev ? current.indentationRules || prev.indentationRules : current.indentationRules,\n      onEnterRules: prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules,\n      autoClosingPairs: prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs,\n      surroundingPairs: prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs,\n      autoCloseBefore: prev ? current.autoCloseBefore || prev.autoCloseBefore : current.autoCloseBefore,\n      folding: prev ? current.folding || prev.folding : current.folding,\n      __electricCharacterSupport: prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport\n    };\n  }\n  static _handleComments(conf) {\n    let commentRule = conf.comments;\n    if (!commentRule) {\n      return null;\n    }\n    // comment configuration\n    let comments = {};\n    if (commentRule.lineComment) {\n      comments.lineCommentToken = commentRule.lineComment;\n    }\n    if (commentRule.blockComment) {\n      let [blockStart, blockEnd] = commentRule.blockComment;\n      comments.blockCommentStartToken = blockStart;\n      comments.blockCommentEndToken = blockEnd;\n    }\n    return comments;\n  }\n}\nexport class LanguageConfigurationChangeEvent {\n  constructor(languageIdentifier) {\n    this.languageIdentifier = languageIdentifier;\n  }\n}\nexport class LanguageConfigurationRegistryImpl {\n  constructor() {\n    this._entries = new Map();\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n  }\n  register(languageIdentifier, configuration) {\n    let previous = this._getRichEditSupport(languageIdentifier.id);\n    let current = new RichEditSupport(languageIdentifier, previous, configuration);\n    this._entries.set(languageIdentifier.id, current);\n    this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));\n    return toDisposable(() => {\n      if (this._entries.get(languageIdentifier.id) === current) {\n        this._entries.set(languageIdentifier.id, previous);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));\n      }\n    });\n  }\n  _getRichEditSupport(languageId) {\n    return this._entries.get(languageId);\n  }\n  getIndentationRules(languageId) {\n    const value = this._entries.get(languageId);\n    if (!value) {\n      return null;\n    }\n    return value.indentationRules || null;\n  }\n  // begin electricCharacter\n  _getElectricCharacterSupport(languageId) {\n    let value = this._getRichEditSupport(languageId);\n    if (!value) {\n      return null;\n    }\n    return value.electricCharacter || null;\n  }\n  getElectricCharacters(languageId) {\n    let electricCharacterSupport = this._getElectricCharacterSupport(languageId);\n    if (!electricCharacterSupport) {\n      return [];\n    }\n    return electricCharacterSupport.getElectricCharacters();\n  }\n  /**\r\n   * Should return opening bracket type to match indentation with\r\n   */\n  onElectricCharacter(character, context, column) {\n    let scopedLineTokens = createScopedLineTokens(context, column - 1);\n    let electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);\n    if (!electricCharacterSupport) {\n      return null;\n    }\n    return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n  }\n  // end electricCharacter\n  getComments(languageId) {\n    let value = this._getRichEditSupport(languageId);\n    if (!value) {\n      return null;\n    }\n    return value.comments || null;\n  }\n  // begin characterPair\n  _getCharacterPairSupport(languageId) {\n    let value = this._getRichEditSupport(languageId);\n    if (!value) {\n      return null;\n    }\n    return value.characterPair || null;\n  }\n  getAutoClosingPairs(languageId) {\n    const characterPairSupport = this._getCharacterPairSupport(languageId);\n    return new AutoClosingPairs(characterPairSupport ? characterPairSupport.getAutoClosingPairs() : []);\n  }\n  getAutoCloseBeforeSet(languageId) {\n    let characterPairSupport = this._getCharacterPairSupport(languageId);\n    if (!characterPairSupport) {\n      return CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n    }\n    return characterPairSupport.getAutoCloseBeforeSet();\n  }\n  getSurroundingPairs(languageId) {\n    let characterPairSupport = this._getCharacterPairSupport(languageId);\n    if (!characterPairSupport) {\n      return [];\n    }\n    return characterPairSupport.getSurroundingPairs();\n  }\n  shouldAutoClosePair(autoClosingPair, context, column) {\n    const scopedLineTokens = createScopedLineTokens(context, column - 1);\n    return CharacterPairSupport.shouldAutoClosePair(autoClosingPair, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n  }\n  // end characterPair\n  getWordDefinition(languageId) {\n    let value = this._getRichEditSupport(languageId);\n    if (!value) {\n      return ensureValidWordDefinition(null);\n    }\n    return ensureValidWordDefinition(value.wordDefinition || null);\n  }\n  getFoldingRules(languageId) {\n    let value = this._getRichEditSupport(languageId);\n    if (!value) {\n      return {};\n    }\n    return value.foldingRules;\n  }\n  // begin Indent Rules\n  getIndentRulesSupport(languageId) {\n    let value = this._getRichEditSupport(languageId);\n    if (!value) {\n      return null;\n    }\n    return value.indentRulesSupport || null;\n  }\n  /**\r\n   * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.\r\n   * Result:\r\n   * -1: run into the boundary of embedded languages\r\n   * 0: every line above are invalid\r\n   * else: nearest preceding line of the same language\r\n   */\n  getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n    let languageID = model.getLanguageIdAtPosition(lineNumber, 0);\n    if (lineNumber > 1) {\n      let lastLineNumber;\n      let resultLineNumber = -1;\n      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n        if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {\n          return resultLineNumber;\n        }\n        let text = model.getLineContent(lastLineNumber);\n        if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n          resultLineNumber = lastLineNumber;\n          continue;\n        }\n        return lastLineNumber;\n      }\n    }\n    return -1;\n  }\n  /**\r\n   * Get inherited indentation from above lines.\r\n   * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\r\n   * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\r\n   * 3. If this line doesn't match any indent rules\r\n   *   a. check whether the line above it matches indentNextLinePattern\r\n   *   b. If not, the indent level of this line is the result\r\n   *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\r\n   * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\r\n   *\r\n   * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\r\n   */\n  getInheritIndentForLine(autoIndent, model, lineNumber) {\n    let honorIntentialIndent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (autoIndent < 4 /* Full */) {\n      return null;\n    }\n    const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n    if (!indentRulesSupport) {\n      return null;\n    }\n    if (lineNumber <= 1) {\n      return {\n        indentation: '',\n        action: null\n      };\n    }\n    const precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n    if (precedingUnIgnoredLine < 0) {\n      return null;\n    } else if (precedingUnIgnoredLine < 1) {\n      return {\n        indentation: '',\n        action: null\n      };\n    }\n    const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n    if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n      return {\n        indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n        action: IndentAction.Indent,\n        line: precedingUnIgnoredLine\n      };\n    } else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n      return {\n        indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n        action: null,\n        line: precedingUnIgnoredLine\n      };\n    } else {\n      // precedingUnIgnoredLine can not be ignored.\n      // it doesn't increase indent of following lines\n      // it doesn't increase just next line\n      // so current line is not affect by precedingUnIgnoredLine\n      // and then we should get a correct inheritted indentation from above lines\n      if (precedingUnIgnoredLine === 1) {\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n          action: null,\n          line: precedingUnIgnoredLine\n        };\n      }\n      const previousLine = precedingUnIgnoredLine - 1;\n      const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n      if (!(previousLineIndentMetadata & (1 /* INCREASE_MASK */ | 2 /* DECREASE_MASK */)) && previousLineIndentMetadata & 4 /* INDENT_NEXTLINE_MASK */) {\n        let stopLine = 0;\n        for (let i = previousLine - 1; i > 0; i--) {\n          if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n            continue;\n          }\n          stopLine = i;\n          break;\n        }\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n          action: null,\n          line: stopLine + 1\n        };\n      }\n      if (honorIntentialIndent) {\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n          action: null,\n          line: precedingUnIgnoredLine\n        };\n      } else {\n        // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n        for (let i = precedingUnIgnoredLine; i > 0; i--) {\n          const lineContent = model.getLineContent(i);\n          if (indentRulesSupport.shouldIncrease(lineContent)) {\n            return {\n              indentation: strings.getLeadingWhitespace(lineContent),\n              action: IndentAction.Indent,\n              line: i\n            };\n          } else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n            let stopLine = 0;\n            for (let j = i - 1; j > 0; j--) {\n              if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                continue;\n              }\n              stopLine = j;\n              break;\n            }\n            return {\n              indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n              action: null,\n              line: stopLine + 1\n            };\n          } else if (indentRulesSupport.shouldDecrease(lineContent)) {\n            return {\n              indentation: strings.getLeadingWhitespace(lineContent),\n              action: null,\n              line: i\n            };\n          }\n        }\n        return {\n          indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n          action: null,\n          line: 1\n        };\n      }\n    }\n  }\n  getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {\n    if (autoIndent < 4 /* Full */) {\n      return null;\n    }\n    const richEditSupport = this._getRichEditSupport(languageId);\n    if (!richEditSupport) {\n      return null;\n    }\n    const indentRulesSupport = this.getIndentRulesSupport(languageId);\n    if (!indentRulesSupport) {\n      return null;\n    }\n    const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);\n    const lineContent = virtualModel.getLineContent(lineNumber);\n    if (indent) {\n      const inheritLine = indent.line;\n      if (inheritLine !== undefined) {\n        const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n        if (enterResult) {\n          let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n          if (enterResult.removeText) {\n            indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n          }\n          if (enterResult.indentAction === IndentAction.Indent || enterResult.indentAction === IndentAction.IndentOutdent) {\n            indentation = indentConverter.shiftIndent(indentation);\n          } else if (enterResult.indentAction === IndentAction.Outdent) {\n            indentation = indentConverter.unshiftIndent(indentation);\n          }\n          if (indentRulesSupport.shouldDecrease(lineContent)) {\n            indentation = indentConverter.unshiftIndent(indentation);\n          }\n          if (enterResult.appendText) {\n            indentation += enterResult.appendText;\n          }\n          return strings.getLeadingWhitespace(indentation);\n        }\n      }\n      if (indentRulesSupport.shouldDecrease(lineContent)) {\n        if (indent.action === IndentAction.Indent) {\n          return indent.indentation;\n        } else {\n          return indentConverter.unshiftIndent(indent.indentation);\n        }\n      } else {\n        if (indent.action === IndentAction.Indent) {\n          return indentConverter.shiftIndent(indent.indentation);\n        } else {\n          return indent.indentation;\n        }\n      }\n    }\n    return null;\n  }\n  getIndentForEnter(autoIndent, model, range, indentConverter) {\n    if (autoIndent < 4 /* Full */) {\n      return null;\n    }\n    model.forceTokenization(range.startLineNumber);\n    const lineTokens = model.getLineTokens(range.startLineNumber);\n    const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n    const scopedLineText = scopedLineTokens.getLineContent();\n    let embeddedLanguage = false;\n    let beforeEnterText;\n    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n      // we are in the embeded language content\n      embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n      beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n    }\n    let afterEnterText;\n    if (range.isEmpty()) {\n      afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n      afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n    if (!indentRulesSupport) {\n      return null;\n    }\n    const beforeEnterResult = beforeEnterText;\n    const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n    const virtualModel = {\n      getLineTokens: lineNumber => {\n        return model.getLineTokens(lineNumber);\n      },\n      getLanguageIdentifier: () => {\n        return model.getLanguageIdentifier();\n      },\n      getLanguageIdAtPosition: (lineNumber, column) => {\n        return model.getLanguageIdAtPosition(lineNumber, column);\n      },\n      getLineContent: lineNumber => {\n        if (lineNumber === range.startLineNumber) {\n          return beforeEnterResult;\n        } else {\n          return model.getLineContent(lineNumber);\n        }\n      }\n    };\n    const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n    const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1);\n    if (!afterEnterAction) {\n      const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n      return {\n        beforeEnter: beforeEnter,\n        afterEnter: beforeEnter\n      };\n    }\n    let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n    if (afterEnterAction.action === IndentAction.Indent) {\n      afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n    }\n    if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n      afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n    }\n    return {\n      beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n      afterEnter: afterEnterIndent\n    };\n  }\n  /**\r\n   * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\r\n   * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\r\n   */\n  getIndentActionForType(autoIndent, model, range, ch, indentConverter) {\n    if (autoIndent < 4 /* Full */) {\n      return null;\n    }\n    const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    if (scopedLineTokens.firstCharOffset) {\n      // this line has mixed languages and indentation rules will not work\n      return null;\n    }\n    const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n    if (!indentRulesSupport) {\n      return null;\n    }\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    // selection support\n    let afterTypeText;\n    if (range.isEmpty()) {\n      afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n      afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n    // Users might change the indentation by purpose and we should honor that instead of readjusting.\n    if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n      // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n      // 1. Get inherited indent action\n      const r = this.getInheritIndentForLine(autoIndent, model, range.startLineNumber, false);\n      if (!r) {\n        return null;\n      }\n      let indentation = r.indentation;\n      if (r.action !== IndentAction.Indent) {\n        indentation = indentConverter.unshiftIndent(indentation);\n      }\n      return indentation;\n    }\n    return null;\n  }\n  getIndentMetadata(model, lineNumber) {\n    const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n    if (!indentRulesSupport) {\n      return null;\n    }\n    if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n      return null;\n    }\n    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n  }\n  // end Indent Rules\n  // begin onEnter\n  getEnterAction(autoIndent, model, range) {\n    const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    const richEditSupport = this._getRichEditSupport(scopedLineTokens.languageId);\n    if (!richEditSupport) {\n      return null;\n    }\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    // selection support\n    let afterEnterText;\n    if (range.isEmpty()) {\n      afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    } else {\n      const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n      afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    let previousLineText = '';\n    if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n      // This is not the first line and the entire line belongs to this mode\n      const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber - 1);\n      if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n        // The line above ends with text belonging to the same mode\n        previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n      }\n    }\n    const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    if (!enterResult) {\n      return null;\n    }\n    const indentAction = enterResult.indentAction;\n    let appendText = enterResult.appendText;\n    const removeText = enterResult.removeText || 0;\n    // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n    if (!appendText) {\n      if (indentAction === IndentAction.Indent || indentAction === IndentAction.IndentOutdent) {\n        appendText = '\\t';\n      } else {\n        appendText = '';\n      }\n    } else if (indentAction === IndentAction.Indent) {\n      appendText = '\\t' + appendText;\n    }\n    let indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    if (removeText) {\n      indentation = indentation.substring(0, indentation.length - removeText);\n    }\n    return {\n      indentAction: indentAction,\n      appendText: appendText,\n      removeText: removeText,\n      indentation: indentation\n    };\n  }\n  getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n      indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n  }\n  getScopedLineTokens(model, lineNumber, columnNumber) {\n    model.forceTokenization(lineNumber);\n    const lineTokens = model.getLineTokens(lineNumber);\n    const column = typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1;\n    return createScopedLineTokens(lineTokens, column);\n  }\n  // end onEnter\n  getBracketsSupport(languageId) {\n    const value = this._getRichEditSupport(languageId);\n    if (!value) {\n      return null;\n    }\n    return value.brackets || null;\n  }\n}\nexport const LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();","map":{"version":3,"names":["Emitter","toDisposable","strings","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","IndentAction","AutoClosingPairs","createScopedLineTokens","CharacterPairSupport","BracketElectricCharacterSupport","IndentRulesSupport","OnEnterSupport","RichEditBrackets","RichEditSupport","constructor","languageIdentifier","previous","rawConf","_languageIdentifier","_brackets","_electricCharacter","prev","_conf","_mergeConf","_onEnterSupport","brackets","indentationRules","onEnterRules","comments","_handleComments","characterPair","wordDefinition","wordPattern","indentRulesSupport","foldingRules","folding","electricCharacter","onEnter","autoIndent","previousLineText","beforeEnterText","afterEnterText","current","autoClosingPairs","surroundingPairs","autoCloseBefore","__electricCharacterSupport","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","LanguageConfigurationChangeEvent","LanguageConfigurationRegistryImpl","_entries","Map","_onDidChange","onDidChange","event","register","configuration","_getRichEditSupport","id","set","fire","get","languageId","getIndentationRules","value","_getElectricCharacterSupport","getElectricCharacters","electricCharacterSupport","onElectricCharacter","character","context","column","scopedLineTokens","firstCharOffset","getComments","_getCharacterPairSupport","getAutoClosingPairs","characterPairSupport","getAutoCloseBeforeSet","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED","getSurroundingPairs","shouldAutoClosePair","autoClosingPair","getWordDefinition","getFoldingRules","getIndentRulesSupport","getPrecedingValidLine","model","lineNumber","languageID","getLanguageIdAtPosition","lastLineNumber","resultLineNumber","text","getLineContent","shouldIgnore","test","getInheritIndentForLine","honorIntentialIndent","arguments","length","undefined","getLanguageIdentifier","indentation","action","precedingUnIgnoredLine","precedingUnIgnoredLineContent","shouldIncrease","shouldIndentNextLine","getLeadingWhitespace","Indent","line","shouldDecrease","previousLine","previousLineIndentMetadata","getIndentMetadata","stopLine","i","lineContent","j","getGoodIndentForLine","virtualModel","indentConverter","richEditSupport","indent","inheritLine","enterResult","removeText","substring","indentAction","IndentOutdent","shiftIndent","Outdent","unshiftIndent","appendText","getIndentForEnter","range","forceTokenization","startLineNumber","lineTokens","getLineTokens","startColumn","scopedLineText","embeddedLanguage","getLanguageId","substr","isEmpty","endScopedLineTokens","getScopedLineTokens","endLineNumber","endColumn","beforeEnterResult","beforeEnterIndent","currentLineIndent","afterEnterAction","beforeEnter","afterEnter","afterEnterIndent","getIndentActionForType","ch","beforeTypeText","afterTypeText","r","getLineCount","getEnterAction","oneLineAboveScopedLineTokens","getIndentationAtPosition","lineText","columnNumber","getLineMaxColumn","getBracketsSupport","LanguageConfigurationRegistry"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/modes/languageConfigurationRegistry.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Emitter } from '../../../base/common/event.js';\r\nimport { toDisposable } from '../../../base/common/lifecycle.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../model/wordHelper.js';\r\nimport { IndentAction, AutoClosingPairs } from './languageConfiguration.js';\r\nimport { createScopedLineTokens } from './supports.js';\r\nimport { CharacterPairSupport } from './supports/characterPair.js';\r\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\r\nimport { IndentRulesSupport } from './supports/indentRules.js';\r\nimport { OnEnterSupport } from './supports/onEnter.js';\r\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\r\nexport class RichEditSupport {\r\n    constructor(languageIdentifier, previous, rawConf) {\r\n        this._languageIdentifier = languageIdentifier;\r\n        this._brackets = null;\r\n        this._electricCharacter = null;\r\n        let prev = null;\r\n        if (previous) {\r\n            prev = previous._conf;\r\n        }\r\n        this._conf = RichEditSupport._mergeConf(prev, rawConf);\r\n        this._onEnterSupport = (this._conf.brackets || this._conf.indentationRules || this._conf.onEnterRules ? new OnEnterSupport(this._conf) : null);\r\n        this.comments = RichEditSupport._handleComments(this._conf);\r\n        this.characterPair = new CharacterPairSupport(this._conf);\r\n        this.wordDefinition = this._conf.wordPattern || DEFAULT_WORD_REGEXP;\r\n        this.indentationRules = this._conf.indentationRules;\r\n        if (this._conf.indentationRules) {\r\n            this.indentRulesSupport = new IndentRulesSupport(this._conf.indentationRules);\r\n        }\r\n        else {\r\n            this.indentRulesSupport = null;\r\n        }\r\n        this.foldingRules = this._conf.folding || {};\r\n    }\r\n    get brackets() {\r\n        if (!this._brackets && this._conf.brackets) {\r\n            this._brackets = new RichEditBrackets(this._languageIdentifier, this._conf.brackets);\r\n        }\r\n        return this._brackets;\r\n    }\r\n    get electricCharacter() {\r\n        if (!this._electricCharacter) {\r\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\r\n        }\r\n        return this._electricCharacter;\r\n    }\r\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\r\n        if (!this._onEnterSupport) {\r\n            return null;\r\n        }\r\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\r\n    }\r\n    static _mergeConf(prev, current) {\r\n        return {\r\n            comments: (prev ? current.comments || prev.comments : current.comments),\r\n            brackets: (prev ? current.brackets || prev.brackets : current.brackets),\r\n            wordPattern: (prev ? current.wordPattern || prev.wordPattern : current.wordPattern),\r\n            indentationRules: (prev ? current.indentationRules || prev.indentationRules : current.indentationRules),\r\n            onEnterRules: (prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules),\r\n            autoClosingPairs: (prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs),\r\n            surroundingPairs: (prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs),\r\n            autoCloseBefore: (prev ? current.autoCloseBefore || prev.autoCloseBefore : current.autoCloseBefore),\r\n            folding: (prev ? current.folding || prev.folding : current.folding),\r\n            __electricCharacterSupport: (prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport),\r\n        };\r\n    }\r\n    static _handleComments(conf) {\r\n        let commentRule = conf.comments;\r\n        if (!commentRule) {\r\n            return null;\r\n        }\r\n        // comment configuration\r\n        let comments = {};\r\n        if (commentRule.lineComment) {\r\n            comments.lineCommentToken = commentRule.lineComment;\r\n        }\r\n        if (commentRule.blockComment) {\r\n            let [blockStart, blockEnd] = commentRule.blockComment;\r\n            comments.blockCommentStartToken = blockStart;\r\n            comments.blockCommentEndToken = blockEnd;\r\n        }\r\n        return comments;\r\n    }\r\n}\r\nexport class LanguageConfigurationChangeEvent {\r\n    constructor(languageIdentifier) {\r\n        this.languageIdentifier = languageIdentifier;\r\n    }\r\n}\r\nexport class LanguageConfigurationRegistryImpl {\r\n    constructor() {\r\n        this._entries = new Map();\r\n        this._onDidChange = new Emitter();\r\n        this.onDidChange = this._onDidChange.event;\r\n    }\r\n    register(languageIdentifier, configuration) {\r\n        let previous = this._getRichEditSupport(languageIdentifier.id);\r\n        let current = new RichEditSupport(languageIdentifier, previous, configuration);\r\n        this._entries.set(languageIdentifier.id, current);\r\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));\r\n        return toDisposable(() => {\r\n            if (this._entries.get(languageIdentifier.id) === current) {\r\n                this._entries.set(languageIdentifier.id, previous);\r\n                this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));\r\n            }\r\n        });\r\n    }\r\n    _getRichEditSupport(languageId) {\r\n        return this._entries.get(languageId);\r\n    }\r\n    getIndentationRules(languageId) {\r\n        const value = this._entries.get(languageId);\r\n        if (!value) {\r\n            return null;\r\n        }\r\n        return value.indentationRules || null;\r\n    }\r\n    // begin electricCharacter\r\n    _getElectricCharacterSupport(languageId) {\r\n        let value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return null;\r\n        }\r\n        return value.electricCharacter || null;\r\n    }\r\n    getElectricCharacters(languageId) {\r\n        let electricCharacterSupport = this._getElectricCharacterSupport(languageId);\r\n        if (!electricCharacterSupport) {\r\n            return [];\r\n        }\r\n        return electricCharacterSupport.getElectricCharacters();\r\n    }\r\n    /**\r\n     * Should return opening bracket type to match indentation with\r\n     */\r\n    onElectricCharacter(character, context, column) {\r\n        let scopedLineTokens = createScopedLineTokens(context, column - 1);\r\n        let electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);\r\n        if (!electricCharacterSupport) {\r\n            return null;\r\n        }\r\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\r\n    }\r\n    // end electricCharacter\r\n    getComments(languageId) {\r\n        let value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return null;\r\n        }\r\n        return value.comments || null;\r\n    }\r\n    // begin characterPair\r\n    _getCharacterPairSupport(languageId) {\r\n        let value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return null;\r\n        }\r\n        return value.characterPair || null;\r\n    }\r\n    getAutoClosingPairs(languageId) {\r\n        const characterPairSupport = this._getCharacterPairSupport(languageId);\r\n        return new AutoClosingPairs(characterPairSupport ? characterPairSupport.getAutoClosingPairs() : []);\r\n    }\r\n    getAutoCloseBeforeSet(languageId) {\r\n        let characterPairSupport = this._getCharacterPairSupport(languageId);\r\n        if (!characterPairSupport) {\r\n            return CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\r\n        }\r\n        return characterPairSupport.getAutoCloseBeforeSet();\r\n    }\r\n    getSurroundingPairs(languageId) {\r\n        let characterPairSupport = this._getCharacterPairSupport(languageId);\r\n        if (!characterPairSupport) {\r\n            return [];\r\n        }\r\n        return characterPairSupport.getSurroundingPairs();\r\n    }\r\n    shouldAutoClosePair(autoClosingPair, context, column) {\r\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\r\n        return CharacterPairSupport.shouldAutoClosePair(autoClosingPair, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\r\n    }\r\n    // end characterPair\r\n    getWordDefinition(languageId) {\r\n        let value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return ensureValidWordDefinition(null);\r\n        }\r\n        return ensureValidWordDefinition(value.wordDefinition || null);\r\n    }\r\n    getFoldingRules(languageId) {\r\n        let value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return {};\r\n        }\r\n        return value.foldingRules;\r\n    }\r\n    // begin Indent Rules\r\n    getIndentRulesSupport(languageId) {\r\n        let value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return null;\r\n        }\r\n        return value.indentRulesSupport || null;\r\n    }\r\n    /**\r\n     * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.\r\n     * Result:\r\n     * -1: run into the boundary of embedded languages\r\n     * 0: every line above are invalid\r\n     * else: nearest preceding line of the same language\r\n     */\r\n    getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\r\n        let languageID = model.getLanguageIdAtPosition(lineNumber, 0);\r\n        if (lineNumber > 1) {\r\n            let lastLineNumber;\r\n            let resultLineNumber = -1;\r\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\r\n                if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {\r\n                    return resultLineNumber;\r\n                }\r\n                let text = model.getLineContent(lastLineNumber);\r\n                if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\r\n                    resultLineNumber = lastLineNumber;\r\n                    continue;\r\n                }\r\n                return lastLineNumber;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * Get inherited indentation from above lines.\r\n     * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\r\n     * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\r\n     * 3. If this line doesn't match any indent rules\r\n     *   a. check whether the line above it matches indentNextLinePattern\r\n     *   b. If not, the indent level of this line is the result\r\n     *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\r\n     * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\r\n     *\r\n     * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\r\n     */\r\n    getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true) {\r\n        if (autoIndent < 4 /* Full */) {\r\n            return null;\r\n        }\r\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\r\n        if (!indentRulesSupport) {\r\n            return null;\r\n        }\r\n        if (lineNumber <= 1) {\r\n            return {\r\n                indentation: '',\r\n                action: null\r\n            };\r\n        }\r\n        const precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\r\n        if (precedingUnIgnoredLine < 0) {\r\n            return null;\r\n        }\r\n        else if (precedingUnIgnoredLine < 1) {\r\n            return {\r\n                indentation: '',\r\n                action: null\r\n            };\r\n        }\r\n        const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\r\n        if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\r\n            return {\r\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\r\n                action: IndentAction.Indent,\r\n                line: precedingUnIgnoredLine\r\n            };\r\n        }\r\n        else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\r\n            return {\r\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\r\n                action: null,\r\n                line: precedingUnIgnoredLine\r\n            };\r\n        }\r\n        else {\r\n            // precedingUnIgnoredLine can not be ignored.\r\n            // it doesn't increase indent of following lines\r\n            // it doesn't increase just next line\r\n            // so current line is not affect by precedingUnIgnoredLine\r\n            // and then we should get a correct inheritted indentation from above lines\r\n            if (precedingUnIgnoredLine === 1) {\r\n                return {\r\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\r\n                    action: null,\r\n                    line: precedingUnIgnoredLine\r\n                };\r\n            }\r\n            const previousLine = precedingUnIgnoredLine - 1;\r\n            const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\r\n            if (!(previousLineIndentMetadata & (1 /* INCREASE_MASK */ | 2 /* DECREASE_MASK */)) &&\r\n                (previousLineIndentMetadata & 4 /* INDENT_NEXTLINE_MASK */)) {\r\n                let stopLine = 0;\r\n                for (let i = previousLine - 1; i > 0; i--) {\r\n                    if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\r\n                        continue;\r\n                    }\r\n                    stopLine = i;\r\n                    break;\r\n                }\r\n                return {\r\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\r\n                    action: null,\r\n                    line: stopLine + 1\r\n                };\r\n            }\r\n            if (honorIntentialIndent) {\r\n                return {\r\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\r\n                    action: null,\r\n                    line: precedingUnIgnoredLine\r\n                };\r\n            }\r\n            else {\r\n                // search from precedingUnIgnoredLine until we find one whose indent is not temporary\r\n                for (let i = precedingUnIgnoredLine; i > 0; i--) {\r\n                    const lineContent = model.getLineContent(i);\r\n                    if (indentRulesSupport.shouldIncrease(lineContent)) {\r\n                        return {\r\n                            indentation: strings.getLeadingWhitespace(lineContent),\r\n                            action: IndentAction.Indent,\r\n                            line: i\r\n                        };\r\n                    }\r\n                    else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\r\n                        let stopLine = 0;\r\n                        for (let j = i - 1; j > 0; j--) {\r\n                            if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\r\n                                continue;\r\n                            }\r\n                            stopLine = j;\r\n                            break;\r\n                        }\r\n                        return {\r\n                            indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\r\n                            action: null,\r\n                            line: stopLine + 1\r\n                        };\r\n                    }\r\n                    else if (indentRulesSupport.shouldDecrease(lineContent)) {\r\n                        return {\r\n                            indentation: strings.getLeadingWhitespace(lineContent),\r\n                            action: null,\r\n                            line: i\r\n                        };\r\n                    }\r\n                }\r\n                return {\r\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\r\n                    action: null,\r\n                    line: 1\r\n                };\r\n            }\r\n        }\r\n    }\r\n    getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {\r\n        if (autoIndent < 4 /* Full */) {\r\n            return null;\r\n        }\r\n        const richEditSupport = this._getRichEditSupport(languageId);\r\n        if (!richEditSupport) {\r\n            return null;\r\n        }\r\n        const indentRulesSupport = this.getIndentRulesSupport(languageId);\r\n        if (!indentRulesSupport) {\r\n            return null;\r\n        }\r\n        const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);\r\n        const lineContent = virtualModel.getLineContent(lineNumber);\r\n        if (indent) {\r\n            const inheritLine = indent.line;\r\n            if (inheritLine !== undefined) {\r\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\r\n                if (enterResult) {\r\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\r\n                    if (enterResult.removeText) {\r\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\r\n                    }\r\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\r\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\r\n                        indentation = indentConverter.shiftIndent(indentation);\r\n                    }\r\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\r\n                        indentation = indentConverter.unshiftIndent(indentation);\r\n                    }\r\n                    if (indentRulesSupport.shouldDecrease(lineContent)) {\r\n                        indentation = indentConverter.unshiftIndent(indentation);\r\n                    }\r\n                    if (enterResult.appendText) {\r\n                        indentation += enterResult.appendText;\r\n                    }\r\n                    return strings.getLeadingWhitespace(indentation);\r\n                }\r\n            }\r\n            if (indentRulesSupport.shouldDecrease(lineContent)) {\r\n                if (indent.action === IndentAction.Indent) {\r\n                    return indent.indentation;\r\n                }\r\n                else {\r\n                    return indentConverter.unshiftIndent(indent.indentation);\r\n                }\r\n            }\r\n            else {\r\n                if (indent.action === IndentAction.Indent) {\r\n                    return indentConverter.shiftIndent(indent.indentation);\r\n                }\r\n                else {\r\n                    return indent.indentation;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    getIndentForEnter(autoIndent, model, range, indentConverter) {\r\n        if (autoIndent < 4 /* Full */) {\r\n            return null;\r\n        }\r\n        model.forceTokenization(range.startLineNumber);\r\n        const lineTokens = model.getLineTokens(range.startLineNumber);\r\n        const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\r\n        const scopedLineText = scopedLineTokens.getLineContent();\r\n        let embeddedLanguage = false;\r\n        let beforeEnterText;\r\n        if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\r\n            // we are in the embeded language content\r\n            embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\r\n            beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        else {\r\n            beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\r\n        }\r\n        let afterEnterText;\r\n        if (range.isEmpty()) {\r\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        else {\r\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\r\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\r\n        if (!indentRulesSupport) {\r\n            return null;\r\n        }\r\n        const beforeEnterResult = beforeEnterText;\r\n        const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\r\n        const virtualModel = {\r\n            getLineTokens: (lineNumber) => {\r\n                return model.getLineTokens(lineNumber);\r\n            },\r\n            getLanguageIdentifier: () => {\r\n                return model.getLanguageIdentifier();\r\n            },\r\n            getLanguageIdAtPosition: (lineNumber, column) => {\r\n                return model.getLanguageIdAtPosition(lineNumber, column);\r\n            },\r\n            getLineContent: (lineNumber) => {\r\n                if (lineNumber === range.startLineNumber) {\r\n                    return beforeEnterResult;\r\n                }\r\n                else {\r\n                    return model.getLineContent(lineNumber);\r\n                }\r\n            }\r\n        };\r\n        const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\r\n        const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1);\r\n        if (!afterEnterAction) {\r\n            const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\r\n            return {\r\n                beforeEnter: beforeEnter,\r\n                afterEnter: beforeEnter\r\n            };\r\n        }\r\n        let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\r\n        if (afterEnterAction.action === IndentAction.Indent) {\r\n            afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\r\n        }\r\n        if (indentRulesSupport.shouldDecrease(afterEnterText)) {\r\n            afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\r\n        }\r\n        return {\r\n            beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\r\n            afterEnter: afterEnterIndent\r\n        };\r\n    }\r\n    /**\r\n     * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\r\n     * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\r\n     */\r\n    getIndentActionForType(autoIndent, model, range, ch, indentConverter) {\r\n        if (autoIndent < 4 /* Full */) {\r\n            return null;\r\n        }\r\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\r\n        if (scopedLineTokens.firstCharOffset) {\r\n            // this line has mixed languages and indentation rules will not work\r\n            return null;\r\n        }\r\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\r\n        if (!indentRulesSupport) {\r\n            return null;\r\n        }\r\n        const scopedLineText = scopedLineTokens.getLineContent();\r\n        const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        // selection support\r\n        let afterTypeText;\r\n        if (range.isEmpty()) {\r\n            afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        else {\r\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\r\n            afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\r\n        // Users might change the indentation by purpose and we should honor that instead of readjusting.\r\n        if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\r\n            // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\r\n            // 1. Get inherited indent action\r\n            const r = this.getInheritIndentForLine(autoIndent, model, range.startLineNumber, false);\r\n            if (!r) {\r\n                return null;\r\n            }\r\n            let indentation = r.indentation;\r\n            if (r.action !== IndentAction.Indent) {\r\n                indentation = indentConverter.unshiftIndent(indentation);\r\n            }\r\n            return indentation;\r\n        }\r\n        return null;\r\n    }\r\n    getIndentMetadata(model, lineNumber) {\r\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\r\n        if (!indentRulesSupport) {\r\n            return null;\r\n        }\r\n        if (lineNumber < 1 || lineNumber > model.getLineCount()) {\r\n            return null;\r\n        }\r\n        return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\r\n    }\r\n    // end Indent Rules\r\n    // begin onEnter\r\n    getEnterAction(autoIndent, model, range) {\r\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\r\n        const richEditSupport = this._getRichEditSupport(scopedLineTokens.languageId);\r\n        if (!richEditSupport) {\r\n            return null;\r\n        }\r\n        const scopedLineText = scopedLineTokens.getLineContent();\r\n        const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        // selection support\r\n        let afterEnterText;\r\n        if (range.isEmpty()) {\r\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        else {\r\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\r\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        let previousLineText = '';\r\n        if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\r\n            // This is not the first line and the entire line belongs to this mode\r\n            const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber - 1);\r\n            if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\r\n                // The line above ends with text belonging to the same mode\r\n                previousLineText = oneLineAboveScopedLineTokens.getLineContent();\r\n            }\r\n        }\r\n        const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\r\n        if (!enterResult) {\r\n            return null;\r\n        }\r\n        const indentAction = enterResult.indentAction;\r\n        let appendText = enterResult.appendText;\r\n        const removeText = enterResult.removeText || 0;\r\n        // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\r\n        if (!appendText) {\r\n            if ((indentAction === IndentAction.Indent) ||\r\n                (indentAction === IndentAction.IndentOutdent)) {\r\n                appendText = '\\t';\r\n            }\r\n            else {\r\n                appendText = '';\r\n            }\r\n        }\r\n        else if (indentAction === IndentAction.Indent) {\r\n            appendText = '\\t' + appendText;\r\n        }\r\n        let indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\r\n        if (removeText) {\r\n            indentation = indentation.substring(0, indentation.length - removeText);\r\n        }\r\n        return {\r\n            indentAction: indentAction,\r\n            appendText: appendText,\r\n            removeText: removeText,\r\n            indentation: indentation\r\n        };\r\n    }\r\n    getIndentationAtPosition(model, lineNumber, column) {\r\n        const lineText = model.getLineContent(lineNumber);\r\n        let indentation = strings.getLeadingWhitespace(lineText);\r\n        if (indentation.length > column - 1) {\r\n            indentation = indentation.substring(0, column - 1);\r\n        }\r\n        return indentation;\r\n    }\r\n    getScopedLineTokens(model, lineNumber, columnNumber) {\r\n        model.forceTokenization(lineNumber);\r\n        const lineTokens = model.getLineTokens(lineNumber);\r\n        const column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\r\n        return createScopedLineTokens(lineTokens, column);\r\n    }\r\n    // end onEnter\r\n    getBracketsSupport(languageId) {\r\n        const value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return null;\r\n        }\r\n        return value.brackets || null;\r\n    }\r\n}\r\nexport const LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}