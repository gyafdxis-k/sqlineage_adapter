{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { mergeSort } from '../../../base/common/arrays.js';\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { globals } from '../../../base/common/platform.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { DiffComputer } from '../diff/diffComputer.js';\nimport { MirrorTextModel as BaseMirrorModel } from '../model/mirrorTextModel.js';\nimport { ensureValidWordDefinition, getWordAtText } from '../model/wordHelper.js';\nimport { computeLinks } from '../modes/linkComputer.js';\nimport { BasicInplaceReplace } from '../modes/supports/inplaceReplaceSupport.js';\nimport { createMonacoBaseAPI } from '../standalone/standaloneBase.js';\nimport * as types from '../../../base/common/types.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\n/**\r\n * @internal\r\n */\nclass MirrorModel extends BaseMirrorModel {\n  get uri() {\n    return this._uri;\n  }\n  get version() {\n    return this._versionId;\n  }\n  get eol() {\n    return this._eol;\n  }\n  getValue() {\n    return this.getText();\n  }\n  getLinesContent() {\n    return this._lines.slice(0);\n  }\n  getLineCount() {\n    return this._lines.length;\n  }\n  getLineContent(lineNumber) {\n    return this._lines[lineNumber - 1];\n  }\n  getWordAtPosition(position, wordDefinition) {\n    let wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n    if (wordAtText) {\n      return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n    }\n    return null;\n  }\n  words(wordDefinition) {\n    const lines = this._lines;\n    const wordenize = this._wordenize.bind(this);\n    let lineNumber = 0;\n    let lineText = '';\n    let wordRangesIdx = 0;\n    let wordRanges = [];\n    return {\n      *[Symbol.iterator]() {\n        while (true) {\n          if (wordRangesIdx < wordRanges.length) {\n            const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n            wordRangesIdx += 1;\n            yield value;\n          } else {\n            if (lineNumber < lines.length) {\n              lineText = lines[lineNumber];\n              wordRanges = wordenize(lineText, wordDefinition);\n              wordRangesIdx = 0;\n              lineNumber += 1;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    };\n  }\n  getLineWords(lineNumber, wordDefinition) {\n    let content = this._lines[lineNumber - 1];\n    let ranges = this._wordenize(content, wordDefinition);\n    let words = [];\n    for (const range of ranges) {\n      words.push({\n        word: content.substring(range.start, range.end),\n        startColumn: range.start + 1,\n        endColumn: range.end + 1\n      });\n    }\n    return words;\n  }\n  _wordenize(content, wordDefinition) {\n    const result = [];\n    let match;\n    wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n    while (match = wordDefinition.exec(content)) {\n      if (match[0].length === 0) {\n        // it did match the empty string\n        break;\n      }\n      result.push({\n        start: match.index,\n        end: match.index + match[0].length\n      });\n    }\n    return result;\n  }\n  getValueInRange(range) {\n    range = this._validateRange(range);\n    if (range.startLineNumber === range.endLineNumber) {\n      return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n    }\n    let lineEnding = this._eol;\n    let startLineIndex = range.startLineNumber - 1;\n    let endLineIndex = range.endLineNumber - 1;\n    let resultLines = [];\n    resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n    for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n      resultLines.push(this._lines[i]);\n    }\n    resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n    return resultLines.join(lineEnding);\n  }\n  offsetAt(position) {\n    position = this._validatePosition(position);\n    this._ensureLineStarts();\n    return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + (position.column - 1);\n  }\n  positionAt(offset) {\n    offset = Math.floor(offset);\n    offset = Math.max(0, offset);\n    this._ensureLineStarts();\n    let out = this._lineStarts.getIndexOf(offset);\n    let lineLength = this._lines[out.index].length;\n    // Ensure we return a valid position\n    return {\n      lineNumber: 1 + out.index,\n      column: 1 + Math.min(out.remainder, lineLength)\n    };\n  }\n  _validateRange(range) {\n    const start = this._validatePosition({\n      lineNumber: range.startLineNumber,\n      column: range.startColumn\n    });\n    const end = this._validatePosition({\n      lineNumber: range.endLineNumber,\n      column: range.endColumn\n    });\n    if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {\n      return {\n        startLineNumber: start.lineNumber,\n        startColumn: start.column,\n        endLineNumber: end.lineNumber,\n        endColumn: end.column\n      };\n    }\n    return range;\n  }\n  _validatePosition(position) {\n    if (!Position.isIPosition(position)) {\n      throw new Error('bad position');\n    }\n    let {\n      lineNumber,\n      column\n    } = position;\n    let hasChanged = false;\n    if (lineNumber < 1) {\n      lineNumber = 1;\n      column = 1;\n      hasChanged = true;\n    } else if (lineNumber > this._lines.length) {\n      lineNumber = this._lines.length;\n      column = this._lines[lineNumber - 1].length + 1;\n      hasChanged = true;\n    } else {\n      let maxCharacter = this._lines[lineNumber - 1].length + 1;\n      if (column < 1) {\n        column = 1;\n        hasChanged = true;\n      } else if (column > maxCharacter) {\n        column = maxCharacter;\n        hasChanged = true;\n      }\n    }\n    if (!hasChanged) {\n      return position;\n    } else {\n      return {\n        lineNumber,\n        column\n      };\n    }\n  }\n}\n/**\r\n * @internal\r\n */\nexport class EditorSimpleWorker {\n  constructor(host, foreignModuleFactory) {\n    this._host = host;\n    this._models = Object.create(null);\n    this._foreignModuleFactory = foreignModuleFactory;\n    this._foreignModule = null;\n  }\n  dispose() {\n    this._models = Object.create(null);\n  }\n  _getModel(uri) {\n    return this._models[uri];\n  }\n  _getModels() {\n    let all = [];\n    Object.keys(this._models).forEach(key => all.push(this._models[key]));\n    return all;\n  }\n  acceptNewModel(data) {\n    this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n  }\n  acceptModelChanged(strURL, e) {\n    if (!this._models[strURL]) {\n      return;\n    }\n    let model = this._models[strURL];\n    model.onEvents(e);\n  }\n  acceptRemovedModel(strURL) {\n    if (!this._models[strURL]) {\n      return;\n    }\n    delete this._models[strURL];\n  }\n  // ---- BEGIN diff --------------------------------------------------------------------------\n  computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const original = this._getModel(originalUrl);\n      const modified = this._getModel(modifiedUrl);\n      if (!original || !modified) {\n        return null;\n      }\n      const originalLines = original.getLinesContent();\n      const modifiedLines = modified.getLinesContent();\n      const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n        shouldComputeCharChanges: true,\n        shouldPostProcessCharChanges: true,\n        shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n        shouldMakePrettyDiff: true,\n        maxComputationTime: maxComputationTime\n      });\n      const diffResult = diffComputer.computeDiff();\n      const identical = diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified);\n      return {\n        quitEarly: diffResult.quitEarly,\n        identical: identical,\n        changes: diffResult.changes\n      };\n    });\n  }\n  _modelsAreIdentical(original, modified) {\n    const originalLineCount = original.getLineCount();\n    const modifiedLineCount = modified.getLineCount();\n    if (originalLineCount !== modifiedLineCount) {\n      return false;\n    }\n    for (let line = 1; line <= originalLineCount; line++) {\n      const originalLine = original.getLineContent(line);\n      const modifiedLine = modified.getLineContent(line);\n      if (originalLine !== modifiedLine) {\n        return false;\n      }\n    }\n    return true;\n  }\n  computeMoreMinimalEdits(modelUrl, edits) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const model = this._getModel(modelUrl);\n      if (!model) {\n        return edits;\n      }\n      const result = [];\n      let lastEol = undefined;\n      edits = mergeSort(edits, (a, b) => {\n        if (a.range && b.range) {\n          return Range.compareRangesUsingStarts(a.range, b.range);\n        }\n        // eol only changes should go to the end\n        let aRng = a.range ? 0 : 1;\n        let bRng = b.range ? 0 : 1;\n        return aRng - bRng;\n      });\n      for (let {\n        range,\n        text,\n        eol\n      } of edits) {\n        if (typeof eol === 'number') {\n          lastEol = eol;\n        }\n        if (Range.isEmpty(range) && !text) {\n          // empty change\n          continue;\n        }\n        const original = model.getValueInRange(range);\n        text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n        if (original === text) {\n          // noop\n          continue;\n        }\n        // make sure diff won't take too long\n        if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n          result.push({\n            range,\n            text\n          });\n          continue;\n        }\n        // compute diff between original and edit.text\n        const changes = stringDiff(original, text, false);\n        const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n        for (const change of changes) {\n          const start = model.positionAt(editOffset + change.originalStart);\n          const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n          const newEdit = {\n            text: text.substr(change.modifiedStart, change.modifiedLength),\n            range: {\n              startLineNumber: start.lineNumber,\n              startColumn: start.column,\n              endLineNumber: end.lineNumber,\n              endColumn: end.column\n            }\n          };\n          if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n            result.push(newEdit);\n          }\n        }\n      }\n      if (typeof lastEol === 'number') {\n        result.push({\n          eol: lastEol,\n          text: '',\n          range: {\n            startLineNumber: 0,\n            startColumn: 0,\n            endLineNumber: 0,\n            endColumn: 0\n          }\n        });\n      }\n      return result;\n    });\n  }\n  // ---- END minimal edits ---------------------------------------------------------------\n  computeLinks(modelUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let model = this._getModel(modelUrl);\n      if (!model) {\n        return null;\n      }\n      return computeLinks(model);\n    });\n  }\n  textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const sw = new StopWatch(true);\n      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n      const seen = new Set();\n      outer: for (let url of modelUrls) {\n        const model = this._getModel(url);\n        if (!model) {\n          continue;\n        }\n        for (let word of model.words(wordDefRegExp)) {\n          if (word === leadingWord || !isNaN(Number(word))) {\n            continue;\n          }\n          seen.add(word);\n          if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n            break outer;\n          }\n        }\n      }\n      return {\n        words: Array.from(seen),\n        duration: sw.elapsed()\n      };\n    });\n  }\n  // ---- END suggest --------------------------------------------------------------------------\n  //#region -- word ranges --\n  computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let model = this._getModel(modelUrl);\n      if (!model) {\n        return Object.create(null);\n      }\n      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n      const result = Object.create(null);\n      for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n        let words = model.getLineWords(line, wordDefRegExp);\n        for (const word of words) {\n          if (!isNaN(Number(word.word))) {\n            continue;\n          }\n          let array = result[word.word];\n          if (!array) {\n            array = [];\n            result[word.word] = array;\n          }\n          array.push({\n            startLineNumber: line,\n            startColumn: word.startColumn,\n            endLineNumber: line,\n            endColumn: word.endColumn\n          });\n        }\n      }\n      return result;\n    });\n  }\n  //#endregion\n  navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let model = this._getModel(modelUrl);\n      if (!model) {\n        return null;\n      }\n      let wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n      if (range.startColumn === range.endColumn) {\n        range = {\n          startLineNumber: range.startLineNumber,\n          startColumn: range.startColumn,\n          endLineNumber: range.endLineNumber,\n          endColumn: range.endColumn + 1\n        };\n      }\n      let selectionText = model.getValueInRange(range);\n      let wordRange = model.getWordAtPosition({\n        lineNumber: range.startLineNumber,\n        column: range.startColumn\n      }, wordDefRegExp);\n      if (!wordRange) {\n        return null;\n      }\n      let word = model.getValueInRange(wordRange);\n      let result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n      return result;\n    });\n  }\n  // ---- BEGIN foreign module support --------------------------------------------------------------------------\n  loadForeignModule(moduleId, createData, foreignHostMethods) {\n    const proxyMethodRequest = (method, args) => {\n      return this._host.fhr(method, args);\n    };\n    const foreignHost = types.createProxyObject(foreignHostMethods, proxyMethodRequest);\n    let ctx = {\n      host: foreignHost,\n      getMirrorModels: () => {\n        return this._getModels();\n      }\n    };\n    if (this._foreignModuleFactory) {\n      this._foreignModule = this._foreignModuleFactory(ctx, createData);\n      // static foreing module\n      return Promise.resolve(types.getAllMethodNames(this._foreignModule));\n    }\n    // ESM-comment-begin\n    // \t\treturn new Promise<any>((resolve, reject) => {\n    // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\n    // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\n    // \n    // \t\t\t\tresolve(types.getAllMethodNames(this._foreignModule));\n    // \n    // \t\t\t}, reject);\n    // \t\t});\n    // ESM-comment-end\n    // ESM-uncomment-begin\n    return Promise.reject(new Error(\"Unexpected usage\"));\n    // ESM-uncomment-end\n  }\n  // foreign method request\n  fmr(method, args) {\n    if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n      return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n    }\n    try {\n      return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n}\n// ---- END diff --------------------------------------------------------------------------\n// ---- BEGIN minimal edits ---------------------------------------------------------------\nEditorSimpleWorker._diffLimit = 100000;\n// ---- BEGIN suggest --------------------------------------------------------------------------\nEditorSimpleWorker._suggestionsLimit = 10000;\n/**\r\n * Called on the worker side\r\n * @internal\r\n */\nexport function create(host) {\n  return new EditorSimpleWorker(host, null);\n}\nif (typeof importScripts === 'function') {\n  // Running in a web worker\n  globals.monaco = createMonacoBaseAPI();\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","mergeSort","stringDiff","globals","URI","Position","Range","DiffComputer","MirrorTextModel","BaseMirrorModel","ensureValidWordDefinition","getWordAtText","computeLinks","BasicInplaceReplace","createMonacoBaseAPI","types","StopWatch","MirrorModel","uri","_uri","version","_versionId","eol","_eol","getValue","getText","getLinesContent","_lines","slice","getLineCount","length","getLineContent","lineNumber","getWordAtPosition","position","wordDefinition","wordAtText","column","startColumn","endColumn","words","lines","wordenize","_wordenize","bind","lineText","wordRangesIdx","wordRanges","Symbol","iterator","substring","start","end","getLineWords","content","ranges","range","push","word","match","lastIndex","exec","index","getValueInRange","_validateRange","startLineNumber","endLineNumber","lineEnding","startLineIndex","endLineIndex","resultLines","i","join","offsetAt","_validatePosition","_ensureLineStarts","_lineStarts","getAccumulatedValue","positionAt","offset","Math","floor","max","out","getIndexOf","lineLength","min","remainder","isIPosition","Error","hasChanged","maxCharacter","EditorSimpleWorker","constructor","host","foreignModuleFactory","_host","_models","Object","create","_foreignModuleFactory","_foreignModule","dispose","_getModel","_getModels","all","keys","forEach","key","acceptNewModel","data","url","parse","EOL","versionId","acceptModelChanged","strURL","model","onEvents","acceptRemovedModel","computeDiff","originalUrl","modifiedUrl","ignoreTrimWhitespace","maxComputationTime","original","modified","originalLines","modifiedLines","diffComputer","shouldComputeCharChanges","shouldPostProcessCharChanges","shouldIgnoreTrimWhitespace","shouldMakePrettyDiff","diffResult","identical","changes","_modelsAreIdentical","quitEarly","originalLineCount","modifiedLineCount","line","originalLine","modifiedLine","computeMoreMinimalEdits","modelUrl","edits","lastEol","undefined","a","b","compareRangesUsingStarts","aRng","bRng","text","isEmpty","replace","_diffLimit","editOffset","lift","getStartPosition","change","originalStart","originalLength","newEdit","substr","modifiedStart","modifiedLength","textualSuggest","modelUrls","leadingWord","wordDef","wordDefFlags","sw","wordDefRegExp","RegExp","seen","Set","outer","isNaN","Number","add","size","_suggestionsLimit","Array","from","duration","elapsed","computeWordRanges","array","navigateValueSet","up","selectionText","wordRange","INSTANCE","loadForeignModule","moduleId","createData","foreignHostMethods","proxyMethodRequest","method","args","fhr","foreignHost","createProxyObject","ctx","getMirrorModels","getAllMethodNames","fmr","importScripts","monaco"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { mergeSort } from '../../../base/common/arrays.js';\r\nimport { stringDiff } from '../../../base/common/diff/diff.js';\r\nimport { globals } from '../../../base/common/platform.js';\r\nimport { URI } from '../../../base/common/uri.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { DiffComputer } from '../diff/diffComputer.js';\r\nimport { MirrorTextModel as BaseMirrorModel } from '../model/mirrorTextModel.js';\r\nimport { ensureValidWordDefinition, getWordAtText } from '../model/wordHelper.js';\r\nimport { computeLinks } from '../modes/linkComputer.js';\r\nimport { BasicInplaceReplace } from '../modes/supports/inplaceReplaceSupport.js';\r\nimport { createMonacoBaseAPI } from '../standalone/standaloneBase.js';\r\nimport * as types from '../../../base/common/types.js';\r\nimport { StopWatch } from '../../../base/common/stopwatch.js';\r\n/**\r\n * @internal\r\n */\r\nclass MirrorModel extends BaseMirrorModel {\r\n    get uri() {\r\n        return this._uri;\r\n    }\r\n    get version() {\r\n        return this._versionId;\r\n    }\r\n    get eol() {\r\n        return this._eol;\r\n    }\r\n    getValue() {\r\n        return this.getText();\r\n    }\r\n    getLinesContent() {\r\n        return this._lines.slice(0);\r\n    }\r\n    getLineCount() {\r\n        return this._lines.length;\r\n    }\r\n    getLineContent(lineNumber) {\r\n        return this._lines[lineNumber - 1];\r\n    }\r\n    getWordAtPosition(position, wordDefinition) {\r\n        let wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\r\n        if (wordAtText) {\r\n            return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\r\n        }\r\n        return null;\r\n    }\r\n    words(wordDefinition) {\r\n        const lines = this._lines;\r\n        const wordenize = this._wordenize.bind(this);\r\n        let lineNumber = 0;\r\n        let lineText = '';\r\n        let wordRangesIdx = 0;\r\n        let wordRanges = [];\r\n        return {\r\n            *[Symbol.iterator]() {\r\n                while (true) {\r\n                    if (wordRangesIdx < wordRanges.length) {\r\n                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\r\n                        wordRangesIdx += 1;\r\n                        yield value;\r\n                    }\r\n                    else {\r\n                        if (lineNumber < lines.length) {\r\n                            lineText = lines[lineNumber];\r\n                            wordRanges = wordenize(lineText, wordDefinition);\r\n                            wordRangesIdx = 0;\r\n                            lineNumber += 1;\r\n                        }\r\n                        else {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n    getLineWords(lineNumber, wordDefinition) {\r\n        let content = this._lines[lineNumber - 1];\r\n        let ranges = this._wordenize(content, wordDefinition);\r\n        let words = [];\r\n        for (const range of ranges) {\r\n            words.push({\r\n                word: content.substring(range.start, range.end),\r\n                startColumn: range.start + 1,\r\n                endColumn: range.end + 1\r\n            });\r\n        }\r\n        return words;\r\n    }\r\n    _wordenize(content, wordDefinition) {\r\n        const result = [];\r\n        let match;\r\n        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\r\n        while (match = wordDefinition.exec(content)) {\r\n            if (match[0].length === 0) {\r\n                // it did match the empty string\r\n                break;\r\n            }\r\n            result.push({ start: match.index, end: match.index + match[0].length });\r\n        }\r\n        return result;\r\n    }\r\n    getValueInRange(range) {\r\n        range = this._validateRange(range);\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\r\n        }\r\n        let lineEnding = this._eol;\r\n        let startLineIndex = range.startLineNumber - 1;\r\n        let endLineIndex = range.endLineNumber - 1;\r\n        let resultLines = [];\r\n        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\r\n        for (let i = startLineIndex + 1; i < endLineIndex; i++) {\r\n            resultLines.push(this._lines[i]);\r\n        }\r\n        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\r\n        return resultLines.join(lineEnding);\r\n    }\r\n    offsetAt(position) {\r\n        position = this._validatePosition(position);\r\n        this._ensureLineStarts();\r\n        return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + (position.column - 1);\r\n    }\r\n    positionAt(offset) {\r\n        offset = Math.floor(offset);\r\n        offset = Math.max(0, offset);\r\n        this._ensureLineStarts();\r\n        let out = this._lineStarts.getIndexOf(offset);\r\n        let lineLength = this._lines[out.index].length;\r\n        // Ensure we return a valid position\r\n        return {\r\n            lineNumber: 1 + out.index,\r\n            column: 1 + Math.min(out.remainder, lineLength)\r\n        };\r\n    }\r\n    _validateRange(range) {\r\n        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\r\n        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\r\n        if (start.lineNumber !== range.startLineNumber\r\n            || start.column !== range.startColumn\r\n            || end.lineNumber !== range.endLineNumber\r\n            || end.column !== range.endColumn) {\r\n            return {\r\n                startLineNumber: start.lineNumber,\r\n                startColumn: start.column,\r\n                endLineNumber: end.lineNumber,\r\n                endColumn: end.column\r\n            };\r\n        }\r\n        return range;\r\n    }\r\n    _validatePosition(position) {\r\n        if (!Position.isIPosition(position)) {\r\n            throw new Error('bad position');\r\n        }\r\n        let { lineNumber, column } = position;\r\n        let hasChanged = false;\r\n        if (lineNumber < 1) {\r\n            lineNumber = 1;\r\n            column = 1;\r\n            hasChanged = true;\r\n        }\r\n        else if (lineNumber > this._lines.length) {\r\n            lineNumber = this._lines.length;\r\n            column = this._lines[lineNumber - 1].length + 1;\r\n            hasChanged = true;\r\n        }\r\n        else {\r\n            let maxCharacter = this._lines[lineNumber - 1].length + 1;\r\n            if (column < 1) {\r\n                column = 1;\r\n                hasChanged = true;\r\n            }\r\n            else if (column > maxCharacter) {\r\n                column = maxCharacter;\r\n                hasChanged = true;\r\n            }\r\n        }\r\n        if (!hasChanged) {\r\n            return position;\r\n        }\r\n        else {\r\n            return { lineNumber, column };\r\n        }\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nexport class EditorSimpleWorker {\r\n    constructor(host, foreignModuleFactory) {\r\n        this._host = host;\r\n        this._models = Object.create(null);\r\n        this._foreignModuleFactory = foreignModuleFactory;\r\n        this._foreignModule = null;\r\n    }\r\n    dispose() {\r\n        this._models = Object.create(null);\r\n    }\r\n    _getModel(uri) {\r\n        return this._models[uri];\r\n    }\r\n    _getModels() {\r\n        let all = [];\r\n        Object.keys(this._models).forEach((key) => all.push(this._models[key]));\r\n        return all;\r\n    }\r\n    acceptNewModel(data) {\r\n        this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\r\n    }\r\n    acceptModelChanged(strURL, e) {\r\n        if (!this._models[strURL]) {\r\n            return;\r\n        }\r\n        let model = this._models[strURL];\r\n        model.onEvents(e);\r\n    }\r\n    acceptRemovedModel(strURL) {\r\n        if (!this._models[strURL]) {\r\n            return;\r\n        }\r\n        delete this._models[strURL];\r\n    }\r\n    // ---- BEGIN diff --------------------------------------------------------------------------\r\n    computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const original = this._getModel(originalUrl);\r\n            const modified = this._getModel(modifiedUrl);\r\n            if (!original || !modified) {\r\n                return null;\r\n            }\r\n            const originalLines = original.getLinesContent();\r\n            const modifiedLines = modified.getLinesContent();\r\n            const diffComputer = new DiffComputer(originalLines, modifiedLines, {\r\n                shouldComputeCharChanges: true,\r\n                shouldPostProcessCharChanges: true,\r\n                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\r\n                shouldMakePrettyDiff: true,\r\n                maxComputationTime: maxComputationTime\r\n            });\r\n            const diffResult = diffComputer.computeDiff();\r\n            const identical = (diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified));\r\n            return {\r\n                quitEarly: diffResult.quitEarly,\r\n                identical: identical,\r\n                changes: diffResult.changes\r\n            };\r\n        });\r\n    }\r\n    _modelsAreIdentical(original, modified) {\r\n        const originalLineCount = original.getLineCount();\r\n        const modifiedLineCount = modified.getLineCount();\r\n        if (originalLineCount !== modifiedLineCount) {\r\n            return false;\r\n        }\r\n        for (let line = 1; line <= originalLineCount; line++) {\r\n            const originalLine = original.getLineContent(line);\r\n            const modifiedLine = modified.getLineContent(line);\r\n            if (originalLine !== modifiedLine) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    computeMoreMinimalEdits(modelUrl, edits) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const model = this._getModel(modelUrl);\r\n            if (!model) {\r\n                return edits;\r\n            }\r\n            const result = [];\r\n            let lastEol = undefined;\r\n            edits = mergeSort(edits, (a, b) => {\r\n                if (a.range && b.range) {\r\n                    return Range.compareRangesUsingStarts(a.range, b.range);\r\n                }\r\n                // eol only changes should go to the end\r\n                let aRng = a.range ? 0 : 1;\r\n                let bRng = b.range ? 0 : 1;\r\n                return aRng - bRng;\r\n            });\r\n            for (let { range, text, eol } of edits) {\r\n                if (typeof eol === 'number') {\r\n                    lastEol = eol;\r\n                }\r\n                if (Range.isEmpty(range) && !text) {\r\n                    // empty change\r\n                    continue;\r\n                }\r\n                const original = model.getValueInRange(range);\r\n                text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\r\n                if (original === text) {\r\n                    // noop\r\n                    continue;\r\n                }\r\n                // make sure diff won't take too long\r\n                if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\r\n                    result.push({ range, text });\r\n                    continue;\r\n                }\r\n                // compute diff between original and edit.text\r\n                const changes = stringDiff(original, text, false);\r\n                const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\r\n                for (const change of changes) {\r\n                    const start = model.positionAt(editOffset + change.originalStart);\r\n                    const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\r\n                    const newEdit = {\r\n                        text: text.substr(change.modifiedStart, change.modifiedLength),\r\n                        range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\r\n                    };\r\n                    if (model.getValueInRange(newEdit.range) !== newEdit.text) {\r\n                        result.push(newEdit);\r\n                    }\r\n                }\r\n            }\r\n            if (typeof lastEol === 'number') {\r\n                result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    // ---- END minimal edits ---------------------------------------------------------------\r\n    computeLinks(modelUrl) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let model = this._getModel(modelUrl);\r\n            if (!model) {\r\n                return null;\r\n            }\r\n            return computeLinks(model);\r\n        });\r\n    }\r\n    textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const sw = new StopWatch(true);\r\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\r\n            const seen = new Set();\r\n            outer: for (let url of modelUrls) {\r\n                const model = this._getModel(url);\r\n                if (!model) {\r\n                    continue;\r\n                }\r\n                for (let word of model.words(wordDefRegExp)) {\r\n                    if (word === leadingWord || !isNaN(Number(word))) {\r\n                        continue;\r\n                    }\r\n                    seen.add(word);\r\n                    if (seen.size > EditorSimpleWorker._suggestionsLimit) {\r\n                        break outer;\r\n                    }\r\n                }\r\n            }\r\n            return { words: Array.from(seen), duration: sw.elapsed() };\r\n        });\r\n    }\r\n    // ---- END suggest --------------------------------------------------------------------------\r\n    //#region -- word ranges --\r\n    computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let model = this._getModel(modelUrl);\r\n            if (!model) {\r\n                return Object.create(null);\r\n            }\r\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\r\n            const result = Object.create(null);\r\n            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\r\n                let words = model.getLineWords(line, wordDefRegExp);\r\n                for (const word of words) {\r\n                    if (!isNaN(Number(word.word))) {\r\n                        continue;\r\n                    }\r\n                    let array = result[word.word];\r\n                    if (!array) {\r\n                        array = [];\r\n                        result[word.word] = array;\r\n                    }\r\n                    array.push({\r\n                        startLineNumber: line,\r\n                        startColumn: word.startColumn,\r\n                        endLineNumber: line,\r\n                        endColumn: word.endColumn\r\n                    });\r\n                }\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    //#endregion\r\n    navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let model = this._getModel(modelUrl);\r\n            if (!model) {\r\n                return null;\r\n            }\r\n            let wordDefRegExp = new RegExp(wordDef, wordDefFlags);\r\n            if (range.startColumn === range.endColumn) {\r\n                range = {\r\n                    startLineNumber: range.startLineNumber,\r\n                    startColumn: range.startColumn,\r\n                    endLineNumber: range.endLineNumber,\r\n                    endColumn: range.endColumn + 1\r\n                };\r\n            }\r\n            let selectionText = model.getValueInRange(range);\r\n            let wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\r\n            if (!wordRange) {\r\n                return null;\r\n            }\r\n            let word = model.getValueInRange(wordRange);\r\n            let result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\r\n            return result;\r\n        });\r\n    }\r\n    // ---- BEGIN foreign module support --------------------------------------------------------------------------\r\n    loadForeignModule(moduleId, createData, foreignHostMethods) {\r\n        const proxyMethodRequest = (method, args) => {\r\n            return this._host.fhr(method, args);\r\n        };\r\n        const foreignHost = types.createProxyObject(foreignHostMethods, proxyMethodRequest);\r\n        let ctx = {\r\n            host: foreignHost,\r\n            getMirrorModels: () => {\r\n                return this._getModels();\r\n            }\r\n        };\r\n        if (this._foreignModuleFactory) {\r\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\r\n            // static foreing module\r\n            return Promise.resolve(types.getAllMethodNames(this._foreignModule));\r\n        }\r\n        // ESM-comment-begin\r\n        // \t\treturn new Promise<any>((resolve, reject) => {\r\n        // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\r\n        // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\r\n        // \r\n        // \t\t\t\tresolve(types.getAllMethodNames(this._foreignModule));\r\n        // \r\n        // \t\t\t}, reject);\r\n        // \t\t});\r\n        // ESM-comment-end\r\n        // ESM-uncomment-begin\r\n        return Promise.reject(new Error(`Unexpected usage`));\r\n        // ESM-uncomment-end\r\n    }\r\n    // foreign method request\r\n    fmr(method, args) {\r\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\r\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\r\n        }\r\n        try {\r\n            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n}\r\n// ---- END diff --------------------------------------------------------------------------\r\n// ---- BEGIN minimal edits ---------------------------------------------------------------\r\nEditorSimpleWorker._diffLimit = 100000;\r\n// ---- BEGIN suggest --------------------------------------------------------------------------\r\nEditorSimpleWorker._suggestionsLimit = 10000;\r\n/**\r\n * Called on the worker side\r\n * @internal\r\n */\r\nexport function create(host) {\r\n    return new EditorSimpleWorker(host, null);\r\n}\r\nif (typeof importScripts === 'function') {\r\n    // Running in a web worker\r\n    globals.monaco = createMonacoBaseAPI();\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}