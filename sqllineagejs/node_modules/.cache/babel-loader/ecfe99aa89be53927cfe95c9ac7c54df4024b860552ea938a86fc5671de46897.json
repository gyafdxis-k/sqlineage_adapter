{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { MAX_LINE_NUMBER, FoldingRegions } from './foldingRanges.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nconst MAX_FOLDING_REGIONS = 5000;\nconst foldingContext = {};\nexport const ID_SYNTAX_PROVIDER = 'syntax';\nexport class SyntaxRangeProvider {\n  constructor(editorModel, providers, handleFoldingRangesChange) {\n    let limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MAX_FOLDING_REGIONS;\n    this.editorModel = editorModel;\n    this.providers = providers;\n    this.limit = limit;\n    this.id = ID_SYNTAX_PROVIDER;\n    for (const provider of providers) {\n      if (typeof provider.onDidChange === 'function') {\n        if (!this.disposables) {\n          this.disposables = new DisposableStore();\n        }\n        this.disposables.add(provider.onDidChange(handleFoldingRangesChange));\n      }\n    }\n  }\n  compute(cancellationToken) {\n    return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {\n      if (ranges) {\n        let res = sanitizeRanges(ranges, this.limit);\n        return res;\n      }\n      return null;\n    });\n  }\n  dispose() {\n    var _a;\n    (_a = this.disposables) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n}\nfunction collectSyntaxRanges(providers, model, cancellationToken) {\n  let rangeData = null;\n  let promises = providers.map((provider, i) => {\n    return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(ranges => {\n      if (cancellationToken.isCancellationRequested) {\n        return;\n      }\n      if (Array.isArray(ranges)) {\n        if (!Array.isArray(rangeData)) {\n          rangeData = [];\n        }\n        let nLines = model.getLineCount();\n        for (let r of ranges) {\n          if (r.start > 0 && r.end > r.start && r.end <= nLines) {\n            rangeData.push({\n              start: r.start,\n              end: r.end,\n              rank: i,\n              kind: r.kind\n            });\n          }\n        }\n      }\n    }, onUnexpectedExternalError);\n  });\n  return Promise.all(promises).then(_ => {\n    return rangeData;\n  });\n}\nexport class RangesCollector {\n  constructor(foldingRangesLimit) {\n    this._startIndexes = [];\n    this._endIndexes = [];\n    this._nestingLevels = [];\n    this._nestingLevelCounts = [];\n    this._types = [];\n    this._length = 0;\n    this._foldingRangesLimit = foldingRangesLimit;\n  }\n  add(startLineNumber, endLineNumber, type, nestingLevel) {\n    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n      return;\n    }\n    let index = this._length;\n    this._startIndexes[index] = startLineNumber;\n    this._endIndexes[index] = endLineNumber;\n    this._nestingLevels[index] = nestingLevel;\n    this._types[index] = type;\n    this._length++;\n    if (nestingLevel < 30) {\n      this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\n    }\n  }\n  toIndentRanges() {\n    if (this._length <= this._foldingRangesLimit) {\n      let startIndexes = new Uint32Array(this._length);\n      let endIndexes = new Uint32Array(this._length);\n      for (let i = 0; i < this._length; i++) {\n        startIndexes[i] = this._startIndexes[i];\n        endIndexes[i] = this._endIndexes[i];\n      }\n      return new FoldingRegions(startIndexes, endIndexes, this._types);\n    } else {\n      let entries = 0;\n      let maxLevel = this._nestingLevelCounts.length;\n      for (let i = 0; i < this._nestingLevelCounts.length; i++) {\n        let n = this._nestingLevelCounts[i];\n        if (n) {\n          if (n + entries > this._foldingRangesLimit) {\n            maxLevel = i;\n            break;\n          }\n          entries += n;\n        }\n      }\n      let startIndexes = new Uint32Array(this._foldingRangesLimit);\n      let endIndexes = new Uint32Array(this._foldingRangesLimit);\n      let types = [];\n      for (let i = 0, k = 0; i < this._length; i++) {\n        let level = this._nestingLevels[i];\n        if (level < maxLevel || level === maxLevel && entries++ < this._foldingRangesLimit) {\n          startIndexes[k] = this._startIndexes[i];\n          endIndexes[k] = this._endIndexes[i];\n          types[k] = this._types[i];\n          k++;\n        }\n      }\n      return new FoldingRegions(startIndexes, endIndexes, types);\n    }\n  }\n}\nexport function sanitizeRanges(rangeData, limit) {\n  let sorted = rangeData.sort((d1, d2) => {\n    let diff = d1.start - d2.start;\n    if (diff === 0) {\n      diff = d1.rank - d2.rank;\n    }\n    return diff;\n  });\n  let collector = new RangesCollector(limit);\n  let top = undefined;\n  let previous = [];\n  for (let entry of sorted) {\n    if (!top) {\n      top = entry;\n      collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n    } else {\n      if (entry.start > top.start) {\n        if (entry.end <= top.end) {\n          previous.push(top);\n          top = entry;\n          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        } else {\n          if (entry.start > top.end) {\n            do {\n              top = previous.pop();\n            } while (top && entry.start > top.end);\n            if (top) {\n              previous.push(top);\n            }\n            top = entry;\n          }\n          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\n        }\n      }\n    }\n  }\n  return collector.toIndentRanges();\n}","map":{"version":3,"names":["onUnexpectedExternalError","MAX_LINE_NUMBER","FoldingRegions","DisposableStore","MAX_FOLDING_REGIONS","foldingContext","ID_SYNTAX_PROVIDER","SyntaxRangeProvider","constructor","editorModel","providers","handleFoldingRangesChange","limit","arguments","length","undefined","id","provider","onDidChange","disposables","add","compute","cancellationToken","collectSyntaxRanges","then","ranges","res","sanitizeRanges","dispose","_a","model","rangeData","promises","map","i","Promise","resolve","provideFoldingRanges","isCancellationRequested","Array","isArray","nLines","getLineCount","r","start","end","push","rank","kind","all","_","RangesCollector","foldingRangesLimit","_startIndexes","_endIndexes","_nestingLevels","_nestingLevelCounts","_types","_length","_foldingRangesLimit","startLineNumber","endLineNumber","type","nestingLevel","index","toIndentRanges","startIndexes","Uint32Array","endIndexes","entries","maxLevel","n","types","k","level","sorted","sort","d1","d2","diff","collector","top","previous","entry","value","pop"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/folding/syntaxRangeProvider.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { onUnexpectedExternalError } from '../../../base/common/errors.js';\r\nimport { MAX_LINE_NUMBER, FoldingRegions } from './foldingRanges.js';\r\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\r\nconst MAX_FOLDING_REGIONS = 5000;\r\nconst foldingContext = {};\r\nexport const ID_SYNTAX_PROVIDER = 'syntax';\r\nexport class SyntaxRangeProvider {\r\n    constructor(editorModel, providers, handleFoldingRangesChange, limit = MAX_FOLDING_REGIONS) {\r\n        this.editorModel = editorModel;\r\n        this.providers = providers;\r\n        this.limit = limit;\r\n        this.id = ID_SYNTAX_PROVIDER;\r\n        for (const provider of providers) {\r\n            if (typeof provider.onDidChange === 'function') {\r\n                if (!this.disposables) {\r\n                    this.disposables = new DisposableStore();\r\n                }\r\n                this.disposables.add(provider.onDidChange(handleFoldingRangesChange));\r\n            }\r\n        }\r\n    }\r\n    compute(cancellationToken) {\r\n        return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then(ranges => {\r\n            if (ranges) {\r\n                let res = sanitizeRanges(ranges, this.limit);\r\n                return res;\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    dispose() {\r\n        var _a;\r\n        (_a = this.disposables) === null || _a === void 0 ? void 0 : _a.dispose();\r\n    }\r\n}\r\nfunction collectSyntaxRanges(providers, model, cancellationToken) {\r\n    let rangeData = null;\r\n    let promises = providers.map((provider, i) => {\r\n        return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then(ranges => {\r\n            if (cancellationToken.isCancellationRequested) {\r\n                return;\r\n            }\r\n            if (Array.isArray(ranges)) {\r\n                if (!Array.isArray(rangeData)) {\r\n                    rangeData = [];\r\n                }\r\n                let nLines = model.getLineCount();\r\n                for (let r of ranges) {\r\n                    if (r.start > 0 && r.end > r.start && r.end <= nLines) {\r\n                        rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });\r\n                    }\r\n                }\r\n            }\r\n        }, onUnexpectedExternalError);\r\n    });\r\n    return Promise.all(promises).then(_ => {\r\n        return rangeData;\r\n    });\r\n}\r\nexport class RangesCollector {\r\n    constructor(foldingRangesLimit) {\r\n        this._startIndexes = [];\r\n        this._endIndexes = [];\r\n        this._nestingLevels = [];\r\n        this._nestingLevelCounts = [];\r\n        this._types = [];\r\n        this._length = 0;\r\n        this._foldingRangesLimit = foldingRangesLimit;\r\n    }\r\n    add(startLineNumber, endLineNumber, type, nestingLevel) {\r\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\r\n            return;\r\n        }\r\n        let index = this._length;\r\n        this._startIndexes[index] = startLineNumber;\r\n        this._endIndexes[index] = endLineNumber;\r\n        this._nestingLevels[index] = nestingLevel;\r\n        this._types[index] = type;\r\n        this._length++;\r\n        if (nestingLevel < 30) {\r\n            this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;\r\n        }\r\n    }\r\n    toIndentRanges() {\r\n        if (this._length <= this._foldingRangesLimit) {\r\n            let startIndexes = new Uint32Array(this._length);\r\n            let endIndexes = new Uint32Array(this._length);\r\n            for (let i = 0; i < this._length; i++) {\r\n                startIndexes[i] = this._startIndexes[i];\r\n                endIndexes[i] = this._endIndexes[i];\r\n            }\r\n            return new FoldingRegions(startIndexes, endIndexes, this._types);\r\n        }\r\n        else {\r\n            let entries = 0;\r\n            let maxLevel = this._nestingLevelCounts.length;\r\n            for (let i = 0; i < this._nestingLevelCounts.length; i++) {\r\n                let n = this._nestingLevelCounts[i];\r\n                if (n) {\r\n                    if (n + entries > this._foldingRangesLimit) {\r\n                        maxLevel = i;\r\n                        break;\r\n                    }\r\n                    entries += n;\r\n                }\r\n            }\r\n            let startIndexes = new Uint32Array(this._foldingRangesLimit);\r\n            let endIndexes = new Uint32Array(this._foldingRangesLimit);\r\n            let types = [];\r\n            for (let i = 0, k = 0; i < this._length; i++) {\r\n                let level = this._nestingLevels[i];\r\n                if (level < maxLevel || (level === maxLevel && entries++ < this._foldingRangesLimit)) {\r\n                    startIndexes[k] = this._startIndexes[i];\r\n                    endIndexes[k] = this._endIndexes[i];\r\n                    types[k] = this._types[i];\r\n                    k++;\r\n                }\r\n            }\r\n            return new FoldingRegions(startIndexes, endIndexes, types);\r\n        }\r\n    }\r\n}\r\nexport function sanitizeRanges(rangeData, limit) {\r\n    let sorted = rangeData.sort((d1, d2) => {\r\n        let diff = d1.start - d2.start;\r\n        if (diff === 0) {\r\n            diff = d1.rank - d2.rank;\r\n        }\r\n        return diff;\r\n    });\r\n    let collector = new RangesCollector(limit);\r\n    let top = undefined;\r\n    let previous = [];\r\n    for (let entry of sorted) {\r\n        if (!top) {\r\n            top = entry;\r\n            collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\r\n        }\r\n        else {\r\n            if (entry.start > top.start) {\r\n                if (entry.end <= top.end) {\r\n                    previous.push(top);\r\n                    top = entry;\r\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\r\n                }\r\n                else {\r\n                    if (entry.start > top.end) {\r\n                        do {\r\n                            top = previous.pop();\r\n                        } while (top && entry.start > top.end);\r\n                        if (top) {\r\n                            previous.push(top);\r\n                        }\r\n                        top = entry;\r\n                    }\r\n                    collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return collector.toIndentRanges();\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}