{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from './strings.js';\nconst hasBuffer = typeof Buffer !== 'undefined';\nconst hasTextDecoder = typeof TextDecoder !== 'undefined';\nlet textDecoder;\nexport class VSBuffer {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.byteLength = this.buffer.byteLength;\n  }\n  static wrap(actual) {\n    if (hasBuffer && !Buffer.isBuffer(actual)) {\n      // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n      // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n      actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n    }\n    return new VSBuffer(actual);\n  }\n  toString() {\n    if (hasBuffer) {\n      return this.buffer.toString();\n    } else if (hasTextDecoder) {\n      if (!textDecoder) {\n        textDecoder = new TextDecoder();\n      }\n      return textDecoder.decode(this.buffer);\n    } else {\n      return strings.decodeUTF8(this.buffer);\n    }\n  }\n}\nexport function readUInt16LE(source, offset) {\n  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;\n}\nexport function writeUInt16LE(destination, value, offset) {\n  destination[offset + 0] = value & 0b11111111;\n  value = value >>> 8;\n  destination[offset + 1] = value & 0b11111111;\n}\nexport function readUInt32BE(source, offset) {\n  return source[offset] * Math.pow(2, 24) + source[offset + 1] * Math.pow(2, 16) + source[offset + 2] * Math.pow(2, 8) + source[offset + 3];\n}\nexport function writeUInt32BE(destination, value, offset) {\n  destination[offset + 3] = value;\n  value = value >>> 8;\n  destination[offset + 2] = value;\n  value = value >>> 8;\n  destination[offset + 1] = value;\n  value = value >>> 8;\n  destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n  return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n  destination[offset] = value;\n}","map":{"version":3,"names":["strings","hasBuffer","Buffer","hasTextDecoder","TextDecoder","textDecoder","VSBuffer","constructor","buffer","byteLength","wrap","actual","isBuffer","from","byteOffset","toString","decode","decodeUTF8","readUInt16LE","source","offset","writeUInt16LE","destination","value","readUInt32BE","Math","pow","writeUInt32BE","readUInt8","writeUInt8"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/buffer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from './strings.js';\r\nconst hasBuffer = (typeof Buffer !== 'undefined');\r\nconst hasTextDecoder = (typeof TextDecoder !== 'undefined');\r\nlet textDecoder;\r\nexport class VSBuffer {\r\n    constructor(buffer) {\r\n        this.buffer = buffer;\r\n        this.byteLength = this.buffer.byteLength;\r\n    }\r\n    static wrap(actual) {\r\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\r\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\r\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\r\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\r\n        }\r\n        return new VSBuffer(actual);\r\n    }\r\n    toString() {\r\n        if (hasBuffer) {\r\n            return this.buffer.toString();\r\n        }\r\n        else if (hasTextDecoder) {\r\n            if (!textDecoder) {\r\n                textDecoder = new TextDecoder();\r\n            }\r\n            return textDecoder.decode(this.buffer);\r\n        }\r\n        else {\r\n            return strings.decodeUTF8(this.buffer);\r\n        }\r\n    }\r\n}\r\nexport function readUInt16LE(source, offset) {\r\n    return (((source[offset + 0] << 0) >>> 0) |\r\n        ((source[offset + 1] << 8) >>> 0));\r\n}\r\nexport function writeUInt16LE(destination, value, offset) {\r\n    destination[offset + 0] = (value & 0b11111111);\r\n    value = value >>> 8;\r\n    destination[offset + 1] = (value & 0b11111111);\r\n}\r\nexport function readUInt32BE(source, offset) {\r\n    return (source[offset] * Math.pow(2, 24)\r\n        + source[offset + 1] * Math.pow(2, 16)\r\n        + source[offset + 2] * Math.pow(2, 8)\r\n        + source[offset + 3]);\r\n}\r\nexport function writeUInt32BE(destination, value, offset) {\r\n    destination[offset + 3] = value;\r\n    value = value >>> 8;\r\n    destination[offset + 2] = value;\r\n    value = value >>> 8;\r\n    destination[offset + 1] = value;\r\n    value = value >>> 8;\r\n    destination[offset] = value;\r\n}\r\nexport function readUInt8(source, offset) {\r\n    return source[offset];\r\n}\r\nexport function writeUInt8(destination, value, offset) {\r\n    destination[offset] = value;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,OAAO,MAAM,cAAc;AACvC,MAAMC,SAAS,GAAI,OAAOC,MAAM,KAAK,WAAY;AACjD,MAAMC,cAAc,GAAI,OAAOC,WAAW,KAAK,WAAY;AAC3D,IAAIC,WAAW;AACf,OAAO,MAAMC,QAAQ,CAAC;EAClBC,WAAWA,CAACC,MAAM,EAAE;IAChB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,UAAU,GAAG,IAAI,CAACD,MAAM,CAACC,UAAU;EAC5C;EACA,OAAOC,IAAIA,CAACC,MAAM,EAAE;IAChB,IAAIV,SAAS,IAAI,CAAEC,MAAM,CAACU,QAAQ,CAACD,MAAM,CAAE,EAAE;MACzC;MACA;MACAA,MAAM,GAAGT,MAAM,CAACW,IAAI,CAACF,MAAM,CAACH,MAAM,EAAEG,MAAM,CAACG,UAAU,EAAEH,MAAM,CAACF,UAAU,CAAC;IAC7E;IACA,OAAO,IAAIH,QAAQ,CAACK,MAAM,CAAC;EAC/B;EACAI,QAAQA,CAAA,EAAG;IACP,IAAId,SAAS,EAAE;MACX,OAAO,IAAI,CAACO,MAAM,CAACO,QAAQ,CAAC,CAAC;IACjC,CAAC,MACI,IAAIZ,cAAc,EAAE;MACrB,IAAI,CAACE,WAAW,EAAE;QACdA,WAAW,GAAG,IAAID,WAAW,CAAC,CAAC;MACnC;MACA,OAAOC,WAAW,CAACW,MAAM,CAAC,IAAI,CAACR,MAAM,CAAC;IAC1C,CAAC,MACI;MACD,OAAOR,OAAO,CAACiB,UAAU,CAAC,IAAI,CAACT,MAAM,CAAC;IAC1C;EACJ;AACJ;AACA,OAAO,SAASU,YAAYA,CAACC,MAAM,EAAEC,MAAM,EAAE;EACzC,OAAUD,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,KAAM,CAAC,GAClCD,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,KAAM,CAAE;AACzC;AACA,OAAO,SAASC,aAAaA,CAACC,WAAW,EAAEC,KAAK,EAAEH,MAAM,EAAE;EACtDE,WAAW,CAACF,MAAM,GAAG,CAAC,CAAC,GAAIG,KAAK,GAAG,UAAW;EAC9CA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBD,WAAW,CAACF,MAAM,GAAG,CAAC,CAAC,GAAIG,KAAK,GAAG,UAAW;AAClD;AACA,OAAO,SAASC,YAAYA,CAACL,MAAM,EAAEC,MAAM,EAAE;EACzC,OAAQD,MAAM,CAACC,MAAM,CAAC,GAAGK,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAClCP,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,GAAGK,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GACpCP,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,GAAGK,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GACnCP,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC;AAC5B;AACA,OAAO,SAASO,aAAaA,CAACL,WAAW,EAAEC,KAAK,EAAEH,MAAM,EAAE;EACtDE,WAAW,CAACF,MAAM,GAAG,CAAC,CAAC,GAAGG,KAAK;EAC/BA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBD,WAAW,CAACF,MAAM,GAAG,CAAC,CAAC,GAAGG,KAAK;EAC/BA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBD,WAAW,CAACF,MAAM,GAAG,CAAC,CAAC,GAAGG,KAAK;EAC/BA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBD,WAAW,CAACF,MAAM,CAAC,GAAGG,KAAK;AAC/B;AACA,OAAO,SAASK,SAASA,CAACT,MAAM,EAAEC,MAAM,EAAE;EACtC,OAAOD,MAAM,CAACC,MAAM,CAAC;AACzB;AACA,OAAO,SAASS,UAAUA,CAACP,WAAW,EAAEC,KAAK,EAAEH,MAAM,EAAE;EACnDE,WAAW,CAACF,MAAM,CAAC,GAAGG,KAAK;AAC/B"},"metadata":{},"sourceType":"module","externalDependencies":[]}