{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nimport { TextModel } from '../../common/model/textModel.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nconst MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5000;\nexport const ID_INDENT_PROVIDER = 'indent';\nexport class IndentRangeProvider {\n  constructor(editorModel) {\n    this.editorModel = editorModel;\n    this.id = ID_INDENT_PROVIDER;\n  }\n  dispose() {}\n  compute(cancelationToken) {\n    let foldingRules = LanguageConfigurationRegistry.getFoldingRules(this.editorModel.getLanguageIdentifier().id);\n    let offSide = foldingRules && !!foldingRules.offSide;\n    let markers = foldingRules && foldingRules.markers;\n    return Promise.resolve(computeRanges(this.editorModel, offSide, markers));\n  }\n}\n// public only for testing\nexport class RangesCollector {\n  constructor(foldingRangesLimit) {\n    this._startIndexes = [];\n    this._endIndexes = [];\n    this._indentOccurrences = [];\n    this._length = 0;\n    this._foldingRangesLimit = foldingRangesLimit;\n  }\n  insertFirst(startLineNumber, endLineNumber, indent) {\n    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n      return;\n    }\n    let index = this._length;\n    this._startIndexes[index] = startLineNumber;\n    this._endIndexes[index] = endLineNumber;\n    this._length++;\n    if (indent < 1000) {\n      this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\n    }\n  }\n  toIndentRanges(model) {\n    if (this._length <= this._foldingRangesLimit) {\n      // reverse and create arrays of the exact length\n      let startIndexes = new Uint32Array(this._length);\n      let endIndexes = new Uint32Array(this._length);\n      for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {\n        startIndexes[k] = this._startIndexes[i];\n        endIndexes[k] = this._endIndexes[i];\n      }\n      return new FoldingRegions(startIndexes, endIndexes);\n    } else {\n      let entries = 0;\n      let maxIndent = this._indentOccurrences.length;\n      for (let i = 0; i < this._indentOccurrences.length; i++) {\n        let n = this._indentOccurrences[i];\n        if (n) {\n          if (n + entries > this._foldingRangesLimit) {\n            maxIndent = i;\n            break;\n          }\n          entries += n;\n        }\n      }\n      const tabSize = model.getOptions().tabSize;\n      // reverse and create arrays of the exact length\n      let startIndexes = new Uint32Array(this._foldingRangesLimit);\n      let endIndexes = new Uint32Array(this._foldingRangesLimit);\n      for (let i = this._length - 1, k = 0; i >= 0; i--) {\n        let startIndex = this._startIndexes[i];\n        let lineContent = model.getLineContent(startIndex);\n        let indent = TextModel.computeIndentLevel(lineContent, tabSize);\n        if (indent < maxIndent || indent === maxIndent && entries++ < this._foldingRangesLimit) {\n          startIndexes[k] = startIndex;\n          endIndexes[k] = this._endIndexes[i];\n          k++;\n        }\n      }\n      return new FoldingRegions(startIndexes, endIndexes);\n    }\n  }\n}\nexport function computeRanges(model, offSide, markers) {\n  let foldingRangesLimit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT;\n  const tabSize = model.getOptions().tabSize;\n  let result = new RangesCollector(foldingRangesLimit);\n  let pattern = undefined;\n  if (markers) {\n    pattern = new RegExp(\"(\".concat(markers.start.source, \")|(?:\").concat(markers.end.source, \")\"));\n  }\n  let previousRegions = [];\n  let line = model.getLineCount() + 1;\n  previousRegions.push({\n    indent: -1,\n    endAbove: line,\n    line\n  }); // sentinel, to make sure there's at least one entry\n  for (let line = model.getLineCount(); line > 0; line--) {\n    let lineContent = model.getLineContent(line);\n    let indent = TextModel.computeIndentLevel(lineContent, tabSize);\n    let previous = previousRegions[previousRegions.length - 1];\n    if (indent === -1) {\n      if (offSide) {\n        // for offSide languages, empty lines are associated to the previous block\n        // note: the next block is already written to the results, so this only\n        // impacts the end position of the block before\n        previous.endAbove = line;\n      }\n      continue; // only whitespace\n    }\n\n    let m;\n    if (pattern && (m = lineContent.match(pattern))) {\n      // folding pattern match\n      if (m[1]) {\n        // start pattern match\n        // discard all regions until the folding pattern\n        let i = previousRegions.length - 1;\n        while (i > 0 && previousRegions[i].indent !== -2) {\n          i--;\n        }\n        if (i > 0) {\n          previousRegions.length = i + 1;\n          previous = previousRegions[i];\n          // new folding range from pattern, includes the end line\n          result.insertFirst(line, previous.line, indent);\n          previous.line = line;\n          previous.indent = indent;\n          previous.endAbove = line;\n          continue;\n        } else {\n          // no end marker found, treat line as a regular line\n        }\n      } else {\n        // end pattern match\n        previousRegions.push({\n          indent: -2,\n          endAbove: line,\n          line\n        });\n        continue;\n      }\n    }\n    if (previous.indent > indent) {\n      // discard all regions with larger indent\n      do {\n        previousRegions.pop();\n        previous = previousRegions[previousRegions.length - 1];\n      } while (previous.indent > indent);\n      // new folding range\n      let endLineNumber = previous.endAbove - 1;\n      if (endLineNumber - line >= 1) {\n        // needs at east size 1\n        result.insertFirst(line, endLineNumber, indent);\n      }\n    }\n    if (previous.indent === indent) {\n      previous.endAbove = line;\n    } else {\n      // previous.indent < indent\n      // new region with a bigger indent\n      previousRegions.push({\n        indent,\n        endAbove: line,\n        line\n      });\n    }\n  }\n  return result.toIndentRanges(model);\n}","map":{"version":3,"names":["FoldingRegions","MAX_LINE_NUMBER","TextModel","LanguageConfigurationRegistry","MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT","ID_INDENT_PROVIDER","IndentRangeProvider","constructor","editorModel","id","dispose","compute","cancelationToken","foldingRules","getFoldingRules","getLanguageIdentifier","offSide","markers","Promise","resolve","computeRanges","RangesCollector","foldingRangesLimit","_startIndexes","_endIndexes","_indentOccurrences","_length","_foldingRangesLimit","insertFirst","startLineNumber","endLineNumber","indent","index","toIndentRanges","model","startIndexes","Uint32Array","endIndexes","i","k","entries","maxIndent","length","n","tabSize","getOptions","startIndex","lineContent","getLineContent","computeIndentLevel","arguments","undefined","result","pattern","RegExp","concat","start","source","end","previousRegions","line","getLineCount","push","endAbove","previous","m","match","pop"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/folding/indentRangeProvider.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\r\nimport { TextModel } from '../../common/model/textModel.js';\r\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\r\nconst MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5000;\r\nexport const ID_INDENT_PROVIDER = 'indent';\r\nexport class IndentRangeProvider {\r\n    constructor(editorModel) {\r\n        this.editorModel = editorModel;\r\n        this.id = ID_INDENT_PROVIDER;\r\n    }\r\n    dispose() {\r\n    }\r\n    compute(cancelationToken) {\r\n        let foldingRules = LanguageConfigurationRegistry.getFoldingRules(this.editorModel.getLanguageIdentifier().id);\r\n        let offSide = foldingRules && !!foldingRules.offSide;\r\n        let markers = foldingRules && foldingRules.markers;\r\n        return Promise.resolve(computeRanges(this.editorModel, offSide, markers));\r\n    }\r\n}\r\n// public only for testing\r\nexport class RangesCollector {\r\n    constructor(foldingRangesLimit) {\r\n        this._startIndexes = [];\r\n        this._endIndexes = [];\r\n        this._indentOccurrences = [];\r\n        this._length = 0;\r\n        this._foldingRangesLimit = foldingRangesLimit;\r\n    }\r\n    insertFirst(startLineNumber, endLineNumber, indent) {\r\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\r\n            return;\r\n        }\r\n        let index = this._length;\r\n        this._startIndexes[index] = startLineNumber;\r\n        this._endIndexes[index] = endLineNumber;\r\n        this._length++;\r\n        if (indent < 1000) {\r\n            this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\r\n        }\r\n    }\r\n    toIndentRanges(model) {\r\n        if (this._length <= this._foldingRangesLimit) {\r\n            // reverse and create arrays of the exact length\r\n            let startIndexes = new Uint32Array(this._length);\r\n            let endIndexes = new Uint32Array(this._length);\r\n            for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {\r\n                startIndexes[k] = this._startIndexes[i];\r\n                endIndexes[k] = this._endIndexes[i];\r\n            }\r\n            return new FoldingRegions(startIndexes, endIndexes);\r\n        }\r\n        else {\r\n            let entries = 0;\r\n            let maxIndent = this._indentOccurrences.length;\r\n            for (let i = 0; i < this._indentOccurrences.length; i++) {\r\n                let n = this._indentOccurrences[i];\r\n                if (n) {\r\n                    if (n + entries > this._foldingRangesLimit) {\r\n                        maxIndent = i;\r\n                        break;\r\n                    }\r\n                    entries += n;\r\n                }\r\n            }\r\n            const tabSize = model.getOptions().tabSize;\r\n            // reverse and create arrays of the exact length\r\n            let startIndexes = new Uint32Array(this._foldingRangesLimit);\r\n            let endIndexes = new Uint32Array(this._foldingRangesLimit);\r\n            for (let i = this._length - 1, k = 0; i >= 0; i--) {\r\n                let startIndex = this._startIndexes[i];\r\n                let lineContent = model.getLineContent(startIndex);\r\n                let indent = TextModel.computeIndentLevel(lineContent, tabSize);\r\n                if (indent < maxIndent || (indent === maxIndent && entries++ < this._foldingRangesLimit)) {\r\n                    startIndexes[k] = startIndex;\r\n                    endIndexes[k] = this._endIndexes[i];\r\n                    k++;\r\n                }\r\n            }\r\n            return new FoldingRegions(startIndexes, endIndexes);\r\n        }\r\n    }\r\n}\r\nexport function computeRanges(model, offSide, markers, foldingRangesLimit = MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT) {\r\n    const tabSize = model.getOptions().tabSize;\r\n    let result = new RangesCollector(foldingRangesLimit);\r\n    let pattern = undefined;\r\n    if (markers) {\r\n        pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);\r\n    }\r\n    let previousRegions = [];\r\n    let line = model.getLineCount() + 1;\r\n    previousRegions.push({ indent: -1, endAbove: line, line }); // sentinel, to make sure there's at least one entry\r\n    for (let line = model.getLineCount(); line > 0; line--) {\r\n        let lineContent = model.getLineContent(line);\r\n        let indent = TextModel.computeIndentLevel(lineContent, tabSize);\r\n        let previous = previousRegions[previousRegions.length - 1];\r\n        if (indent === -1) {\r\n            if (offSide) {\r\n                // for offSide languages, empty lines are associated to the previous block\r\n                // note: the next block is already written to the results, so this only\r\n                // impacts the end position of the block before\r\n                previous.endAbove = line;\r\n            }\r\n            continue; // only whitespace\r\n        }\r\n        let m;\r\n        if (pattern && (m = lineContent.match(pattern))) {\r\n            // folding pattern match\r\n            if (m[1]) { // start pattern match\r\n                // discard all regions until the folding pattern\r\n                let i = previousRegions.length - 1;\r\n                while (i > 0 && previousRegions[i].indent !== -2) {\r\n                    i--;\r\n                }\r\n                if (i > 0) {\r\n                    previousRegions.length = i + 1;\r\n                    previous = previousRegions[i];\r\n                    // new folding range from pattern, includes the end line\r\n                    result.insertFirst(line, previous.line, indent);\r\n                    previous.line = line;\r\n                    previous.indent = indent;\r\n                    previous.endAbove = line;\r\n                    continue;\r\n                }\r\n                else {\r\n                    // no end marker found, treat line as a regular line\r\n                }\r\n            }\r\n            else { // end pattern match\r\n                previousRegions.push({ indent: -2, endAbove: line, line });\r\n                continue;\r\n            }\r\n        }\r\n        if (previous.indent > indent) {\r\n            // discard all regions with larger indent\r\n            do {\r\n                previousRegions.pop();\r\n                previous = previousRegions[previousRegions.length - 1];\r\n            } while (previous.indent > indent);\r\n            // new folding range\r\n            let endLineNumber = previous.endAbove - 1;\r\n            if (endLineNumber - line >= 1) { // needs at east size 1\r\n                result.insertFirst(line, endLineNumber, indent);\r\n            }\r\n        }\r\n        if (previous.indent === indent) {\r\n            previous.endAbove = line;\r\n        }\r\n        else { // previous.indent < indent\r\n            // new region with a bigger indent\r\n            previousRegions.push({ indent, endAbove: line, line });\r\n        }\r\n    }\r\n    return result.toIndentRanges(model);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}