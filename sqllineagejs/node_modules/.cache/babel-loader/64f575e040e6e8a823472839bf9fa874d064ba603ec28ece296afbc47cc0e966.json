{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n  constructor(token, index, fontStyle, foreground, background) {\n    this.token = token;\n    this.index = index;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n}\n/**\r\n * Parse a raw theme into rules.\r\n */\nexport function parseTokenTheme(source) {\n  if (!source || !Array.isArray(source)) {\n    return [];\n  }\n  let result = [],\n    resultLen = 0;\n  for (let i = 0, len = source.length; i < len; i++) {\n    let entry = source[i];\n    let fontStyle = -1 /* NotSet */;\n    if (typeof entry.fontStyle === 'string') {\n      fontStyle = 0 /* None */;\n      let segments = entry.fontStyle.split(' ');\n      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n        let segment = segments[j];\n        switch (segment) {\n          case 'italic':\n            fontStyle = fontStyle | 1 /* Italic */;\n            break;\n          case 'bold':\n            fontStyle = fontStyle | 2 /* Bold */;\n            break;\n          case 'underline':\n            fontStyle = fontStyle | 4 /* Underline */;\n            break;\n        }\n      }\n    }\n    let foreground = null;\n    if (typeof entry.foreground === 'string') {\n      foreground = entry.foreground;\n    }\n    let background = null;\n    if (typeof entry.background === 'string') {\n      background = entry.background;\n    }\n    result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n  }\n  return result;\n}\n/**\r\n * Resolve rules (i.e. inheritance).\r\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n  // Sort rules lexicographically, and then by index if necessary\n  parsedThemeRules.sort((a, b) => {\n    let r = strcmp(a.token, b.token);\n    if (r !== 0) {\n      return r;\n    }\n    return a.index - b.index;\n  });\n  // Determine defaults\n  let defaultFontStyle = 0 /* None */;\n  let defaultForeground = '000000';\n  let defaultBackground = 'ffffff';\n  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n    let incomingDefaults = parsedThemeRules.shift();\n    if (incomingDefaults.fontStyle !== -1 /* NotSet */) {\n      defaultFontStyle = incomingDefaults.fontStyle;\n    }\n    if (incomingDefaults.foreground !== null) {\n      defaultForeground = incomingDefaults.foreground;\n    }\n    if (incomingDefaults.background !== null) {\n      defaultBackground = incomingDefaults.background;\n    }\n  }\n  let colorMap = new ColorMap();\n  // start with token colors from custom token themes\n  for (let color of customTokenColors) {\n    colorMap.getId(color);\n  }\n  let foregroundColorId = colorMap.getId(defaultForeground);\n  let backgroundColorId = colorMap.getId(defaultBackground);\n  let defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n  let root = new ThemeTrieElement(defaults);\n  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n    let rule = parsedThemeRules[i];\n    root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n  }\n  return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n  constructor() {\n    this._lastColorId = 0;\n    this._id2color = [];\n    this._color2id = new Map();\n  }\n  getId(color) {\n    if (color === null) {\n      return 0;\n    }\n    const match = color.match(colorRegExp);\n    if (!match) {\n      throw new Error('Illegal value for token color: ' + color);\n    }\n    color = match[1].toUpperCase();\n    let value = this._color2id.get(color);\n    if (value) {\n      return value;\n    }\n    value = ++this._lastColorId;\n    this._color2id.set(color, value);\n    this._id2color[value] = Color.fromHex('#' + color);\n    return value;\n  }\n  getColorMap() {\n    return this._id2color.slice(0);\n  }\n}\nexport class TokenTheme {\n  constructor(colorMap, root) {\n    this._colorMap = colorMap;\n    this._root = root;\n    this._cache = new Map();\n  }\n  static createFromRawTokenTheme(source, customTokenColors) {\n    return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n  }\n  static createFromParsedTokenTheme(source, customTokenColors) {\n    return resolveParsedTokenThemeRules(source, customTokenColors);\n  }\n  getColorMap() {\n    return this._colorMap.getColorMap();\n  }\n  _match(token) {\n    return this._root.match(token);\n  }\n  match(languageId, token) {\n    // The cache contains the metadata without the language bits set.\n    let result = this._cache.get(token);\n    if (typeof result === 'undefined') {\n      let rule = this._match(token);\n      let standardToken = toStandardTokenType(token);\n      result = (rule.metadata | standardToken << 8 /* TOKEN_TYPE_OFFSET */) >>> 0;\n      this._cache.set(token, result);\n    }\n    return (result | languageId << 0 /* LANGUAGEID_OFFSET */) >>> 0;\n  }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n  let m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n  if (!m) {\n    return 0 /* Other */;\n  }\n\n  switch (m[1]) {\n    case 'comment':\n      return 1 /* Comment */;\n    case 'string':\n      return 2 /* String */;\n    case 'regex':\n      return 4 /* RegEx */;\n    case 'regexp':\n      return 4 /* RegEx */;\n  }\n\n  throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nexport class ThemeTrieElementRule {\n  constructor(fontStyle, foreground, background) {\n    this._fontStyle = fontStyle;\n    this._foreground = foreground;\n    this._background = background;\n    this.metadata = (this._fontStyle << 11 /* FONT_STYLE_OFFSET */ | this._foreground << 14 /* FOREGROUND_OFFSET */ | this._background << 23 /* BACKGROUND_OFFSET */) >>> 0;\n  }\n  clone() {\n    return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n  }\n  acceptOverwrite(fontStyle, foreground, background) {\n    if (fontStyle !== -1 /* NotSet */) {\n      this._fontStyle = fontStyle;\n    }\n    if (foreground !== 0 /* None */) {\n      this._foreground = foreground;\n    }\n    if (background !== 0 /* None */) {\n      this._background = background;\n    }\n    this.metadata = (this._fontStyle << 11 /* FONT_STYLE_OFFSET */ | this._foreground << 14 /* FOREGROUND_OFFSET */ | this._background << 23 /* BACKGROUND_OFFSET */) >>> 0;\n  }\n}\nexport class ThemeTrieElement {\n  constructor(mainRule) {\n    this._mainRule = mainRule;\n    this._children = new Map();\n  }\n  match(token) {\n    if (token === '') {\n      return this._mainRule;\n    }\n    let dotIndex = token.indexOf('.');\n    let head;\n    let tail;\n    if (dotIndex === -1) {\n      head = token;\n      tail = '';\n    } else {\n      head = token.substring(0, dotIndex);\n      tail = token.substring(dotIndex + 1);\n    }\n    let child = this._children.get(head);\n    if (typeof child !== 'undefined') {\n      return child.match(tail);\n    }\n    return this._mainRule;\n  }\n  insert(token, fontStyle, foreground, background) {\n    if (token === '') {\n      // Merge into the main rule\n      this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n      return;\n    }\n    let dotIndex = token.indexOf('.');\n    let head;\n    let tail;\n    if (dotIndex === -1) {\n      head = token;\n      tail = '';\n    } else {\n      head = token.substring(0, dotIndex);\n      tail = token.substring(dotIndex + 1);\n    }\n    let child = this._children.get(head);\n    if (typeof child === 'undefined') {\n      child = new ThemeTrieElement(this._mainRule.clone());\n      this._children.set(head, child);\n    }\n    child.insert(tail, fontStyle, foreground, background);\n  }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n  let rules = [];\n  for (let i = 1, len = colorMap.length; i < len; i++) {\n    let color = colorMap[i];\n    rules[i] = \".mtk\".concat(i, \" { color: \").concat(color, \"; }\");\n  }\n  rules.push('.mtki { font-style: italic; }');\n  rules.push('.mtkb { font-weight: bold; }');\n  rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n  return rules.join('\\n');\n}","map":{"version":3,"names":["Color","ParsedTokenThemeRule","constructor","token","index","fontStyle","foreground","background","parseTokenTheme","source","Array","isArray","result","resultLen","i","len","length","entry","segments","split","j","lenJ","segment","resolveParsedTokenThemeRules","parsedThemeRules","customTokenColors","sort","a","b","r","strcmp","defaultFontStyle","defaultForeground","defaultBackground","incomingDefaults","shift","colorMap","ColorMap","color","getId","foregroundColorId","backgroundColorId","defaults","ThemeTrieElementRule","root","ThemeTrieElement","rule","insert","TokenTheme","colorRegExp","_lastColorId","_id2color","_color2id","Map","match","Error","toUpperCase","value","get","set","fromHex","getColorMap","slice","_colorMap","_root","_cache","createFromRawTokenTheme","createFromParsedTokenTheme","_match","languageId","standardToken","toStandardTokenType","metadata","STANDARD_TOKEN_TYPE_REGEXP","tokenType","m","_fontStyle","_foreground","_background","clone","acceptOverwrite","mainRule","_mainRule","_children","dotIndex","indexOf","head","tail","substring","child","generateTokensCSSForColorMap","rules","concat","push","join"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/modes/supports/tokenization.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Color } from '../../../../base/common/color.js';\r\nexport class ParsedTokenThemeRule {\r\n    constructor(token, index, fontStyle, foreground, background) {\r\n        this.token = token;\r\n        this.index = index;\r\n        this.fontStyle = fontStyle;\r\n        this.foreground = foreground;\r\n        this.background = background;\r\n    }\r\n}\r\n/**\r\n * Parse a raw theme into rules.\r\n */\r\nexport function parseTokenTheme(source) {\r\n    if (!source || !Array.isArray(source)) {\r\n        return [];\r\n    }\r\n    let result = [], resultLen = 0;\r\n    for (let i = 0, len = source.length; i < len; i++) {\r\n        let entry = source[i];\r\n        let fontStyle = -1 /* NotSet */;\r\n        if (typeof entry.fontStyle === 'string') {\r\n            fontStyle = 0 /* None */;\r\n            let segments = entry.fontStyle.split(' ');\r\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\r\n                let segment = segments[j];\r\n                switch (segment) {\r\n                    case 'italic':\r\n                        fontStyle = fontStyle | 1 /* Italic */;\r\n                        break;\r\n                    case 'bold':\r\n                        fontStyle = fontStyle | 2 /* Bold */;\r\n                        break;\r\n                    case 'underline':\r\n                        fontStyle = fontStyle | 4 /* Underline */;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        let foreground = null;\r\n        if (typeof entry.foreground === 'string') {\r\n            foreground = entry.foreground;\r\n        }\r\n        let background = null;\r\n        if (typeof entry.background === 'string') {\r\n            background = entry.background;\r\n        }\r\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Resolve rules (i.e. inheritance).\r\n */\r\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\r\n    // Sort rules lexicographically, and then by index if necessary\r\n    parsedThemeRules.sort((a, b) => {\r\n        let r = strcmp(a.token, b.token);\r\n        if (r !== 0) {\r\n            return r;\r\n        }\r\n        return a.index - b.index;\r\n    });\r\n    // Determine defaults\r\n    let defaultFontStyle = 0 /* None */;\r\n    let defaultForeground = '000000';\r\n    let defaultBackground = 'ffffff';\r\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\r\n        let incomingDefaults = parsedThemeRules.shift();\r\n        if (incomingDefaults.fontStyle !== -1 /* NotSet */) {\r\n            defaultFontStyle = incomingDefaults.fontStyle;\r\n        }\r\n        if (incomingDefaults.foreground !== null) {\r\n            defaultForeground = incomingDefaults.foreground;\r\n        }\r\n        if (incomingDefaults.background !== null) {\r\n            defaultBackground = incomingDefaults.background;\r\n        }\r\n    }\r\n    let colorMap = new ColorMap();\r\n    // start with token colors from custom token themes\r\n    for (let color of customTokenColors) {\r\n        colorMap.getId(color);\r\n    }\r\n    let foregroundColorId = colorMap.getId(defaultForeground);\r\n    let backgroundColorId = colorMap.getId(defaultBackground);\r\n    let defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\r\n    let root = new ThemeTrieElement(defaults);\r\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\r\n        let rule = parsedThemeRules[i];\r\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\r\n    }\r\n    return new TokenTheme(colorMap, root);\r\n}\r\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\r\nexport class ColorMap {\r\n    constructor() {\r\n        this._lastColorId = 0;\r\n        this._id2color = [];\r\n        this._color2id = new Map();\r\n    }\r\n    getId(color) {\r\n        if (color === null) {\r\n            return 0;\r\n        }\r\n        const match = color.match(colorRegExp);\r\n        if (!match) {\r\n            throw new Error('Illegal value for token color: ' + color);\r\n        }\r\n        color = match[1].toUpperCase();\r\n        let value = this._color2id.get(color);\r\n        if (value) {\r\n            return value;\r\n        }\r\n        value = ++this._lastColorId;\r\n        this._color2id.set(color, value);\r\n        this._id2color[value] = Color.fromHex('#' + color);\r\n        return value;\r\n    }\r\n    getColorMap() {\r\n        return this._id2color.slice(0);\r\n    }\r\n}\r\nexport class TokenTheme {\r\n    constructor(colorMap, root) {\r\n        this._colorMap = colorMap;\r\n        this._root = root;\r\n        this._cache = new Map();\r\n    }\r\n    static createFromRawTokenTheme(source, customTokenColors) {\r\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\r\n    }\r\n    static createFromParsedTokenTheme(source, customTokenColors) {\r\n        return resolveParsedTokenThemeRules(source, customTokenColors);\r\n    }\r\n    getColorMap() {\r\n        return this._colorMap.getColorMap();\r\n    }\r\n    _match(token) {\r\n        return this._root.match(token);\r\n    }\r\n    match(languageId, token) {\r\n        // The cache contains the metadata without the language bits set.\r\n        let result = this._cache.get(token);\r\n        if (typeof result === 'undefined') {\r\n            let rule = this._match(token);\r\n            let standardToken = toStandardTokenType(token);\r\n            result = (rule.metadata\r\n                | (standardToken << 8 /* TOKEN_TYPE_OFFSET */)) >>> 0;\r\n            this._cache.set(token, result);\r\n        }\r\n        return (result\r\n            | (languageId << 0 /* LANGUAGEID_OFFSET */)) >>> 0;\r\n    }\r\n}\r\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\r\nexport function toStandardTokenType(tokenType) {\r\n    let m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\r\n    if (!m) {\r\n        return 0 /* Other */;\r\n    }\r\n    switch (m[1]) {\r\n        case 'comment':\r\n            return 1 /* Comment */;\r\n        case 'string':\r\n            return 2 /* String */;\r\n        case 'regex':\r\n            return 4 /* RegEx */;\r\n        case 'regexp':\r\n            return 4 /* RegEx */;\r\n    }\r\n    throw new Error('Unexpected match for standard token type!');\r\n}\r\nexport function strcmp(a, b) {\r\n    if (a < b) {\r\n        return -1;\r\n    }\r\n    if (a > b) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nexport class ThemeTrieElementRule {\r\n    constructor(fontStyle, foreground, background) {\r\n        this._fontStyle = fontStyle;\r\n        this._foreground = foreground;\r\n        this._background = background;\r\n        this.metadata = ((this._fontStyle << 11 /* FONT_STYLE_OFFSET */)\r\n            | (this._foreground << 14 /* FOREGROUND_OFFSET */)\r\n            | (this._background << 23 /* BACKGROUND_OFFSET */)) >>> 0;\r\n    }\r\n    clone() {\r\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\r\n    }\r\n    acceptOverwrite(fontStyle, foreground, background) {\r\n        if (fontStyle !== -1 /* NotSet */) {\r\n            this._fontStyle = fontStyle;\r\n        }\r\n        if (foreground !== 0 /* None */) {\r\n            this._foreground = foreground;\r\n        }\r\n        if (background !== 0 /* None */) {\r\n            this._background = background;\r\n        }\r\n        this.metadata = ((this._fontStyle << 11 /* FONT_STYLE_OFFSET */)\r\n            | (this._foreground << 14 /* FOREGROUND_OFFSET */)\r\n            | (this._background << 23 /* BACKGROUND_OFFSET */)) >>> 0;\r\n    }\r\n}\r\nexport class ThemeTrieElement {\r\n    constructor(mainRule) {\r\n        this._mainRule = mainRule;\r\n        this._children = new Map();\r\n    }\r\n    match(token) {\r\n        if (token === '') {\r\n            return this._mainRule;\r\n        }\r\n        let dotIndex = token.indexOf('.');\r\n        let head;\r\n        let tail;\r\n        if (dotIndex === -1) {\r\n            head = token;\r\n            tail = '';\r\n        }\r\n        else {\r\n            head = token.substring(0, dotIndex);\r\n            tail = token.substring(dotIndex + 1);\r\n        }\r\n        let child = this._children.get(head);\r\n        if (typeof child !== 'undefined') {\r\n            return child.match(tail);\r\n        }\r\n        return this._mainRule;\r\n    }\r\n    insert(token, fontStyle, foreground, background) {\r\n        if (token === '') {\r\n            // Merge into the main rule\r\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\r\n            return;\r\n        }\r\n        let dotIndex = token.indexOf('.');\r\n        let head;\r\n        let tail;\r\n        if (dotIndex === -1) {\r\n            head = token;\r\n            tail = '';\r\n        }\r\n        else {\r\n            head = token.substring(0, dotIndex);\r\n            tail = token.substring(dotIndex + 1);\r\n        }\r\n        let child = this._children.get(head);\r\n        if (typeof child === 'undefined') {\r\n            child = new ThemeTrieElement(this._mainRule.clone());\r\n            this._children.set(head, child);\r\n        }\r\n        child.insert(tail, fontStyle, foreground, background);\r\n    }\r\n}\r\nexport function generateTokensCSSForColorMap(colorMap) {\r\n    let rules = [];\r\n    for (let i = 1, len = colorMap.length; i < len; i++) {\r\n        let color = colorMap[i];\r\n        rules[i] = `.mtk${i} { color: ${color}; }`;\r\n    }\r\n    rules.push('.mtki { font-style: italic; }');\r\n    rules.push('.mtkb { font-weight: bold; }');\r\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\r\n    return rules.join('\\n');\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}