{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport * as viewEvents from '../view/viewEvents.js';\nimport { PrefixSumIndexOfResult } from './prefixSumComputer.js';\nimport { LineBreakData, ViewLineData } from './viewModel.js';\nexport class CoordinatesConverter {\n  constructor(lines) {\n    this._lines = lines;\n  }\n  // View -> Model conversion and related methods\n  convertViewPositionToModelPosition(viewPosition) {\n    return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n  }\n  convertViewRangeToModelRange(viewRange) {\n    return this._lines.convertViewRangeToModelRange(viewRange);\n  }\n  validateViewPosition(viewPosition, expectedModelPosition) {\n    return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n  }\n  validateViewRange(viewRange, expectedModelRange) {\n    return this._lines.validateViewRange(viewRange, expectedModelRange);\n  }\n  // Model -> View conversion and related methods\n  convertModelPositionToViewPosition(modelPosition) {\n    return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);\n  }\n  convertModelRangeToViewRange(modelRange) {\n    return this._lines.convertModelRangeToViewRange(modelRange);\n  }\n  modelPositionIsVisible(modelPosition) {\n    return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n  }\n  getModelLineViewLineCount(modelLineNumber) {\n    return this._lines.getModelLineViewLineCount(modelLineNumber);\n  }\n}\nclass LineNumberMapper {\n  constructor(viewLineCounts) {\n    this._counts = viewLineCounts;\n    this._isValid = false;\n    this._validEndIndex = -1;\n    this._modelToView = [];\n    this._viewToModel = [];\n  }\n  _invalidate(index) {\n    this._isValid = false;\n    this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n  }\n  _ensureValid() {\n    if (this._isValid) {\n      return;\n    }\n    for (let i = this._validEndIndex + 1, len = this._counts.length; i < len; i++) {\n      const viewLineCount = this._counts[i];\n      const viewLinesAbove = i > 0 ? this._modelToView[i - 1] : 0;\n      this._modelToView[i] = viewLinesAbove + viewLineCount;\n      for (let j = 0; j < viewLineCount; j++) {\n        this._viewToModel[viewLinesAbove + j] = i;\n      }\n    }\n    // trim things\n    this._modelToView.length = this._counts.length;\n    this._viewToModel.length = this._modelToView[this._modelToView.length - 1];\n    // mark as valid\n    this._isValid = true;\n    this._validEndIndex = this._counts.length - 1;\n  }\n  changeValue(index, value) {\n    if (this._counts[index] === value) {\n      // no change\n      return;\n    }\n    this._counts[index] = value;\n    this._invalidate(index);\n  }\n  removeValues(start, deleteCount) {\n    this._counts.splice(start, deleteCount);\n    this._invalidate(start);\n  }\n  insertValues(insertIndex, insertArr) {\n    this._counts = arrays.arrayInsert(this._counts, insertIndex, insertArr);\n    this._invalidate(insertIndex);\n  }\n  getTotalValue() {\n    this._ensureValid();\n    return this._viewToModel.length;\n  }\n  getAccumulatedValue(index) {\n    this._ensureValid();\n    return this._modelToView[index];\n  }\n  getIndexOf(accumulatedValue) {\n    this._ensureValid();\n    const modelLineIndex = this._viewToModel[accumulatedValue];\n    const viewLinesAbove = modelLineIndex > 0 ? this._modelToView[modelLineIndex - 1] : 0;\n    return new PrefixSumIndexOfResult(modelLineIndex, accumulatedValue - viewLinesAbove);\n  }\n}\nexport class SplitLinesCollection {\n  constructor(model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\n    this.model = model;\n    this._validModelVersionId = -1;\n    this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n    this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n    this.fontInfo = fontInfo;\n    this.tabSize = tabSize;\n    this.wrappingStrategy = wrappingStrategy;\n    this.wrappingColumn = wrappingColumn;\n    this.wrappingIndent = wrappingIndent;\n    this._constructLines( /*resetHiddenAreas*/true, null);\n  }\n  dispose() {\n    this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);\n  }\n  createCoordinatesConverter() {\n    return new CoordinatesConverter(this);\n  }\n  _constructLines(resetHiddenAreas, previousLineBreaks) {\n    this.lines = [];\n    if (resetHiddenAreas) {\n      this.hiddenAreasIds = [];\n    }\n    let linesContent = this.model.getLinesContent();\n    const lineCount = linesContent.length;\n    const lineBreaksComputer = this.createLineBreaksComputer();\n    for (let i = 0; i < lineCount; i++) {\n      lineBreaksComputer.addRequest(linesContent[i], previousLineBreaks ? previousLineBreaks[i] : null);\n    }\n    const linesBreaks = lineBreaksComputer.finalize();\n    let values = [];\n    let hiddenAreas = this.hiddenAreasIds.map(areaId => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n    let hiddenAreaStart = 1,\n      hiddenAreaEnd = 0;\n    let hiddenAreaIdx = -1;\n    let nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n    for (let i = 0; i < lineCount; i++) {\n      let lineNumber = i + 1;\n      if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n        hiddenAreaIdx++;\n        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n      }\n      let isInHiddenArea = lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd;\n      let line = createSplitLine(linesBreaks[i], !isInHiddenArea);\n      values[i] = line.getViewLineCount();\n      this.lines[i] = line;\n    }\n    this._validModelVersionId = this.model.getVersionId();\n    this.prefixSumComputer = new LineNumberMapper(values);\n  }\n  getHiddenAreas() {\n    return this.hiddenAreasIds.map(decId => {\n      return this.model.getDecorationRange(decId);\n    });\n  }\n  _reduceRanges(_ranges) {\n    if (_ranges.length === 0) {\n      return [];\n    }\n    let ranges = _ranges.map(r => this.model.validateRange(r)).sort(Range.compareRangesUsingStarts);\n    let result = [];\n    let currentRangeStart = ranges[0].startLineNumber;\n    let currentRangeEnd = ranges[0].endLineNumber;\n    for (let i = 1, len = ranges.length; i < len; i++) {\n      let range = ranges[i];\n      if (range.startLineNumber > currentRangeEnd + 1) {\n        result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n        currentRangeStart = range.startLineNumber;\n        currentRangeEnd = range.endLineNumber;\n      } else if (range.endLineNumber > currentRangeEnd) {\n        currentRangeEnd = range.endLineNumber;\n      }\n    }\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n  }\n  setHiddenAreas(_ranges) {\n    let newRanges = this._reduceRanges(_ranges);\n    // BEGIN TODO@Martin: Please stop calling this method on each model change!\n    let oldRanges = this.hiddenAreasIds.map(areaId => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n    if (newRanges.length === oldRanges.length) {\n      let hasDifference = false;\n      for (let i = 0; i < newRanges.length; i++) {\n        if (!newRanges[i].equalsRange(oldRanges[i])) {\n          hasDifference = true;\n          break;\n        }\n      }\n      if (!hasDifference) {\n        return false;\n      }\n    }\n    // END TODO@Martin: Please stop calling this method on each model change!\n    let newDecorations = [];\n    for (const newRange of newRanges) {\n      newDecorations.push({\n        range: newRange,\n        options: ModelDecorationOptions.EMPTY\n      });\n    }\n    this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);\n    let hiddenAreas = newRanges;\n    let hiddenAreaStart = 1,\n      hiddenAreaEnd = 0;\n    let hiddenAreaIdx = -1;\n    let nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.lines.length + 2;\n    let hasVisibleLine = false;\n    for (let i = 0; i < this.lines.length; i++) {\n      let lineNumber = i + 1;\n      if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n        hiddenAreaIdx++;\n        hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n        hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n        nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.lines.length + 2;\n      }\n      let lineChanged = false;\n      if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n        // Line should be hidden\n        if (this.lines[i].isVisible()) {\n          this.lines[i] = this.lines[i].setVisible(false);\n          lineChanged = true;\n        }\n      } else {\n        hasVisibleLine = true;\n        // Line should be visible\n        if (!this.lines[i].isVisible()) {\n          this.lines[i] = this.lines[i].setVisible(true);\n          lineChanged = true;\n        }\n      }\n      if (lineChanged) {\n        let newOutputLineCount = this.lines[i].getViewLineCount();\n        this.prefixSumComputer.changeValue(i, newOutputLineCount);\n      }\n    }\n    if (!hasVisibleLine) {\n      // Cannot have everything be hidden => reveal everything!\n      this.setHiddenAreas([]);\n    }\n    return true;\n  }\n  modelPositionIsVisible(modelLineNumber, _modelColumn) {\n    if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n      // invalid arguments\n      return false;\n    }\n    return this.lines[modelLineNumber - 1].isVisible();\n  }\n  getModelLineViewLineCount(modelLineNumber) {\n    if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n      // invalid arguments\n      return 1;\n    }\n    return this.lines[modelLineNumber - 1].getViewLineCount();\n  }\n  setTabSize(newTabSize) {\n    if (this.tabSize === newTabSize) {\n      return false;\n    }\n    this.tabSize = newTabSize;\n    this._constructLines( /*resetHiddenAreas*/false, null);\n    return true;\n  }\n  setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\n    const equalFontInfo = this.fontInfo.equals(fontInfo);\n    const equalWrappingStrategy = this.wrappingStrategy === wrappingStrategy;\n    const equalWrappingColumn = this.wrappingColumn === wrappingColumn;\n    const equalWrappingIndent = this.wrappingIndent === wrappingIndent;\n    if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\n      return false;\n    }\n    const onlyWrappingColumnChanged = equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent;\n    this.fontInfo = fontInfo;\n    this.wrappingStrategy = wrappingStrategy;\n    this.wrappingColumn = wrappingColumn;\n    this.wrappingIndent = wrappingIndent;\n    let previousLineBreaks = null;\n    if (onlyWrappingColumnChanged) {\n      previousLineBreaks = [];\n      for (let i = 0, len = this.lines.length; i < len; i++) {\n        previousLineBreaks[i] = this.lines[i].getLineBreakData();\n      }\n    }\n    this._constructLines( /*resetHiddenAreas*/false, previousLineBreaks);\n    return true;\n  }\n  createLineBreaksComputer() {\n    const lineBreaksComputerFactory = this.wrappingStrategy === 'advanced' ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory;\n    return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\n  }\n  onModelFlushed() {\n    this._constructLines( /*resetHiddenAreas*/true, null);\n  }\n  onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n    if (versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return null;\n    }\n    let outputFromLineNumber = fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1;\n    let outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);\n    this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n    this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n    return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n  }\n  onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n    if (versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return null;\n    }\n    // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n    const isInHiddenArea = fromLineNumber > 2 && !this.lines[fromLineNumber - 2].isVisible();\n    let outputFromLineNumber = fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1;\n    let totalOutputLineCount = 0;\n    let insertLines = [];\n    let insertPrefixSumValues = [];\n    for (let i = 0, len = lineBreaks.length; i < len; i++) {\n      let line = createSplitLine(lineBreaks[i], !isInHiddenArea);\n      insertLines.push(line);\n      let outputLineCount = line.getViewLineCount();\n      totalOutputLineCount += outputLineCount;\n      insertPrefixSumValues[i] = outputLineCount;\n    }\n    // TODO@Alex: use arrays.arrayInsert\n    this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));\n    this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n    return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n  }\n  onModelLineChanged(versionId, lineNumber, lineBreakData) {\n    if (versionId <= this._validModelVersionId) {\n      // Here we check for versionId in case the lines were reconstructed in the meantime.\n      // We don't want to apply stale change events on top of a newer read model state.\n      return [false, null, null, null];\n    }\n    let lineIndex = lineNumber - 1;\n    let oldOutputLineCount = this.lines[lineIndex].getViewLineCount();\n    let isVisible = this.lines[lineIndex].isVisible();\n    let line = createSplitLine(lineBreakData, isVisible);\n    this.lines[lineIndex] = line;\n    let newOutputLineCount = this.lines[lineIndex].getViewLineCount();\n    let lineMappingChanged = false;\n    let changeFrom = 0;\n    let changeTo = -1;\n    let insertFrom = 0;\n    let insertTo = -1;\n    let deleteFrom = 0;\n    let deleteTo = -1;\n    if (oldOutputLineCount > newOutputLineCount) {\n      changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;\n      changeTo = changeFrom + newOutputLineCount - 1;\n      deleteFrom = changeTo + 1;\n      deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n      lineMappingChanged = true;\n    } else if (oldOutputLineCount < newOutputLineCount) {\n      changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;\n      changeTo = changeFrom + oldOutputLineCount - 1;\n      insertFrom = changeTo + 1;\n      insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n      lineMappingChanged = true;\n    } else {\n      changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;\n      changeTo = changeFrom + newOutputLineCount - 1;\n    }\n    this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);\n    const viewLinesChangedEvent = changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null;\n    const viewLinesInsertedEvent = insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null;\n    const viewLinesDeletedEvent = deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null;\n    return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n  }\n  acceptVersionId(versionId) {\n    this._validModelVersionId = versionId;\n    if (this.lines.length === 1 && !this.lines[0].isVisible()) {\n      // At least one line must be visible => reset hidden areas\n      this.setHiddenAreas([]);\n    }\n  }\n  getViewLineCount() {\n    return this.prefixSumComputer.getTotalValue();\n  }\n  _toValidViewLineNumber(viewLineNumber) {\n    if (viewLineNumber < 1) {\n      return 1;\n    }\n    const viewLineCount = this.getViewLineCount();\n    if (viewLineNumber > viewLineCount) {\n      return viewLineCount;\n    }\n    return viewLineNumber | 0;\n  }\n  getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    minLineNumber = this._toValidViewLineNumber(minLineNumber);\n    maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n    const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n    const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n    const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n    const result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n    const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n    const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n    return {\n      startLineNumber: viewStartPosition.lineNumber,\n      endLineNumber: viewEndPosition.lineNumber,\n      indent: result.indent\n    };\n  }\n  getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n    const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n    const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n    let result = [];\n    let resultRepeatCount = [];\n    let resultRepeatOption = [];\n    const modelStartLineIndex = modelStart.lineNumber - 1;\n    const modelEndLineIndex = modelEnd.lineNumber - 1;\n    let reqStart = null;\n    for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n      const line = this.lines[modelLineIndex];\n      if (line.isVisible()) {\n        let viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n        let viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n        let count = viewLineEndIndex - viewLineStartIndex + 1;\n        let option = 0 /* BlockNone */;\n        if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n          // wrapped lines should block indent guides\n          option = viewLineStartIndex === 0 ? 1 /* BlockSubsequent */ : 2 /* BlockAll */;\n        }\n\n        resultRepeatCount.push(count);\n        resultRepeatOption.push(option);\n        // merge into previous request\n        if (reqStart === null) {\n          reqStart = new Position(modelLineIndex + 1, 0);\n        }\n      } else {\n        // hit invisible line => flush request\n        if (reqStart !== null) {\n          result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n          reqStart = null;\n        }\n      }\n    }\n    if (reqStart !== null) {\n      result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n      reqStart = null;\n    }\n    const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n    let viewIndents = new Array(viewLineCount);\n    let currIndex = 0;\n    for (let i = 0, len = result.length; i < len; i++) {\n      let value = result[i];\n      let count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n      let option = resultRepeatOption[i];\n      let blockAtIndex;\n      if (option === 2 /* BlockAll */) {\n        blockAtIndex = 0;\n      } else if (option === 1 /* BlockSubsequent */) {\n        blockAtIndex = 1;\n      } else {\n        blockAtIndex = count;\n      }\n      for (let j = 0; j < count; j++) {\n        if (j === blockAtIndex) {\n          value = 0;\n        }\n        viewIndents[currIndex++] = value;\n      }\n    }\n    return viewIndents;\n  }\n  getViewLineContent(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);\n  }\n  getViewLineLength(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);\n  }\n  getViewLineMinColumn(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n  }\n  getViewLineMaxColumn(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n  }\n  getViewLineData(viewLineNumber) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    return this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);\n  }\n  getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n    viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n    viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n    let start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);\n    let viewLineNumber = viewStartLineNumber;\n    let startModelLineIndex = start.index;\n    let startRemainder = start.remainder;\n    let result = [];\n    for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n      let line = this.lines[modelLineIndex];\n      if (!line.isVisible()) {\n        continue;\n      }\n      let fromViewLineIndex = modelLineIndex === startModelLineIndex ? startRemainder : 0;\n      let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n      let lastLine = false;\n      if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n        lastLine = true;\n        remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n      }\n      let toViewLineIndex = fromViewLineIndex + remainingViewLineCount;\n      line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);\n      viewLineNumber += remainingViewLineCount;\n      if (lastLine) {\n        break;\n      }\n    }\n    return result;\n  }\n  validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    let line = this.lines[lineIndex];\n    let minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n    let maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n    if (viewColumn < minColumn) {\n      viewColumn = minColumn;\n    }\n    if (viewColumn > maxColumn) {\n      viewColumn = maxColumn;\n    }\n    let computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n    let computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n    if (computedModelPosition.equals(expectedModelPosition)) {\n      return new Position(viewLineNumber, viewColumn);\n    }\n    return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n  }\n  validateViewRange(viewRange, expectedModelRange) {\n    const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n    const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n    return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n  }\n  convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n    viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n    let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n    let lineIndex = r.index;\n    let remainder = r.remainder;\n    let inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn);\n    // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n    return this.model.validatePosition(new Position(lineIndex + 1, inputColumn));\n  }\n  convertViewRangeToModelRange(viewRange) {\n    const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n    const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n  convertModelPositionToViewPosition(_modelLineNumber, _modelColumn) {\n    const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n    const inputLineNumber = validPosition.lineNumber;\n    const inputColumn = validPosition.column;\n    let lineIndex = inputLineNumber - 1,\n      lineIndexChanged = false;\n    while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n      lineIndex--;\n      lineIndexChanged = true;\n    }\n    if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n      // Could not reach a real line\n      // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n      return new Position(1, 1);\n    }\n    const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n    let r;\n    if (lineIndexChanged) {\n      r = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    } else {\n      r = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn);\n    }\n    // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n    return r;\n  }\n  convertModelRangeToViewRange(modelRange) {\n    let start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);\n    let end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);\n    if (modelRange.startLineNumber === modelRange.endLineNumber && start.lineNumber !== end.lineNumber) {\n      // This is a single line range that ends up taking more lines due to wrapping\n      if (end.column === this.getViewLineMinColumn(end.lineNumber)) {\n        // the end column lands on the first column of the next line\n        return new Range(start.lineNumber, start.column, end.lineNumber - 1, this.getViewLineMaxColumn(end.lineNumber - 1));\n      }\n    }\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n  _getViewLineNumberForModelPosition(inputLineNumber, inputColumn) {\n    let lineIndex = inputLineNumber - 1;\n    if (this.lines[lineIndex].isVisible()) {\n      // this model line is visible\n      const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n      return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn);\n    }\n    // this model line is not visible\n    while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n      lineIndex--;\n    }\n    if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n      // Could not reach a real line\n      return 1;\n    }\n    const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n    return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n  }\n  getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {\n    const decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n    const result = new OverviewRulerDecorations();\n    for (const decoration of decorations) {\n      const opts = decoration.options.overviewRuler;\n      const lane = opts ? opts.position : 0;\n      if (lane === 0) {\n        continue;\n      }\n      const color = opts.getColor(theme);\n      const viewStartLineNumber = this._getViewLineNumberForModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n      const viewEndLineNumber = this._getViewLineNumberForModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n      result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n    }\n    return result.result;\n  }\n  getDecorationsInRange(range, ownerId, filterOutValidation) {\n    const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n    const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n    if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n      // most likely there are no hidden lines => fast path\n      // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n      return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n    }\n    let result = [];\n    const modelStartLineIndex = modelStart.lineNumber - 1;\n    const modelEndLineIndex = modelEnd.lineNumber - 1;\n    let reqStart = null;\n    for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n      const line = this.lines[modelLineIndex];\n      if (line.isVisible()) {\n        // merge into previous request\n        if (reqStart === null) {\n          reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n        }\n      } else {\n        // hit invisible line => flush request\n        if (reqStart !== null) {\n          const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n          result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n          reqStart = null;\n        }\n      }\n    }\n    if (reqStart !== null) {\n      result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n      reqStart = null;\n    }\n    result.sort((a, b) => {\n      const res = Range.compareRangesUsingStarts(a.range, b.range);\n      if (res === 0) {\n        if (a.id < b.id) {\n          return -1;\n        }\n        if (a.id > b.id) {\n          return 1;\n        }\n        return 0;\n      }\n      return res;\n    });\n    // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n    let finalResult = [],\n      finalResultLen = 0;\n    let prevDecId = null;\n    for (const dec of result) {\n      const decId = dec.id;\n      if (prevDecId === decId) {\n        // skip\n        continue;\n      }\n      prevDecId = decId;\n      finalResult[finalResultLen++] = dec;\n    }\n    return finalResult;\n  }\n}\nclass VisibleIdentitySplitLine {\n  constructor() {}\n  isVisible() {\n    return true;\n  }\n  setVisible(isVisible) {\n    if (isVisible) {\n      return this;\n    }\n    return InvisibleIdentitySplitLine.INSTANCE;\n  }\n  getLineBreakData() {\n    return null;\n  }\n  getViewLineCount() {\n    return 1;\n  }\n  getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n    return model.getLineContent(modelLineNumber);\n  }\n  getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n    return model.getLineLength(modelLineNumber);\n  }\n  getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n    return model.getLineMinColumn(modelLineNumber);\n  }\n  getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n    return model.getLineMaxColumn(modelLineNumber);\n  }\n  getViewLineData(model, modelLineNumber, _outputLineIndex) {\n    let lineTokens = model.getLineTokens(modelLineNumber);\n    let lineContent = lineTokens.getLineContent();\n    return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate());\n  }\n  getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n    if (!needed[globalStartIndex]) {\n      result[globalStartIndex] = null;\n      return;\n    }\n    result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n  }\n  getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n    return outputColumn;\n  }\n  getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n    return new Position(deltaLineNumber, inputColumn);\n  }\n  getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n    return deltaLineNumber;\n  }\n}\nVisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();\nclass InvisibleIdentitySplitLine {\n  constructor() {}\n  isVisible() {\n    return false;\n  }\n  setVisible(isVisible) {\n    if (!isVisible) {\n      return this;\n    }\n    return VisibleIdentitySplitLine.INSTANCE;\n  }\n  getLineBreakData() {\n    return null;\n  }\n  getViewLineCount() {\n    return 0;\n  }\n  getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n  getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n  getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n  getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n  getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n    throw new Error('Not supported');\n  }\n  getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n    throw new Error('Not supported');\n  }\n  getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n    throw new Error('Not supported');\n  }\n  getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n    throw new Error('Not supported');\n  }\n  getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n    throw new Error('Not supported');\n  }\n}\nInvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();\nexport class SplitLine {\n  constructor(lineBreakData, isVisible) {\n    this._lineBreakData = lineBreakData;\n    this._isVisible = isVisible;\n  }\n  isVisible() {\n    return this._isVisible;\n  }\n  setVisible(isVisible) {\n    this._isVisible = isVisible;\n    return this;\n  }\n  getLineBreakData() {\n    return this._lineBreakData;\n  }\n  getViewLineCount() {\n    if (!this._isVisible) {\n      return 0;\n    }\n    return this._lineBreakData.breakOffsets.length;\n  }\n  getInputStartOffsetOfOutputLineIndex(outputLineIndex) {\n    return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex, 0);\n  }\n  getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex) {\n    if (outputLineIndex + 1 === this._lineBreakData.breakOffsets.length) {\n      return model.getLineMaxColumn(modelLineNumber) - 1;\n    }\n    return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex + 1, 0);\n  }\n  getViewLineContent(model, modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n    let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n    let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n    let r = model.getValueInRange({\n      startLineNumber: modelLineNumber,\n      startColumn: startOffset + 1,\n      endLineNumber: modelLineNumber,\n      endColumn: endOffset + 1\n    });\n    if (outputLineIndex > 0) {\n      r = spaces(this._lineBreakData.wrappedTextIndentLength) + r;\n    }\n    return r;\n  }\n  getViewLineLength(model, modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n    let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n    let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n    let r = endOffset - startOffset;\n    if (outputLineIndex > 0) {\n      r = this._lineBreakData.wrappedTextIndentLength + r;\n    }\n    return r;\n  }\n  getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n    if (outputLineIndex > 0) {\n      return this._lineBreakData.wrappedTextIndentLength + 1;\n    }\n    return 1;\n  }\n  getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n    return this.getViewLineContent(model, modelLineNumber, outputLineIndex).length + 1;\n  }\n  getViewLineData(model, modelLineNumber, outputLineIndex) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n    let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n    let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n    let lineContent = model.getValueInRange({\n      startLineNumber: modelLineNumber,\n      startColumn: startOffset + 1,\n      endLineNumber: modelLineNumber,\n      endColumn: endOffset + 1\n    });\n    if (outputLineIndex > 0) {\n      lineContent = spaces(this._lineBreakData.wrappedTextIndentLength) + lineContent;\n    }\n    let minColumn = outputLineIndex > 0 ? this._lineBreakData.wrappedTextIndentLength + 1 : 1;\n    let maxColumn = lineContent.length + 1;\n    let continuesWithWrappedLine = outputLineIndex + 1 < this.getViewLineCount();\n    let deltaStartIndex = 0;\n    if (outputLineIndex > 0) {\n      deltaStartIndex = this._lineBreakData.wrappedTextIndentLength;\n    }\n    let lineTokens = model.getLineTokens(modelLineNumber);\n    const startVisibleColumn = outputLineIndex === 0 ? 0 : this._lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1];\n    return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex));\n  }\n  getViewLinesData(model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n    for (let outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {\n      let globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;\n      if (!needed[globalIndex]) {\n        result[globalIndex] = null;\n        continue;\n      }\n      result[globalIndex] = this.getViewLineData(model, modelLineNumber, outputLineIndex);\n    }\n  }\n  getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n    let adjustedColumn = outputColumn - 1;\n    if (outputLineIndex > 0) {\n      if (adjustedColumn < this._lineBreakData.wrappedTextIndentLength) {\n        adjustedColumn = 0;\n      } else {\n        adjustedColumn -= this._lineBreakData.wrappedTextIndentLength;\n      }\n    }\n    return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex, adjustedColumn) + 1;\n  }\n  getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n    let r = LineBreakData.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, inputColumn - 1);\n    let outputLineIndex = r.outputLineIndex;\n    let outputColumn = r.outputOffset + 1;\n    if (outputLineIndex > 0) {\n      outputColumn += this._lineBreakData.wrappedTextIndentLength;\n    }\n    //\t\tconsole.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);\n    return new Position(deltaLineNumber + outputLineIndex, outputColumn);\n  }\n  getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n    if (!this._isVisible) {\n      throw new Error('Not supported');\n    }\n    const r = LineBreakData.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, inputColumn - 1);\n    return deltaLineNumber + r.outputLineIndex;\n  }\n}\nlet _spaces = [''];\nfunction spaces(count) {\n  if (count >= _spaces.length) {\n    for (let i = 1; i <= count; i++) {\n      _spaces[i] = _makeSpaces(i);\n    }\n  }\n  return _spaces[count];\n}\nfunction _makeSpaces(count) {\n  return new Array(count + 1).join(' ');\n}\nfunction createSplitLine(lineBreakData, isVisible) {\n  if (lineBreakData === null) {\n    // No mapping needed\n    if (isVisible) {\n      return VisibleIdentitySplitLine.INSTANCE;\n    }\n    return InvisibleIdentitySplitLine.INSTANCE;\n  } else {\n    return new SplitLine(lineBreakData, isVisible);\n  }\n}\nexport class IdentityCoordinatesConverter {\n  constructor(lines) {\n    this._lines = lines;\n  }\n  _validPosition(pos) {\n    return this._lines.model.validatePosition(pos);\n  }\n  _validRange(range) {\n    return this._lines.model.validateRange(range);\n  }\n  // View -> Model conversion and related methods\n  convertViewPositionToModelPosition(viewPosition) {\n    return this._validPosition(viewPosition);\n  }\n  convertViewRangeToModelRange(viewRange) {\n    return this._validRange(viewRange);\n  }\n  validateViewPosition(_viewPosition, expectedModelPosition) {\n    return this._validPosition(expectedModelPosition);\n  }\n  validateViewRange(_viewRange, expectedModelRange) {\n    return this._validRange(expectedModelRange);\n  }\n  // Model -> View conversion and related methods\n  convertModelPositionToViewPosition(modelPosition) {\n    return this._validPosition(modelPosition);\n  }\n  convertModelRangeToViewRange(modelRange) {\n    return this._validRange(modelRange);\n  }\n  modelPositionIsVisible(modelPosition) {\n    const lineCount = this._lines.model.getLineCount();\n    if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n      // invalid arguments\n      return false;\n    }\n    return true;\n  }\n  getModelLineViewLineCount(modelLineNumber) {\n    return 1;\n  }\n}\nexport class IdentityLinesCollection {\n  constructor(model) {\n    this.model = model;\n  }\n  dispose() {}\n  createCoordinatesConverter() {\n    return new IdentityCoordinatesConverter(this);\n  }\n  getHiddenAreas() {\n    return [];\n  }\n  setHiddenAreas(_ranges) {\n    return false;\n  }\n  setTabSize(_newTabSize) {\n    return false;\n  }\n  setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n    return false;\n  }\n  createLineBreaksComputer() {\n    let result = [];\n    return {\n      addRequest: (lineText, previousLineBreakData) => {\n        result.push(null);\n      },\n      finalize: () => {\n        return result;\n      }\n    };\n  }\n  onModelFlushed() {}\n  onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n    return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n  }\n  onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n    return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n  }\n  onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n    return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n  }\n  acceptVersionId(_versionId) {}\n  getViewLineCount() {\n    return this.model.getLineCount();\n  }\n  getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n    return {\n      startLineNumber: viewLineNumber,\n      endLineNumber: viewLineNumber,\n      indent: 0\n    };\n  }\n  getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n    const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n    let result = new Array(viewLineCount);\n    for (let i = 0; i < viewLineCount; i++) {\n      result[i] = 0;\n    }\n    return result;\n  }\n  getViewLineContent(viewLineNumber) {\n    return this.model.getLineContent(viewLineNumber);\n  }\n  getViewLineLength(viewLineNumber) {\n    return this.model.getLineLength(viewLineNumber);\n  }\n  getViewLineMinColumn(viewLineNumber) {\n    return this.model.getLineMinColumn(viewLineNumber);\n  }\n  getViewLineMaxColumn(viewLineNumber) {\n    return this.model.getLineMaxColumn(viewLineNumber);\n  }\n  getViewLineData(viewLineNumber) {\n    let lineTokens = this.model.getLineTokens(viewLineNumber);\n    let lineContent = lineTokens.getLineContent();\n    return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate());\n  }\n  getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n    const lineCount = this.model.getLineCount();\n    viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n    viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n    let result = [];\n    for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n      let idx = lineNumber - viewStartLineNumber;\n      if (!needed[idx]) {\n        result[idx] = null;\n      }\n      result[idx] = this.getViewLineData(lineNumber);\n    }\n    return result;\n  }\n  getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {\n    const decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n    const result = new OverviewRulerDecorations();\n    for (const decoration of decorations) {\n      const opts = decoration.options.overviewRuler;\n      const lane = opts ? opts.position : 0;\n      if (lane === 0) {\n        continue;\n      }\n      const color = opts.getColor(theme);\n      const viewStartLineNumber = decoration.range.startLineNumber;\n      const viewEndLineNumber = decoration.range.endLineNumber;\n      result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n    }\n    return result.result;\n  }\n  getDecorationsInRange(range, ownerId, filterOutValidation) {\n    return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n  }\n}\nclass OverviewRulerDecorations {\n  constructor() {\n    this.result = Object.create(null);\n  }\n  accept(color, startLineNumber, endLineNumber, lane) {\n    let prev = this.result[color];\n    if (prev) {\n      const prevLane = prev[prev.length - 3];\n      const prevEndLineNumber = prev[prev.length - 1];\n      if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n        // merge into prev\n        if (endLineNumber > prevEndLineNumber) {\n          prev[prev.length - 1] = endLineNumber;\n        }\n        return;\n      }\n      // push\n      prev.push(lane, startLineNumber, endLineNumber);\n    } else {\n      this.result[color] = [lane, startLineNumber, endLineNumber];\n    }\n  }\n}","map":{"version":3,"names":["arrays","Position","Range","ModelDecorationOptions","viewEvents","PrefixSumIndexOfResult","LineBreakData","ViewLineData","CoordinatesConverter","constructor","lines","_lines","convertViewPositionToModelPosition","viewPosition","lineNumber","column","convertViewRangeToModelRange","viewRange","validateViewPosition","expectedModelPosition","validateViewRange","expectedModelRange","convertModelPositionToViewPosition","modelPosition","convertModelRangeToViewRange","modelRange","modelPositionIsVisible","getModelLineViewLineCount","modelLineNumber","LineNumberMapper","viewLineCounts","_counts","_isValid","_validEndIndex","_modelToView","_viewToModel","_invalidate","index","Math","min","_ensureValid","i","len","length","viewLineCount","viewLinesAbove","j","changeValue","value","removeValues","start","deleteCount","splice","insertValues","insertIndex","insertArr","arrayInsert","getTotalValue","getAccumulatedValue","getIndexOf","accumulatedValue","modelLineIndex","SplitLinesCollection","model","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","fontInfo","tabSize","wrappingStrategy","wrappingColumn","wrappingIndent","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","dispose","hiddenAreasIds","deltaDecorations","createCoordinatesConverter","resetHiddenAreas","previousLineBreaks","linesContent","getLinesContent","lineCount","lineBreaksComputer","createLineBreaksComputer","addRequest","linesBreaks","finalize","values","hiddenAreas","map","areaId","getDecorationRange","sort","compareRangesUsingStarts","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","startLineNumber","endLineNumber","isInHiddenArea","line","createSplitLine","getViewLineCount","getVersionId","prefixSumComputer","getHiddenAreas","decId","_reduceRanges","_ranges","ranges","r","validateRange","result","currentRangeStart","currentRangeEnd","range","push","setHiddenAreas","newRanges","oldRanges","hasDifference","equalsRange","newDecorations","newRange","options","EMPTY","hasVisibleLine","lineChanged","isVisible","setVisible","newOutputLineCount","_modelColumn","setTabSize","newTabSize","setWrappingSettings","equalFontInfo","equals","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","onlyWrappingColumnChanged","getLineBreakData","lineBreaksComputerFactory","onModelFlushed","onModelLinesDeleted","versionId","fromLineNumber","toLineNumber","outputFromLineNumber","outputToLineNumber","ViewLinesDeletedEvent","onModelLinesInserted","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","outputLineCount","slice","concat","ViewLinesInsertedEvent","onModelLineChanged","lineBreakData","lineIndex","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","viewLinesChangedEvent","ViewLinesChangedEvent","viewLinesInsertedEvent","viewLinesDeletedEvent","acceptVersionId","_toValidViewLineNumber","viewLineNumber","getActiveIndentGuide","minLineNumber","maxLineNumber","getViewLineMinColumn","modelMinPosition","modelMaxPosition","viewStartPosition","viewEndPosition","getLineMaxColumn","indent","getViewLinesIndentGuides","viewStartLineNumber","viewEndLineNumber","modelStart","modelEnd","getViewLineMaxColumn","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","viewLineStartIndex","getViewLineNumberOfModelPosition","viewLineEndIndex","count","option","getLinesIndentGuides","viewIndents","Array","currIndex","blockAtIndex","getViewLineContent","remainder","getViewLineLength","getViewLineData","getViewLinesData","needed","startModelLineIndex","startRemainder","getLineCount","fromViewLineIndex","remainingViewLineCount","lastLine","toViewLineIndex","viewColumn","minColumn","maxColumn","computedModelColumn","getModelColumnOfViewPosition","computedModelPosition","validatePosition","validViewStart","startColumn","getStartPosition","validViewEnd","endColumn","getEndPosition","inputColumn","end","_modelLineNumber","validPosition","inputLineNumber","lineIndexChanged","deltaLineNumber","getViewPositionOfModelPosition","_getViewLineNumberForModelPosition","getAllOverviewRulerDecorations","ownerId","filterOutValidation","theme","decorations","getOverviewRulerDecorations","OverviewRulerDecorations","decoration","opts","overviewRuler","lane","position","color","getColor","accept","getDecorationsInRange","maxLineColumn","a","b","res","id","finalResult","finalResultLen","prevDecId","dec","VisibleIdentitySplitLine","InvisibleIdentitySplitLine","INSTANCE","_outputLineIndex","getLineContent","getLineLength","getLineMinColumn","lineTokens","getLineTokens","lineContent","inflate","_fromOuputLineIndex","_toOutputLineIndex","globalStartIndex","outputColumn","_inputColumn","_model","Error","_globalStartIndex","_needed","_result","_outputColumn","_deltaLineNumber","SplitLine","_lineBreakData","_isVisible","breakOffsets","getInputStartOffsetOfOutputLineIndex","outputLineIndex","getInputOffsetOfOutputPosition","getInputEndOffsetOfOutputLineIndex","startOffset","endOffset","getValueInRange","spaces","wrappedTextIndentLength","continuesWithWrappedLine","deltaStartIndex","startVisibleColumn","breakOffsetsVisibleColumn","sliceAndInflate","fromOuputLineIndex","toOutputLineIndex","globalIndex","adjustedColumn","getOutputPositionOfInputOffset","outputOffset","_spaces","_makeSpaces","join","IdentityCoordinatesConverter","_validPosition","pos","_validRange","_viewPosition","_viewRange","IdentityLinesCollection","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","lineText","previousLineBreakData","_versionId","_minLineNumber","_maxLineNumber","max","idx","Object","create","prev","prevLane","prevEndLineNumber"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/viewModel/splitLinesCollection.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as arrays from '../../../base/common/arrays.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { ModelDecorationOptions } from '../model/textModel.js';\r\nimport * as viewEvents from '../view/viewEvents.js';\r\nimport { PrefixSumIndexOfResult } from './prefixSumComputer.js';\r\nimport { LineBreakData, ViewLineData } from './viewModel.js';\r\nexport class CoordinatesConverter {\r\n    constructor(lines) {\r\n        this._lines = lines;\r\n    }\r\n    // View -> Model conversion and related methods\r\n    convertViewPositionToModelPosition(viewPosition) {\r\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\r\n    }\r\n    convertViewRangeToModelRange(viewRange) {\r\n        return this._lines.convertViewRangeToModelRange(viewRange);\r\n    }\r\n    validateViewPosition(viewPosition, expectedModelPosition) {\r\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\r\n    }\r\n    validateViewRange(viewRange, expectedModelRange) {\r\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\r\n    }\r\n    // Model -> View conversion and related methods\r\n    convertModelPositionToViewPosition(modelPosition) {\r\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);\r\n    }\r\n    convertModelRangeToViewRange(modelRange) {\r\n        return this._lines.convertModelRangeToViewRange(modelRange);\r\n    }\r\n    modelPositionIsVisible(modelPosition) {\r\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\r\n    }\r\n    getModelLineViewLineCount(modelLineNumber) {\r\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\r\n    }\r\n}\r\nclass LineNumberMapper {\r\n    constructor(viewLineCounts) {\r\n        this._counts = viewLineCounts;\r\n        this._isValid = false;\r\n        this._validEndIndex = -1;\r\n        this._modelToView = [];\r\n        this._viewToModel = [];\r\n    }\r\n    _invalidate(index) {\r\n        this._isValid = false;\r\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\r\n    }\r\n    _ensureValid() {\r\n        if (this._isValid) {\r\n            return;\r\n        }\r\n        for (let i = this._validEndIndex + 1, len = this._counts.length; i < len; i++) {\r\n            const viewLineCount = this._counts[i];\r\n            const viewLinesAbove = (i > 0 ? this._modelToView[i - 1] : 0);\r\n            this._modelToView[i] = viewLinesAbove + viewLineCount;\r\n            for (let j = 0; j < viewLineCount; j++) {\r\n                this._viewToModel[viewLinesAbove + j] = i;\r\n            }\r\n        }\r\n        // trim things\r\n        this._modelToView.length = this._counts.length;\r\n        this._viewToModel.length = this._modelToView[this._modelToView.length - 1];\r\n        // mark as valid\r\n        this._isValid = true;\r\n        this._validEndIndex = this._counts.length - 1;\r\n    }\r\n    changeValue(index, value) {\r\n        if (this._counts[index] === value) {\r\n            // no change\r\n            return;\r\n        }\r\n        this._counts[index] = value;\r\n        this._invalidate(index);\r\n    }\r\n    removeValues(start, deleteCount) {\r\n        this._counts.splice(start, deleteCount);\r\n        this._invalidate(start);\r\n    }\r\n    insertValues(insertIndex, insertArr) {\r\n        this._counts = arrays.arrayInsert(this._counts, insertIndex, insertArr);\r\n        this._invalidate(insertIndex);\r\n    }\r\n    getTotalValue() {\r\n        this._ensureValid();\r\n        return this._viewToModel.length;\r\n    }\r\n    getAccumulatedValue(index) {\r\n        this._ensureValid();\r\n        return this._modelToView[index];\r\n    }\r\n    getIndexOf(accumulatedValue) {\r\n        this._ensureValid();\r\n        const modelLineIndex = this._viewToModel[accumulatedValue];\r\n        const viewLinesAbove = (modelLineIndex > 0 ? this._modelToView[modelLineIndex - 1] : 0);\r\n        return new PrefixSumIndexOfResult(modelLineIndex, accumulatedValue - viewLinesAbove);\r\n    }\r\n}\r\nexport class SplitLinesCollection {\r\n    constructor(model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\r\n        this.model = model;\r\n        this._validModelVersionId = -1;\r\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\r\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\r\n        this.fontInfo = fontInfo;\r\n        this.tabSize = tabSize;\r\n        this.wrappingStrategy = wrappingStrategy;\r\n        this.wrappingColumn = wrappingColumn;\r\n        this.wrappingIndent = wrappingIndent;\r\n        this._constructLines(/*resetHiddenAreas*/ true, null);\r\n    }\r\n    dispose() {\r\n        this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);\r\n    }\r\n    createCoordinatesConverter() {\r\n        return new CoordinatesConverter(this);\r\n    }\r\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\r\n        this.lines = [];\r\n        if (resetHiddenAreas) {\r\n            this.hiddenAreasIds = [];\r\n        }\r\n        let linesContent = this.model.getLinesContent();\r\n        const lineCount = linesContent.length;\r\n        const lineBreaksComputer = this.createLineBreaksComputer();\r\n        for (let i = 0; i < lineCount; i++) {\r\n            lineBreaksComputer.addRequest(linesContent[i], previousLineBreaks ? previousLineBreaks[i] : null);\r\n        }\r\n        const linesBreaks = lineBreaksComputer.finalize();\r\n        let values = [];\r\n        let hiddenAreas = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\r\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\r\n        let hiddenAreaIdx = -1;\r\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\r\n        for (let i = 0; i < lineCount; i++) {\r\n            let lineNumber = i + 1;\r\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\r\n                hiddenAreaIdx++;\r\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\r\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\r\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\r\n            }\r\n            let isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\r\n            let line = createSplitLine(linesBreaks[i], !isInHiddenArea);\r\n            values[i] = line.getViewLineCount();\r\n            this.lines[i] = line;\r\n        }\r\n        this._validModelVersionId = this.model.getVersionId();\r\n        this.prefixSumComputer = new LineNumberMapper(values);\r\n    }\r\n    getHiddenAreas() {\r\n        return this.hiddenAreasIds.map((decId) => {\r\n            return this.model.getDecorationRange(decId);\r\n        });\r\n    }\r\n    _reduceRanges(_ranges) {\r\n        if (_ranges.length === 0) {\r\n            return [];\r\n        }\r\n        let ranges = _ranges.map(r => this.model.validateRange(r)).sort(Range.compareRangesUsingStarts);\r\n        let result = [];\r\n        let currentRangeStart = ranges[0].startLineNumber;\r\n        let currentRangeEnd = ranges[0].endLineNumber;\r\n        for (let i = 1, len = ranges.length; i < len; i++) {\r\n            let range = ranges[i];\r\n            if (range.startLineNumber > currentRangeEnd + 1) {\r\n                result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\r\n                currentRangeStart = range.startLineNumber;\r\n                currentRangeEnd = range.endLineNumber;\r\n            }\r\n            else if (range.endLineNumber > currentRangeEnd) {\r\n                currentRangeEnd = range.endLineNumber;\r\n            }\r\n        }\r\n        result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\r\n        return result;\r\n    }\r\n    setHiddenAreas(_ranges) {\r\n        let newRanges = this._reduceRanges(_ranges);\r\n        // BEGIN TODO@Martin: Please stop calling this method on each model change!\r\n        let oldRanges = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\r\n        if (newRanges.length === oldRanges.length) {\r\n            let hasDifference = false;\r\n            for (let i = 0; i < newRanges.length; i++) {\r\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\r\n                    hasDifference = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!hasDifference) {\r\n                return false;\r\n            }\r\n        }\r\n        // END TODO@Martin: Please stop calling this method on each model change!\r\n        let newDecorations = [];\r\n        for (const newRange of newRanges) {\r\n            newDecorations.push({\r\n                range: newRange,\r\n                options: ModelDecorationOptions.EMPTY\r\n            });\r\n        }\r\n        this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);\r\n        let hiddenAreas = newRanges;\r\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\r\n        let hiddenAreaIdx = -1;\r\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\r\n        let hasVisibleLine = false;\r\n        for (let i = 0; i < this.lines.length; i++) {\r\n            let lineNumber = i + 1;\r\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\r\n                hiddenAreaIdx++;\r\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\r\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\r\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\r\n            }\r\n            let lineChanged = false;\r\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\r\n                // Line should be hidden\r\n                if (this.lines[i].isVisible()) {\r\n                    this.lines[i] = this.lines[i].setVisible(false);\r\n                    lineChanged = true;\r\n                }\r\n            }\r\n            else {\r\n                hasVisibleLine = true;\r\n                // Line should be visible\r\n                if (!this.lines[i].isVisible()) {\r\n                    this.lines[i] = this.lines[i].setVisible(true);\r\n                    lineChanged = true;\r\n                }\r\n            }\r\n            if (lineChanged) {\r\n                let newOutputLineCount = this.lines[i].getViewLineCount();\r\n                this.prefixSumComputer.changeValue(i, newOutputLineCount);\r\n            }\r\n        }\r\n        if (!hasVisibleLine) {\r\n            // Cannot have everything be hidden => reveal everything!\r\n            this.setHiddenAreas([]);\r\n        }\r\n        return true;\r\n    }\r\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\r\n        if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\r\n            // invalid arguments\r\n            return false;\r\n        }\r\n        return this.lines[modelLineNumber - 1].isVisible();\r\n    }\r\n    getModelLineViewLineCount(modelLineNumber) {\r\n        if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\r\n            // invalid arguments\r\n            return 1;\r\n        }\r\n        return this.lines[modelLineNumber - 1].getViewLineCount();\r\n    }\r\n    setTabSize(newTabSize) {\r\n        if (this.tabSize === newTabSize) {\r\n            return false;\r\n        }\r\n        this.tabSize = newTabSize;\r\n        this._constructLines(/*resetHiddenAreas*/ false, null);\r\n        return true;\r\n    }\r\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\r\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\r\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\r\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\r\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\r\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\r\n            return false;\r\n        }\r\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent);\r\n        this.fontInfo = fontInfo;\r\n        this.wrappingStrategy = wrappingStrategy;\r\n        this.wrappingColumn = wrappingColumn;\r\n        this.wrappingIndent = wrappingIndent;\r\n        let previousLineBreaks = null;\r\n        if (onlyWrappingColumnChanged) {\r\n            previousLineBreaks = [];\r\n            for (let i = 0, len = this.lines.length; i < len; i++) {\r\n                previousLineBreaks[i] = this.lines[i].getLineBreakData();\r\n            }\r\n        }\r\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\r\n        return true;\r\n    }\r\n    createLineBreaksComputer() {\r\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\r\n            ? this._domLineBreaksComputerFactory\r\n            : this._monospaceLineBreaksComputerFactory);\r\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\r\n    }\r\n    onModelFlushed() {\r\n        this._constructLines(/*resetHiddenAreas*/ true, null);\r\n    }\r\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\r\n        if (versionId <= this._validModelVersionId) {\r\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\r\n            // We don't want to apply stale change events on top of a newer read model state.\r\n            return null;\r\n        }\r\n        let outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\r\n        let outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);\r\n        this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\r\n        this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\r\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\r\n    }\r\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\r\n        if (versionId <= this._validModelVersionId) {\r\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\r\n            // We don't want to apply stale change events on top of a newer read model state.\r\n            return null;\r\n        }\r\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\r\n        const isInHiddenArea = (fromLineNumber > 2 && !this.lines[fromLineNumber - 2].isVisible());\r\n        let outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\r\n        let totalOutputLineCount = 0;\r\n        let insertLines = [];\r\n        let insertPrefixSumValues = [];\r\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\r\n            let line = createSplitLine(lineBreaks[i], !isInHiddenArea);\r\n            insertLines.push(line);\r\n            let outputLineCount = line.getViewLineCount();\r\n            totalOutputLineCount += outputLineCount;\r\n            insertPrefixSumValues[i] = outputLineCount;\r\n        }\r\n        // TODO@Alex: use arrays.arrayInsert\r\n        this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));\r\n        this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);\r\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\r\n    }\r\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\r\n        if (versionId <= this._validModelVersionId) {\r\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\r\n            // We don't want to apply stale change events on top of a newer read model state.\r\n            return [false, null, null, null];\r\n        }\r\n        let lineIndex = lineNumber - 1;\r\n        let oldOutputLineCount = this.lines[lineIndex].getViewLineCount();\r\n        let isVisible = this.lines[lineIndex].isVisible();\r\n        let line = createSplitLine(lineBreakData, isVisible);\r\n        this.lines[lineIndex] = line;\r\n        let newOutputLineCount = this.lines[lineIndex].getViewLineCount();\r\n        let lineMappingChanged = false;\r\n        let changeFrom = 0;\r\n        let changeTo = -1;\r\n        let insertFrom = 0;\r\n        let insertTo = -1;\r\n        let deleteFrom = 0;\r\n        let deleteTo = -1;\r\n        if (oldOutputLineCount > newOutputLineCount) {\r\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\r\n            changeTo = changeFrom + newOutputLineCount - 1;\r\n            deleteFrom = changeTo + 1;\r\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\r\n            lineMappingChanged = true;\r\n        }\r\n        else if (oldOutputLineCount < newOutputLineCount) {\r\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\r\n            changeTo = changeFrom + oldOutputLineCount - 1;\r\n            insertFrom = changeTo + 1;\r\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\r\n            lineMappingChanged = true;\r\n        }\r\n        else {\r\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\r\n            changeTo = changeFrom + newOutputLineCount - 1;\r\n        }\r\n        this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);\r\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null);\r\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\r\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\r\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\r\n    }\r\n    acceptVersionId(versionId) {\r\n        this._validModelVersionId = versionId;\r\n        if (this.lines.length === 1 && !this.lines[0].isVisible()) {\r\n            // At least one line must be visible => reset hidden areas\r\n            this.setHiddenAreas([]);\r\n        }\r\n    }\r\n    getViewLineCount() {\r\n        return this.prefixSumComputer.getTotalValue();\r\n    }\r\n    _toValidViewLineNumber(viewLineNumber) {\r\n        if (viewLineNumber < 1) {\r\n            return 1;\r\n        }\r\n        const viewLineCount = this.getViewLineCount();\r\n        if (viewLineNumber > viewLineCount) {\r\n            return viewLineCount;\r\n        }\r\n        return viewLineNumber | 0;\r\n    }\r\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\r\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\r\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\r\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\r\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\r\n        const result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\r\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\r\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\r\n        return {\r\n            startLineNumber: viewStartPosition.lineNumber,\r\n            endLineNumber: viewEndPosition.lineNumber,\r\n            indent: result.indent\r\n        };\r\n    }\r\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\r\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\r\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\r\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\r\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\r\n        let result = [];\r\n        let resultRepeatCount = [];\r\n        let resultRepeatOption = [];\r\n        const modelStartLineIndex = modelStart.lineNumber - 1;\r\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\r\n        let reqStart = null;\r\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\r\n            const line = this.lines[modelLineIndex];\r\n            if (line.isVisible()) {\r\n                let viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\r\n                let viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\r\n                let count = viewLineEndIndex - viewLineStartIndex + 1;\r\n                let option = 0 /* BlockNone */;\r\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\r\n                    // wrapped lines should block indent guides\r\n                    option = (viewLineStartIndex === 0 ? 1 /* BlockSubsequent */ : 2 /* BlockAll */);\r\n                }\r\n                resultRepeatCount.push(count);\r\n                resultRepeatOption.push(option);\r\n                // merge into previous request\r\n                if (reqStart === null) {\r\n                    reqStart = new Position(modelLineIndex + 1, 0);\r\n                }\r\n            }\r\n            else {\r\n                // hit invisible line => flush request\r\n                if (reqStart !== null) {\r\n                    result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\r\n                    reqStart = null;\r\n                }\r\n            }\r\n        }\r\n        if (reqStart !== null) {\r\n            result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\r\n            reqStart = null;\r\n        }\r\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\r\n        let viewIndents = new Array(viewLineCount);\r\n        let currIndex = 0;\r\n        for (let i = 0, len = result.length; i < len; i++) {\r\n            let value = result[i];\r\n            let count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\r\n            let option = resultRepeatOption[i];\r\n            let blockAtIndex;\r\n            if (option === 2 /* BlockAll */) {\r\n                blockAtIndex = 0;\r\n            }\r\n            else if (option === 1 /* BlockSubsequent */) {\r\n                blockAtIndex = 1;\r\n            }\r\n            else {\r\n                blockAtIndex = count;\r\n            }\r\n            for (let j = 0; j < count; j++) {\r\n                if (j === blockAtIndex) {\r\n                    value = 0;\r\n                }\r\n                viewIndents[currIndex++] = value;\r\n            }\r\n        }\r\n        return viewIndents;\r\n    }\r\n    getViewLineContent(viewLineNumber) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        return this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);\r\n    }\r\n    getViewLineLength(viewLineNumber) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        return this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);\r\n    }\r\n    getViewLineMinColumn(viewLineNumber) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        return this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);\r\n    }\r\n    getViewLineMaxColumn(viewLineNumber) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        return this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\r\n    }\r\n    getViewLineData(viewLineNumber) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        return this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);\r\n    }\r\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\r\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\r\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\r\n        let start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);\r\n        let viewLineNumber = viewStartLineNumber;\r\n        let startModelLineIndex = start.index;\r\n        let startRemainder = start.remainder;\r\n        let result = [];\r\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\r\n            let line = this.lines[modelLineIndex];\r\n            if (!line.isVisible()) {\r\n                continue;\r\n            }\r\n            let fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\r\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\r\n            let lastLine = false;\r\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\r\n                lastLine = true;\r\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\r\n            }\r\n            let toViewLineIndex = fromViewLineIndex + remainingViewLineCount;\r\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);\r\n            viewLineNumber += remainingViewLineCount;\r\n            if (lastLine) {\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        let line = this.lines[lineIndex];\r\n        let minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\r\n        let maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\r\n        if (viewColumn < minColumn) {\r\n            viewColumn = minColumn;\r\n        }\r\n        if (viewColumn > maxColumn) {\r\n            viewColumn = maxColumn;\r\n        }\r\n        let computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\r\n        let computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\r\n        if (computedModelPosition.equals(expectedModelPosition)) {\r\n            return new Position(viewLineNumber, viewColumn);\r\n        }\r\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\r\n    }\r\n    validateViewRange(viewRange, expectedModelRange) {\r\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\r\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\r\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\r\n    }\r\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        let inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn);\r\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\r\n        return this.model.validatePosition(new Position(lineIndex + 1, inputColumn));\r\n    }\r\n    convertViewRangeToModelRange(viewRange) {\r\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\r\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\r\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\r\n    }\r\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn) {\r\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\r\n        const inputLineNumber = validPosition.lineNumber;\r\n        const inputColumn = validPosition.column;\r\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\r\n        while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\r\n            lineIndex--;\r\n            lineIndexChanged = true;\r\n        }\r\n        if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\r\n            // Could not reach a real line\r\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\r\n            return new Position(1, 1);\r\n        }\r\n        const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\r\n        let r;\r\n        if (lineIndexChanged) {\r\n            r = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\r\n        }\r\n        else {\r\n            r = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn);\r\n        }\r\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\r\n        return r;\r\n    }\r\n    convertModelRangeToViewRange(modelRange) {\r\n        let start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);\r\n        let end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);\r\n        if (modelRange.startLineNumber === modelRange.endLineNumber && start.lineNumber !== end.lineNumber) {\r\n            // This is a single line range that ends up taking more lines due to wrapping\r\n            if (end.column === this.getViewLineMinColumn(end.lineNumber)) {\r\n                // the end column lands on the first column of the next line\r\n                return new Range(start.lineNumber, start.column, end.lineNumber - 1, this.getViewLineMaxColumn(end.lineNumber - 1));\r\n            }\r\n        }\r\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\r\n    }\r\n    _getViewLineNumberForModelPosition(inputLineNumber, inputColumn) {\r\n        let lineIndex = inputLineNumber - 1;\r\n        if (this.lines[lineIndex].isVisible()) {\r\n            // this model line is visible\r\n            const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\r\n            return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn);\r\n        }\r\n        // this model line is not visible\r\n        while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\r\n            lineIndex--;\r\n        }\r\n        if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\r\n            // Could not reach a real line\r\n            return 1;\r\n        }\r\n        const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\r\n        return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\r\n    }\r\n    getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {\r\n        const decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\r\n        const result = new OverviewRulerDecorations();\r\n        for (const decoration of decorations) {\r\n            const opts = decoration.options.overviewRuler;\r\n            const lane = opts ? opts.position : 0;\r\n            if (lane === 0) {\r\n                continue;\r\n            }\r\n            const color = opts.getColor(theme);\r\n            const viewStartLineNumber = this._getViewLineNumberForModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\r\n            const viewEndLineNumber = this._getViewLineNumberForModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\r\n            result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\r\n        }\r\n        return result.result;\r\n    }\r\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\r\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\r\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\r\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\r\n            // most likely there are no hidden lines => fast path\r\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\r\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\r\n        }\r\n        let result = [];\r\n        const modelStartLineIndex = modelStart.lineNumber - 1;\r\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\r\n        let reqStart = null;\r\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\r\n            const line = this.lines[modelLineIndex];\r\n            if (line.isVisible()) {\r\n                // merge into previous request\r\n                if (reqStart === null) {\r\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\r\n                }\r\n            }\r\n            else {\r\n                // hit invisible line => flush request\r\n                if (reqStart !== null) {\r\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\r\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\r\n                    reqStart = null;\r\n                }\r\n            }\r\n        }\r\n        if (reqStart !== null) {\r\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\r\n            reqStart = null;\r\n        }\r\n        result.sort((a, b) => {\r\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\r\n            if (res === 0) {\r\n                if (a.id < b.id) {\r\n                    return -1;\r\n                }\r\n                if (a.id > b.id) {\r\n                    return 1;\r\n                }\r\n                return 0;\r\n            }\r\n            return res;\r\n        });\r\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\r\n        let finalResult = [], finalResultLen = 0;\r\n        let prevDecId = null;\r\n        for (const dec of result) {\r\n            const decId = dec.id;\r\n            if (prevDecId === decId) {\r\n                // skip\r\n                continue;\r\n            }\r\n            prevDecId = decId;\r\n            finalResult[finalResultLen++] = dec;\r\n        }\r\n        return finalResult;\r\n    }\r\n}\r\nclass VisibleIdentitySplitLine {\r\n    constructor() { }\r\n    isVisible() {\r\n        return true;\r\n    }\r\n    setVisible(isVisible) {\r\n        if (isVisible) {\r\n            return this;\r\n        }\r\n        return InvisibleIdentitySplitLine.INSTANCE;\r\n    }\r\n    getLineBreakData() {\r\n        return null;\r\n    }\r\n    getViewLineCount() {\r\n        return 1;\r\n    }\r\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\r\n        return model.getLineContent(modelLineNumber);\r\n    }\r\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\r\n        return model.getLineLength(modelLineNumber);\r\n    }\r\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\r\n        return model.getLineMinColumn(modelLineNumber);\r\n    }\r\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\r\n        return model.getLineMaxColumn(modelLineNumber);\r\n    }\r\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\r\n        let lineTokens = model.getLineTokens(modelLineNumber);\r\n        let lineContent = lineTokens.getLineContent();\r\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate());\r\n    }\r\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\r\n        if (!needed[globalStartIndex]) {\r\n            result[globalStartIndex] = null;\r\n            return;\r\n        }\r\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\r\n    }\r\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\r\n        return outputColumn;\r\n    }\r\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\r\n        return new Position(deltaLineNumber, inputColumn);\r\n    }\r\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\r\n        return deltaLineNumber;\r\n    }\r\n}\r\nVisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();\r\nclass InvisibleIdentitySplitLine {\r\n    constructor() { }\r\n    isVisible() {\r\n        return false;\r\n    }\r\n    setVisible(isVisible) {\r\n        if (!isVisible) {\r\n            return this;\r\n        }\r\n        return VisibleIdentitySplitLine.INSTANCE;\r\n    }\r\n    getLineBreakData() {\r\n        return null;\r\n    }\r\n    getViewLineCount() {\r\n        return 0;\r\n    }\r\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\r\n        throw new Error('Not supported');\r\n    }\r\n}\r\nInvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();\r\nexport class SplitLine {\r\n    constructor(lineBreakData, isVisible) {\r\n        this._lineBreakData = lineBreakData;\r\n        this._isVisible = isVisible;\r\n    }\r\n    isVisible() {\r\n        return this._isVisible;\r\n    }\r\n    setVisible(isVisible) {\r\n        this._isVisible = isVisible;\r\n        return this;\r\n    }\r\n    getLineBreakData() {\r\n        return this._lineBreakData;\r\n    }\r\n    getViewLineCount() {\r\n        if (!this._isVisible) {\r\n            return 0;\r\n        }\r\n        return this._lineBreakData.breakOffsets.length;\r\n    }\r\n    getInputStartOffsetOfOutputLineIndex(outputLineIndex) {\r\n        return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex, 0);\r\n    }\r\n    getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex) {\r\n        if (outputLineIndex + 1 === this._lineBreakData.breakOffsets.length) {\r\n            return model.getLineMaxColumn(modelLineNumber) - 1;\r\n        }\r\n        return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex + 1, 0);\r\n    }\r\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\r\n        let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\r\n        let r = model.getValueInRange({\r\n            startLineNumber: modelLineNumber,\r\n            startColumn: startOffset + 1,\r\n            endLineNumber: modelLineNumber,\r\n            endColumn: endOffset + 1\r\n        });\r\n        if (outputLineIndex > 0) {\r\n            r = spaces(this._lineBreakData.wrappedTextIndentLength) + r;\r\n        }\r\n        return r;\r\n    }\r\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\r\n        let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\r\n        let r = endOffset - startOffset;\r\n        if (outputLineIndex > 0) {\r\n            r = this._lineBreakData.wrappedTextIndentLength + r;\r\n        }\r\n        return r;\r\n    }\r\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        if (outputLineIndex > 0) {\r\n            return this._lineBreakData.wrappedTextIndentLength + 1;\r\n        }\r\n        return 1;\r\n    }\r\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        return this.getViewLineContent(model, modelLineNumber, outputLineIndex).length + 1;\r\n    }\r\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\r\n        let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\r\n        let lineContent = model.getValueInRange({\r\n            startLineNumber: modelLineNumber,\r\n            startColumn: startOffset + 1,\r\n            endLineNumber: modelLineNumber,\r\n            endColumn: endOffset + 1\r\n        });\r\n        if (outputLineIndex > 0) {\r\n            lineContent = spaces(this._lineBreakData.wrappedTextIndentLength) + lineContent;\r\n        }\r\n        let minColumn = (outputLineIndex > 0 ? this._lineBreakData.wrappedTextIndentLength + 1 : 1);\r\n        let maxColumn = lineContent.length + 1;\r\n        let continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\r\n        let deltaStartIndex = 0;\r\n        if (outputLineIndex > 0) {\r\n            deltaStartIndex = this._lineBreakData.wrappedTextIndentLength;\r\n        }\r\n        let lineTokens = model.getLineTokens(modelLineNumber);\r\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : this._lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\r\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex));\r\n    }\r\n    getViewLinesData(model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        for (let outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {\r\n            let globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;\r\n            if (!needed[globalIndex]) {\r\n                result[globalIndex] = null;\r\n                continue;\r\n            }\r\n            result[globalIndex] = this.getViewLineData(model, modelLineNumber, outputLineIndex);\r\n        }\r\n    }\r\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        let adjustedColumn = outputColumn - 1;\r\n        if (outputLineIndex > 0) {\r\n            if (adjustedColumn < this._lineBreakData.wrappedTextIndentLength) {\r\n                adjustedColumn = 0;\r\n            }\r\n            else {\r\n                adjustedColumn -= this._lineBreakData.wrappedTextIndentLength;\r\n            }\r\n        }\r\n        return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex, adjustedColumn) + 1;\r\n    }\r\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        let r = LineBreakData.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, inputColumn - 1);\r\n        let outputLineIndex = r.outputLineIndex;\r\n        let outputColumn = r.outputOffset + 1;\r\n        if (outputLineIndex > 0) {\r\n            outputColumn += this._lineBreakData.wrappedTextIndentLength;\r\n        }\r\n        //\t\tconsole.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);\r\n        return new Position(deltaLineNumber + outputLineIndex, outputColumn);\r\n    }\r\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        const r = LineBreakData.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, inputColumn - 1);\r\n        return (deltaLineNumber + r.outputLineIndex);\r\n    }\r\n}\r\nlet _spaces = [''];\r\nfunction spaces(count) {\r\n    if (count >= _spaces.length) {\r\n        for (let i = 1; i <= count; i++) {\r\n            _spaces[i] = _makeSpaces(i);\r\n        }\r\n    }\r\n    return _spaces[count];\r\n}\r\nfunction _makeSpaces(count) {\r\n    return new Array(count + 1).join(' ');\r\n}\r\nfunction createSplitLine(lineBreakData, isVisible) {\r\n    if (lineBreakData === null) {\r\n        // No mapping needed\r\n        if (isVisible) {\r\n            return VisibleIdentitySplitLine.INSTANCE;\r\n        }\r\n        return InvisibleIdentitySplitLine.INSTANCE;\r\n    }\r\n    else {\r\n        return new SplitLine(lineBreakData, isVisible);\r\n    }\r\n}\r\nexport class IdentityCoordinatesConverter {\r\n    constructor(lines) {\r\n        this._lines = lines;\r\n    }\r\n    _validPosition(pos) {\r\n        return this._lines.model.validatePosition(pos);\r\n    }\r\n    _validRange(range) {\r\n        return this._lines.model.validateRange(range);\r\n    }\r\n    // View -> Model conversion and related methods\r\n    convertViewPositionToModelPosition(viewPosition) {\r\n        return this._validPosition(viewPosition);\r\n    }\r\n    convertViewRangeToModelRange(viewRange) {\r\n        return this._validRange(viewRange);\r\n    }\r\n    validateViewPosition(_viewPosition, expectedModelPosition) {\r\n        return this._validPosition(expectedModelPosition);\r\n    }\r\n    validateViewRange(_viewRange, expectedModelRange) {\r\n        return this._validRange(expectedModelRange);\r\n    }\r\n    // Model -> View conversion and related methods\r\n    convertModelPositionToViewPosition(modelPosition) {\r\n        return this._validPosition(modelPosition);\r\n    }\r\n    convertModelRangeToViewRange(modelRange) {\r\n        return this._validRange(modelRange);\r\n    }\r\n    modelPositionIsVisible(modelPosition) {\r\n        const lineCount = this._lines.model.getLineCount();\r\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\r\n            // invalid arguments\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    getModelLineViewLineCount(modelLineNumber) {\r\n        return 1;\r\n    }\r\n}\r\nexport class IdentityLinesCollection {\r\n    constructor(model) {\r\n        this.model = model;\r\n    }\r\n    dispose() {\r\n    }\r\n    createCoordinatesConverter() {\r\n        return new IdentityCoordinatesConverter(this);\r\n    }\r\n    getHiddenAreas() {\r\n        return [];\r\n    }\r\n    setHiddenAreas(_ranges) {\r\n        return false;\r\n    }\r\n    setTabSize(_newTabSize) {\r\n        return false;\r\n    }\r\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\r\n        return false;\r\n    }\r\n    createLineBreaksComputer() {\r\n        let result = [];\r\n        return {\r\n            addRequest: (lineText, previousLineBreakData) => {\r\n                result.push(null);\r\n            },\r\n            finalize: () => {\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    onModelFlushed() {\r\n    }\r\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\r\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\r\n    }\r\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\r\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\r\n    }\r\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\r\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\r\n    }\r\n    acceptVersionId(_versionId) {\r\n    }\r\n    getViewLineCount() {\r\n        return this.model.getLineCount();\r\n    }\r\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\r\n        return {\r\n            startLineNumber: viewLineNumber,\r\n            endLineNumber: viewLineNumber,\r\n            indent: 0\r\n        };\r\n    }\r\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\r\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\r\n        let result = new Array(viewLineCount);\r\n        for (let i = 0; i < viewLineCount; i++) {\r\n            result[i] = 0;\r\n        }\r\n        return result;\r\n    }\r\n    getViewLineContent(viewLineNumber) {\r\n        return this.model.getLineContent(viewLineNumber);\r\n    }\r\n    getViewLineLength(viewLineNumber) {\r\n        return this.model.getLineLength(viewLineNumber);\r\n    }\r\n    getViewLineMinColumn(viewLineNumber) {\r\n        return this.model.getLineMinColumn(viewLineNumber);\r\n    }\r\n    getViewLineMaxColumn(viewLineNumber) {\r\n        return this.model.getLineMaxColumn(viewLineNumber);\r\n    }\r\n    getViewLineData(viewLineNumber) {\r\n        let lineTokens = this.model.getLineTokens(viewLineNumber);\r\n        let lineContent = lineTokens.getLineContent();\r\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate());\r\n    }\r\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\r\n        const lineCount = this.model.getLineCount();\r\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\r\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\r\n        let result = [];\r\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\r\n            let idx = lineNumber - viewStartLineNumber;\r\n            if (!needed[idx]) {\r\n                result[idx] = null;\r\n            }\r\n            result[idx] = this.getViewLineData(lineNumber);\r\n        }\r\n        return result;\r\n    }\r\n    getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {\r\n        const decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\r\n        const result = new OverviewRulerDecorations();\r\n        for (const decoration of decorations) {\r\n            const opts = decoration.options.overviewRuler;\r\n            const lane = opts ? opts.position : 0;\r\n            if (lane === 0) {\r\n                continue;\r\n            }\r\n            const color = opts.getColor(theme);\r\n            const viewStartLineNumber = decoration.range.startLineNumber;\r\n            const viewEndLineNumber = decoration.range.endLineNumber;\r\n            result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\r\n        }\r\n        return result.result;\r\n    }\r\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\r\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\r\n    }\r\n}\r\nclass OverviewRulerDecorations {\r\n    constructor() {\r\n        this.result = Object.create(null);\r\n    }\r\n    accept(color, startLineNumber, endLineNumber, lane) {\r\n        let prev = this.result[color];\r\n        if (prev) {\r\n            const prevLane = prev[prev.length - 3];\r\n            const prevEndLineNumber = prev[prev.length - 1];\r\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\r\n                // merge into prev\r\n                if (endLineNumber > prevEndLineNumber) {\r\n                    prev[prev.length - 1] = endLineNumber;\r\n                }\r\n                return;\r\n            }\r\n            // push\r\n            prev.push(lane, startLineNumber, endLineNumber);\r\n        }\r\n        else {\r\n            this.result[color] = [lane, startLineNumber, endLineNumber];\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}