{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n  constructor() {\n    this.spacesDiff = 0;\n    this.looksLikeAlignment = false;\n  }\n}\n/**\r\n * Compute the diff in spaces between two line's indentation.\r\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n  result.spacesDiff = 0;\n  result.looksLikeAlignment = false;\n  // This can go both ways (e.g.):\n  //  - a: \"\\t\"\n  //  - b: \"\\t    \"\n  //  => This should count 1 tab and 4 spaces\n  let i;\n  for (i = 0; i < aLength && i < bLength; i++) {\n    let aCharCode = a.charCodeAt(i);\n    let bCharCode = b.charCodeAt(i);\n    if (aCharCode !== bCharCode) {\n      break;\n    }\n  }\n  let aSpacesCnt = 0,\n    aTabsCount = 0;\n  for (let j = i; j < aLength; j++) {\n    let aCharCode = a.charCodeAt(j);\n    if (aCharCode === 32 /* Space */) {\n      aSpacesCnt++;\n    } else {\n      aTabsCount++;\n    }\n  }\n  let bSpacesCnt = 0,\n    bTabsCount = 0;\n  for (let j = i; j < bLength; j++) {\n    let bCharCode = b.charCodeAt(j);\n    if (bCharCode === 32 /* Space */) {\n      bSpacesCnt++;\n    } else {\n      bTabsCount++;\n    }\n  }\n  if (aSpacesCnt > 0 && aTabsCount > 0) {\n    return;\n  }\n  if (bSpacesCnt > 0 && bTabsCount > 0) {\n    return;\n  }\n  let tabsDiff = Math.abs(aTabsCount - bTabsCount);\n  let spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n  if (tabsDiff === 0) {\n    // check if the indentation difference might be caused by alignment reasons\n    // sometime folks like to align their code, but this should not be used as a hint\n    result.spacesDiff = spacesDiff;\n    if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n      if (b.charCodeAt(bSpacesCnt) !== 32 /* Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* Space */) {\n        if (a.charCodeAt(a.length - 1) === 44 /* Comma */) {\n          // This looks like an alignment desire: e.g.\n          // const a = b + c,\n          //       d = b - c;\n          result.looksLikeAlignment = true;\n        }\n      }\n    }\n    return;\n  }\n  if (spacesDiff % tabsDiff === 0) {\n    result.spacesDiff = spacesDiff / tabsDiff;\n    return;\n  }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n  // Look at most at the first 10k lines\n  const linesCount = Math.min(source.getLineCount(), 10000);\n  let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n  let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n  let previousLineText = ''; // content of latest line that contained non-whitespace chars\n  let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n  const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n  const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n  let spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n  let tmp = new SpacesDiffResult();\n  for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n    let currentLineLength = source.getLineLength(lineNumber);\n    let currentLineText = source.getLineContent(lineNumber);\n    // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n    // checking charCode on chunks directly is cheaper.\n    const useCurrentLineText = currentLineLength <= 65536;\n    let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n    let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n    let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n    let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n    for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n      let charCode = useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j);\n      if (charCode === 9 /* Tab */) {\n        currentLineTabsCount++;\n      } else if (charCode === 32 /* Space */) {\n        currentLineSpacesCount++;\n      } else {\n        // Hit non whitespace character on this line\n        currentLineHasContent = true;\n        currentLineIndentation = j;\n        break;\n      }\n    }\n    // Ignore empty or only whitespace lines\n    if (!currentLineHasContent) {\n      continue;\n    }\n    if (currentLineTabsCount > 0) {\n      linesIndentedWithTabsCount++;\n    } else if (currentLineSpacesCount > 1) {\n      linesIndentedWithSpacesCount++;\n    }\n    spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n    if (tmp.looksLikeAlignment) {\n      // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n      //\n      // - item1\n      //   - item2\n      //\n      // otherwise skip this line entirely\n      //\n      // const a = 1,\n      //       b = 2;\n      if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n        continue;\n      }\n    }\n    let currentSpacesDiff = tmp.spacesDiff;\n    if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n      spacesDiffCount[currentSpacesDiff]++;\n    }\n    previousLineText = currentLineText;\n    previousLineIndentation = currentLineIndentation;\n  }\n  let insertSpaces = defaultInsertSpaces;\n  if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n    insertSpaces = linesIndentedWithTabsCount < linesIndentedWithSpacesCount;\n  }\n  let tabSize = defaultTabSize;\n  // Guess tabSize only if inserting spaces...\n  if (insertSpaces) {\n    let tabSizeScore = insertSpaces ? 0 : 0.1 * linesCount;\n    // console.log(\"score threshold: \" + tabSizeScore);\n    ALLOWED_TAB_SIZE_GUESSES.forEach(possibleTabSize => {\n      let possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n      if (possibleTabSizeScore > tabSizeScore) {\n        tabSizeScore = possibleTabSizeScore;\n        tabSize = possibleTabSize;\n      }\n    });\n    // Let a tabSize of 2 win even if it is not the maximum\n    // (only in case 4 was guessed)\n    if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n      tabSize = 2;\n    }\n  }\n  // console.log('--------------------------');\n  // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n  // console.log('spacesDiffCount: ' + spacesDiffCount);\n  // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n  return {\n    insertSpaces: insertSpaces,\n    tabSize: tabSize\n  };\n}","map":{"version":3,"names":["SpacesDiffResult","constructor","spacesDiff","looksLikeAlignment","a","aLength","b","bLength","result","i","aCharCode","charCodeAt","bCharCode","aSpacesCnt","aTabsCount","j","bSpacesCnt","bTabsCount","tabsDiff","Math","abs","length","guessIndentation","source","defaultTabSize","defaultInsertSpaces","linesCount","min","getLineCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineText","previousLineIndentation","ALLOWED_TAB_SIZE_GUESSES","MAX_ALLOWED_TAB_SIZE_GUESS","spacesDiffCount","tmp","lineNumber","currentLineLength","getLineLength","currentLineText","getLineContent","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","lenJ","charCode","getLineCharCode","currentSpacesDiff","insertSpaces","tabSize","tabSizeScore","forEach","possibleTabSize","possibleTabSizeScore"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass SpacesDiffResult {\r\n    constructor() {\r\n        this.spacesDiff = 0;\r\n        this.looksLikeAlignment = false;\r\n    }\r\n}\r\n/**\r\n * Compute the diff in spaces between two line's indentation.\r\n */\r\nfunction spacesDiff(a, aLength, b, bLength, result) {\r\n    result.spacesDiff = 0;\r\n    result.looksLikeAlignment = false;\r\n    // This can go both ways (e.g.):\r\n    //  - a: \"\\t\"\r\n    //  - b: \"\\t    \"\r\n    //  => This should count 1 tab and 4 spaces\r\n    let i;\r\n    for (i = 0; i < aLength && i < bLength; i++) {\r\n        let aCharCode = a.charCodeAt(i);\r\n        let bCharCode = b.charCodeAt(i);\r\n        if (aCharCode !== bCharCode) {\r\n            break;\r\n        }\r\n    }\r\n    let aSpacesCnt = 0, aTabsCount = 0;\r\n    for (let j = i; j < aLength; j++) {\r\n        let aCharCode = a.charCodeAt(j);\r\n        if (aCharCode === 32 /* Space */) {\r\n            aSpacesCnt++;\r\n        }\r\n        else {\r\n            aTabsCount++;\r\n        }\r\n    }\r\n    let bSpacesCnt = 0, bTabsCount = 0;\r\n    for (let j = i; j < bLength; j++) {\r\n        let bCharCode = b.charCodeAt(j);\r\n        if (bCharCode === 32 /* Space */) {\r\n            bSpacesCnt++;\r\n        }\r\n        else {\r\n            bTabsCount++;\r\n        }\r\n    }\r\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\r\n        return;\r\n    }\r\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\r\n        return;\r\n    }\r\n    let tabsDiff = Math.abs(aTabsCount - bTabsCount);\r\n    let spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\r\n    if (tabsDiff === 0) {\r\n        // check if the indentation difference might be caused by alignment reasons\r\n        // sometime folks like to align their code, but this should not be used as a hint\r\n        result.spacesDiff = spacesDiff;\r\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\r\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* Space */) {\r\n                if (a.charCodeAt(a.length - 1) === 44 /* Comma */) {\r\n                    // This looks like an alignment desire: e.g.\r\n                    // const a = b + c,\r\n                    //       d = b - c;\r\n                    result.looksLikeAlignment = true;\r\n                }\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    if (spacesDiff % tabsDiff === 0) {\r\n        result.spacesDiff = spacesDiff / tabsDiff;\r\n        return;\r\n    }\r\n}\r\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\r\n    // Look at most at the first 10k lines\r\n    const linesCount = Math.min(source.getLineCount(), 10000);\r\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\r\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\r\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\r\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\r\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\r\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\r\n    let spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\r\n    let tmp = new SpacesDiffResult();\r\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\r\n        let currentLineLength = source.getLineLength(lineNumber);\r\n        let currentLineText = source.getLineContent(lineNumber);\r\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\r\n        // checking charCode on chunks directly is cheaper.\r\n        const useCurrentLineText = (currentLineLength <= 65536);\r\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\r\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\r\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\r\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\r\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\r\n            let charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\r\n            if (charCode === 9 /* Tab */) {\r\n                currentLineTabsCount++;\r\n            }\r\n            else if (charCode === 32 /* Space */) {\r\n                currentLineSpacesCount++;\r\n            }\r\n            else {\r\n                // Hit non whitespace character on this line\r\n                currentLineHasContent = true;\r\n                currentLineIndentation = j;\r\n                break;\r\n            }\r\n        }\r\n        // Ignore empty or only whitespace lines\r\n        if (!currentLineHasContent) {\r\n            continue;\r\n        }\r\n        if (currentLineTabsCount > 0) {\r\n            linesIndentedWithTabsCount++;\r\n        }\r\n        else if (currentLineSpacesCount > 1) {\r\n            linesIndentedWithSpacesCount++;\r\n        }\r\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\r\n        if (tmp.looksLikeAlignment) {\r\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\r\n            //\r\n            // - item1\r\n            //   - item2\r\n            //\r\n            // otherwise skip this line entirely\r\n            //\r\n            // const a = 1,\r\n            //       b = 2;\r\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\r\n                continue;\r\n            }\r\n        }\r\n        let currentSpacesDiff = tmp.spacesDiff;\r\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\r\n            spacesDiffCount[currentSpacesDiff]++;\r\n        }\r\n        previousLineText = currentLineText;\r\n        previousLineIndentation = currentLineIndentation;\r\n    }\r\n    let insertSpaces = defaultInsertSpaces;\r\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\r\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\r\n    }\r\n    let tabSize = defaultTabSize;\r\n    // Guess tabSize only if inserting spaces...\r\n    if (insertSpaces) {\r\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\r\n        // console.log(\"score threshold: \" + tabSizeScore);\r\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\r\n            let possibleTabSizeScore = spacesDiffCount[possibleTabSize];\r\n            if (possibleTabSizeScore > tabSizeScore) {\r\n                tabSizeScore = possibleTabSizeScore;\r\n                tabSize = possibleTabSize;\r\n            }\r\n        });\r\n        // Let a tabSize of 2 win even if it is not the maximum\r\n        // (only in case 4 was guessed)\r\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\r\n            tabSize = 2;\r\n        }\r\n    }\r\n    // console.log('--------------------------');\r\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\r\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\r\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\r\n    return {\r\n        insertSpaces: insertSpaces,\r\n        tabSize: tabSize\r\n    };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}