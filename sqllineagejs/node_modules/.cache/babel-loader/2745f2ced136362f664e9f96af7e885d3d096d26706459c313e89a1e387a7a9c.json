{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EditorAction, registerEditorAction, registerEditorContribution } from '../../browser/editorExtensions.js';\nimport { ShiftCommand } from '../../common/commands/shiftCommand.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { EditorContextKeys } from '../../common/editorContextKeys.js';\nimport { TextModel } from '../../common/model/textModel.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport { IModelService } from '../../common/services/modelService.js';\nimport * as indentUtils from './indentUtils.js';\nimport { IQuickInputService } from '../../../platform/quickinput/common/quickInput.js';\nexport function getReindentEditOperations(model, startLineNumber, endLineNumber, inheritedIndent) {\n  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n    // Model is empty\n    return [];\n  }\n  let indentationRules = LanguageConfigurationRegistry.getIndentationRules(model.getLanguageIdentifier().id);\n  if (!indentationRules) {\n    return [];\n  }\n  endLineNumber = Math.min(endLineNumber, model.getLineCount());\n  // Skip `unIndentedLinePattern` lines\n  while (startLineNumber <= endLineNumber) {\n    if (!indentationRules.unIndentedLinePattern) {\n      break;\n    }\n    let text = model.getLineContent(startLineNumber);\n    if (!indentationRules.unIndentedLinePattern.test(text)) {\n      break;\n    }\n    startLineNumber++;\n  }\n  if (startLineNumber > endLineNumber - 1) {\n    return [];\n  }\n  const {\n    tabSize,\n    indentSize,\n    insertSpaces\n  } = model.getOptions();\n  const shiftIndent = (indentation, count) => {\n    count = count || 1;\n    return ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);\n  };\n  const unshiftIndent = (indentation, count) => {\n    count = count || 1;\n    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);\n  };\n  let indentEdits = [];\n  // indentation being passed to lines below\n  let globalIndent;\n  // Calculate indentation for the first line\n  // If there is no passed-in indentation, we use the indentation of the first line as base.\n  let currentLineText = model.getLineContent(startLineNumber);\n  let adjustedLineContent = currentLineText;\n  if (inheritedIndent !== undefined && inheritedIndent !== null) {\n    globalIndent = inheritedIndent;\n    let oldIndentation = strings.getLeadingWhitespace(currentLineText);\n    adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);\n    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {\n      globalIndent = unshiftIndent(globalIndent);\n      adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);\n    }\n    if (currentLineText !== adjustedLineContent) {\n      indentEdits.push(EditOperation.replaceMove(new Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(globalIndent, indentSize, insertSpaces)));\n    }\n  } else {\n    globalIndent = strings.getLeadingWhitespace(currentLineText);\n  }\n  // idealIndentForNextLine doesn't equal globalIndent when there is a line matching `indentNextLinePattern`.\n  let idealIndentForNextLine = globalIndent;\n  if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {\n    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n    globalIndent = shiftIndent(globalIndent);\n  } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {\n    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n  }\n  startLineNumber++;\n  // Calculate indentation adjustment for all following lines\n  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n    let text = model.getLineContent(lineNumber);\n    let oldIndentation = strings.getLeadingWhitespace(text);\n    let adjustedLineContent = idealIndentForNextLine + text.substring(oldIndentation.length);\n    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {\n      idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);\n      globalIndent = unshiftIndent(globalIndent);\n    }\n    if (oldIndentation !== idealIndentForNextLine) {\n      indentEdits.push(EditOperation.replaceMove(new Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));\n    }\n    // calculate idealIndentForNextLine\n    if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text)) {\n      // In reindent phase, if the line matches `unIndentedLinePattern` we inherit indentation from above lines\n      // but don't change globalIndent and idealIndentForNextLine.\n      continue;\n    } else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {\n      globalIndent = shiftIndent(globalIndent);\n      idealIndentForNextLine = globalIndent;\n    } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {\n      idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n    } else {\n      idealIndentForNextLine = globalIndent;\n    }\n  }\n  return indentEdits;\n}\nexport class IndentationToSpacesAction extends EditorAction {\n  constructor() {\n    super({\n      id: IndentationToSpacesAction.ID,\n      label: nls.localize('indentationToSpaces', \"Convert Indentation to Spaces\"),\n      alias: 'Convert Indentation to Spaces',\n      precondition: EditorContextKeys.writable\n    });\n  }\n  run(accessor, editor) {\n    let model = editor.getModel();\n    if (!model) {\n      return;\n    }\n    let modelOpts = model.getOptions();\n    let selection = editor.getSelection();\n    if (!selection) {\n      return;\n    }\n    const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, [command]);\n    editor.pushUndoStop();\n    model.updateOptions({\n      insertSpaces: true\n    });\n  }\n}\nIndentationToSpacesAction.ID = 'editor.action.indentationToSpaces';\nexport class IndentationToTabsAction extends EditorAction {\n  constructor() {\n    super({\n      id: IndentationToTabsAction.ID,\n      label: nls.localize('indentationToTabs', \"Convert Indentation to Tabs\"),\n      alias: 'Convert Indentation to Tabs',\n      precondition: EditorContextKeys.writable\n    });\n  }\n  run(accessor, editor) {\n    let model = editor.getModel();\n    if (!model) {\n      return;\n    }\n    let modelOpts = model.getOptions();\n    let selection = editor.getSelection();\n    if (!selection) {\n      return;\n    }\n    const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);\n    editor.pushUndoStop();\n    editor.executeCommands(this.id, [command]);\n    editor.pushUndoStop();\n    model.updateOptions({\n      insertSpaces: false\n    });\n  }\n}\nIndentationToTabsAction.ID = 'editor.action.indentationToTabs';\nexport class ChangeIndentationSizeAction extends EditorAction {\n  constructor(insertSpaces, opts) {\n    super(opts);\n    this.insertSpaces = insertSpaces;\n  }\n  run(accessor, editor) {\n    const quickInputService = accessor.get(IQuickInputService);\n    const modelService = accessor.get(IModelService);\n    let model = editor.getModel();\n    if (!model) {\n      return;\n    }\n    let creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);\n    const picks = [1, 2, 3, 4, 5, 6, 7, 8].map(n => ({\n      id: n.toString(),\n      label: n.toString(),\n      // add description for tabSize value set in the configuration\n      description: n === creationOpts.tabSize ? nls.localize('configuredTabSize', \"Configured Tab Size\") : undefined\n    }));\n    // auto focus the tabSize set for the current editor\n    const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);\n    setTimeout(() => {\n      quickInputService.pick(picks, {\n        placeHolder: nls.localize({\n          key: 'selectTabWidth',\n          comment: ['Tab corresponds to the tab key']\n        }, \"Select Tab Size for Current File\"),\n        activeItem: picks[autoFocusIndex]\n      }).then(pick => {\n        if (pick) {\n          if (model && !model.isDisposed()) {\n            model.updateOptions({\n              tabSize: parseInt(pick.label, 10),\n              insertSpaces: this.insertSpaces\n            });\n          }\n        }\n      });\n    }, 50 /* quick input is sensitive to being opened so soon after another */);\n  }\n}\n\nexport class IndentUsingTabs extends ChangeIndentationSizeAction {\n  constructor() {\n    super(false, {\n      id: IndentUsingTabs.ID,\n      label: nls.localize('indentUsingTabs', \"Indent Using Tabs\"),\n      alias: 'Indent Using Tabs',\n      precondition: undefined\n    });\n  }\n}\nIndentUsingTabs.ID = 'editor.action.indentUsingTabs';\nexport class IndentUsingSpaces extends ChangeIndentationSizeAction {\n  constructor() {\n    super(true, {\n      id: IndentUsingSpaces.ID,\n      label: nls.localize('indentUsingSpaces', \"Indent Using Spaces\"),\n      alias: 'Indent Using Spaces',\n      precondition: undefined\n    });\n  }\n}\nIndentUsingSpaces.ID = 'editor.action.indentUsingSpaces';\nexport class DetectIndentation extends EditorAction {\n  constructor() {\n    super({\n      id: DetectIndentation.ID,\n      label: nls.localize('detectIndentation', \"Detect Indentation from Content\"),\n      alias: 'Detect Indentation from Content',\n      precondition: undefined\n    });\n  }\n  run(accessor, editor) {\n    const modelService = accessor.get(IModelService);\n    let model = editor.getModel();\n    if (!model) {\n      return;\n    }\n    let creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);\n    model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);\n  }\n}\nDetectIndentation.ID = 'editor.action.detectIndentation';\nexport class ReindentLinesAction extends EditorAction {\n  constructor() {\n    super({\n      id: 'editor.action.reindentlines',\n      label: nls.localize('editor.reindentlines', \"Reindent Lines\"),\n      alias: 'Reindent Lines',\n      precondition: EditorContextKeys.writable\n    });\n  }\n  run(accessor, editor) {\n    let model = editor.getModel();\n    if (!model) {\n      return;\n    }\n    let edits = getReindentEditOperations(model, 1, model.getLineCount());\n    if (edits.length > 0) {\n      editor.pushUndoStop();\n      editor.executeEdits(this.id, edits);\n      editor.pushUndoStop();\n    }\n  }\n}\nexport class ReindentSelectedLinesAction extends EditorAction {\n  constructor() {\n    super({\n      id: 'editor.action.reindentselectedlines',\n      label: nls.localize('editor.reindentselectedlines', \"Reindent Selected Lines\"),\n      alias: 'Reindent Selected Lines',\n      precondition: EditorContextKeys.writable\n    });\n  }\n  run(accessor, editor) {\n    let model = editor.getModel();\n    if (!model) {\n      return;\n    }\n    let selections = editor.getSelections();\n    if (selections === null) {\n      return;\n    }\n    let edits = [];\n    for (let selection of selections) {\n      let startLineNumber = selection.startLineNumber;\n      let endLineNumber = selection.endLineNumber;\n      if (startLineNumber !== endLineNumber && selection.endColumn === 1) {\n        endLineNumber--;\n      }\n      if (startLineNumber === 1) {\n        if (startLineNumber === endLineNumber) {\n          continue;\n        }\n      } else {\n        startLineNumber--;\n      }\n      let editOperations = getReindentEditOperations(model, startLineNumber, endLineNumber);\n      edits.push(...editOperations);\n    }\n    if (edits.length > 0) {\n      editor.pushUndoStop();\n      editor.executeEdits(this.id, edits);\n      editor.pushUndoStop();\n    }\n  }\n}\nexport class AutoIndentOnPasteCommand {\n  constructor(edits, initialSelection) {\n    this._initialSelection = initialSelection;\n    this._edits = [];\n    this._selectionId = null;\n    for (let edit of edits) {\n      if (edit.range && typeof edit.text === 'string') {\n        this._edits.push(edit);\n      }\n    }\n  }\n  getEditOperations(model, builder) {\n    for (let edit of this._edits) {\n      builder.addEditOperation(Range.lift(edit.range), edit.text);\n    }\n    let selectionIsSet = false;\n    if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {\n      if (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {\n        selectionIsSet = true;\n        this._selectionId = builder.trackSelection(this._initialSelection, true);\n      } else if (this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {\n        selectionIsSet = true;\n        this._selectionId = builder.trackSelection(this._initialSelection, false);\n      }\n    }\n    if (!selectionIsSet) {\n      this._selectionId = builder.trackSelection(this._initialSelection);\n    }\n  }\n  computeCursorState(model, helper) {\n    return helper.getTrackedSelection(this._selectionId);\n  }\n}\nexport class AutoIndentOnPaste {\n  constructor(editor) {\n    this.callOnDispose = new DisposableStore();\n    this.callOnModel = new DisposableStore();\n    this.editor = editor;\n    this.callOnDispose.add(editor.onDidChangeConfiguration(() => this.update()));\n    this.callOnDispose.add(editor.onDidChangeModel(() => this.update()));\n    this.callOnDispose.add(editor.onDidChangeModelLanguage(() => this.update()));\n  }\n  update() {\n    // clean up\n    this.callOnModel.clear();\n    // we are disabled\n    if (this.editor.getOption(8 /* autoIndent */) < 4 /* Full */ || this.editor.getOption(42 /* formatOnPaste */)) {\n      return;\n    }\n    // no model\n    if (!this.editor.hasModel()) {\n      return;\n    }\n    this.callOnModel.add(this.editor.onDidPaste(_ref => {\n      let {\n        range\n      } = _ref;\n      this.trigger(range);\n    }));\n  }\n  trigger(range) {\n    let selections = this.editor.getSelections();\n    if (selections === null || selections.length > 1) {\n      return;\n    }\n    const model = this.editor.getModel();\n    if (!model) {\n      return;\n    }\n    if (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {\n      return;\n    }\n    const autoIndent = this.editor.getOption(8 /* autoIndent */);\n    const {\n      tabSize,\n      indentSize,\n      insertSpaces\n    } = model.getOptions();\n    let textEdits = [];\n    let indentConverter = {\n      shiftIndent: indentation => {\n        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      },\n      unshiftIndent: indentation => {\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n      }\n    };\n    let startLineNumber = range.startLineNumber;\n    while (startLineNumber <= range.endLineNumber) {\n      if (this.shouldIgnoreLine(model, startLineNumber)) {\n        startLineNumber++;\n        continue;\n      }\n      break;\n    }\n    if (startLineNumber > range.endLineNumber) {\n      return;\n    }\n    let firstLineText = model.getLineContent(startLineNumber);\n    if (!/\\S/.test(firstLineText.substring(0, range.startColumn - 1))) {\n      let indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, model, model.getLanguageIdentifier().id, startLineNumber, indentConverter);\n      if (indentOfFirstLine !== null) {\n        let oldIndentation = strings.getLeadingWhitespace(firstLineText);\n        let newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n        let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n        if (newSpaceCnt !== oldSpaceCnt) {\n          let newIndent = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n          textEdits.push({\n            range: new Range(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),\n            text: newIndent\n          });\n          firstLineText = newIndent + firstLineText.substr(oldIndentation.length);\n        } else {\n          let indentMetadata = LanguageConfigurationRegistry.getIndentMetadata(model, startLineNumber);\n          if (indentMetadata === 0 || indentMetadata === 8 /* UNINDENT_MASK */) {\n            // we paste content into a line where only contains whitespaces\n            // after pasting, the indentation of the first line is already correct\n            // the first line doesn't match any indentation rule\n            // then no-op.\n            return;\n          }\n        }\n      }\n    }\n    const firstLineNumber = startLineNumber;\n    // ignore empty or ignored lines\n    while (startLineNumber < range.endLineNumber) {\n      if (!/\\S/.test(model.getLineContent(startLineNumber + 1))) {\n        startLineNumber++;\n        continue;\n      }\n      break;\n    }\n    if (startLineNumber !== range.endLineNumber) {\n      let virtualModel = {\n        getLineTokens: lineNumber => {\n          return model.getLineTokens(lineNumber);\n        },\n        getLanguageIdentifier: () => {\n          return model.getLanguageIdentifier();\n        },\n        getLanguageIdAtPosition: (lineNumber, column) => {\n          return model.getLanguageIdAtPosition(lineNumber, column);\n        },\n        getLineContent: lineNumber => {\n          if (lineNumber === firstLineNumber) {\n            return firstLineText;\n          } else {\n            return model.getLineContent(lineNumber);\n          }\n        }\n      };\n      let indentOfSecondLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, virtualModel, model.getLanguageIdentifier().id, startLineNumber + 1, indentConverter);\n      if (indentOfSecondLine !== null) {\n        let newSpaceCntOfSecondLine = indentUtils.getSpaceCnt(indentOfSecondLine, tabSize);\n        let oldSpaceCntOfSecondLine = indentUtils.getSpaceCnt(strings.getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);\n        if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {\n          let spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;\n          for (let i = startLineNumber + 1; i <= range.endLineNumber; i++) {\n            let lineContent = model.getLineContent(i);\n            let originalIndent = strings.getLeadingWhitespace(lineContent);\n            let originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n            let newSpacesCnt = originalSpacesCnt + spaceCntOffset;\n            let newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n            if (newIndent !== originalIndent) {\n              textEdits.push({\n                range: new Range(i, 1, i, originalIndent.length + 1),\n                text: newIndent\n              });\n            }\n          }\n        }\n      }\n    }\n    if (textEdits.length > 0) {\n      this.editor.pushUndoStop();\n      let cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());\n      this.editor.executeCommand('autoIndentOnPaste', cmd);\n      this.editor.pushUndoStop();\n    }\n  }\n  shouldIgnoreLine(model, lineNumber) {\n    model.forceTokenization(lineNumber);\n    let nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n    if (nonWhitespaceColumn === 0) {\n      return true;\n    }\n    let tokens = model.getLineTokens(lineNumber);\n    if (tokens.getCount() > 0) {\n      let firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhitespaceColumn);\n      if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === 1 /* Comment */) {\n        return true;\n      }\n    }\n    return false;\n  }\n  dispose() {\n    this.callOnDispose.dispose();\n    this.callOnModel.dispose();\n  }\n}\nAutoIndentOnPaste.ID = 'editor.contrib.autoIndentOnPaste';\nfunction getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {\n  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n    // Model is empty\n    return;\n  }\n  let spaces = '';\n  for (let i = 0; i < tabSize; i++) {\n    spaces += ' ';\n  }\n  let spacesRegExp = new RegExp(spaces, 'gi');\n  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n    let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n    if (lastIndentationColumn === 0) {\n      lastIndentationColumn = model.getLineMaxColumn(lineNumber);\n    }\n    if (lastIndentationColumn === 1) {\n      continue;\n    }\n    const originalIndentationRange = new Range(lineNumber, 1, lineNumber, lastIndentationColumn);\n    const originalIndentation = model.getValueInRange(originalIndentationRange);\n    const newIndentation = tabsToSpaces ? originalIndentation.replace(/\\t/ig, spaces) : originalIndentation.replace(spacesRegExp, '\\t');\n    builder.addEditOperation(originalIndentationRange, newIndentation);\n  }\n}\nexport class IndentationToSpacesCommand {\n  constructor(selection, tabSize) {\n    this.selection = selection;\n    this.tabSize = tabSize;\n    this.selectionId = null;\n  }\n  getEditOperations(model, builder) {\n    this.selectionId = builder.trackSelection(this.selection);\n    getIndentationEditOperations(model, builder, this.tabSize, true);\n  }\n  computeCursorState(model, helper) {\n    return helper.getTrackedSelection(this.selectionId);\n  }\n}\nexport class IndentationToTabsCommand {\n  constructor(selection, tabSize) {\n    this.selection = selection;\n    this.tabSize = tabSize;\n    this.selectionId = null;\n  }\n  getEditOperations(model, builder) {\n    this.selectionId = builder.trackSelection(this.selection);\n    getIndentationEditOperations(model, builder, this.tabSize, false);\n  }\n  computeCursorState(model, helper) {\n    return helper.getTrackedSelection(this.selectionId);\n  }\n}\nregisterEditorContribution(AutoIndentOnPaste.ID, AutoIndentOnPaste);\nregisterEditorAction(IndentationToSpacesAction);\nregisterEditorAction(IndentationToTabsAction);\nregisterEditorAction(IndentUsingTabs);\nregisterEditorAction(IndentUsingSpaces);\nregisterEditorAction(DetectIndentation);\nregisterEditorAction(ReindentLinesAction);\nregisterEditorAction(ReindentSelectedLinesAction);","map":{"version":3,"names":["nls","DisposableStore","strings","EditorAction","registerEditorAction","registerEditorContribution","ShiftCommand","EditOperation","Range","Selection","EditorContextKeys","TextModel","LanguageConfigurationRegistry","IModelService","indentUtils","IQuickInputService","getReindentEditOperations","model","startLineNumber","endLineNumber","inheritedIndent","getLineCount","getLineMaxColumn","indentationRules","getIndentationRules","getLanguageIdentifier","id","Math","min","unIndentedLinePattern","text","getLineContent","test","tabSize","indentSize","insertSpaces","getOptions","shiftIndent","indentation","count","length","unshiftIndent","indentEdits","globalIndent","currentLineText","adjustedLineContent","undefined","oldIndentation","getLeadingWhitespace","substring","decreaseIndentPattern","push","replaceMove","normalizeIndentation","idealIndentForNextLine","increaseIndentPattern","indentNextLinePattern","lineNumber","IndentationToSpacesAction","constructor","ID","label","localize","alias","precondition","writable","run","accessor","editor","getModel","modelOpts","selection","getSelection","command","IndentationToSpacesCommand","pushUndoStop","executeCommands","updateOptions","IndentationToTabsAction","IndentationToTabsCommand","ChangeIndentationSizeAction","opts","quickInputService","get","modelService","creationOpts","getCreationOptions","language","uri","isForSimpleWidget","picks","map","n","toString","description","autoFocusIndex","setTimeout","pick","placeHolder","key","comment","activeItem","then","isDisposed","parseInt","IndentUsingTabs","IndentUsingSpaces","DetectIndentation","detectIndentation","ReindentLinesAction","edits","executeEdits","ReindentSelectedLinesAction","selections","getSelections","endColumn","editOperations","AutoIndentOnPasteCommand","initialSelection","_initialSelection","_edits","_selectionId","edit","range","getEditOperations","builder","addEditOperation","lift","selectionIsSet","Array","isArray","isEmpty","startColumn","trackSelection","computeCursorState","helper","getTrackedSelection","AutoIndentOnPaste","callOnDispose","callOnModel","add","onDidChangeConfiguration","update","onDidChangeModel","onDidChangeModelLanguage","clear","getOption","hasModel","onDidPaste","_ref","trigger","isCheapToTokenize","getStartPosition","autoIndent","textEdits","indentConverter","shouldIgnoreLine","firstLineText","indentOfFirstLine","getGoodIndentForLine","newSpaceCnt","getSpaceCnt","oldSpaceCnt","newIndent","generateIndent","substr","indentMetadata","getIndentMetadata","firstLineNumber","virtualModel","getLineTokens","getLanguageIdAtPosition","column","indentOfSecondLine","newSpaceCntOfSecondLine","oldSpaceCntOfSecondLine","spaceCntOffset","i","lineContent","originalIndent","originalSpacesCnt","newSpacesCnt","cmd","executeCommand","forceTokenization","nonWhitespaceColumn","getLineFirstNonWhitespaceColumn","tokens","getCount","firstNonWhitespaceTokenIndex","findTokenIndexAtOffset","getStandardTokenType","dispose","getIndentationEditOperations","tabsToSpaces","spaces","spacesRegExp","RegExp","lineCount","lastIndentationColumn","originalIndentationRange","originalIndentation","getValueInRange","newIndentation","replace","selectionId"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/indentation/indentation.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as nls from '../../../nls.js';\r\nimport { DisposableStore } from '../../../base/common/lifecycle.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { EditorAction, registerEditorAction, registerEditorContribution } from '../../browser/editorExtensions.js';\r\nimport { ShiftCommand } from '../../common/commands/shiftCommand.js';\r\nimport { EditOperation } from '../../common/core/editOperation.js';\r\nimport { Range } from '../../common/core/range.js';\r\nimport { Selection } from '../../common/core/selection.js';\r\nimport { EditorContextKeys } from '../../common/editorContextKeys.js';\r\nimport { TextModel } from '../../common/model/textModel.js';\r\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\r\nimport { IModelService } from '../../common/services/modelService.js';\r\nimport * as indentUtils from './indentUtils.js';\r\nimport { IQuickInputService } from '../../../platform/quickinput/common/quickInput.js';\r\nexport function getReindentEditOperations(model, startLineNumber, endLineNumber, inheritedIndent) {\r\n    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\r\n        // Model is empty\r\n        return [];\r\n    }\r\n    let indentationRules = LanguageConfigurationRegistry.getIndentationRules(model.getLanguageIdentifier().id);\r\n    if (!indentationRules) {\r\n        return [];\r\n    }\r\n    endLineNumber = Math.min(endLineNumber, model.getLineCount());\r\n    // Skip `unIndentedLinePattern` lines\r\n    while (startLineNumber <= endLineNumber) {\r\n        if (!indentationRules.unIndentedLinePattern) {\r\n            break;\r\n        }\r\n        let text = model.getLineContent(startLineNumber);\r\n        if (!indentationRules.unIndentedLinePattern.test(text)) {\r\n            break;\r\n        }\r\n        startLineNumber++;\r\n    }\r\n    if (startLineNumber > endLineNumber - 1) {\r\n        return [];\r\n    }\r\n    const { tabSize, indentSize, insertSpaces } = model.getOptions();\r\n    const shiftIndent = (indentation, count) => {\r\n        count = count || 1;\r\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);\r\n    };\r\n    const unshiftIndent = (indentation, count) => {\r\n        count = count || 1;\r\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);\r\n    };\r\n    let indentEdits = [];\r\n    // indentation being passed to lines below\r\n    let globalIndent;\r\n    // Calculate indentation for the first line\r\n    // If there is no passed-in indentation, we use the indentation of the first line as base.\r\n    let currentLineText = model.getLineContent(startLineNumber);\r\n    let adjustedLineContent = currentLineText;\r\n    if (inheritedIndent !== undefined && inheritedIndent !== null) {\r\n        globalIndent = inheritedIndent;\r\n        let oldIndentation = strings.getLeadingWhitespace(currentLineText);\r\n        adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);\r\n        if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {\r\n            globalIndent = unshiftIndent(globalIndent);\r\n            adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);\r\n        }\r\n        if (currentLineText !== adjustedLineContent) {\r\n            indentEdits.push(EditOperation.replaceMove(new Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(globalIndent, indentSize, insertSpaces)));\r\n        }\r\n    }\r\n    else {\r\n        globalIndent = strings.getLeadingWhitespace(currentLineText);\r\n    }\r\n    // idealIndentForNextLine doesn't equal globalIndent when there is a line matching `indentNextLinePattern`.\r\n    let idealIndentForNextLine = globalIndent;\r\n    if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {\r\n        idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\r\n        globalIndent = shiftIndent(globalIndent);\r\n    }\r\n    else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {\r\n        idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\r\n    }\r\n    startLineNumber++;\r\n    // Calculate indentation adjustment for all following lines\r\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n        let text = model.getLineContent(lineNumber);\r\n        let oldIndentation = strings.getLeadingWhitespace(text);\r\n        let adjustedLineContent = idealIndentForNextLine + text.substring(oldIndentation.length);\r\n        if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {\r\n            idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);\r\n            globalIndent = unshiftIndent(globalIndent);\r\n        }\r\n        if (oldIndentation !== idealIndentForNextLine) {\r\n            indentEdits.push(EditOperation.replaceMove(new Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));\r\n        }\r\n        // calculate idealIndentForNextLine\r\n        if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text)) {\r\n            // In reindent phase, if the line matches `unIndentedLinePattern` we inherit indentation from above lines\r\n            // but don't change globalIndent and idealIndentForNextLine.\r\n            continue;\r\n        }\r\n        else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {\r\n            globalIndent = shiftIndent(globalIndent);\r\n            idealIndentForNextLine = globalIndent;\r\n        }\r\n        else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {\r\n            idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\r\n        }\r\n        else {\r\n            idealIndentForNextLine = globalIndent;\r\n        }\r\n    }\r\n    return indentEdits;\r\n}\r\nexport class IndentationToSpacesAction extends EditorAction {\r\n    constructor() {\r\n        super({\r\n            id: IndentationToSpacesAction.ID,\r\n            label: nls.localize('indentationToSpaces', \"Convert Indentation to Spaces\"),\r\n            alias: 'Convert Indentation to Spaces',\r\n            precondition: EditorContextKeys.writable\r\n        });\r\n    }\r\n    run(accessor, editor) {\r\n        let model = editor.getModel();\r\n        if (!model) {\r\n            return;\r\n        }\r\n        let modelOpts = model.getOptions();\r\n        let selection = editor.getSelection();\r\n        if (!selection) {\r\n            return;\r\n        }\r\n        const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);\r\n        editor.pushUndoStop();\r\n        editor.executeCommands(this.id, [command]);\r\n        editor.pushUndoStop();\r\n        model.updateOptions({\r\n            insertSpaces: true\r\n        });\r\n    }\r\n}\r\nIndentationToSpacesAction.ID = 'editor.action.indentationToSpaces';\r\nexport class IndentationToTabsAction extends EditorAction {\r\n    constructor() {\r\n        super({\r\n            id: IndentationToTabsAction.ID,\r\n            label: nls.localize('indentationToTabs', \"Convert Indentation to Tabs\"),\r\n            alias: 'Convert Indentation to Tabs',\r\n            precondition: EditorContextKeys.writable\r\n        });\r\n    }\r\n    run(accessor, editor) {\r\n        let model = editor.getModel();\r\n        if (!model) {\r\n            return;\r\n        }\r\n        let modelOpts = model.getOptions();\r\n        let selection = editor.getSelection();\r\n        if (!selection) {\r\n            return;\r\n        }\r\n        const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);\r\n        editor.pushUndoStop();\r\n        editor.executeCommands(this.id, [command]);\r\n        editor.pushUndoStop();\r\n        model.updateOptions({\r\n            insertSpaces: false\r\n        });\r\n    }\r\n}\r\nIndentationToTabsAction.ID = 'editor.action.indentationToTabs';\r\nexport class ChangeIndentationSizeAction extends EditorAction {\r\n    constructor(insertSpaces, opts) {\r\n        super(opts);\r\n        this.insertSpaces = insertSpaces;\r\n    }\r\n    run(accessor, editor) {\r\n        const quickInputService = accessor.get(IQuickInputService);\r\n        const modelService = accessor.get(IModelService);\r\n        let model = editor.getModel();\r\n        if (!model) {\r\n            return;\r\n        }\r\n        let creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);\r\n        const picks = [1, 2, 3, 4, 5, 6, 7, 8].map(n => ({\r\n            id: n.toString(),\r\n            label: n.toString(),\r\n            // add description for tabSize value set in the configuration\r\n            description: n === creationOpts.tabSize ? nls.localize('configuredTabSize', \"Configured Tab Size\") : undefined\r\n        }));\r\n        // auto focus the tabSize set for the current editor\r\n        const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);\r\n        setTimeout(() => {\r\n            quickInputService.pick(picks, { placeHolder: nls.localize({ key: 'selectTabWidth', comment: ['Tab corresponds to the tab key'] }, \"Select Tab Size for Current File\"), activeItem: picks[autoFocusIndex] }).then(pick => {\r\n                if (pick) {\r\n                    if (model && !model.isDisposed()) {\r\n                        model.updateOptions({\r\n                            tabSize: parseInt(pick.label, 10),\r\n                            insertSpaces: this.insertSpaces\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }, 50 /* quick input is sensitive to being opened so soon after another */);\r\n    }\r\n}\r\nexport class IndentUsingTabs extends ChangeIndentationSizeAction {\r\n    constructor() {\r\n        super(false, {\r\n            id: IndentUsingTabs.ID,\r\n            label: nls.localize('indentUsingTabs', \"Indent Using Tabs\"),\r\n            alias: 'Indent Using Tabs',\r\n            precondition: undefined\r\n        });\r\n    }\r\n}\r\nIndentUsingTabs.ID = 'editor.action.indentUsingTabs';\r\nexport class IndentUsingSpaces extends ChangeIndentationSizeAction {\r\n    constructor() {\r\n        super(true, {\r\n            id: IndentUsingSpaces.ID,\r\n            label: nls.localize('indentUsingSpaces', \"Indent Using Spaces\"),\r\n            alias: 'Indent Using Spaces',\r\n            precondition: undefined\r\n        });\r\n    }\r\n}\r\nIndentUsingSpaces.ID = 'editor.action.indentUsingSpaces';\r\nexport class DetectIndentation extends EditorAction {\r\n    constructor() {\r\n        super({\r\n            id: DetectIndentation.ID,\r\n            label: nls.localize('detectIndentation', \"Detect Indentation from Content\"),\r\n            alias: 'Detect Indentation from Content',\r\n            precondition: undefined\r\n        });\r\n    }\r\n    run(accessor, editor) {\r\n        const modelService = accessor.get(IModelService);\r\n        let model = editor.getModel();\r\n        if (!model) {\r\n            return;\r\n        }\r\n        let creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);\r\n        model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);\r\n    }\r\n}\r\nDetectIndentation.ID = 'editor.action.detectIndentation';\r\nexport class ReindentLinesAction extends EditorAction {\r\n    constructor() {\r\n        super({\r\n            id: 'editor.action.reindentlines',\r\n            label: nls.localize('editor.reindentlines', \"Reindent Lines\"),\r\n            alias: 'Reindent Lines',\r\n            precondition: EditorContextKeys.writable\r\n        });\r\n    }\r\n    run(accessor, editor) {\r\n        let model = editor.getModel();\r\n        if (!model) {\r\n            return;\r\n        }\r\n        let edits = getReindentEditOperations(model, 1, model.getLineCount());\r\n        if (edits.length > 0) {\r\n            editor.pushUndoStop();\r\n            editor.executeEdits(this.id, edits);\r\n            editor.pushUndoStop();\r\n        }\r\n    }\r\n}\r\nexport class ReindentSelectedLinesAction extends EditorAction {\r\n    constructor() {\r\n        super({\r\n            id: 'editor.action.reindentselectedlines',\r\n            label: nls.localize('editor.reindentselectedlines', \"Reindent Selected Lines\"),\r\n            alias: 'Reindent Selected Lines',\r\n            precondition: EditorContextKeys.writable\r\n        });\r\n    }\r\n    run(accessor, editor) {\r\n        let model = editor.getModel();\r\n        if (!model) {\r\n            return;\r\n        }\r\n        let selections = editor.getSelections();\r\n        if (selections === null) {\r\n            return;\r\n        }\r\n        let edits = [];\r\n        for (let selection of selections) {\r\n            let startLineNumber = selection.startLineNumber;\r\n            let endLineNumber = selection.endLineNumber;\r\n            if (startLineNumber !== endLineNumber && selection.endColumn === 1) {\r\n                endLineNumber--;\r\n            }\r\n            if (startLineNumber === 1) {\r\n                if (startLineNumber === endLineNumber) {\r\n                    continue;\r\n                }\r\n            }\r\n            else {\r\n                startLineNumber--;\r\n            }\r\n            let editOperations = getReindentEditOperations(model, startLineNumber, endLineNumber);\r\n            edits.push(...editOperations);\r\n        }\r\n        if (edits.length > 0) {\r\n            editor.pushUndoStop();\r\n            editor.executeEdits(this.id, edits);\r\n            editor.pushUndoStop();\r\n        }\r\n    }\r\n}\r\nexport class AutoIndentOnPasteCommand {\r\n    constructor(edits, initialSelection) {\r\n        this._initialSelection = initialSelection;\r\n        this._edits = [];\r\n        this._selectionId = null;\r\n        for (let edit of edits) {\r\n            if (edit.range && typeof edit.text === 'string') {\r\n                this._edits.push(edit);\r\n            }\r\n        }\r\n    }\r\n    getEditOperations(model, builder) {\r\n        for (let edit of this._edits) {\r\n            builder.addEditOperation(Range.lift(edit.range), edit.text);\r\n        }\r\n        let selectionIsSet = false;\r\n        if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {\r\n            if (this._edits[0].range.startColumn === this._initialSelection.endColumn &&\r\n                this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {\r\n                selectionIsSet = true;\r\n                this._selectionId = builder.trackSelection(this._initialSelection, true);\r\n            }\r\n            else if (this._edits[0].range.endColumn === this._initialSelection.startColumn &&\r\n                this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {\r\n                selectionIsSet = true;\r\n                this._selectionId = builder.trackSelection(this._initialSelection, false);\r\n            }\r\n        }\r\n        if (!selectionIsSet) {\r\n            this._selectionId = builder.trackSelection(this._initialSelection);\r\n        }\r\n    }\r\n    computeCursorState(model, helper) {\r\n        return helper.getTrackedSelection(this._selectionId);\r\n    }\r\n}\r\nexport class AutoIndentOnPaste {\r\n    constructor(editor) {\r\n        this.callOnDispose = new DisposableStore();\r\n        this.callOnModel = new DisposableStore();\r\n        this.editor = editor;\r\n        this.callOnDispose.add(editor.onDidChangeConfiguration(() => this.update()));\r\n        this.callOnDispose.add(editor.onDidChangeModel(() => this.update()));\r\n        this.callOnDispose.add(editor.onDidChangeModelLanguage(() => this.update()));\r\n    }\r\n    update() {\r\n        // clean up\r\n        this.callOnModel.clear();\r\n        // we are disabled\r\n        if (this.editor.getOption(8 /* autoIndent */) < 4 /* Full */ || this.editor.getOption(42 /* formatOnPaste */)) {\r\n            return;\r\n        }\r\n        // no model\r\n        if (!this.editor.hasModel()) {\r\n            return;\r\n        }\r\n        this.callOnModel.add(this.editor.onDidPaste(({ range }) => {\r\n            this.trigger(range);\r\n        }));\r\n    }\r\n    trigger(range) {\r\n        let selections = this.editor.getSelections();\r\n        if (selections === null || selections.length > 1) {\r\n            return;\r\n        }\r\n        const model = this.editor.getModel();\r\n        if (!model) {\r\n            return;\r\n        }\r\n        if (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {\r\n            return;\r\n        }\r\n        const autoIndent = this.editor.getOption(8 /* autoIndent */);\r\n        const { tabSize, indentSize, insertSpaces } = model.getOptions();\r\n        let textEdits = [];\r\n        let indentConverter = {\r\n            shiftIndent: (indentation) => {\r\n                return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\r\n            },\r\n            unshiftIndent: (indentation) => {\r\n                return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\r\n            }\r\n        };\r\n        let startLineNumber = range.startLineNumber;\r\n        while (startLineNumber <= range.endLineNumber) {\r\n            if (this.shouldIgnoreLine(model, startLineNumber)) {\r\n                startLineNumber++;\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        if (startLineNumber > range.endLineNumber) {\r\n            return;\r\n        }\r\n        let firstLineText = model.getLineContent(startLineNumber);\r\n        if (!/\\S/.test(firstLineText.substring(0, range.startColumn - 1))) {\r\n            let indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, model, model.getLanguageIdentifier().id, startLineNumber, indentConverter);\r\n            if (indentOfFirstLine !== null) {\r\n                let oldIndentation = strings.getLeadingWhitespace(firstLineText);\r\n                let newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\r\n                let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\r\n                if (newSpaceCnt !== oldSpaceCnt) {\r\n                    let newIndent = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\r\n                    textEdits.push({\r\n                        range: new Range(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),\r\n                        text: newIndent\r\n                    });\r\n                    firstLineText = newIndent + firstLineText.substr(oldIndentation.length);\r\n                }\r\n                else {\r\n                    let indentMetadata = LanguageConfigurationRegistry.getIndentMetadata(model, startLineNumber);\r\n                    if (indentMetadata === 0 || indentMetadata === 8 /* UNINDENT_MASK */) {\r\n                        // we paste content into a line where only contains whitespaces\r\n                        // after pasting, the indentation of the first line is already correct\r\n                        // the first line doesn't match any indentation rule\r\n                        // then no-op.\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const firstLineNumber = startLineNumber;\r\n        // ignore empty or ignored lines\r\n        while (startLineNumber < range.endLineNumber) {\r\n            if (!/\\S/.test(model.getLineContent(startLineNumber + 1))) {\r\n                startLineNumber++;\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        if (startLineNumber !== range.endLineNumber) {\r\n            let virtualModel = {\r\n                getLineTokens: (lineNumber) => {\r\n                    return model.getLineTokens(lineNumber);\r\n                },\r\n                getLanguageIdentifier: () => {\r\n                    return model.getLanguageIdentifier();\r\n                },\r\n                getLanguageIdAtPosition: (lineNumber, column) => {\r\n                    return model.getLanguageIdAtPosition(lineNumber, column);\r\n                },\r\n                getLineContent: (lineNumber) => {\r\n                    if (lineNumber === firstLineNumber) {\r\n                        return firstLineText;\r\n                    }\r\n                    else {\r\n                        return model.getLineContent(lineNumber);\r\n                    }\r\n                }\r\n            };\r\n            let indentOfSecondLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, virtualModel, model.getLanguageIdentifier().id, startLineNumber + 1, indentConverter);\r\n            if (indentOfSecondLine !== null) {\r\n                let newSpaceCntOfSecondLine = indentUtils.getSpaceCnt(indentOfSecondLine, tabSize);\r\n                let oldSpaceCntOfSecondLine = indentUtils.getSpaceCnt(strings.getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);\r\n                if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {\r\n                    let spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;\r\n                    for (let i = startLineNumber + 1; i <= range.endLineNumber; i++) {\r\n                        let lineContent = model.getLineContent(i);\r\n                        let originalIndent = strings.getLeadingWhitespace(lineContent);\r\n                        let originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\r\n                        let newSpacesCnt = originalSpacesCnt + spaceCntOffset;\r\n                        let newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\r\n                        if (newIndent !== originalIndent) {\r\n                            textEdits.push({\r\n                                range: new Range(i, 1, i, originalIndent.length + 1),\r\n                                text: newIndent\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (textEdits.length > 0) {\r\n            this.editor.pushUndoStop();\r\n            let cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());\r\n            this.editor.executeCommand('autoIndentOnPaste', cmd);\r\n            this.editor.pushUndoStop();\r\n        }\r\n    }\r\n    shouldIgnoreLine(model, lineNumber) {\r\n        model.forceTokenization(lineNumber);\r\n        let nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\r\n        if (nonWhitespaceColumn === 0) {\r\n            return true;\r\n        }\r\n        let tokens = model.getLineTokens(lineNumber);\r\n        if (tokens.getCount() > 0) {\r\n            let firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhitespaceColumn);\r\n            if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === 1 /* Comment */) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    dispose() {\r\n        this.callOnDispose.dispose();\r\n        this.callOnModel.dispose();\r\n    }\r\n}\r\nAutoIndentOnPaste.ID = 'editor.contrib.autoIndentOnPaste';\r\nfunction getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {\r\n    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\r\n        // Model is empty\r\n        return;\r\n    }\r\n    let spaces = '';\r\n    for (let i = 0; i < tabSize; i++) {\r\n        spaces += ' ';\r\n    }\r\n    let spacesRegExp = new RegExp(spaces, 'gi');\r\n    for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {\r\n        let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\r\n        if (lastIndentationColumn === 0) {\r\n            lastIndentationColumn = model.getLineMaxColumn(lineNumber);\r\n        }\r\n        if (lastIndentationColumn === 1) {\r\n            continue;\r\n        }\r\n        const originalIndentationRange = new Range(lineNumber, 1, lineNumber, lastIndentationColumn);\r\n        const originalIndentation = model.getValueInRange(originalIndentationRange);\r\n        const newIndentation = (tabsToSpaces\r\n            ? originalIndentation.replace(/\\t/ig, spaces)\r\n            : originalIndentation.replace(spacesRegExp, '\\t'));\r\n        builder.addEditOperation(originalIndentationRange, newIndentation);\r\n    }\r\n}\r\nexport class IndentationToSpacesCommand {\r\n    constructor(selection, tabSize) {\r\n        this.selection = selection;\r\n        this.tabSize = tabSize;\r\n        this.selectionId = null;\r\n    }\r\n    getEditOperations(model, builder) {\r\n        this.selectionId = builder.trackSelection(this.selection);\r\n        getIndentationEditOperations(model, builder, this.tabSize, true);\r\n    }\r\n    computeCursorState(model, helper) {\r\n        return helper.getTrackedSelection(this.selectionId);\r\n    }\r\n}\r\nexport class IndentationToTabsCommand {\r\n    constructor(selection, tabSize) {\r\n        this.selection = selection;\r\n        this.tabSize = tabSize;\r\n        this.selectionId = null;\r\n    }\r\n    getEditOperations(model, builder) {\r\n        this.selectionId = builder.trackSelection(this.selection);\r\n        getIndentationEditOperations(model, builder, this.tabSize, false);\r\n    }\r\n    computeCursorState(model, helper) {\r\n        return helper.getTrackedSelection(this.selectionId);\r\n    }\r\n}\r\nregisterEditorContribution(AutoIndentOnPaste.ID, AutoIndentOnPaste);\r\nregisterEditorAction(IndentationToSpacesAction);\r\nregisterEditorAction(IndentationToTabsAction);\r\nregisterEditorAction(IndentUsingTabs);\r\nregisterEditorAction(IndentUsingSpaces);\r\nregisterEditorAction(DetectIndentation);\r\nregisterEditorAction(ReindentLinesAction);\r\nregisterEditorAction(ReindentSelectedLinesAction);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}