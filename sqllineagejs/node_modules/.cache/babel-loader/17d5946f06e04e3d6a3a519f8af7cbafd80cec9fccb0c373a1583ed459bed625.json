{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport class Scanner {\n  constructor() {\n    this.value = '';\n    this.pos = 0;\n  }\n  static isDigitCharacter(ch) {\n    return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;\n  }\n\n  static isVariableCharacter(ch) {\n    return ch === 95 /* Underline */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 65 /* A */ && ch <= 90 /* Z */;\n  }\n\n  text(value) {\n    this.value = value;\n    this.pos = 0;\n  }\n  tokenText(token) {\n    return this.value.substr(token.pos, token.len);\n  }\n  next() {\n    if (this.pos >= this.value.length) {\n      return {\n        type: 14 /* EOF */,\n        pos: this.pos,\n        len: 0\n      };\n    }\n    let pos = this.pos;\n    let len = 0;\n    let ch = this.value.charCodeAt(pos);\n    let type;\n    // static types\n    type = Scanner._table[ch];\n    if (typeof type === 'number') {\n      this.pos += 1;\n      return {\n        type,\n        pos,\n        len: 1\n      };\n    }\n    // number\n    if (Scanner.isDigitCharacter(ch)) {\n      type = 8 /* Int */;\n      do {\n        len += 1;\n        ch = this.value.charCodeAt(pos + len);\n      } while (Scanner.isDigitCharacter(ch));\n      this.pos += len;\n      return {\n        type,\n        pos,\n        len\n      };\n    }\n    // variable name\n    if (Scanner.isVariableCharacter(ch)) {\n      type = 9 /* VariableName */;\n      do {\n        ch = this.value.charCodeAt(pos + ++len);\n      } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));\n      this.pos += len;\n      return {\n        type,\n        pos,\n        len\n      };\n    }\n    // format\n    type = 10 /* Format */;\n    do {\n      len += 1;\n      ch = this.value.charCodeAt(pos + len);\n    } while (!isNaN(ch) && typeof Scanner._table[ch] === 'undefined' // not static token\n    && !Scanner.isDigitCharacter(ch) // not number\n    && !Scanner.isVariableCharacter(ch) // not variable\n    );\n\n    this.pos += len;\n    return {\n      type,\n      pos,\n      len\n    };\n  }\n}\nScanner._table = {\n  [36 /* DollarSign */]: 0 /* Dollar */,\n  [58 /* Colon */]: 1 /* Colon */,\n  [44 /* Comma */]: 2 /* Comma */,\n  [123 /* OpenCurlyBrace */]: 3 /* CurlyOpen */,\n  [125 /* CloseCurlyBrace */]: 4 /* CurlyClose */,\n  [92 /* Backslash */]: 5 /* Backslash */,\n  [47 /* Slash */]: 6 /* Forwardslash */,\n  [124 /* Pipe */]: 7 /* Pipe */,\n  [43 /* Plus */]: 11 /* Plus */,\n  [45 /* Dash */]: 12 /* Dash */,\n  [63 /* QuestionMark */]: 13 /* QuestionMark */\n};\n\nexport class Marker {\n  constructor() {\n    this._children = [];\n  }\n  appendChild(child) {\n    if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {\n      // this and previous child are text -> merge them\n      this._children[this._children.length - 1].value += child.value;\n    } else {\n      // normal adoption of child\n      child.parent = this;\n      this._children.push(child);\n    }\n    return this;\n  }\n  replace(child, others) {\n    const {\n      parent\n    } = child;\n    const idx = parent.children.indexOf(child);\n    const newChildren = parent.children.slice(0);\n    newChildren.splice(idx, 1, ...others);\n    parent._children = newChildren;\n    (function _fixParent(children, parent) {\n      for (const child of children) {\n        child.parent = parent;\n        _fixParent(child.children, child);\n      }\n    })(others, parent);\n  }\n  get children() {\n    return this._children;\n  }\n  get snippet() {\n    let candidate = this;\n    while (true) {\n      if (!candidate) {\n        return undefined;\n      }\n      if (candidate instanceof TextmateSnippet) {\n        return candidate;\n      }\n      candidate = candidate.parent;\n    }\n  }\n  toString() {\n    return this.children.reduce((prev, cur) => prev + cur.toString(), '');\n  }\n  len() {\n    return 0;\n  }\n}\nexport class Text extends Marker {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  toString() {\n    return this.value;\n  }\n  len() {\n    return this.value.length;\n  }\n  clone() {\n    return new Text(this.value);\n  }\n}\nexport class TransformableMarker extends Marker {}\nexport class Placeholder extends TransformableMarker {\n  constructor(index) {\n    super();\n    this.index = index;\n  }\n  static compareByIndex(a, b) {\n    if (a.index === b.index) {\n      return 0;\n    } else if (a.isFinalTabstop) {\n      return 1;\n    } else if (b.isFinalTabstop) {\n      return -1;\n    } else if (a.index < b.index) {\n      return -1;\n    } else if (a.index > b.index) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  get isFinalTabstop() {\n    return this.index === 0;\n  }\n  get choice() {\n    return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : undefined;\n  }\n  clone() {\n    let ret = new Placeholder(this.index);\n    if (this.transform) {\n      ret.transform = this.transform.clone();\n    }\n    ret._children = this.children.map(child => child.clone());\n    return ret;\n  }\n}\nexport class Choice extends Marker {\n  constructor() {\n    super(...arguments);\n    this.options = [];\n  }\n  appendChild(marker) {\n    if (marker instanceof Text) {\n      marker.parent = this;\n      this.options.push(marker);\n    }\n    return this;\n  }\n  toString() {\n    return this.options[0].value;\n  }\n  len() {\n    return this.options[0].len();\n  }\n  clone() {\n    let ret = new Choice();\n    this.options.forEach(ret.appendChild, ret);\n    return ret;\n  }\n}\nexport class Transform extends Marker {\n  constructor() {\n    super(...arguments);\n    this.regexp = new RegExp('');\n  }\n  resolve(value) {\n    const _this = this;\n    let didMatch = false;\n    let ret = value.replace(this.regexp, function () {\n      didMatch = true;\n      return _this._replace(Array.prototype.slice.call(arguments, 0, -2));\n    });\n    // when the regex didn't match and when the transform has\n    // else branches, then run those\n    if (!didMatch && this._children.some(child => child instanceof FormatString && Boolean(child.elseValue))) {\n      ret = this._replace([]);\n    }\n    return ret;\n  }\n  _replace(groups) {\n    let ret = '';\n    for (const marker of this._children) {\n      if (marker instanceof FormatString) {\n        let value = groups[marker.index] || '';\n        value = marker.resolve(value);\n        ret += value;\n      } else {\n        ret += marker.toString();\n      }\n    }\n    return ret;\n  }\n  toString() {\n    return '';\n  }\n  clone() {\n    let ret = new Transform();\n    ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));\n    ret._children = this.children.map(child => child.clone());\n    return ret;\n  }\n}\nexport class FormatString extends Marker {\n  constructor(index, shorthandName, ifValue, elseValue) {\n    super();\n    this.index = index;\n    this.shorthandName = shorthandName;\n    this.ifValue = ifValue;\n    this.elseValue = elseValue;\n  }\n  resolve(value) {\n    if (this.shorthandName === 'upcase') {\n      return !value ? '' : value.toLocaleUpperCase();\n    } else if (this.shorthandName === 'downcase') {\n      return !value ? '' : value.toLocaleLowerCase();\n    } else if (this.shorthandName === 'capitalize') {\n      return !value ? '' : value[0].toLocaleUpperCase() + value.substr(1);\n    } else if (this.shorthandName === 'pascalcase') {\n      return !value ? '' : this._toPascalCase(value);\n    } else if (Boolean(value) && typeof this.ifValue === 'string') {\n      return this.ifValue;\n    } else if (!Boolean(value) && typeof this.elseValue === 'string') {\n      return this.elseValue;\n    } else {\n      return value || '';\n    }\n  }\n  _toPascalCase(value) {\n    const match = value.match(/[a-z]+/gi);\n    if (!match) {\n      return value;\n    }\n    return match.map(function (word) {\n      return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();\n    }).join('');\n  }\n  clone() {\n    let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);\n    return ret;\n  }\n}\nexport class Variable extends TransformableMarker {\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n  resolve(resolver) {\n    let value = resolver.resolve(this);\n    if (this.transform) {\n      value = this.transform.resolve(value || '');\n    }\n    if (value !== undefined) {\n      this._children = [new Text(value)];\n      return true;\n    }\n    return false;\n  }\n  clone() {\n    const ret = new Variable(this.name);\n    if (this.transform) {\n      ret.transform = this.transform.clone();\n    }\n    ret._children = this.children.map(child => child.clone());\n    return ret;\n  }\n}\nfunction walk(marker, visitor) {\n  const stack = [...marker];\n  while (stack.length > 0) {\n    const marker = stack.shift();\n    const recurse = visitor(marker);\n    if (!recurse) {\n      break;\n    }\n    stack.unshift(...marker.children);\n  }\n}\nexport class TextmateSnippet extends Marker {\n  get placeholderInfo() {\n    if (!this._placeholders) {\n      // fill in placeholders\n      let all = [];\n      let last;\n      this.walk(function (candidate) {\n        if (candidate instanceof Placeholder) {\n          all.push(candidate);\n          last = !last || last.index < candidate.index ? candidate : last;\n        }\n        return true;\n      });\n      this._placeholders = {\n        all,\n        last\n      };\n    }\n    return this._placeholders;\n  }\n  get placeholders() {\n    const {\n      all\n    } = this.placeholderInfo;\n    return all;\n  }\n  offset(marker) {\n    let pos = 0;\n    let found = false;\n    this.walk(candidate => {\n      if (candidate === marker) {\n        found = true;\n        return false;\n      }\n      pos += candidate.len();\n      return true;\n    });\n    if (!found) {\n      return -1;\n    }\n    return pos;\n  }\n  fullLen(marker) {\n    let ret = 0;\n    walk([marker], marker => {\n      ret += marker.len();\n      return true;\n    });\n    return ret;\n  }\n  enclosingPlaceholders(placeholder) {\n    let ret = [];\n    let {\n      parent\n    } = placeholder;\n    while (parent) {\n      if (parent instanceof Placeholder) {\n        ret.push(parent);\n      }\n      parent = parent.parent;\n    }\n    return ret;\n  }\n  resolveVariables(resolver) {\n    this.walk(candidate => {\n      if (candidate instanceof Variable) {\n        if (candidate.resolve(resolver)) {\n          this._placeholders = undefined;\n        }\n      }\n      return true;\n    });\n    return this;\n  }\n  appendChild(child) {\n    this._placeholders = undefined;\n    return super.appendChild(child);\n  }\n  replace(child, others) {\n    this._placeholders = undefined;\n    return super.replace(child, others);\n  }\n  clone() {\n    let ret = new TextmateSnippet();\n    this._children = this.children.map(child => child.clone());\n    return ret;\n  }\n  walk(visitor) {\n    walk(this.children, visitor);\n  }\n}\nexport class SnippetParser {\n  constructor() {\n    this._scanner = new Scanner();\n    this._token = {\n      type: 14 /* EOF */,\n      pos: 0,\n      len: 0\n    };\n  }\n  static escape(value) {\n    return value.replace(/\\$|}|\\\\/g, '\\\\$&');\n  }\n  static guessNeedsClipboard(template) {\n    return /\\${?CLIPBOARD/.test(template);\n  }\n  parse(value, insertFinalTabstop, enforceFinalTabstop) {\n    this._scanner.text(value);\n    this._token = this._scanner.next();\n    const snippet = new TextmateSnippet();\n    while (this._parse(snippet)) {\n      // nothing\n    }\n    // fill in values for placeholders. the first placeholder of an index\n    // that has a value defines the value for all placeholders with that index\n    const placeholderDefaultValues = new Map();\n    const incompletePlaceholders = [];\n    let placeholderCount = 0;\n    snippet.walk(marker => {\n      if (marker instanceof Placeholder) {\n        placeholderCount += 1;\n        if (marker.isFinalTabstop) {\n          placeholderDefaultValues.set(0, undefined);\n        } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {\n          placeholderDefaultValues.set(marker.index, marker.children);\n        } else {\n          incompletePlaceholders.push(marker);\n        }\n      }\n      return true;\n    });\n    for (const placeholder of incompletePlaceholders) {\n      const defaultValues = placeholderDefaultValues.get(placeholder.index);\n      if (defaultValues) {\n        const clone = new Placeholder(placeholder.index);\n        clone.transform = placeholder.transform;\n        for (const child of defaultValues) {\n          clone.appendChild(child.clone());\n        }\n        snippet.replace(placeholder, [clone]);\n      }\n    }\n    if (!enforceFinalTabstop) {\n      enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;\n    }\n    if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {\n      // the snippet uses placeholders but has no\n      // final tabstop defined -> insert at the end\n      snippet.appendChild(new Placeholder(0));\n    }\n    return snippet;\n  }\n  _accept(type, value) {\n    if (type === undefined || this._token.type === type) {\n      let ret = !value ? true : this._scanner.tokenText(this._token);\n      this._token = this._scanner.next();\n      return ret;\n    }\n    return false;\n  }\n  _backTo(token) {\n    this._scanner.pos = token.pos + token.len;\n    this._token = token;\n    return false;\n  }\n  _until(type) {\n    const start = this._token;\n    while (this._token.type !== type) {\n      if (this._token.type === 14 /* EOF */) {\n        return false;\n      } else if (this._token.type === 5 /* Backslash */) {\n        const nextToken = this._scanner.next();\n        if (nextToken.type !== 0 /* Dollar */ && nextToken.type !== 4 /* CurlyClose */ && nextToken.type !== 5 /* Backslash */) {\n          return false;\n        }\n      }\n      this._token = this._scanner.next();\n    }\n    const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\\\(\\$|}|\\\\)/g, '$1');\n    this._token = this._scanner.next();\n    return value;\n  }\n  _parse(marker) {\n    return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);\n  }\n  // \\$, \\\\, \\} -> just text\n  _parseEscaped(marker) {\n    let value;\n    if (value = this._accept(5 /* Backslash */, true)) {\n      // saw a backslash, append escaped token or that backslash\n      value = this._accept(0 /* Dollar */, true) || this._accept(4 /* CurlyClose */, true) || this._accept(5 /* Backslash */, true) || value;\n      marker.appendChild(new Text(value));\n      return true;\n    }\n    return false;\n  }\n  // $foo -> variable, $1 -> tabstop\n  _parseTabstopOrVariableName(parent) {\n    let value;\n    const token = this._token;\n    const match = this._accept(0 /* Dollar */) && (value = this._accept(9 /* VariableName */, true) || this._accept(8 /* Int */, true));\n    if (!match) {\n      return this._backTo(token);\n    }\n    parent.appendChild(/^\\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));\n    return true;\n  }\n  // ${1:<children>}, ${1} -> placeholder\n  _parseComplexPlaceholder(parent) {\n    let index;\n    const token = this._token;\n    const match = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (index = this._accept(8 /* Int */, true));\n    if (!match) {\n      return this._backTo(token);\n    }\n    const placeholder = new Placeholder(Number(index));\n    if (this._accept(1 /* Colon */)) {\n      // ${1:<children>}\n      while (true) {\n        // ...} -> done\n        if (this._accept(4 /* CurlyClose */)) {\n          parent.appendChild(placeholder);\n          return true;\n        }\n        if (this._parse(placeholder)) {\n          continue;\n        }\n        // fallback\n        parent.appendChild(new Text('${' + index + ':'));\n        placeholder.children.forEach(parent.appendChild, parent);\n        return true;\n      }\n    } else if (placeholder.index > 0 && this._accept(7 /* Pipe */)) {\n      // ${1|one,two,three|}\n      const choice = new Choice();\n      while (true) {\n        if (this._parseChoiceElement(choice)) {\n          if (this._accept(2 /* Comma */)) {\n            // opt, -> more\n            continue;\n          }\n          if (this._accept(7 /* Pipe */)) {\n            placeholder.appendChild(choice);\n            if (this._accept(4 /* CurlyClose */)) {\n              // ..|} -> done\n              parent.appendChild(placeholder);\n              return true;\n            }\n          }\n        }\n        this._backTo(token);\n        return false;\n      }\n    } else if (this._accept(6 /* Forwardslash */)) {\n      // ${1/<regex>/<format>/<options>}\n      if (this._parseTransform(placeholder)) {\n        parent.appendChild(placeholder);\n        return true;\n      }\n      this._backTo(token);\n      return false;\n    } else if (this._accept(4 /* CurlyClose */)) {\n      // ${1}\n      parent.appendChild(placeholder);\n      return true;\n    } else {\n      // ${1 <- missing curly or colon\n      return this._backTo(token);\n    }\n  }\n  _parseChoiceElement(parent) {\n    const token = this._token;\n    const values = [];\n    while (true) {\n      if (this._token.type === 2 /* Comma */ || this._token.type === 7 /* Pipe */) {\n        break;\n      }\n      let value;\n      if (value = this._accept(5 /* Backslash */, true)) {\n        // \\, \\|, or \\\\\n        value = this._accept(2 /* Comma */, true) || this._accept(7 /* Pipe */, true) || this._accept(5 /* Backslash */, true) || value;\n      } else {\n        value = this._accept(undefined, true);\n      }\n      if (!value) {\n        // EOF\n        this._backTo(token);\n        return false;\n      }\n      values.push(value);\n    }\n    if (values.length === 0) {\n      this._backTo(token);\n      return false;\n    }\n    parent.appendChild(new Text(values.join('')));\n    return true;\n  }\n  // ${foo:<children>}, ${foo} -> variable\n  _parseComplexVariable(parent) {\n    let name;\n    const token = this._token;\n    const match = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (name = this._accept(9 /* VariableName */, true));\n    if (!match) {\n      return this._backTo(token);\n    }\n    const variable = new Variable(name);\n    if (this._accept(1 /* Colon */)) {\n      // ${foo:<children>}\n      while (true) {\n        // ...} -> done\n        if (this._accept(4 /* CurlyClose */)) {\n          parent.appendChild(variable);\n          return true;\n        }\n        if (this._parse(variable)) {\n          continue;\n        }\n        // fallback\n        parent.appendChild(new Text('${' + name + ':'));\n        variable.children.forEach(parent.appendChild, parent);\n        return true;\n      }\n    } else if (this._accept(6 /* Forwardslash */)) {\n      // ${foo/<regex>/<format>/<options>}\n      if (this._parseTransform(variable)) {\n        parent.appendChild(variable);\n        return true;\n      }\n      this._backTo(token);\n      return false;\n    } else if (this._accept(4 /* CurlyClose */)) {\n      // ${foo}\n      parent.appendChild(variable);\n      return true;\n    } else {\n      // ${foo <- missing curly or colon\n      return this._backTo(token);\n    }\n  }\n  _parseTransform(parent) {\n    // ...<regex>/<format>/<options>}\n    let transform = new Transform();\n    let regexValue = '';\n    let regexOptions = '';\n    // (1) /regex\n    while (true) {\n      if (this._accept(6 /* Forwardslash */)) {\n        break;\n      }\n      let escaped;\n      if (escaped = this._accept(5 /* Backslash */, true)) {\n        escaped = this._accept(6 /* Forwardslash */, true) || escaped;\n        regexValue += escaped;\n        continue;\n      }\n      if (this._token.type !== 14 /* EOF */) {\n        regexValue += this._accept(undefined, true);\n        continue;\n      }\n      return false;\n    }\n    // (2) /format\n    while (true) {\n      if (this._accept(6 /* Forwardslash */)) {\n        break;\n      }\n      let escaped;\n      if (escaped = this._accept(5 /* Backslash */, true)) {\n        escaped = this._accept(5 /* Backslash */, true) || this._accept(6 /* Forwardslash */, true) || escaped;\n        transform.appendChild(new Text(escaped));\n        continue;\n      }\n      if (this._parseFormatString(transform) || this._parseAnything(transform)) {\n        continue;\n      }\n      return false;\n    }\n    // (3) /option\n    while (true) {\n      if (this._accept(4 /* CurlyClose */)) {\n        break;\n      }\n      if (this._token.type !== 14 /* EOF */) {\n        regexOptions += this._accept(undefined, true);\n        continue;\n      }\n      return false;\n    }\n    try {\n      transform.regexp = new RegExp(regexValue, regexOptions);\n    } catch (e) {\n      // invalid regexp\n      return false;\n    }\n    parent.transform = transform;\n    return true;\n  }\n  _parseFormatString(parent) {\n    const token = this._token;\n    if (!this._accept(0 /* Dollar */)) {\n      return false;\n    }\n    let complex = false;\n    if (this._accept(3 /* CurlyOpen */)) {\n      complex = true;\n    }\n    let index = this._accept(8 /* Int */, true);\n    if (!index) {\n      this._backTo(token);\n      return false;\n    } else if (!complex) {\n      // $1\n      parent.appendChild(new FormatString(Number(index)));\n      return true;\n    } else if (this._accept(4 /* CurlyClose */)) {\n      // ${1}\n      parent.appendChild(new FormatString(Number(index)));\n      return true;\n    } else if (!this._accept(1 /* Colon */)) {\n      this._backTo(token);\n      return false;\n    }\n    if (this._accept(6 /* Forwardslash */)) {\n      // ${1:/upcase}\n      let shorthand = this._accept(9 /* VariableName */, true);\n      if (!shorthand || !this._accept(4 /* CurlyClose */)) {\n        this._backTo(token);\n        return false;\n      } else {\n        parent.appendChild(new FormatString(Number(index), shorthand));\n        return true;\n      }\n    } else if (this._accept(11 /* Plus */)) {\n      // ${1:+<if>}\n      let ifValue = this._until(4 /* CurlyClose */);\n      if (ifValue) {\n        parent.appendChild(new FormatString(Number(index), undefined, ifValue, undefined));\n        return true;\n      }\n    } else if (this._accept(12 /* Dash */)) {\n      // ${2:-<else>}\n      let elseValue = this._until(4 /* CurlyClose */);\n      if (elseValue) {\n        parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n        return true;\n      }\n    } else if (this._accept(13 /* QuestionMark */)) {\n      // ${2:?<if>:<else>}\n      let ifValue = this._until(1 /* Colon */);\n      if (ifValue) {\n        let elseValue = this._until(4 /* CurlyClose */);\n        if (elseValue) {\n          parent.appendChild(new FormatString(Number(index), undefined, ifValue, elseValue));\n          return true;\n        }\n      }\n    } else {\n      // ${1:<else>}\n      let elseValue = this._until(4 /* CurlyClose */);\n      if (elseValue) {\n        parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\n        return true;\n      }\n    }\n    this._backTo(token);\n    return false;\n  }\n  _parseAnything(marker) {\n    if (this._token.type !== 14 /* EOF */) {\n      marker.appendChild(new Text(this._scanner.tokenText(this._token)));\n      this._accept(undefined);\n      return true;\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["Scanner","constructor","value","pos","isDigitCharacter","ch","isVariableCharacter","text","tokenText","token","substr","len","next","length","type","charCodeAt","_table","isNaN","Marker","_children","appendChild","child","Text","parent","push","replace","others","idx","children","indexOf","newChildren","slice","splice","_fixParent","snippet","candidate","undefined","TextmateSnippet","toString","reduce","prev","cur","clone","TransformableMarker","Placeholder","index","compareByIndex","a","b","isFinalTabstop","choice","Choice","ret","transform","map","arguments","options","marker","forEach","Transform","regexp","RegExp","resolve","_this","didMatch","_replace","Array","prototype","call","some","FormatString","Boolean","elseValue","groups","source","ignoreCase","global","shorthandName","ifValue","toLocaleUpperCase","toLocaleLowerCase","_toPascalCase","match","word","charAt","toUpperCase","toLowerCase","join","Variable","name","resolver","walk","visitor","stack","shift","recurse","unshift","placeholderInfo","_placeholders","all","last","placeholders","offset","found","fullLen","enclosingPlaceholders","placeholder","resolveVariables","SnippetParser","_scanner","_token","escape","guessNeedsClipboard","template","test","parse","insertFinalTabstop","enforceFinalTabstop","_parse","placeholderDefaultValues","Map","incompletePlaceholders","placeholderCount","set","has","defaultValues","get","_accept","_backTo","_until","start","nextToken","substring","_parseEscaped","_parseTabstopOrVariableName","_parseComplexPlaceholder","_parseComplexVariable","_parseAnything","Number","_parseChoiceElement","_parseTransform","values","variable","regexValue","regexOptions","escaped","_parseFormatString","e","complex","shorthand"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetParser.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport class Scanner {\r\n    constructor() {\r\n        this.value = '';\r\n        this.pos = 0;\r\n    }\r\n    static isDigitCharacter(ch) {\r\n        return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;\r\n    }\r\n    static isVariableCharacter(ch) {\r\n        return ch === 95 /* Underline */\r\n            || (ch >= 97 /* a */ && ch <= 122 /* z */)\r\n            || (ch >= 65 /* A */ && ch <= 90 /* Z */);\r\n    }\r\n    text(value) {\r\n        this.value = value;\r\n        this.pos = 0;\r\n    }\r\n    tokenText(token) {\r\n        return this.value.substr(token.pos, token.len);\r\n    }\r\n    next() {\r\n        if (this.pos >= this.value.length) {\r\n            return { type: 14 /* EOF */, pos: this.pos, len: 0 };\r\n        }\r\n        let pos = this.pos;\r\n        let len = 0;\r\n        let ch = this.value.charCodeAt(pos);\r\n        let type;\r\n        // static types\r\n        type = Scanner._table[ch];\r\n        if (typeof type === 'number') {\r\n            this.pos += 1;\r\n            return { type, pos, len: 1 };\r\n        }\r\n        // number\r\n        if (Scanner.isDigitCharacter(ch)) {\r\n            type = 8 /* Int */;\r\n            do {\r\n                len += 1;\r\n                ch = this.value.charCodeAt(pos + len);\r\n            } while (Scanner.isDigitCharacter(ch));\r\n            this.pos += len;\r\n            return { type, pos, len };\r\n        }\r\n        // variable name\r\n        if (Scanner.isVariableCharacter(ch)) {\r\n            type = 9 /* VariableName */;\r\n            do {\r\n                ch = this.value.charCodeAt(pos + (++len));\r\n            } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));\r\n            this.pos += len;\r\n            return { type, pos, len };\r\n        }\r\n        // format\r\n        type = 10 /* Format */;\r\n        do {\r\n            len += 1;\r\n            ch = this.value.charCodeAt(pos + len);\r\n        } while (!isNaN(ch)\r\n            && typeof Scanner._table[ch] === 'undefined' // not static token\r\n            && !Scanner.isDigitCharacter(ch) // not number\r\n            && !Scanner.isVariableCharacter(ch) // not variable\r\n        );\r\n        this.pos += len;\r\n        return { type, pos, len };\r\n    }\r\n}\r\nScanner._table = {\r\n    [36 /* DollarSign */]: 0 /* Dollar */,\r\n    [58 /* Colon */]: 1 /* Colon */,\r\n    [44 /* Comma */]: 2 /* Comma */,\r\n    [123 /* OpenCurlyBrace */]: 3 /* CurlyOpen */,\r\n    [125 /* CloseCurlyBrace */]: 4 /* CurlyClose */,\r\n    [92 /* Backslash */]: 5 /* Backslash */,\r\n    [47 /* Slash */]: 6 /* Forwardslash */,\r\n    [124 /* Pipe */]: 7 /* Pipe */,\r\n    [43 /* Plus */]: 11 /* Plus */,\r\n    [45 /* Dash */]: 12 /* Dash */,\r\n    [63 /* QuestionMark */]: 13 /* QuestionMark */,\r\n};\r\nexport class Marker {\r\n    constructor() {\r\n        this._children = [];\r\n    }\r\n    appendChild(child) {\r\n        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {\r\n            // this and previous child are text -> merge them\r\n            this._children[this._children.length - 1].value += child.value;\r\n        }\r\n        else {\r\n            // normal adoption of child\r\n            child.parent = this;\r\n            this._children.push(child);\r\n        }\r\n        return this;\r\n    }\r\n    replace(child, others) {\r\n        const { parent } = child;\r\n        const idx = parent.children.indexOf(child);\r\n        const newChildren = parent.children.slice(0);\r\n        newChildren.splice(idx, 1, ...others);\r\n        parent._children = newChildren;\r\n        (function _fixParent(children, parent) {\r\n            for (const child of children) {\r\n                child.parent = parent;\r\n                _fixParent(child.children, child);\r\n            }\r\n        })(others, parent);\r\n    }\r\n    get children() {\r\n        return this._children;\r\n    }\r\n    get snippet() {\r\n        let candidate = this;\r\n        while (true) {\r\n            if (!candidate) {\r\n                return undefined;\r\n            }\r\n            if (candidate instanceof TextmateSnippet) {\r\n                return candidate;\r\n            }\r\n            candidate = candidate.parent;\r\n        }\r\n    }\r\n    toString() {\r\n        return this.children.reduce((prev, cur) => prev + cur.toString(), '');\r\n    }\r\n    len() {\r\n        return 0;\r\n    }\r\n}\r\nexport class Text extends Marker {\r\n    constructor(value) {\r\n        super();\r\n        this.value = value;\r\n    }\r\n    toString() {\r\n        return this.value;\r\n    }\r\n    len() {\r\n        return this.value.length;\r\n    }\r\n    clone() {\r\n        return new Text(this.value);\r\n    }\r\n}\r\nexport class TransformableMarker extends Marker {\r\n}\r\nexport class Placeholder extends TransformableMarker {\r\n    constructor(index) {\r\n        super();\r\n        this.index = index;\r\n    }\r\n    static compareByIndex(a, b) {\r\n        if (a.index === b.index) {\r\n            return 0;\r\n        }\r\n        else if (a.isFinalTabstop) {\r\n            return 1;\r\n        }\r\n        else if (b.isFinalTabstop) {\r\n            return -1;\r\n        }\r\n        else if (a.index < b.index) {\r\n            return -1;\r\n        }\r\n        else if (a.index > b.index) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    get isFinalTabstop() {\r\n        return this.index === 0;\r\n    }\r\n    get choice() {\r\n        return this._children.length === 1 && this._children[0] instanceof Choice\r\n            ? this._children[0]\r\n            : undefined;\r\n    }\r\n    clone() {\r\n        let ret = new Placeholder(this.index);\r\n        if (this.transform) {\r\n            ret.transform = this.transform.clone();\r\n        }\r\n        ret._children = this.children.map(child => child.clone());\r\n        return ret;\r\n    }\r\n}\r\nexport class Choice extends Marker {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.options = [];\r\n    }\r\n    appendChild(marker) {\r\n        if (marker instanceof Text) {\r\n            marker.parent = this;\r\n            this.options.push(marker);\r\n        }\r\n        return this;\r\n    }\r\n    toString() {\r\n        return this.options[0].value;\r\n    }\r\n    len() {\r\n        return this.options[0].len();\r\n    }\r\n    clone() {\r\n        let ret = new Choice();\r\n        this.options.forEach(ret.appendChild, ret);\r\n        return ret;\r\n    }\r\n}\r\nexport class Transform extends Marker {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.regexp = new RegExp('');\r\n    }\r\n    resolve(value) {\r\n        const _this = this;\r\n        let didMatch = false;\r\n        let ret = value.replace(this.regexp, function () {\r\n            didMatch = true;\r\n            return _this._replace(Array.prototype.slice.call(arguments, 0, -2));\r\n        });\r\n        // when the regex didn't match and when the transform has\r\n        // else branches, then run those\r\n        if (!didMatch && this._children.some(child => child instanceof FormatString && Boolean(child.elseValue))) {\r\n            ret = this._replace([]);\r\n        }\r\n        return ret;\r\n    }\r\n    _replace(groups) {\r\n        let ret = '';\r\n        for (const marker of this._children) {\r\n            if (marker instanceof FormatString) {\r\n                let value = groups[marker.index] || '';\r\n                value = marker.resolve(value);\r\n                ret += value;\r\n            }\r\n            else {\r\n                ret += marker.toString();\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    toString() {\r\n        return '';\r\n    }\r\n    clone() {\r\n        let ret = new Transform();\r\n        ret.regexp = new RegExp(this.regexp.source, '' + (this.regexp.ignoreCase ? 'i' : '') + (this.regexp.global ? 'g' : ''));\r\n        ret._children = this.children.map(child => child.clone());\r\n        return ret;\r\n    }\r\n}\r\nexport class FormatString extends Marker {\r\n    constructor(index, shorthandName, ifValue, elseValue) {\r\n        super();\r\n        this.index = index;\r\n        this.shorthandName = shorthandName;\r\n        this.ifValue = ifValue;\r\n        this.elseValue = elseValue;\r\n    }\r\n    resolve(value) {\r\n        if (this.shorthandName === 'upcase') {\r\n            return !value ? '' : value.toLocaleUpperCase();\r\n        }\r\n        else if (this.shorthandName === 'downcase') {\r\n            return !value ? '' : value.toLocaleLowerCase();\r\n        }\r\n        else if (this.shorthandName === 'capitalize') {\r\n            return !value ? '' : (value[0].toLocaleUpperCase() + value.substr(1));\r\n        }\r\n        else if (this.shorthandName === 'pascalcase') {\r\n            return !value ? '' : this._toPascalCase(value);\r\n        }\r\n        else if (Boolean(value) && typeof this.ifValue === 'string') {\r\n            return this.ifValue;\r\n        }\r\n        else if (!Boolean(value) && typeof this.elseValue === 'string') {\r\n            return this.elseValue;\r\n        }\r\n        else {\r\n            return value || '';\r\n        }\r\n    }\r\n    _toPascalCase(value) {\r\n        const match = value.match(/[a-z]+/gi);\r\n        if (!match) {\r\n            return value;\r\n        }\r\n        return match.map(function (word) {\r\n            return word.charAt(0).toUpperCase()\r\n                + word.substr(1).toLowerCase();\r\n        })\r\n            .join('');\r\n    }\r\n    clone() {\r\n        let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);\r\n        return ret;\r\n    }\r\n}\r\nexport class Variable extends TransformableMarker {\r\n    constructor(name) {\r\n        super();\r\n        this.name = name;\r\n    }\r\n    resolve(resolver) {\r\n        let value = resolver.resolve(this);\r\n        if (this.transform) {\r\n            value = this.transform.resolve(value || '');\r\n        }\r\n        if (value !== undefined) {\r\n            this._children = [new Text(value)];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    clone() {\r\n        const ret = new Variable(this.name);\r\n        if (this.transform) {\r\n            ret.transform = this.transform.clone();\r\n        }\r\n        ret._children = this.children.map(child => child.clone());\r\n        return ret;\r\n    }\r\n}\r\nfunction walk(marker, visitor) {\r\n    const stack = [...marker];\r\n    while (stack.length > 0) {\r\n        const marker = stack.shift();\r\n        const recurse = visitor(marker);\r\n        if (!recurse) {\r\n            break;\r\n        }\r\n        stack.unshift(...marker.children);\r\n    }\r\n}\r\nexport class TextmateSnippet extends Marker {\r\n    get placeholderInfo() {\r\n        if (!this._placeholders) {\r\n            // fill in placeholders\r\n            let all = [];\r\n            let last;\r\n            this.walk(function (candidate) {\r\n                if (candidate instanceof Placeholder) {\r\n                    all.push(candidate);\r\n                    last = !last || last.index < candidate.index ? candidate : last;\r\n                }\r\n                return true;\r\n            });\r\n            this._placeholders = { all, last };\r\n        }\r\n        return this._placeholders;\r\n    }\r\n    get placeholders() {\r\n        const { all } = this.placeholderInfo;\r\n        return all;\r\n    }\r\n    offset(marker) {\r\n        let pos = 0;\r\n        let found = false;\r\n        this.walk(candidate => {\r\n            if (candidate === marker) {\r\n                found = true;\r\n                return false;\r\n            }\r\n            pos += candidate.len();\r\n            return true;\r\n        });\r\n        if (!found) {\r\n            return -1;\r\n        }\r\n        return pos;\r\n    }\r\n    fullLen(marker) {\r\n        let ret = 0;\r\n        walk([marker], marker => {\r\n            ret += marker.len();\r\n            return true;\r\n        });\r\n        return ret;\r\n    }\r\n    enclosingPlaceholders(placeholder) {\r\n        let ret = [];\r\n        let { parent } = placeholder;\r\n        while (parent) {\r\n            if (parent instanceof Placeholder) {\r\n                ret.push(parent);\r\n            }\r\n            parent = parent.parent;\r\n        }\r\n        return ret;\r\n    }\r\n    resolveVariables(resolver) {\r\n        this.walk(candidate => {\r\n            if (candidate instanceof Variable) {\r\n                if (candidate.resolve(resolver)) {\r\n                    this._placeholders = undefined;\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n        return this;\r\n    }\r\n    appendChild(child) {\r\n        this._placeholders = undefined;\r\n        return super.appendChild(child);\r\n    }\r\n    replace(child, others) {\r\n        this._placeholders = undefined;\r\n        return super.replace(child, others);\r\n    }\r\n    clone() {\r\n        let ret = new TextmateSnippet();\r\n        this._children = this.children.map(child => child.clone());\r\n        return ret;\r\n    }\r\n    walk(visitor) {\r\n        walk(this.children, visitor);\r\n    }\r\n}\r\nexport class SnippetParser {\r\n    constructor() {\r\n        this._scanner = new Scanner();\r\n        this._token = { type: 14 /* EOF */, pos: 0, len: 0 };\r\n    }\r\n    static escape(value) {\r\n        return value.replace(/\\$|}|\\\\/g, '\\\\$&');\r\n    }\r\n    static guessNeedsClipboard(template) {\r\n        return /\\${?CLIPBOARD/.test(template);\r\n    }\r\n    parse(value, insertFinalTabstop, enforceFinalTabstop) {\r\n        this._scanner.text(value);\r\n        this._token = this._scanner.next();\r\n        const snippet = new TextmateSnippet();\r\n        while (this._parse(snippet)) {\r\n            // nothing\r\n        }\r\n        // fill in values for placeholders. the first placeholder of an index\r\n        // that has a value defines the value for all placeholders with that index\r\n        const placeholderDefaultValues = new Map();\r\n        const incompletePlaceholders = [];\r\n        let placeholderCount = 0;\r\n        snippet.walk(marker => {\r\n            if (marker instanceof Placeholder) {\r\n                placeholderCount += 1;\r\n                if (marker.isFinalTabstop) {\r\n                    placeholderDefaultValues.set(0, undefined);\r\n                }\r\n                else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {\r\n                    placeholderDefaultValues.set(marker.index, marker.children);\r\n                }\r\n                else {\r\n                    incompletePlaceholders.push(marker);\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n        for (const placeholder of incompletePlaceholders) {\r\n            const defaultValues = placeholderDefaultValues.get(placeholder.index);\r\n            if (defaultValues) {\r\n                const clone = new Placeholder(placeholder.index);\r\n                clone.transform = placeholder.transform;\r\n                for (const child of defaultValues) {\r\n                    clone.appendChild(child.clone());\r\n                }\r\n                snippet.replace(placeholder, [clone]);\r\n            }\r\n        }\r\n        if (!enforceFinalTabstop) {\r\n            enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;\r\n        }\r\n        if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {\r\n            // the snippet uses placeholders but has no\r\n            // final tabstop defined -> insert at the end\r\n            snippet.appendChild(new Placeholder(0));\r\n        }\r\n        return snippet;\r\n    }\r\n    _accept(type, value) {\r\n        if (type === undefined || this._token.type === type) {\r\n            let ret = !value ? true : this._scanner.tokenText(this._token);\r\n            this._token = this._scanner.next();\r\n            return ret;\r\n        }\r\n        return false;\r\n    }\r\n    _backTo(token) {\r\n        this._scanner.pos = token.pos + token.len;\r\n        this._token = token;\r\n        return false;\r\n    }\r\n    _until(type) {\r\n        const start = this._token;\r\n        while (this._token.type !== type) {\r\n            if (this._token.type === 14 /* EOF */) {\r\n                return false;\r\n            }\r\n            else if (this._token.type === 5 /* Backslash */) {\r\n                const nextToken = this._scanner.next();\r\n                if (nextToken.type !== 0 /* Dollar */\r\n                    && nextToken.type !== 4 /* CurlyClose */\r\n                    && nextToken.type !== 5 /* Backslash */) {\r\n                    return false;\r\n                }\r\n            }\r\n            this._token = this._scanner.next();\r\n        }\r\n        const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\\\(\\$|}|\\\\)/g, '$1');\r\n        this._token = this._scanner.next();\r\n        return value;\r\n    }\r\n    _parse(marker) {\r\n        return this._parseEscaped(marker)\r\n            || this._parseTabstopOrVariableName(marker)\r\n            || this._parseComplexPlaceholder(marker)\r\n            || this._parseComplexVariable(marker)\r\n            || this._parseAnything(marker);\r\n    }\r\n    // \\$, \\\\, \\} -> just text\r\n    _parseEscaped(marker) {\r\n        let value;\r\n        if (value = this._accept(5 /* Backslash */, true)) {\r\n            // saw a backslash, append escaped token or that backslash\r\n            value = this._accept(0 /* Dollar */, true)\r\n                || this._accept(4 /* CurlyClose */, true)\r\n                || this._accept(5 /* Backslash */, true)\r\n                || value;\r\n            marker.appendChild(new Text(value));\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // $foo -> variable, $1 -> tabstop\r\n    _parseTabstopOrVariableName(parent) {\r\n        let value;\r\n        const token = this._token;\r\n        const match = this._accept(0 /* Dollar */)\r\n            && (value = this._accept(9 /* VariableName */, true) || this._accept(8 /* Int */, true));\r\n        if (!match) {\r\n            return this._backTo(token);\r\n        }\r\n        parent.appendChild(/^\\d+$/.test(value)\r\n            ? new Placeholder(Number(value))\r\n            : new Variable(value));\r\n        return true;\r\n    }\r\n    // ${1:<children>}, ${1} -> placeholder\r\n    _parseComplexPlaceholder(parent) {\r\n        let index;\r\n        const token = this._token;\r\n        const match = this._accept(0 /* Dollar */)\r\n            && this._accept(3 /* CurlyOpen */)\r\n            && (index = this._accept(8 /* Int */, true));\r\n        if (!match) {\r\n            return this._backTo(token);\r\n        }\r\n        const placeholder = new Placeholder(Number(index));\r\n        if (this._accept(1 /* Colon */)) {\r\n            // ${1:<children>}\r\n            while (true) {\r\n                // ...} -> done\r\n                if (this._accept(4 /* CurlyClose */)) {\r\n                    parent.appendChild(placeholder);\r\n                    return true;\r\n                }\r\n                if (this._parse(placeholder)) {\r\n                    continue;\r\n                }\r\n                // fallback\r\n                parent.appendChild(new Text('${' + index + ':'));\r\n                placeholder.children.forEach(parent.appendChild, parent);\r\n                return true;\r\n            }\r\n        }\r\n        else if (placeholder.index > 0 && this._accept(7 /* Pipe */)) {\r\n            // ${1|one,two,three|}\r\n            const choice = new Choice();\r\n            while (true) {\r\n                if (this._parseChoiceElement(choice)) {\r\n                    if (this._accept(2 /* Comma */)) {\r\n                        // opt, -> more\r\n                        continue;\r\n                    }\r\n                    if (this._accept(7 /* Pipe */)) {\r\n                        placeholder.appendChild(choice);\r\n                        if (this._accept(4 /* CurlyClose */)) {\r\n                            // ..|} -> done\r\n                            parent.appendChild(placeholder);\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n                this._backTo(token);\r\n                return false;\r\n            }\r\n        }\r\n        else if (this._accept(6 /* Forwardslash */)) {\r\n            // ${1/<regex>/<format>/<options>}\r\n            if (this._parseTransform(placeholder)) {\r\n                parent.appendChild(placeholder);\r\n                return true;\r\n            }\r\n            this._backTo(token);\r\n            return false;\r\n        }\r\n        else if (this._accept(4 /* CurlyClose */)) {\r\n            // ${1}\r\n            parent.appendChild(placeholder);\r\n            return true;\r\n        }\r\n        else {\r\n            // ${1 <- missing curly or colon\r\n            return this._backTo(token);\r\n        }\r\n    }\r\n    _parseChoiceElement(parent) {\r\n        const token = this._token;\r\n        const values = [];\r\n        while (true) {\r\n            if (this._token.type === 2 /* Comma */ || this._token.type === 7 /* Pipe */) {\r\n                break;\r\n            }\r\n            let value;\r\n            if (value = this._accept(5 /* Backslash */, true)) {\r\n                // \\, \\|, or \\\\\r\n                value = this._accept(2 /* Comma */, true)\r\n                    || this._accept(7 /* Pipe */, true)\r\n                    || this._accept(5 /* Backslash */, true)\r\n                    || value;\r\n            }\r\n            else {\r\n                value = this._accept(undefined, true);\r\n            }\r\n            if (!value) {\r\n                // EOF\r\n                this._backTo(token);\r\n                return false;\r\n            }\r\n            values.push(value);\r\n        }\r\n        if (values.length === 0) {\r\n            this._backTo(token);\r\n            return false;\r\n        }\r\n        parent.appendChild(new Text(values.join('')));\r\n        return true;\r\n    }\r\n    // ${foo:<children>}, ${foo} -> variable\r\n    _parseComplexVariable(parent) {\r\n        let name;\r\n        const token = this._token;\r\n        const match = this._accept(0 /* Dollar */)\r\n            && this._accept(3 /* CurlyOpen */)\r\n            && (name = this._accept(9 /* VariableName */, true));\r\n        if (!match) {\r\n            return this._backTo(token);\r\n        }\r\n        const variable = new Variable(name);\r\n        if (this._accept(1 /* Colon */)) {\r\n            // ${foo:<children>}\r\n            while (true) {\r\n                // ...} -> done\r\n                if (this._accept(4 /* CurlyClose */)) {\r\n                    parent.appendChild(variable);\r\n                    return true;\r\n                }\r\n                if (this._parse(variable)) {\r\n                    continue;\r\n                }\r\n                // fallback\r\n                parent.appendChild(new Text('${' + name + ':'));\r\n                variable.children.forEach(parent.appendChild, parent);\r\n                return true;\r\n            }\r\n        }\r\n        else if (this._accept(6 /* Forwardslash */)) {\r\n            // ${foo/<regex>/<format>/<options>}\r\n            if (this._parseTransform(variable)) {\r\n                parent.appendChild(variable);\r\n                return true;\r\n            }\r\n            this._backTo(token);\r\n            return false;\r\n        }\r\n        else if (this._accept(4 /* CurlyClose */)) {\r\n            // ${foo}\r\n            parent.appendChild(variable);\r\n            return true;\r\n        }\r\n        else {\r\n            // ${foo <- missing curly or colon\r\n            return this._backTo(token);\r\n        }\r\n    }\r\n    _parseTransform(parent) {\r\n        // ...<regex>/<format>/<options>}\r\n        let transform = new Transform();\r\n        let regexValue = '';\r\n        let regexOptions = '';\r\n        // (1) /regex\r\n        while (true) {\r\n            if (this._accept(6 /* Forwardslash */)) {\r\n                break;\r\n            }\r\n            let escaped;\r\n            if (escaped = this._accept(5 /* Backslash */, true)) {\r\n                escaped = this._accept(6 /* Forwardslash */, true) || escaped;\r\n                regexValue += escaped;\r\n                continue;\r\n            }\r\n            if (this._token.type !== 14 /* EOF */) {\r\n                regexValue += this._accept(undefined, true);\r\n                continue;\r\n            }\r\n            return false;\r\n        }\r\n        // (2) /format\r\n        while (true) {\r\n            if (this._accept(6 /* Forwardslash */)) {\r\n                break;\r\n            }\r\n            let escaped;\r\n            if (escaped = this._accept(5 /* Backslash */, true)) {\r\n                escaped = this._accept(5 /* Backslash */, true) || this._accept(6 /* Forwardslash */, true) || escaped;\r\n                transform.appendChild(new Text(escaped));\r\n                continue;\r\n            }\r\n            if (this._parseFormatString(transform) || this._parseAnything(transform)) {\r\n                continue;\r\n            }\r\n            return false;\r\n        }\r\n        // (3) /option\r\n        while (true) {\r\n            if (this._accept(4 /* CurlyClose */)) {\r\n                break;\r\n            }\r\n            if (this._token.type !== 14 /* EOF */) {\r\n                regexOptions += this._accept(undefined, true);\r\n                continue;\r\n            }\r\n            return false;\r\n        }\r\n        try {\r\n            transform.regexp = new RegExp(regexValue, regexOptions);\r\n        }\r\n        catch (e) {\r\n            // invalid regexp\r\n            return false;\r\n        }\r\n        parent.transform = transform;\r\n        return true;\r\n    }\r\n    _parseFormatString(parent) {\r\n        const token = this._token;\r\n        if (!this._accept(0 /* Dollar */)) {\r\n            return false;\r\n        }\r\n        let complex = false;\r\n        if (this._accept(3 /* CurlyOpen */)) {\r\n            complex = true;\r\n        }\r\n        let index = this._accept(8 /* Int */, true);\r\n        if (!index) {\r\n            this._backTo(token);\r\n            return false;\r\n        }\r\n        else if (!complex) {\r\n            // $1\r\n            parent.appendChild(new FormatString(Number(index)));\r\n            return true;\r\n        }\r\n        else if (this._accept(4 /* CurlyClose */)) {\r\n            // ${1}\r\n            parent.appendChild(new FormatString(Number(index)));\r\n            return true;\r\n        }\r\n        else if (!this._accept(1 /* Colon */)) {\r\n            this._backTo(token);\r\n            return false;\r\n        }\r\n        if (this._accept(6 /* Forwardslash */)) {\r\n            // ${1:/upcase}\r\n            let shorthand = this._accept(9 /* VariableName */, true);\r\n            if (!shorthand || !this._accept(4 /* CurlyClose */)) {\r\n                this._backTo(token);\r\n                return false;\r\n            }\r\n            else {\r\n                parent.appendChild(new FormatString(Number(index), shorthand));\r\n                return true;\r\n            }\r\n        }\r\n        else if (this._accept(11 /* Plus */)) {\r\n            // ${1:+<if>}\r\n            let ifValue = this._until(4 /* CurlyClose */);\r\n            if (ifValue) {\r\n                parent.appendChild(new FormatString(Number(index), undefined, ifValue, undefined));\r\n                return true;\r\n            }\r\n        }\r\n        else if (this._accept(12 /* Dash */)) {\r\n            // ${2:-<else>}\r\n            let elseValue = this._until(4 /* CurlyClose */);\r\n            if (elseValue) {\r\n                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\r\n                return true;\r\n            }\r\n        }\r\n        else if (this._accept(13 /* QuestionMark */)) {\r\n            // ${2:?<if>:<else>}\r\n            let ifValue = this._until(1 /* Colon */);\r\n            if (ifValue) {\r\n                let elseValue = this._until(4 /* CurlyClose */);\r\n                if (elseValue) {\r\n                    parent.appendChild(new FormatString(Number(index), undefined, ifValue, elseValue));\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // ${1:<else>}\r\n            let elseValue = this._until(4 /* CurlyClose */);\r\n            if (elseValue) {\r\n                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\r\n                return true;\r\n            }\r\n        }\r\n        this._backTo(token);\r\n        return false;\r\n    }\r\n    _parseAnything(marker) {\r\n        if (this._token.type !== 14 /* EOF */) {\r\n            marker.appendChild(new Text(this._scanner.tokenText(this._token)));\r\n            this._accept(undefined);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}