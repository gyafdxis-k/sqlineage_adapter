{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from './errors.js';\nimport { Disposable, combinedDisposable, DisposableStore } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\nexport var Event;\n(function (Event) {\n  Event.None = () => Disposable.None;\n  /**\r\n   * Given an event, returns another event which only fires once.\r\n   */\n  function once(event) {\n    return function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      // we need this, in case the event fires during the listener call\n      let didFire = false;\n      let result;\n      result = event(e => {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n      if (didFire) {\n        result.dispose();\n      }\n      return result;\n    };\n  }\n  Event.once = once;\n  /**\r\n   * Given an event and a `map` function, returns another event which maps each element\r\n   * through the mapping function.\r\n   */\n  function map(event, map) {\n    return snapshot(function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(i => listener.call(thisArgs, map(i)), null, disposables);\n    });\n  }\n  Event.map = map;\n  /**\r\n   * Given an event and an `each` function, returns another identical event and calls\r\n   * the `each` function per each element.\r\n   */\n  function forEach(event, each) {\n    return snapshot(function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(i => {\n        each(i);\n        listener.call(thisArgs, i);\n      }, null, disposables);\n    });\n  }\n  Event.forEach = forEach;\n  function filter(event, filter) {\n    return snapshot(function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(e => filter(e) && listener.call(thisArgs, e), null, disposables);\n    });\n  }\n  Event.filter = filter;\n  /**\r\n   * Given an event, returns the same event but typed as `Event<void>`.\r\n   */\n  function signal(event) {\n    return event;\n  }\n  Event.signal = signal;\n  function any() {\n    for (var _len = arguments.length, events = new Array(_len), _key = 0; _key < _len; _key++) {\n      events[_key] = arguments[_key];\n    }\n    return function (listener) {\n      let thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n    };\n  }\n  Event.any = any;\n  /**\r\n   * Given an event and a `merge` function, returns another event which maps each element\r\n   * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\r\n   */\n  function reduce(event, merge, initial) {\n    let output = initial;\n    return map(event, e => {\n      output = merge(output, e);\n      return output;\n    });\n  }\n  Event.reduce = reduce;\n  /**\r\n   * Given a chain of event processing functions (filter, map, etc), each\r\n   * function will be invoked per event & per listener. Snapshotting an event\r\n   * chain allows each function to be invoked just once per event.\r\n   */\n  function snapshot(event) {\n    let listener;\n    const emitter = new Emitter({\n      onFirstListenerAdd() {\n        listener = event(emitter.fire, emitter);\n      },\n      onLastListenerRemove() {\n        listener.dispose();\n      }\n    });\n    return emitter.event;\n  }\n  Event.snapshot = snapshot;\n  function debounce(event, merge) {\n    let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n    let leading = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let leakWarningThreshold = arguments.length > 4 ? arguments[4] : undefined;\n    let subscription;\n    let output = undefined;\n    let handle = undefined;\n    let numDebouncedCalls = 0;\n    const emitter = new Emitter({\n      leakWarningThreshold,\n      onFirstListenerAdd() {\n        subscription = event(cur => {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n          if (leading && !handle) {\n            emitter.fire(output);\n            output = undefined;\n          }\n          clearTimeout(handle);\n          handle = setTimeout(() => {\n            const _output = output;\n            output = undefined;\n            handle = undefined;\n            if (!leading || numDebouncedCalls > 1) {\n              emitter.fire(_output);\n            }\n            numDebouncedCalls = 0;\n          }, delay);\n        });\n      },\n      onLastListenerRemove() {\n        subscription.dispose();\n      }\n    });\n    return emitter.event;\n  }\n  Event.debounce = debounce;\n  /**\r\n   * Given an event, it returns another event which fires only once and as soon as\r\n   * the input event emits. The event data is the number of millis it took for the\r\n   * event to fire.\r\n   */\n  function stopwatch(event) {\n    const start = new Date().getTime();\n    return map(once(event), _ => new Date().getTime() - start);\n  }\n  Event.stopwatch = stopwatch;\n  /**\r\n   * Given an event, it returns another event which fires only when the event\r\n   * element changes.\r\n   */\n  function latch(event) {\n    let firstCall = true;\n    let cache;\n    return filter(event, value => {\n      const shouldEmit = firstCall || value !== cache;\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    });\n  }\n  Event.latch = latch;\n  /**\r\n   * Buffers the provided event until a first listener comes\r\n   * along, at which point fire all the events at once and\r\n   * pipe the event from then on.\r\n   *\r\n   * ```typescript\r\n   * const emitter = new Emitter<number>();\r\n   * const event = emitter.event;\r\n   * const bufferedEvent = buffer(event);\r\n   *\r\n   * emitter.fire(1);\r\n   * emitter.fire(2);\r\n   * emitter.fire(3);\r\n   * // nothing...\r\n   *\r\n   * const listener = bufferedEvent(num => console.log(num));\r\n   * // 1, 2, 3\r\n   *\r\n   * emitter.fire(4);\r\n   * // 4\r\n   * ```\r\n   */\n  function buffer(event) {\n    let nextTick = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let _buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let buffer = _buffer.slice();\n    let listener = event(e => {\n      if (buffer) {\n        buffer.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n    const flush = () => {\n      if (buffer) {\n        buffer.forEach(e => emitter.fire(e));\n      }\n      buffer = null;\n    };\n    const emitter = new Emitter({\n      onFirstListenerAdd() {\n        if (!listener) {\n          listener = event(e => emitter.fire(e));\n        }\n      },\n      onFirstListenerDidAdd() {\n        if (buffer) {\n          if (nextTick) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n      onLastListenerRemove() {\n        if (listener) {\n          listener.dispose();\n        }\n        listener = null;\n      }\n    });\n    return emitter.event;\n  }\n  Event.buffer = buffer;\n  class ChainableEvent {\n    constructor(event) {\n      this.event = event;\n    }\n    map(fn) {\n      return new ChainableEvent(map(this.event, fn));\n    }\n    forEach(fn) {\n      return new ChainableEvent(forEach(this.event, fn));\n    }\n    filter(fn) {\n      return new ChainableEvent(filter(this.event, fn));\n    }\n    reduce(merge, initial) {\n      return new ChainableEvent(reduce(this.event, merge, initial));\n    }\n    latch() {\n      return new ChainableEvent(latch(this.event));\n    }\n    debounce(merge) {\n      let delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      let leading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      let leakWarningThreshold = arguments.length > 3 ? arguments[3] : undefined;\n      return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n    }\n    on(listener, thisArgs, disposables) {\n      return this.event(listener, thisArgs, disposables);\n    }\n    once(listener, thisArgs, disposables) {\n      return once(this.event)(listener, thisArgs, disposables);\n    }\n  }\n  function chain(event) {\n    return new ChainableEvent(event);\n  }\n  Event.chain = chain;\n  function fromNodeEventEmitter(emitter, eventName) {\n    let map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : id => id;\n    const fn = function () {\n      return result.fire(map(...arguments));\n    };\n    const onFirstListenerAdd = () => emitter.on(eventName, fn);\n    const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n    const result = new Emitter({\n      onFirstListenerAdd,\n      onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromNodeEventEmitter = fromNodeEventEmitter;\n  function fromDOMEventEmitter(emitter, eventName) {\n    let map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : id => id;\n    const fn = function () {\n      return result.fire(map(...arguments));\n    };\n    const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n    const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n    const result = new Emitter({\n      onFirstListenerAdd,\n      onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromDOMEventEmitter = fromDOMEventEmitter;\n  function fromPromise(promise) {\n    const emitter = new Emitter();\n    let shouldEmit = false;\n    promise.then(undefined, () => null).then(() => {\n      if (!shouldEmit) {\n        setTimeout(() => emitter.fire(undefined), 0);\n      } else {\n        emitter.fire(undefined);\n      }\n    });\n    shouldEmit = true;\n    return emitter.event;\n  }\n  Event.fromPromise = fromPromise;\n  function toPromise(event) {\n    return new Promise(resolve => once(event)(resolve));\n  }\n  Event.toPromise = toPromise;\n})(Event || (Event = {}));\nclass EventProfiling {\n  constructor(name) {\n    this._listenerCount = 0;\n    this._invocationCount = 0;\n    this._elapsedOverall = 0;\n    this._name = \"\".concat(name, \"_\").concat(EventProfiling._idPool++);\n  }\n  start(listenerCount) {\n    this._stopWatch = new StopWatch(true);\n    this._listenerCount = listenerCount;\n  }\n  stop() {\n    if (this._stopWatch) {\n      const elapsed = this._stopWatch.elapsed();\n      this._elapsedOverall += elapsed;\n      this._invocationCount += 1;\n      console.info(\"did FIRE \".concat(this._name, \": elapsed_ms: \").concat(elapsed.toFixed(5), \", listener: \").concat(this._listenerCount, \" (elapsed_overall: \").concat(this._elapsedOverall.toFixed(2), \", invocations: \").concat(this._invocationCount, \")\"));\n      this._stopWatch = undefined;\n    }\n  }\n}\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n  constructor(customThreshold) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.random().toString(18).slice(2, 5);\n    this.customThreshold = customThreshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n  dispose() {\n    if (this._stacks) {\n      this._stacks.clear();\n    }\n  }\n  check(listenerCount) {\n    let threshold = _globalLeakWarningThreshold;\n    if (typeof this.customThreshold === 'number') {\n      threshold = this.customThreshold;\n    }\n    if (threshold <= 0 || listenerCount < threshold) {\n      return undefined;\n    }\n    if (!this._stacks) {\n      this._stacks = new Map();\n    }\n    const stack = new Error().stack.split('\\n').slice(3).join('\\n');\n    const count = this._stacks.get(stack) || 0;\n    this._stacks.set(stack, count + 1);\n    this._warnCountdown -= 1;\n    if (this._warnCountdown <= 0) {\n      // only warn on first exceed and then every time the limit\n      // is exceeded by 50% again\n      this._warnCountdown = threshold * 0.5;\n      // find most frequent listener and print warning\n      let topStack;\n      let topCount = 0;\n      for (const [stack, count] of this._stacks) {\n        if (!topStack || topCount < count) {\n          topStack = stack;\n          topCount = count;\n        }\n      }\n      console.warn(\"[\".concat(this.name, \"] potential listener LEAK detected, having \").concat(listenerCount, \" listeners already. MOST frequent listener (\").concat(topCount, \"):\"));\n      console.warn(topStack);\n    }\n    return () => {\n      const count = this._stacks.get(stack) || 0;\n      this._stacks.set(stack, count - 1);\n    };\n  }\n}\n/**\r\n * The Emitter can be used to expose an Event to the public\r\n * to fire it from the insides.\r\n * Sample:\r\n    class Document {\r\n\r\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\r\n\r\n        public onDidChange = this._onDidChange.event;\r\n\r\n        // getter-style\r\n        // get onDidChange(): Event<(value:string)=>any> {\r\n        // \treturn this._onDidChange.event;\r\n        // }\r\n\r\n        private _doIt() {\r\n            //...\r\n            this._onDidChange.fire(value);\r\n        }\r\n    }\r\n */\nexport class Emitter {\n  constructor(options) {\n    var _a;\n    this._disposed = false;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n    this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\n  }\n  /**\r\n   * For the public to allow to subscribe\r\n   * to events from this Emitter\r\n   */\n  get event() {\n    if (!this._event) {\n      this._event = (listener, thisArgs, disposables) => {\n        var _a;\n        if (!this._listeners) {\n          this._listeners = new LinkedList();\n        }\n        const firstListener = this._listeners.isEmpty();\n        if (firstListener && this._options && this._options.onFirstListenerAdd) {\n          this._options.onFirstListenerAdd(this);\n        }\n        const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n        if (firstListener && this._options && this._options.onFirstListenerDidAdd) {\n          this._options.onFirstListenerDidAdd(this);\n        }\n        if (this._options && this._options.onListenerDidAdd) {\n          this._options.onListenerDidAdd(this, listener, thisArgs);\n        }\n        // check and record this emitter for potential leakage\n        const removeMonitor = (_a = this._leakageMon) === null || _a === void 0 ? void 0 : _a.check(this._listeners.size);\n        let result;\n        result = {\n          dispose: () => {\n            if (removeMonitor) {\n              removeMonitor();\n            }\n            result.dispose = Emitter._noop;\n            if (!this._disposed) {\n              remove();\n              if (this._options && this._options.onLastListenerRemove) {\n                const hasListeners = this._listeners && !this._listeners.isEmpty();\n                if (!hasListeners) {\n                  this._options.onLastListenerRemove(this);\n                }\n              }\n            }\n          }\n        };\n        if (disposables instanceof DisposableStore) {\n          disposables.add(result);\n        } else if (Array.isArray(disposables)) {\n          disposables.push(result);\n        }\n        return result;\n      };\n    }\n    return this._event;\n  }\n  /**\r\n   * To be kept private to fire an event to\r\n   * subscribers\r\n   */\n  fire(event) {\n    var _a, _b;\n    if (this._listeners) {\n      // put all [listener,event]-pairs into delivery queue\n      // then emit all event. an inner/nested event might be\n      // the driver of this\n      if (!this._deliveryQueue) {\n        this._deliveryQueue = new LinkedList();\n      }\n      for (let listener of this._listeners) {\n        this._deliveryQueue.push([listener, event]);\n      }\n      // start/stop performance insight collection\n      (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n      while (this._deliveryQueue.size > 0) {\n        const [listener, event] = this._deliveryQueue.shift();\n        try {\n          if (typeof listener === 'function') {\n            listener.call(undefined, event);\n          } else {\n            listener[0].call(listener[1], event);\n          }\n        } catch (e) {\n          onUnexpectedError(e);\n        }\n      }\n      (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n    }\n  }\n  dispose() {\n    var _a, _b, _c;\n    (_a = this._listeners) === null || _a === void 0 ? void 0 : _a.clear();\n    (_b = this._deliveryQueue) === null || _b === void 0 ? void 0 : _b.clear();\n    (_c = this._leakageMon) === null || _c === void 0 ? void 0 : _c.dispose();\n    this._disposed = true;\n  }\n}\nEmitter._noop = function () {};\nexport class PauseableEmitter extends Emitter {\n  constructor(options) {\n    super(options);\n    this._isPaused = 0;\n    this._eventQueue = new LinkedList();\n    this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n  }\n  pause() {\n    this._isPaused++;\n  }\n  resume() {\n    if (this._isPaused !== 0 && --this._isPaused === 0) {\n      if (this._mergeFn) {\n        // use the merge function to create a single composite\n        // event. make a copy in case firing pauses this emitter\n        const events = Array.from(this._eventQueue);\n        this._eventQueue.clear();\n        super.fire(this._mergeFn(events));\n      } else {\n        // no merging, fire each event individually and test\n        // that this emitter isn't paused halfway through\n        while (!this._isPaused && this._eventQueue.size !== 0) {\n          super.fire(this._eventQueue.shift());\n        }\n      }\n    }\n  }\n  fire(event) {\n    if (this._listeners) {\n      if (this._isPaused !== 0) {\n        this._eventQueue.push(event);\n      } else {\n        super.fire(event);\n      }\n    }\n  }\n}\n/**\r\n * The EventBufferer is useful in situations in which you want\r\n * to delay firing your events during some code.\r\n * You can wrap that code and be sure that the event will not\r\n * be fired during that wrap.\r\n *\r\n * ```\r\n * const emitter: Emitter;\r\n * const delayer = new EventDelayer();\r\n * const delayedEvent = delayer.wrapEvent(emitter.event);\r\n *\r\n * delayedEvent(console.log);\r\n *\r\n * delayer.bufferEvents(() => {\r\n *   emitter.fire(); // event will not be fired yet\r\n * });\r\n *\r\n * // event will only be fired at this point\r\n * ```\r\n */\nexport class EventBufferer {\n  constructor() {\n    this.buffers = [];\n  }\n  wrapEvent(event) {\n    return (listener, thisArgs, disposables) => {\n      return event(i => {\n        const buffer = this.buffers[this.buffers.length - 1];\n        if (buffer) {\n          buffer.push(() => listener.call(thisArgs, i));\n        } else {\n          listener.call(thisArgs, i);\n        }\n      }, undefined, disposables);\n    };\n  }\n  bufferEvents(fn) {\n    const buffer = [];\n    this.buffers.push(buffer);\n    const r = fn();\n    this.buffers.pop();\n    buffer.forEach(flush => flush());\n    return r;\n  }\n}\n/**\r\n * A Relay is an event forwarder which functions as a replugabble event pipe.\r\n * Once created, you can connect an input event to it and it will simply forward\r\n * events from that input event through its own `event` property. The `input`\r\n * can be changed at any point in time.\r\n */\nexport class Relay {\n  constructor() {\n    this.listening = false;\n    this.inputEvent = Event.None;\n    this.inputEventListener = Disposable.None;\n    this.emitter = new Emitter({\n      onFirstListenerDidAdd: () => {\n        this.listening = true;\n        this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n      },\n      onLastListenerRemove: () => {\n        this.listening = false;\n        this.inputEventListener.dispose();\n      }\n    });\n    this.event = this.emitter.event;\n  }\n  set input(event) {\n    this.inputEvent = event;\n    if (this.listening) {\n      this.inputEventListener.dispose();\n      this.inputEventListener = event(this.emitter.fire, this.emitter);\n    }\n  }\n  dispose() {\n    this.inputEventListener.dispose();\n    this.emitter.dispose();\n  }\n}","map":{"version":3,"names":["onUnexpectedError","Disposable","combinedDisposable","DisposableStore","LinkedList","StopWatch","Event","None","once","event","listener","thisArgs","arguments","length","undefined","disposables","didFire","result","e","dispose","call","map","snapshot","i","forEach","each","filter","signal","any","_len","events","Array","_key","reduce","merge","initial","output","emitter","Emitter","onFirstListenerAdd","fire","onLastListenerRemove","debounce","delay","leading","leakWarningThreshold","subscription","handle","numDebouncedCalls","cur","clearTimeout","setTimeout","_output","stopwatch","start","Date","getTime","_","latch","firstCall","cache","value","shouldEmit","buffer","nextTick","_buffer","slice","push","flush","onFirstListenerDidAdd","ChainableEvent","constructor","fn","on","chain","fromNodeEventEmitter","eventName","id","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","fromPromise","promise","then","toPromise","Promise","resolve","EventProfiling","name","_listenerCount","_invocationCount","_elapsedOverall","_name","concat","_idPool","listenerCount","_stopWatch","stop","elapsed","console","info","toFixed","_globalLeakWarningThreshold","LeakageMonitor","customThreshold","Math","random","toString","_warnCountdown","_stacks","clear","check","threshold","Map","stack","Error","split","join","count","get","set","topStack","topCount","warn","options","_a","_disposed","_options","_leakageMon","_perfMon","_profName","_event","_listeners","firstListener","isEmpty","remove","onListenerDidAdd","removeMonitor","size","_noop","hasListeners","add","isArray","_b","_deliveryQueue","shift","_c","PauseableEmitter","_isPaused","_eventQueue","_mergeFn","pause","resume","from","EventBufferer","buffers","wrapEvent","bufferEvents","r","pop","Relay","listening","inputEvent","inputEventListener","input"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/event.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { onUnexpectedError } from './errors.js';\r\nimport { Disposable, combinedDisposable, DisposableStore } from './lifecycle.js';\r\nimport { LinkedList } from './linkedList.js';\r\nimport { StopWatch } from './stopwatch.js';\r\nexport var Event;\r\n(function (Event) {\r\n    Event.None = () => Disposable.None;\r\n    /**\r\n     * Given an event, returns another event which only fires once.\r\n     */\r\n    function once(event) {\r\n        return (listener, thisArgs = null, disposables) => {\r\n            // we need this, in case the event fires during the listener call\r\n            let didFire = false;\r\n            let result;\r\n            result = event(e => {\r\n                if (didFire) {\r\n                    return;\r\n                }\r\n                else if (result) {\r\n                    result.dispose();\r\n                }\r\n                else {\r\n                    didFire = true;\r\n                }\r\n                return listener.call(thisArgs, e);\r\n            }, null, disposables);\r\n            if (didFire) {\r\n                result.dispose();\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    Event.once = once;\r\n    /**\r\n     * Given an event and a `map` function, returns another event which maps each element\r\n     * through the mapping function.\r\n     */\r\n    function map(event, map) {\r\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables));\r\n    }\r\n    Event.map = map;\r\n    /**\r\n     * Given an event and an `each` function, returns another identical event and calls\r\n     * the `each` function per each element.\r\n     */\r\n    function forEach(event, each) {\r\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\r\n    }\r\n    Event.forEach = forEach;\r\n    function filter(event, filter) {\r\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\r\n    }\r\n    Event.filter = filter;\r\n    /**\r\n     * Given an event, returns the same event but typed as `Event<void>`.\r\n     */\r\n    function signal(event) {\r\n        return event;\r\n    }\r\n    Event.signal = signal;\r\n    function any(...events) {\r\n        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\r\n    }\r\n    Event.any = any;\r\n    /**\r\n     * Given an event and a `merge` function, returns another event which maps each element\r\n     * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\r\n     */\r\n    function reduce(event, merge, initial) {\r\n        let output = initial;\r\n        return map(event, e => {\r\n            output = merge(output, e);\r\n            return output;\r\n        });\r\n    }\r\n    Event.reduce = reduce;\r\n    /**\r\n     * Given a chain of event processing functions (filter, map, etc), each\r\n     * function will be invoked per event & per listener. Snapshotting an event\r\n     * chain allows each function to be invoked just once per event.\r\n     */\r\n    function snapshot(event) {\r\n        let listener;\r\n        const emitter = new Emitter({\r\n            onFirstListenerAdd() {\r\n                listener = event(emitter.fire, emitter);\r\n            },\r\n            onLastListenerRemove() {\r\n                listener.dispose();\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.snapshot = snapshot;\r\n    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold) {\r\n        let subscription;\r\n        let output = undefined;\r\n        let handle = undefined;\r\n        let numDebouncedCalls = 0;\r\n        const emitter = new Emitter({\r\n            leakWarningThreshold,\r\n            onFirstListenerAdd() {\r\n                subscription = event(cur => {\r\n                    numDebouncedCalls++;\r\n                    output = merge(output, cur);\r\n                    if (leading && !handle) {\r\n                        emitter.fire(output);\r\n                        output = undefined;\r\n                    }\r\n                    clearTimeout(handle);\r\n                    handle = setTimeout(() => {\r\n                        const _output = output;\r\n                        output = undefined;\r\n                        handle = undefined;\r\n                        if (!leading || numDebouncedCalls > 1) {\r\n                            emitter.fire(_output);\r\n                        }\r\n                        numDebouncedCalls = 0;\r\n                    }, delay);\r\n                });\r\n            },\r\n            onLastListenerRemove() {\r\n                subscription.dispose();\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.debounce = debounce;\r\n    /**\r\n     * Given an event, it returns another event which fires only once and as soon as\r\n     * the input event emits. The event data is the number of millis it took for the\r\n     * event to fire.\r\n     */\r\n    function stopwatch(event) {\r\n        const start = new Date().getTime();\r\n        return map(once(event), _ => new Date().getTime() - start);\r\n    }\r\n    Event.stopwatch = stopwatch;\r\n    /**\r\n     * Given an event, it returns another event which fires only when the event\r\n     * element changes.\r\n     */\r\n    function latch(event) {\r\n        let firstCall = true;\r\n        let cache;\r\n        return filter(event, value => {\r\n            const shouldEmit = firstCall || value !== cache;\r\n            firstCall = false;\r\n            cache = value;\r\n            return shouldEmit;\r\n        });\r\n    }\r\n    Event.latch = latch;\r\n    /**\r\n     * Buffers the provided event until a first listener comes\r\n     * along, at which point fire all the events at once and\r\n     * pipe the event from then on.\r\n     *\r\n     * ```typescript\r\n     * const emitter = new Emitter<number>();\r\n     * const event = emitter.event;\r\n     * const bufferedEvent = buffer(event);\r\n     *\r\n     * emitter.fire(1);\r\n     * emitter.fire(2);\r\n     * emitter.fire(3);\r\n     * // nothing...\r\n     *\r\n     * const listener = bufferedEvent(num => console.log(num));\r\n     * // 1, 2, 3\r\n     *\r\n     * emitter.fire(4);\r\n     * // 4\r\n     * ```\r\n     */\r\n    function buffer(event, nextTick = false, _buffer = []) {\r\n        let buffer = _buffer.slice();\r\n        let listener = event(e => {\r\n            if (buffer) {\r\n                buffer.push(e);\r\n            }\r\n            else {\r\n                emitter.fire(e);\r\n            }\r\n        });\r\n        const flush = () => {\r\n            if (buffer) {\r\n                buffer.forEach(e => emitter.fire(e));\r\n            }\r\n            buffer = null;\r\n        };\r\n        const emitter = new Emitter({\r\n            onFirstListenerAdd() {\r\n                if (!listener) {\r\n                    listener = event(e => emitter.fire(e));\r\n                }\r\n            },\r\n            onFirstListenerDidAdd() {\r\n                if (buffer) {\r\n                    if (nextTick) {\r\n                        setTimeout(flush);\r\n                    }\r\n                    else {\r\n                        flush();\r\n                    }\r\n                }\r\n            },\r\n            onLastListenerRemove() {\r\n                if (listener) {\r\n                    listener.dispose();\r\n                }\r\n                listener = null;\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.buffer = buffer;\r\n    class ChainableEvent {\r\n        constructor(event) {\r\n            this.event = event;\r\n        }\r\n        map(fn) {\r\n            return new ChainableEvent(map(this.event, fn));\r\n        }\r\n        forEach(fn) {\r\n            return new ChainableEvent(forEach(this.event, fn));\r\n        }\r\n        filter(fn) {\r\n            return new ChainableEvent(filter(this.event, fn));\r\n        }\r\n        reduce(merge, initial) {\r\n            return new ChainableEvent(reduce(this.event, merge, initial));\r\n        }\r\n        latch() {\r\n            return new ChainableEvent(latch(this.event));\r\n        }\r\n        debounce(merge, delay = 100, leading = false, leakWarningThreshold) {\r\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\r\n        }\r\n        on(listener, thisArgs, disposables) {\r\n            return this.event(listener, thisArgs, disposables);\r\n        }\r\n        once(listener, thisArgs, disposables) {\r\n            return once(this.event)(listener, thisArgs, disposables);\r\n        }\r\n    }\r\n    function chain(event) {\r\n        return new ChainableEvent(event);\r\n    }\r\n    Event.chain = chain;\r\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\r\n        const fn = (...args) => result.fire(map(...args));\r\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\r\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\r\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\r\n        return result.event;\r\n    }\r\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\r\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\r\n        const fn = (...args) => result.fire(map(...args));\r\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\r\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\r\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\r\n        return result.event;\r\n    }\r\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\r\n    function fromPromise(promise) {\r\n        const emitter = new Emitter();\r\n        let shouldEmit = false;\r\n        promise\r\n            .then(undefined, () => null)\r\n            .then(() => {\r\n            if (!shouldEmit) {\r\n                setTimeout(() => emitter.fire(undefined), 0);\r\n            }\r\n            else {\r\n                emitter.fire(undefined);\r\n            }\r\n        });\r\n        shouldEmit = true;\r\n        return emitter.event;\r\n    }\r\n    Event.fromPromise = fromPromise;\r\n    function toPromise(event) {\r\n        return new Promise(resolve => once(event)(resolve));\r\n    }\r\n    Event.toPromise = toPromise;\r\n})(Event || (Event = {}));\r\nclass EventProfiling {\r\n    constructor(name) {\r\n        this._listenerCount = 0;\r\n        this._invocationCount = 0;\r\n        this._elapsedOverall = 0;\r\n        this._name = `${name}_${EventProfiling._idPool++}`;\r\n    }\r\n    start(listenerCount) {\r\n        this._stopWatch = new StopWatch(true);\r\n        this._listenerCount = listenerCount;\r\n    }\r\n    stop() {\r\n        if (this._stopWatch) {\r\n            const elapsed = this._stopWatch.elapsed();\r\n            this._elapsedOverall += elapsed;\r\n            this._invocationCount += 1;\r\n            console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\r\n            this._stopWatch = undefined;\r\n        }\r\n    }\r\n}\r\nEventProfiling._idPool = 0;\r\nlet _globalLeakWarningThreshold = -1;\r\nclass LeakageMonitor {\r\n    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {\r\n        this.customThreshold = customThreshold;\r\n        this.name = name;\r\n        this._warnCountdown = 0;\r\n    }\r\n    dispose() {\r\n        if (this._stacks) {\r\n            this._stacks.clear();\r\n        }\r\n    }\r\n    check(listenerCount) {\r\n        let threshold = _globalLeakWarningThreshold;\r\n        if (typeof this.customThreshold === 'number') {\r\n            threshold = this.customThreshold;\r\n        }\r\n        if (threshold <= 0 || listenerCount < threshold) {\r\n            return undefined;\r\n        }\r\n        if (!this._stacks) {\r\n            this._stacks = new Map();\r\n        }\r\n        const stack = new Error().stack.split('\\n').slice(3).join('\\n');\r\n        const count = (this._stacks.get(stack) || 0);\r\n        this._stacks.set(stack, count + 1);\r\n        this._warnCountdown -= 1;\r\n        if (this._warnCountdown <= 0) {\r\n            // only warn on first exceed and then every time the limit\r\n            // is exceeded by 50% again\r\n            this._warnCountdown = threshold * 0.5;\r\n            // find most frequent listener and print warning\r\n            let topStack;\r\n            let topCount = 0;\r\n            for (const [stack, count] of this._stacks) {\r\n                if (!topStack || topCount < count) {\r\n                    topStack = stack;\r\n                    topCount = count;\r\n                }\r\n            }\r\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\r\n            console.warn(topStack);\r\n        }\r\n        return () => {\r\n            const count = (this._stacks.get(stack) || 0);\r\n            this._stacks.set(stack, count - 1);\r\n        };\r\n    }\r\n}\r\n/**\r\n * The Emitter can be used to expose an Event to the public\r\n * to fire it from the insides.\r\n * Sample:\r\n    class Document {\r\n\r\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\r\n\r\n        public onDidChange = this._onDidChange.event;\r\n\r\n        // getter-style\r\n        // get onDidChange(): Event<(value:string)=>any> {\r\n        // \treturn this._onDidChange.event;\r\n        // }\r\n\r\n        private _doIt() {\r\n            //...\r\n            this._onDidChange.fire(value);\r\n        }\r\n    }\r\n */\r\nexport class Emitter {\r\n    constructor(options) {\r\n        var _a;\r\n        this._disposed = false;\r\n        this._options = options;\r\n        this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\r\n        this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\r\n    }\r\n    /**\r\n     * For the public to allow to subscribe\r\n     * to events from this Emitter\r\n     */\r\n    get event() {\r\n        if (!this._event) {\r\n            this._event = (listener, thisArgs, disposables) => {\r\n                var _a;\r\n                if (!this._listeners) {\r\n                    this._listeners = new LinkedList();\r\n                }\r\n                const firstListener = this._listeners.isEmpty();\r\n                if (firstListener && this._options && this._options.onFirstListenerAdd) {\r\n                    this._options.onFirstListenerAdd(this);\r\n                }\r\n                const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\r\n                if (firstListener && this._options && this._options.onFirstListenerDidAdd) {\r\n                    this._options.onFirstListenerDidAdd(this);\r\n                }\r\n                if (this._options && this._options.onListenerDidAdd) {\r\n                    this._options.onListenerDidAdd(this, listener, thisArgs);\r\n                }\r\n                // check and record this emitter for potential leakage\r\n                const removeMonitor = (_a = this._leakageMon) === null || _a === void 0 ? void 0 : _a.check(this._listeners.size);\r\n                let result;\r\n                result = {\r\n                    dispose: () => {\r\n                        if (removeMonitor) {\r\n                            removeMonitor();\r\n                        }\r\n                        result.dispose = Emitter._noop;\r\n                        if (!this._disposed) {\r\n                            remove();\r\n                            if (this._options && this._options.onLastListenerRemove) {\r\n                                const hasListeners = (this._listeners && !this._listeners.isEmpty());\r\n                                if (!hasListeners) {\r\n                                    this._options.onLastListenerRemove(this);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n                if (disposables instanceof DisposableStore) {\r\n                    disposables.add(result);\r\n                }\r\n                else if (Array.isArray(disposables)) {\r\n                    disposables.push(result);\r\n                }\r\n                return result;\r\n            };\r\n        }\r\n        return this._event;\r\n    }\r\n    /**\r\n     * To be kept private to fire an event to\r\n     * subscribers\r\n     */\r\n    fire(event) {\r\n        var _a, _b;\r\n        if (this._listeners) {\r\n            // put all [listener,event]-pairs into delivery queue\r\n            // then emit all event. an inner/nested event might be\r\n            // the driver of this\r\n            if (!this._deliveryQueue) {\r\n                this._deliveryQueue = new LinkedList();\r\n            }\r\n            for (let listener of this._listeners) {\r\n                this._deliveryQueue.push([listener, event]);\r\n            }\r\n            // start/stop performance insight collection\r\n            (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\r\n            while (this._deliveryQueue.size > 0) {\r\n                const [listener, event] = this._deliveryQueue.shift();\r\n                try {\r\n                    if (typeof listener === 'function') {\r\n                        listener.call(undefined, event);\r\n                    }\r\n                    else {\r\n                        listener[0].call(listener[1], event);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    onUnexpectedError(e);\r\n                }\r\n            }\r\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\r\n        }\r\n    }\r\n    dispose() {\r\n        var _a, _b, _c;\r\n        (_a = this._listeners) === null || _a === void 0 ? void 0 : _a.clear();\r\n        (_b = this._deliveryQueue) === null || _b === void 0 ? void 0 : _b.clear();\r\n        (_c = this._leakageMon) === null || _c === void 0 ? void 0 : _c.dispose();\r\n        this._disposed = true;\r\n    }\r\n}\r\nEmitter._noop = function () { };\r\nexport class PauseableEmitter extends Emitter {\r\n    constructor(options) {\r\n        super(options);\r\n        this._isPaused = 0;\r\n        this._eventQueue = new LinkedList();\r\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\r\n    }\r\n    pause() {\r\n        this._isPaused++;\r\n    }\r\n    resume() {\r\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\r\n            if (this._mergeFn) {\r\n                // use the merge function to create a single composite\r\n                // event. make a copy in case firing pauses this emitter\r\n                const events = Array.from(this._eventQueue);\r\n                this._eventQueue.clear();\r\n                super.fire(this._mergeFn(events));\r\n            }\r\n            else {\r\n                // no merging, fire each event individually and test\r\n                // that this emitter isn't paused halfway through\r\n                while (!this._isPaused && this._eventQueue.size !== 0) {\r\n                    super.fire(this._eventQueue.shift());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    fire(event) {\r\n        if (this._listeners) {\r\n            if (this._isPaused !== 0) {\r\n                this._eventQueue.push(event);\r\n            }\r\n            else {\r\n                super.fire(event);\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * The EventBufferer is useful in situations in which you want\r\n * to delay firing your events during some code.\r\n * You can wrap that code and be sure that the event will not\r\n * be fired during that wrap.\r\n *\r\n * ```\r\n * const emitter: Emitter;\r\n * const delayer = new EventDelayer();\r\n * const delayedEvent = delayer.wrapEvent(emitter.event);\r\n *\r\n * delayedEvent(console.log);\r\n *\r\n * delayer.bufferEvents(() => {\r\n *   emitter.fire(); // event will not be fired yet\r\n * });\r\n *\r\n * // event will only be fired at this point\r\n * ```\r\n */\r\nexport class EventBufferer {\r\n    constructor() {\r\n        this.buffers = [];\r\n    }\r\n    wrapEvent(event) {\r\n        return (listener, thisArgs, disposables) => {\r\n            return event(i => {\r\n                const buffer = this.buffers[this.buffers.length - 1];\r\n                if (buffer) {\r\n                    buffer.push(() => listener.call(thisArgs, i));\r\n                }\r\n                else {\r\n                    listener.call(thisArgs, i);\r\n                }\r\n            }, undefined, disposables);\r\n        };\r\n    }\r\n    bufferEvents(fn) {\r\n        const buffer = [];\r\n        this.buffers.push(buffer);\r\n        const r = fn();\r\n        this.buffers.pop();\r\n        buffer.forEach(flush => flush());\r\n        return r;\r\n    }\r\n}\r\n/**\r\n * A Relay is an event forwarder which functions as a replugabble event pipe.\r\n * Once created, you can connect an input event to it and it will simply forward\r\n * events from that input event through its own `event` property. The `input`\r\n * can be changed at any point in time.\r\n */\r\nexport class Relay {\r\n    constructor() {\r\n        this.listening = false;\r\n        this.inputEvent = Event.None;\r\n        this.inputEventListener = Disposable.None;\r\n        this.emitter = new Emitter({\r\n            onFirstListenerDidAdd: () => {\r\n                this.listening = true;\r\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\r\n            },\r\n            onLastListenerRemove: () => {\r\n                this.listening = false;\r\n                this.inputEventListener.dispose();\r\n            }\r\n        });\r\n        this.event = this.emitter.event;\r\n    }\r\n    set input(event) {\r\n        this.inputEvent = event;\r\n        if (this.listening) {\r\n            this.inputEventListener.dispose();\r\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\r\n        }\r\n    }\r\n    dispose() {\r\n        this.inputEventListener.dispose();\r\n        this.emitter.dispose();\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}