{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../modes.js';\nimport { LogLevel } from '../../../platform/log/common/log.js';\nimport { MultilineTokens2, SparseEncodedTokens } from '../model/tokensStore.js';\nexport class SemanticTokensProviderStyling {\n  constructor(_legend, _themeService, _logService) {\n    this._legend = _legend;\n    this._themeService = _themeService;\n    this._logService = _logService;\n    this._hashTable = new HashTable();\n  }\n  getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\n    const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, languageId.id);\n    let metadata;\n    if (entry) {\n      metadata = entry.metadata;\n      if (this._logService.getLevel() === LogLevel.Trace) {\n        this._logService.trace(\"SemanticTokensProviderStyling [CACHED] \".concat(tokenTypeIndex, \" / \").concat(tokenModifierSet, \": foreground \").concat(TokenMetadata.getForeground(metadata), \", fontStyle \").concat(TokenMetadata.getFontStyle(metadata).toString(2)));\n      }\n    } else {\n      let tokenType = this._legend.tokenTypes[tokenTypeIndex];\n      const tokenModifiers = [];\n      if (tokenType) {\n        let modifierSet = tokenModifierSet;\n        for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n          if (modifierSet & 1) {\n            tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n          }\n          modifierSet = modifierSet >> 1;\n        }\n        if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n          this._logService.trace(\"SemanticTokensProviderStyling: unknown token modifier index: \".concat(tokenModifierSet.toString(2), \" for legend: \").concat(JSON.stringify(this._legend.tokenModifiers)));\n          tokenModifiers.push('not-in-legend');\n        }\n        const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId.language);\n        if (typeof tokenStyle === 'undefined') {\n          metadata = 2147483647 /* NO_STYLING */;\n        } else {\n          metadata = 0;\n          if (typeof tokenStyle.italic !== 'undefined') {\n            const italicBit = (tokenStyle.italic ? 1 /* Italic */ : 0) << 11 /* FONT_STYLE_OFFSET */;\n            metadata |= italicBit | 1 /* SEMANTIC_USE_ITALIC */;\n          }\n\n          if (typeof tokenStyle.bold !== 'undefined') {\n            const boldBit = (tokenStyle.bold ? 2 /* Bold */ : 0) << 11 /* FONT_STYLE_OFFSET */;\n            metadata |= boldBit | 2 /* SEMANTIC_USE_BOLD */;\n          }\n\n          if (typeof tokenStyle.underline !== 'undefined') {\n            const underlineBit = (tokenStyle.underline ? 4 /* Underline */ : 0) << 11 /* FONT_STYLE_OFFSET */;\n            metadata |= underlineBit | 4 /* SEMANTIC_USE_UNDERLINE */;\n          }\n\n          if (tokenStyle.foreground) {\n            const foregroundBits = tokenStyle.foreground << 14 /* FOREGROUND_OFFSET */;\n            metadata |= foregroundBits | 8 /* SEMANTIC_USE_FOREGROUND */;\n          }\n\n          if (metadata === 0) {\n            // Nothing!\n            metadata = 2147483647 /* NO_STYLING */;\n          }\n        }\n      } else {\n        if (this._logService.getLevel() === LogLevel.Trace) {\n          this._logService.trace(\"SemanticTokensProviderStyling: unknown token type index: \".concat(tokenTypeIndex, \" for legend: \").concat(JSON.stringify(this._legend.tokenTypes)));\n        }\n        metadata = 2147483647 /* NO_STYLING */;\n        tokenType = 'not-in-legend';\n      }\n      this._hashTable.add(tokenTypeIndex, tokenModifierSet, languageId.id, metadata);\n      if (this._logService.getLevel() === LogLevel.Trace) {\n        this._logService.trace(\"SemanticTokensProviderStyling \".concat(tokenTypeIndex, \" (\").concat(tokenType, \") / \").concat(tokenModifierSet, \" (\").concat(tokenModifiers.join(' '), \"): foreground \").concat(TokenMetadata.getForeground(metadata), \", fontStyle \").concat(TokenMetadata.getFontStyle(metadata).toString(2)));\n      }\n    }\n    return metadata;\n  }\n}\nexport function toMultilineTokens2(tokens, styling, languageId) {\n  const srcData = tokens.data;\n  const tokenCount = tokens.data.length / 5 | 0;\n  const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* DesiredMaxAreas */), 400 /* DesiredTokensPerArea */);\n  const result = [];\n  let tokenIndex = 0;\n  let lastLineNumber = 1;\n  let lastStartCharacter = 0;\n  while (tokenIndex < tokenCount) {\n    const tokenStartIndex = tokenIndex;\n    let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\n    // Keep tokens on the same line in the same area...\n    if (tokenEndIndex < tokenCount) {\n      let smallTokenEndIndex = tokenEndIndex;\n      while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n        smallTokenEndIndex--;\n      }\n      if (smallTokenEndIndex - 1 === tokenStartIndex) {\n        // there are so many tokens on this line that our area would be empty, we must now go right\n        let bigTokenEndIndex = tokenEndIndex;\n        while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n          bigTokenEndIndex++;\n        }\n        tokenEndIndex = bigTokenEndIndex;\n      } else {\n        tokenEndIndex = smallTokenEndIndex;\n      }\n    }\n    let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n    let destOffset = 0;\n    let areaLine = 0;\n    while (tokenIndex < tokenEndIndex) {\n      const srcOffset = 5 * tokenIndex;\n      const deltaLine = srcData[srcOffset];\n      const deltaCharacter = srcData[srcOffset + 1];\n      const lineNumber = lastLineNumber + deltaLine;\n      const startCharacter = deltaLine === 0 ? lastStartCharacter + deltaCharacter : deltaCharacter;\n      const length = srcData[srcOffset + 2];\n      const tokenTypeIndex = srcData[srcOffset + 3];\n      const tokenModifierSet = srcData[srcOffset + 4];\n      const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n      if (metadata !== 2147483647 /* NO_STYLING */) {\n        if (areaLine === 0) {\n          areaLine = lineNumber;\n        }\n        destData[destOffset] = lineNumber - areaLine;\n        destData[destOffset + 1] = startCharacter;\n        destData[destOffset + 2] = startCharacter + length;\n        destData[destOffset + 3] = metadata;\n        destOffset += 4;\n      }\n      lastLineNumber = lineNumber;\n      lastStartCharacter = startCharacter;\n      tokenIndex++;\n    }\n    if (destOffset !== destData.length) {\n      destData = destData.subarray(0, destOffset);\n    }\n    const tokens = new MultilineTokens2(areaLine, new SparseEncodedTokens(destData));\n    result.push(tokens);\n  }\n  return result;\n}\nclass HashTableEntry {\n  constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n    this.tokenTypeIndex = tokenTypeIndex;\n    this.tokenModifierSet = tokenModifierSet;\n    this.languageId = languageId;\n    this.metadata = metadata;\n    this.next = null;\n  }\n}\nclass HashTable {\n  constructor() {\n    this._elementsCount = 0;\n    this._currentLengthIndex = 0;\n    this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n    this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n    this._elements = [];\n    HashTable._nullOutEntries(this._elements, this._currentLength);\n  }\n  static _nullOutEntries(entries, length) {\n    for (let i = 0; i < length; i++) {\n      entries[i] = null;\n    }\n  }\n  _hash2(n1, n2) {\n    return (n1 << 5) - n1 + n2 | 0; // n1 * 31 + n2, keep as int32\n  }\n\n  _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\n    return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n  }\n  get(tokenTypeIndex, tokenModifierSet, languageId) {\n    const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n    let p = this._elements[hash];\n    while (p) {\n      if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n        return p;\n      }\n      p = p.next;\n    }\n    return null;\n  }\n  add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n    this._elementsCount++;\n    if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n      // expand!\n      const oldElements = this._elements;\n      this._currentLengthIndex++;\n      this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n      this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n      this._elements = [];\n      HashTable._nullOutEntries(this._elements, this._currentLength);\n      for (const first of oldElements) {\n        let p = first;\n        while (p) {\n          const oldNext = p.next;\n          p.next = null;\n          this._add(p);\n          p = oldNext;\n        }\n      }\n    }\n    this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n  }\n  _add(element) {\n    const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n    element.next = this._elements[hash];\n    this._elements[hash] = element;\n  }\n}\nHashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];","map":{"version":3,"names":["TokenMetadata","LogLevel","MultilineTokens2","SparseEncodedTokens","SemanticTokensProviderStyling","constructor","_legend","_themeService","_logService","_hashTable","HashTable","getMetadata","tokenTypeIndex","tokenModifierSet","languageId","entry","get","id","metadata","getLevel","Trace","trace","concat","getForeground","getFontStyle","toString","tokenType","tokenTypes","tokenModifiers","modifierSet","modifierIndex","length","push","JSON","stringify","tokenStyle","getColorTheme","getTokenStyleMetadata","language","italic","italicBit","bold","boldBit","underline","underlineBit","foreground","foregroundBits","add","join","toMultilineTokens2","tokens","styling","srcData","data","tokenCount","tokensPerArea","Math","max","ceil","result","tokenIndex","lastLineNumber","lastStartCharacter","tokenStartIndex","tokenEndIndex","min","smallTokenEndIndex","bigTokenEndIndex","destData","Uint32Array","destOffset","areaLine","srcOffset","deltaLine","deltaCharacter","lineNumber","startCharacter","subarray","HashTableEntry","next","_elementsCount","_currentLengthIndex","_currentLength","_SIZES","_growCount","round","_elements","_nullOutEntries","entries","i","_hash2","n1","n2","_hashFunc","hash","p","oldElements","first","oldNext","_add","element"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { TokenMetadata } from '../modes.js';\r\nimport { LogLevel } from '../../../platform/log/common/log.js';\r\nimport { MultilineTokens2, SparseEncodedTokens } from '../model/tokensStore.js';\r\nexport class SemanticTokensProviderStyling {\r\n    constructor(_legend, _themeService, _logService) {\r\n        this._legend = _legend;\r\n        this._themeService = _themeService;\r\n        this._logService = _logService;\r\n        this._hashTable = new HashTable();\r\n    }\r\n    getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\r\n        const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, languageId.id);\r\n        let metadata;\r\n        if (entry) {\r\n            metadata = entry.metadata;\r\n            if (this._logService.getLevel() === LogLevel.Trace) {\r\n                this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\r\n            }\r\n        }\r\n        else {\r\n            let tokenType = this._legend.tokenTypes[tokenTypeIndex];\r\n            const tokenModifiers = [];\r\n            if (tokenType) {\r\n                let modifierSet = tokenModifierSet;\r\n                for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\r\n                    if (modifierSet & 1) {\r\n                        tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\r\n                    }\r\n                    modifierSet = modifierSet >> 1;\r\n                }\r\n                if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\r\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);\r\n                    tokenModifiers.push('not-in-legend');\r\n                }\r\n                const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId.language);\r\n                if (typeof tokenStyle === 'undefined') {\r\n                    metadata = 2147483647 /* NO_STYLING */;\r\n                }\r\n                else {\r\n                    metadata = 0;\r\n                    if (typeof tokenStyle.italic !== 'undefined') {\r\n                        const italicBit = (tokenStyle.italic ? 1 /* Italic */ : 0) << 11 /* FONT_STYLE_OFFSET */;\r\n                        metadata |= italicBit | 1 /* SEMANTIC_USE_ITALIC */;\r\n                    }\r\n                    if (typeof tokenStyle.bold !== 'undefined') {\r\n                        const boldBit = (tokenStyle.bold ? 2 /* Bold */ : 0) << 11 /* FONT_STYLE_OFFSET */;\r\n                        metadata |= boldBit | 2 /* SEMANTIC_USE_BOLD */;\r\n                    }\r\n                    if (typeof tokenStyle.underline !== 'undefined') {\r\n                        const underlineBit = (tokenStyle.underline ? 4 /* Underline */ : 0) << 11 /* FONT_STYLE_OFFSET */;\r\n                        metadata |= underlineBit | 4 /* SEMANTIC_USE_UNDERLINE */;\r\n                    }\r\n                    if (tokenStyle.foreground) {\r\n                        const foregroundBits = (tokenStyle.foreground) << 14 /* FOREGROUND_OFFSET */;\r\n                        metadata |= foregroundBits | 8 /* SEMANTIC_USE_FOREGROUND */;\r\n                    }\r\n                    if (metadata === 0) {\r\n                        // Nothing!\r\n                        metadata = 2147483647 /* NO_STYLING */;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (this._logService.getLevel() === LogLevel.Trace) {\r\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);\r\n                }\r\n                metadata = 2147483647 /* NO_STYLING */;\r\n                tokenType = 'not-in-legend';\r\n            }\r\n            this._hashTable.add(tokenTypeIndex, tokenModifierSet, languageId.id, metadata);\r\n            if (this._logService.getLevel() === LogLevel.Trace) {\r\n                this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\r\n            }\r\n        }\r\n        return metadata;\r\n    }\r\n}\r\nexport function toMultilineTokens2(tokens, styling, languageId) {\r\n    const srcData = tokens.data;\r\n    const tokenCount = (tokens.data.length / 5) | 0;\r\n    const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* DesiredMaxAreas */), 400 /* DesiredTokensPerArea */);\r\n    const result = [];\r\n    let tokenIndex = 0;\r\n    let lastLineNumber = 1;\r\n    let lastStartCharacter = 0;\r\n    while (tokenIndex < tokenCount) {\r\n        const tokenStartIndex = tokenIndex;\r\n        let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\r\n        // Keep tokens on the same line in the same area...\r\n        if (tokenEndIndex < tokenCount) {\r\n            let smallTokenEndIndex = tokenEndIndex;\r\n            while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\r\n                smallTokenEndIndex--;\r\n            }\r\n            if (smallTokenEndIndex - 1 === tokenStartIndex) {\r\n                // there are so many tokens on this line that our area would be empty, we must now go right\r\n                let bigTokenEndIndex = tokenEndIndex;\r\n                while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\r\n                    bigTokenEndIndex++;\r\n                }\r\n                tokenEndIndex = bigTokenEndIndex;\r\n            }\r\n            else {\r\n                tokenEndIndex = smallTokenEndIndex;\r\n            }\r\n        }\r\n        let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\r\n        let destOffset = 0;\r\n        let areaLine = 0;\r\n        while (tokenIndex < tokenEndIndex) {\r\n            const srcOffset = 5 * tokenIndex;\r\n            const deltaLine = srcData[srcOffset];\r\n            const deltaCharacter = srcData[srcOffset + 1];\r\n            const lineNumber = lastLineNumber + deltaLine;\r\n            const startCharacter = (deltaLine === 0 ? lastStartCharacter + deltaCharacter : deltaCharacter);\r\n            const length = srcData[srcOffset + 2];\r\n            const tokenTypeIndex = srcData[srcOffset + 3];\r\n            const tokenModifierSet = srcData[srcOffset + 4];\r\n            const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\r\n            if (metadata !== 2147483647 /* NO_STYLING */) {\r\n                if (areaLine === 0) {\r\n                    areaLine = lineNumber;\r\n                }\r\n                destData[destOffset] = lineNumber - areaLine;\r\n                destData[destOffset + 1] = startCharacter;\r\n                destData[destOffset + 2] = startCharacter + length;\r\n                destData[destOffset + 3] = metadata;\r\n                destOffset += 4;\r\n            }\r\n            lastLineNumber = lineNumber;\r\n            lastStartCharacter = startCharacter;\r\n            tokenIndex++;\r\n        }\r\n        if (destOffset !== destData.length) {\r\n            destData = destData.subarray(0, destOffset);\r\n        }\r\n        const tokens = new MultilineTokens2(areaLine, new SparseEncodedTokens(destData));\r\n        result.push(tokens);\r\n    }\r\n    return result;\r\n}\r\nclass HashTableEntry {\r\n    constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\r\n        this.tokenTypeIndex = tokenTypeIndex;\r\n        this.tokenModifierSet = tokenModifierSet;\r\n        this.languageId = languageId;\r\n        this.metadata = metadata;\r\n        this.next = null;\r\n    }\r\n}\r\nclass HashTable {\r\n    constructor() {\r\n        this._elementsCount = 0;\r\n        this._currentLengthIndex = 0;\r\n        this._currentLength = HashTable._SIZES[this._currentLengthIndex];\r\n        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\r\n        this._elements = [];\r\n        HashTable._nullOutEntries(this._elements, this._currentLength);\r\n    }\r\n    static _nullOutEntries(entries, length) {\r\n        for (let i = 0; i < length; i++) {\r\n            entries[i] = null;\r\n        }\r\n    }\r\n    _hash2(n1, n2) {\r\n        return (((n1 << 5) - n1) + n2) | 0; // n1 * 31 + n2, keep as int32\r\n    }\r\n    _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\r\n        return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\r\n    }\r\n    get(tokenTypeIndex, tokenModifierSet, languageId) {\r\n        const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\r\n        let p = this._elements[hash];\r\n        while (p) {\r\n            if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\r\n                return p;\r\n            }\r\n            p = p.next;\r\n        }\r\n        return null;\r\n    }\r\n    add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\r\n        this._elementsCount++;\r\n        if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\r\n            // expand!\r\n            const oldElements = this._elements;\r\n            this._currentLengthIndex++;\r\n            this._currentLength = HashTable._SIZES[this._currentLengthIndex];\r\n            this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\r\n            this._elements = [];\r\n            HashTable._nullOutEntries(this._elements, this._currentLength);\r\n            for (const first of oldElements) {\r\n                let p = first;\r\n                while (p) {\r\n                    const oldNext = p.next;\r\n                    p.next = null;\r\n                    this._add(p);\r\n                    p = oldNext;\r\n                }\r\n            }\r\n        }\r\n        this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\r\n    }\r\n    _add(element) {\r\n        const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\r\n        element.next = this._elements[hash];\r\n        this._elements[hash] = element;\r\n    }\r\n}\r\nHashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,aAAa,QAAQ,aAAa;AAC3C,SAASC,QAAQ,QAAQ,qCAAqC;AAC9D,SAASC,gBAAgB,EAAEC,mBAAmB,QAAQ,yBAAyB;AAC/E,OAAO,MAAMC,6BAA6B,CAAC;EACvCC,WAAWA,CAACC,OAAO,EAAEC,aAAa,EAAEC,WAAW,EAAE;IAC7C,IAAI,CAACF,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,UAAU,GAAG,IAAIC,SAAS,CAAC,CAAC;EACrC;EACAC,WAAWA,CAACC,cAAc,EAAEC,gBAAgB,EAAEC,UAAU,EAAE;IACtD,MAAMC,KAAK,GAAG,IAAI,CAACN,UAAU,CAACO,GAAG,CAACJ,cAAc,EAAEC,gBAAgB,EAAEC,UAAU,CAACG,EAAE,CAAC;IAClF,IAAIC,QAAQ;IACZ,IAAIH,KAAK,EAAE;MACPG,QAAQ,GAAGH,KAAK,CAACG,QAAQ;MACzB,IAAI,IAAI,CAACV,WAAW,CAACW,QAAQ,CAAC,CAAC,KAAKlB,QAAQ,CAACmB,KAAK,EAAE;QAChD,IAAI,CAACZ,WAAW,CAACa,KAAK,2CAAAC,MAAA,CAA2CV,cAAc,SAAAU,MAAA,CAAMT,gBAAgB,mBAAAS,MAAA,CAAgBtB,aAAa,CAACuB,aAAa,CAACL,QAAQ,CAAC,kBAAAI,MAAA,CAAetB,aAAa,CAACwB,YAAY,CAACN,QAAQ,CAAC,CAACO,QAAQ,CAAC,CAAC,CAAC,CAAE,CAAC;MAChO;IACJ,CAAC,MACI;MACD,IAAIC,SAAS,GAAG,IAAI,CAACpB,OAAO,CAACqB,UAAU,CAACf,cAAc,CAAC;MACvD,MAAMgB,cAAc,GAAG,EAAE;MACzB,IAAIF,SAAS,EAAE;QACX,IAAIG,WAAW,GAAGhB,gBAAgB;QAClC,KAAK,IAAIiB,aAAa,GAAG,CAAC,EAAED,WAAW,GAAG,CAAC,IAAIC,aAAa,GAAG,IAAI,CAACxB,OAAO,CAACsB,cAAc,CAACG,MAAM,EAAED,aAAa,EAAE,EAAE;UAChH,IAAID,WAAW,GAAG,CAAC,EAAE;YACjBD,cAAc,CAACI,IAAI,CAAC,IAAI,CAAC1B,OAAO,CAACsB,cAAc,CAACE,aAAa,CAAC,CAAC;UACnE;UACAD,WAAW,GAAGA,WAAW,IAAI,CAAC;QAClC;QACA,IAAIA,WAAW,GAAG,CAAC,IAAI,IAAI,CAACrB,WAAW,CAACW,QAAQ,CAAC,CAAC,KAAKlB,QAAQ,CAACmB,KAAK,EAAE;UACnE,IAAI,CAACZ,WAAW,CAACa,KAAK,iEAAAC,MAAA,CAAiET,gBAAgB,CAACY,QAAQ,CAAC,CAAC,CAAC,mBAAAH,MAAA,CAAgBW,IAAI,CAACC,SAAS,CAAC,IAAI,CAAC5B,OAAO,CAACsB,cAAc,CAAC,CAAE,CAAC;UACjLA,cAAc,CAACI,IAAI,CAAC,eAAe,CAAC;QACxC;QACA,MAAMG,UAAU,GAAG,IAAI,CAAC5B,aAAa,CAAC6B,aAAa,CAAC,CAAC,CAACC,qBAAqB,CAACX,SAAS,EAAEE,cAAc,EAAEd,UAAU,CAACwB,QAAQ,CAAC;QAC3H,IAAI,OAAOH,UAAU,KAAK,WAAW,EAAE;UACnCjB,QAAQ,GAAG,UAAU,CAAC;QAC1B,CAAC,MACI;UACDA,QAAQ,GAAG,CAAC;UACZ,IAAI,OAAOiB,UAAU,CAACI,MAAM,KAAK,WAAW,EAAE;YAC1C,MAAMC,SAAS,GAAG,CAACL,UAAU,CAACI,MAAM,GAAG,CAAC,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;YACjErB,QAAQ,IAAIsB,SAAS,GAAG,CAAC,CAAC;UAC9B;;UACA,IAAI,OAAOL,UAAU,CAACM,IAAI,KAAK,WAAW,EAAE;YACxC,MAAMC,OAAO,GAAG,CAACP,UAAU,CAACM,IAAI,GAAG,CAAC,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC;YAC3DvB,QAAQ,IAAIwB,OAAO,GAAG,CAAC,CAAC;UAC5B;;UACA,IAAI,OAAOP,UAAU,CAACQ,SAAS,KAAK,WAAW,EAAE;YAC7C,MAAMC,YAAY,GAAG,CAACT,UAAU,CAACQ,SAAS,GAAG,CAAC,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;YAC1EzB,QAAQ,IAAI0B,YAAY,GAAG,CAAC,CAAC;UACjC;;UACA,IAAIT,UAAU,CAACU,UAAU,EAAE;YACvB,MAAMC,cAAc,GAAIX,UAAU,CAACU,UAAU,IAAK,EAAE,CAAC;YACrD3B,QAAQ,IAAI4B,cAAc,GAAG,CAAC,CAAC;UACnC;;UACA,IAAI5B,QAAQ,KAAK,CAAC,EAAE;YAChB;YACAA,QAAQ,GAAG,UAAU,CAAC;UAC1B;QACJ;MACJ,CAAC,MACI;QACD,IAAI,IAAI,CAACV,WAAW,CAACW,QAAQ,CAAC,CAAC,KAAKlB,QAAQ,CAACmB,KAAK,EAAE;UAChD,IAAI,CAACZ,WAAW,CAACa,KAAK,6DAAAC,MAAA,CAA6DV,cAAc,mBAAAU,MAAA,CAAgBW,IAAI,CAACC,SAAS,CAAC,IAAI,CAAC5B,OAAO,CAACqB,UAAU,CAAC,CAAE,CAAC;QAC/J;QACAT,QAAQ,GAAG,UAAU,CAAC;QACtBQ,SAAS,GAAG,eAAe;MAC/B;MACA,IAAI,CAACjB,UAAU,CAACsC,GAAG,CAACnC,cAAc,EAAEC,gBAAgB,EAAEC,UAAU,CAACG,EAAE,EAAEC,QAAQ,CAAC;MAC9E,IAAI,IAAI,CAACV,WAAW,CAACW,QAAQ,CAAC,CAAC,KAAKlB,QAAQ,CAACmB,KAAK,EAAE;QAChD,IAAI,CAACZ,WAAW,CAACa,KAAK,kCAAAC,MAAA,CAAkCV,cAAc,QAAAU,MAAA,CAAKI,SAAS,UAAAJ,MAAA,CAAOT,gBAAgB,QAAAS,MAAA,CAAKM,cAAc,CAACoB,IAAI,CAAC,GAAG,CAAC,oBAAA1B,MAAA,CAAiBtB,aAAa,CAACuB,aAAa,CAACL,QAAQ,CAAC,kBAAAI,MAAA,CAAetB,aAAa,CAACwB,YAAY,CAACN,QAAQ,CAAC,CAACO,QAAQ,CAAC,CAAC,CAAC,CAAE,CAAC;MACpQ;IACJ;IACA,OAAOP,QAAQ;EACnB;AACJ;AACA,OAAO,SAAS+B,kBAAkBA,CAACC,MAAM,EAAEC,OAAO,EAAErC,UAAU,EAAE;EAC5D,MAAMsC,OAAO,GAAGF,MAAM,CAACG,IAAI;EAC3B,MAAMC,UAAU,GAAIJ,MAAM,CAACG,IAAI,CAACtB,MAAM,GAAG,CAAC,GAAI,CAAC;EAC/C,MAAMwB,aAAa,GAAGC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,IAAI,CAACJ,UAAU,GAAG,IAAI,CAAC,qBAAqB,CAAC,EAAE,GAAG,CAAC,0BAA0B,CAAC;EAClH,MAAMK,MAAM,GAAG,EAAE;EACjB,IAAIC,UAAU,GAAG,CAAC;EAClB,IAAIC,cAAc,GAAG,CAAC;EACtB,IAAIC,kBAAkB,GAAG,CAAC;EAC1B,OAAOF,UAAU,GAAGN,UAAU,EAAE;IAC5B,MAAMS,eAAe,GAAGH,UAAU;IAClC,IAAII,aAAa,GAAGR,IAAI,CAACS,GAAG,CAACF,eAAe,GAAGR,aAAa,EAAED,UAAU,CAAC;IACzE;IACA,IAAIU,aAAa,GAAGV,UAAU,EAAE;MAC5B,IAAIY,kBAAkB,GAAGF,aAAa;MACtC,OAAOE,kBAAkB,GAAG,CAAC,GAAGH,eAAe,IAAIX,OAAO,CAAC,CAAC,GAAGc,kBAAkB,CAAC,KAAK,CAAC,EAAE;QACtFA,kBAAkB,EAAE;MACxB;MACA,IAAIA,kBAAkB,GAAG,CAAC,KAAKH,eAAe,EAAE;QAC5C;QACA,IAAII,gBAAgB,GAAGH,aAAa;QACpC,OAAOG,gBAAgB,GAAG,CAAC,GAAGb,UAAU,IAAIF,OAAO,CAAC,CAAC,GAAGe,gBAAgB,CAAC,KAAK,CAAC,EAAE;UAC7EA,gBAAgB,EAAE;QACtB;QACAH,aAAa,GAAGG,gBAAgB;MACpC,CAAC,MACI;QACDH,aAAa,GAAGE,kBAAkB;MACtC;IACJ;IACA,IAAIE,QAAQ,GAAG,IAAIC,WAAW,CAAC,CAACL,aAAa,GAAGD,eAAe,IAAI,CAAC,CAAC;IACrE,IAAIO,UAAU,GAAG,CAAC;IAClB,IAAIC,QAAQ,GAAG,CAAC;IAChB,OAAOX,UAAU,GAAGI,aAAa,EAAE;MAC/B,MAAMQ,SAAS,GAAG,CAAC,GAAGZ,UAAU;MAChC,MAAMa,SAAS,GAAGrB,OAAO,CAACoB,SAAS,CAAC;MACpC,MAAME,cAAc,GAAGtB,OAAO,CAACoB,SAAS,GAAG,CAAC,CAAC;MAC7C,MAAMG,UAAU,GAAGd,cAAc,GAAGY,SAAS;MAC7C,MAAMG,cAAc,GAAIH,SAAS,KAAK,CAAC,GAAGX,kBAAkB,GAAGY,cAAc,GAAGA,cAAe;MAC/F,MAAM3C,MAAM,GAAGqB,OAAO,CAACoB,SAAS,GAAG,CAAC,CAAC;MACrC,MAAM5D,cAAc,GAAGwC,OAAO,CAACoB,SAAS,GAAG,CAAC,CAAC;MAC7C,MAAM3D,gBAAgB,GAAGuC,OAAO,CAACoB,SAAS,GAAG,CAAC,CAAC;MAC/C,MAAMtD,QAAQ,GAAGiC,OAAO,CAACxC,WAAW,CAACC,cAAc,EAAEC,gBAAgB,EAAEC,UAAU,CAAC;MAClF,IAAII,QAAQ,KAAK,UAAU,CAAC,kBAAkB;QAC1C,IAAIqD,QAAQ,KAAK,CAAC,EAAE;UAChBA,QAAQ,GAAGI,UAAU;QACzB;QACAP,QAAQ,CAACE,UAAU,CAAC,GAAGK,UAAU,GAAGJ,QAAQ;QAC5CH,QAAQ,CAACE,UAAU,GAAG,CAAC,CAAC,GAAGM,cAAc;QACzCR,QAAQ,CAACE,UAAU,GAAG,CAAC,CAAC,GAAGM,cAAc,GAAG7C,MAAM;QAClDqC,QAAQ,CAACE,UAAU,GAAG,CAAC,CAAC,GAAGpD,QAAQ;QACnCoD,UAAU,IAAI,CAAC;MACnB;MACAT,cAAc,GAAGc,UAAU;MAC3Bb,kBAAkB,GAAGc,cAAc;MACnChB,UAAU,EAAE;IAChB;IACA,IAAIU,UAAU,KAAKF,QAAQ,CAACrC,MAAM,EAAE;MAChCqC,QAAQ,GAAGA,QAAQ,CAACS,QAAQ,CAAC,CAAC,EAAEP,UAAU,CAAC;IAC/C;IACA,MAAMpB,MAAM,GAAG,IAAIhD,gBAAgB,CAACqE,QAAQ,EAAE,IAAIpE,mBAAmB,CAACiE,QAAQ,CAAC,CAAC;IAChFT,MAAM,CAAC3B,IAAI,CAACkB,MAAM,CAAC;EACvB;EACA,OAAOS,MAAM;AACjB;AACA,MAAMmB,cAAc,CAAC;EACjBzE,WAAWA,CAACO,cAAc,EAAEC,gBAAgB,EAAEC,UAAU,EAAEI,QAAQ,EAAE;IAChE,IAAI,CAACN,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACI,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC6D,IAAI,GAAG,IAAI;EACpB;AACJ;AACA,MAAMrE,SAAS,CAAC;EACZL,WAAWA,CAAA,EAAG;IACV,IAAI,CAAC2E,cAAc,GAAG,CAAC;IACvB,IAAI,CAACC,mBAAmB,GAAG,CAAC;IAC5B,IAAI,CAACC,cAAc,GAAGxE,SAAS,CAACyE,MAAM,CAAC,IAAI,CAACF,mBAAmB,CAAC;IAChE,IAAI,CAACG,UAAU,GAAG5B,IAAI,CAAC6B,KAAK,CAAC,IAAI,CAACJ,mBAAmB,GAAG,CAAC,GAAGvE,SAAS,CAACyE,MAAM,CAACpD,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAACmD,cAAc,GAAG,CAAC,CAAC;IACtH,IAAI,CAACI,SAAS,GAAG,EAAE;IACnB5E,SAAS,CAAC6E,eAAe,CAAC,IAAI,CAACD,SAAS,EAAE,IAAI,CAACJ,cAAc,CAAC;EAClE;EACA,OAAOK,eAAeA,CAACC,OAAO,EAAEzD,MAAM,EAAE;IACpC,KAAK,IAAI0D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1D,MAAM,EAAE0D,CAAC,EAAE,EAAE;MAC7BD,OAAO,CAACC,CAAC,CAAC,GAAG,IAAI;IACrB;EACJ;EACAC,MAAMA,CAACC,EAAE,EAAEC,EAAE,EAAE;IACX,OAAS,CAACD,EAAE,IAAI,CAAC,IAAIA,EAAE,GAAIC,EAAE,GAAI,CAAC,CAAC,CAAC;EACxC;;EACAC,SAASA,CAACjF,cAAc,EAAEC,gBAAgB,EAAEC,UAAU,EAAE;IACpD,OAAO,IAAI,CAAC4E,MAAM,CAAC,IAAI,CAACA,MAAM,CAAC9E,cAAc,EAAEC,gBAAgB,CAAC,EAAEC,UAAU,CAAC,GAAG,IAAI,CAACoE,cAAc;EACvG;EACAlE,GAAGA,CAACJ,cAAc,EAAEC,gBAAgB,EAAEC,UAAU,EAAE;IAC9C,MAAMgF,IAAI,GAAG,IAAI,CAACD,SAAS,CAACjF,cAAc,EAAEC,gBAAgB,EAAEC,UAAU,CAAC;IACzE,IAAIiF,CAAC,GAAG,IAAI,CAACT,SAAS,CAACQ,IAAI,CAAC;IAC5B,OAAOC,CAAC,EAAE;MACN,IAAIA,CAAC,CAACnF,cAAc,KAAKA,cAAc,IAAImF,CAAC,CAAClF,gBAAgB,KAAKA,gBAAgB,IAAIkF,CAAC,CAACjF,UAAU,KAAKA,UAAU,EAAE;QAC/G,OAAOiF,CAAC;MACZ;MACAA,CAAC,GAAGA,CAAC,CAAChB,IAAI;IACd;IACA,OAAO,IAAI;EACf;EACAhC,GAAGA,CAACnC,cAAc,EAAEC,gBAAgB,EAAEC,UAAU,EAAEI,QAAQ,EAAE;IACxD,IAAI,CAAC8D,cAAc,EAAE;IACrB,IAAI,IAAI,CAACI,UAAU,KAAK,CAAC,IAAI,IAAI,CAACJ,cAAc,IAAI,IAAI,CAACI,UAAU,EAAE;MACjE;MACA,MAAMY,WAAW,GAAG,IAAI,CAACV,SAAS;MAClC,IAAI,CAACL,mBAAmB,EAAE;MAC1B,IAAI,CAACC,cAAc,GAAGxE,SAAS,CAACyE,MAAM,CAAC,IAAI,CAACF,mBAAmB,CAAC;MAChE,IAAI,CAACG,UAAU,GAAG5B,IAAI,CAAC6B,KAAK,CAAC,IAAI,CAACJ,mBAAmB,GAAG,CAAC,GAAGvE,SAAS,CAACyE,MAAM,CAACpD,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAACmD,cAAc,GAAG,CAAC,CAAC;MACtH,IAAI,CAACI,SAAS,GAAG,EAAE;MACnB5E,SAAS,CAAC6E,eAAe,CAAC,IAAI,CAACD,SAAS,EAAE,IAAI,CAACJ,cAAc,CAAC;MAC9D,KAAK,MAAMe,KAAK,IAAID,WAAW,EAAE;QAC7B,IAAID,CAAC,GAAGE,KAAK;QACb,OAAOF,CAAC,EAAE;UACN,MAAMG,OAAO,GAAGH,CAAC,CAAChB,IAAI;UACtBgB,CAAC,CAAChB,IAAI,GAAG,IAAI;UACb,IAAI,CAACoB,IAAI,CAACJ,CAAC,CAAC;UACZA,CAAC,GAAGG,OAAO;QACf;MACJ;IACJ;IACA,IAAI,CAACC,IAAI,CAAC,IAAIrB,cAAc,CAAClE,cAAc,EAAEC,gBAAgB,EAAEC,UAAU,EAAEI,QAAQ,CAAC,CAAC;EACzF;EACAiF,IAAIA,CAACC,OAAO,EAAE;IACV,MAAMN,IAAI,GAAG,IAAI,CAACD,SAAS,CAACO,OAAO,CAACxF,cAAc,EAAEwF,OAAO,CAACvF,gBAAgB,EAAEuF,OAAO,CAACtF,UAAU,CAAC;IACjGsF,OAAO,CAACrB,IAAI,GAAG,IAAI,CAACO,SAAS,CAACQ,IAAI,CAAC;IACnC,IAAI,CAACR,SAAS,CAACQ,IAAI,CAAC,GAAGM,OAAO;EAClC;AACJ;AACA1F,SAAS,CAACyE,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}