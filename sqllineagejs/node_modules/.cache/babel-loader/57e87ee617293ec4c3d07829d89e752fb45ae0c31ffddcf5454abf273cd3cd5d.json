{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { RangeUtil } from './rangeUtil.js';\nimport { HorizontalRange, VisibleRanges } from '../../../common/view/renderingContext.js';\nimport { LineDecoration } from '../../../common/viewLayout/lineDecorations.js';\nimport { CharacterMapping, RenderLineInput, renderViewLine, LineRange } from '../../../common/viewLayout/viewLineRenderer.js';\nimport { ColorScheme } from '../../../../platform/theme/common/theme.js';\nimport { EditorFontLigatures } from '../../../common/config/editorOptions.js';\nconst canUseFastRenderedViewLine = function () {\n  if (platform.isNative) {\n    // In VSCode we know very well when the zoom level changes\n    return true;\n  }\n  if (platform.isLinux || browser.isFirefox || browser.isSafari) {\n    // On Linux, it appears that zooming affects char widths (in pixels), which is unexpected.\n    // --\n    // Even though we read character widths correctly, having read them at a specific zoom level\n    // does not mean they are the same at the current zoom level.\n    // --\n    // This could be improved if we ever figure out how to get an event when browsers zoom,\n    // but until then we have to stick with reading client rects.\n    // --\n    // The same has been observed with Firefox on Windows7\n    // --\n    // The same has been oversved with Safari\n    return false;\n  }\n  return true;\n}();\nlet monospaceAssumptionsAreValid = true;\nconst alwaysRenderInlineSelection = browser.isEdgeLegacy;\nexport class DomReadingContext {\n  constructor(domNode, endNode) {\n    this._domNode = domNode;\n    this._clientRectDeltaLeft = 0;\n    this._clientRectDeltaLeftRead = false;\n    this.endNode = endNode;\n  }\n  get clientRectDeltaLeft() {\n    if (!this._clientRectDeltaLeftRead) {\n      this._clientRectDeltaLeftRead = true;\n      this._clientRectDeltaLeft = this._domNode.getBoundingClientRect().left;\n    }\n    return this._clientRectDeltaLeft;\n  }\n}\nexport class ViewLineOptions {\n  constructor(config, themeType) {\n    this.themeType = themeType;\n    const options = config.options;\n    const fontInfo = options.get(38 /* fontInfo */);\n    this.renderWhitespace = options.get(83 /* renderWhitespace */);\n    this.renderControlCharacters = options.get(77 /* renderControlCharacters */);\n    this.spaceWidth = fontInfo.spaceWidth;\n    this.middotWidth = fontInfo.middotWidth;\n    this.wsmiddotWidth = fontInfo.wsmiddotWidth;\n    this.useMonospaceOptimizations = fontInfo.isMonospace && !options.get(26 /* disableMonospaceOptimizations */);\n    this.canUseHalfwidthRightwardsArrow = fontInfo.canUseHalfwidthRightwardsArrow;\n    this.lineHeight = options.get(53 /* lineHeight */);\n    this.stopRenderingLineAfter = options.get(100 /* stopRenderingLineAfter */);\n    this.fontLigatures = options.get(39 /* fontLigatures */);\n  }\n\n  equals(other) {\n    return this.themeType === other.themeType && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.spaceWidth === other.spaceWidth && this.middotWidth === other.middotWidth && this.wsmiddotWidth === other.wsmiddotWidth && this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineHeight === other.lineHeight && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.fontLigatures === other.fontLigatures;\n  }\n}\nexport class ViewLine {\n  constructor(options) {\n    this._options = options;\n    this._isMaybeInvalid = true;\n    this._renderedViewLine = null;\n  }\n  // --- begin IVisibleLineData\n  getDomNode() {\n    if (this._renderedViewLine && this._renderedViewLine.domNode) {\n      return this._renderedViewLine.domNode.domNode;\n    }\n    return null;\n  }\n  setDomNode(domNode) {\n    if (this._renderedViewLine) {\n      this._renderedViewLine.domNode = createFastDomNode(domNode);\n    } else {\n      throw new Error('I have no rendered view line to set the dom node to...');\n    }\n  }\n  onContentChanged() {\n    this._isMaybeInvalid = true;\n  }\n  onTokensChanged() {\n    this._isMaybeInvalid = true;\n  }\n  onDecorationsChanged() {\n    this._isMaybeInvalid = true;\n  }\n  onOptionsChanged(newOptions) {\n    this._isMaybeInvalid = true;\n    this._options = newOptions;\n  }\n  onSelectionChanged() {\n    if (alwaysRenderInlineSelection || this._options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace === 'selection') {\n      this._isMaybeInvalid = true;\n      return true;\n    }\n    return false;\n  }\n  renderLine(lineNumber, deltaTop, viewportData, sb) {\n    if (this._isMaybeInvalid === false) {\n      // it appears that nothing relevant has changed\n      return false;\n    }\n    this._isMaybeInvalid = false;\n    const lineData = viewportData.getViewLineRenderingData(lineNumber);\n    const options = this._options;\n    const actualInlineDecorations = LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn);\n    // Only send selection information when needed for rendering whitespace\n    let selectionsOnLine = null;\n    if (alwaysRenderInlineSelection || options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace === 'selection') {\n      const selections = viewportData.selections;\n      for (const selection of selections) {\n        if (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {\n          // Selection does not intersect line\n          continue;\n        }\n        const startColumn = selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn;\n        const endColumn = selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn;\n        if (startColumn < endColumn) {\n          if (options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace !== 'selection') {\n            actualInlineDecorations.push(new LineDecoration(startColumn, endColumn, 'inline-selected-text', 0 /* Regular */));\n          } else {\n            if (!selectionsOnLine) {\n              selectionsOnLine = [];\n            }\n            selectionsOnLine.push(new LineRange(startColumn - 1, endColumn - 1));\n          }\n        }\n      }\n    }\n    const renderLineInput = new RenderLineInput(options.useMonospaceOptimizations, options.canUseHalfwidthRightwardsArrow, lineData.content, lineData.continuesWithWrappedLine, lineData.isBasicASCII, lineData.containsRTL, lineData.minColumn - 1, lineData.tokens, actualInlineDecorations, lineData.tabSize, lineData.startVisibleColumn, options.spaceWidth, options.middotWidth, options.wsmiddotWidth, options.stopRenderingLineAfter, options.renderWhitespace, options.renderControlCharacters, options.fontLigatures !== EditorFontLigatures.OFF, selectionsOnLine);\n    if (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {\n      // no need to do anything, we have the same render input\n      return false;\n    }\n    sb.appendASCIIString('<div style=\"top:');\n    sb.appendASCIIString(String(deltaTop));\n    sb.appendASCIIString('px;height:');\n    sb.appendASCIIString(String(this._options.lineHeight));\n    sb.appendASCIIString('px;\" class=\"');\n    sb.appendASCIIString(ViewLine.CLASS_NAME);\n    sb.appendASCIIString('\">');\n    const output = renderViewLine(renderLineInput, sb);\n    sb.appendASCIIString('</div>');\n    let renderedViewLine = null;\n    if (monospaceAssumptionsAreValid && canUseFastRenderedViewLine && lineData.isBasicASCII && options.useMonospaceOptimizations && output.containsForeignElements === 0 /* None */) {\n      if (lineData.content.length < 300 && renderLineInput.lineTokens.getCount() < 100) {\n        // Browser rounding errors have been observed in Chrome and IE, so using the fast\n        // view line only for short lines. Please test before removing the length check...\n        // ---\n        // Another rounding error has been observed on Linux in VSCode, where <span> width\n        // rounding errors add up to an observable large number...\n        // ---\n        // Also see another example of rounding errors on Windows in\n        // https://github.com/microsoft/vscode/issues/33178\n        renderedViewLine = new FastRenderedViewLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping);\n      }\n    }\n    if (!renderedViewLine) {\n      renderedViewLine = createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping, output.containsRTL, output.containsForeignElements);\n    }\n    this._renderedViewLine = renderedViewLine;\n    return true;\n  }\n  layoutLine(lineNumber, deltaTop) {\n    if (this._renderedViewLine && this._renderedViewLine.domNode) {\n      this._renderedViewLine.domNode.setTop(deltaTop);\n      this._renderedViewLine.domNode.setHeight(this._options.lineHeight);\n    }\n  }\n  // --- end IVisibleLineData\n  getWidth() {\n    if (!this._renderedViewLine) {\n      return 0;\n    }\n    return this._renderedViewLine.getWidth();\n  }\n  getWidthIsFast() {\n    if (!this._renderedViewLine) {\n      return true;\n    }\n    return this._renderedViewLine.getWidthIsFast();\n  }\n  needsMonospaceFontCheck() {\n    if (!this._renderedViewLine) {\n      return false;\n    }\n    return this._renderedViewLine instanceof FastRenderedViewLine;\n  }\n  monospaceAssumptionsAreValid() {\n    if (!this._renderedViewLine) {\n      return monospaceAssumptionsAreValid;\n    }\n    if (this._renderedViewLine instanceof FastRenderedViewLine) {\n      return this._renderedViewLine.monospaceAssumptionsAreValid();\n    }\n    return monospaceAssumptionsAreValid;\n  }\n  onMonospaceAssumptionsInvalidated() {\n    if (this._renderedViewLine && this._renderedViewLine instanceof FastRenderedViewLine) {\n      this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine();\n    }\n  }\n  getVisibleRangesForRange(startColumn, endColumn, context) {\n    if (!this._renderedViewLine) {\n      return null;\n    }\n    startColumn = startColumn | 0; // @perf\n    endColumn = endColumn | 0; // @perf\n    startColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));\n    endColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));\n    const stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter | 0; // @perf\n    let outsideRenderedLine = false;\n    if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1 && endColumn > stopRenderingLineAfter + 1) {\n      // This range is obviously not visible\n      outsideRenderedLine = true;\n    }\n    if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1) {\n      startColumn = stopRenderingLineAfter + 1;\n    }\n    if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter + 1) {\n      endColumn = stopRenderingLineAfter + 1;\n    }\n    const horizontalRanges = this._renderedViewLine.getVisibleRangesForRange(startColumn, endColumn, context);\n    if (horizontalRanges && horizontalRanges.length > 0) {\n      return new VisibleRanges(outsideRenderedLine, horizontalRanges);\n    }\n    return null;\n  }\n  getColumnOfNodeOffset(lineNumber, spanNode, offset) {\n    if (!this._renderedViewLine) {\n      return 1;\n    }\n    return this._renderedViewLine.getColumnOfNodeOffset(lineNumber, spanNode, offset);\n  }\n}\nViewLine.CLASS_NAME = 'view-line';\n/**\r\n * A rendered line which is guaranteed to contain only regular ASCII and is rendered with a monospace font.\r\n */\nclass FastRenderedViewLine {\n  constructor(domNode, renderLineInput, characterMapping) {\n    this.domNode = domNode;\n    this.input = renderLineInput;\n    this._characterMapping = characterMapping;\n    this._charWidth = renderLineInput.spaceWidth;\n  }\n  getWidth() {\n    return this._getCharPosition(this._characterMapping.length);\n  }\n  getWidthIsFast() {\n    return true;\n  }\n  monospaceAssumptionsAreValid() {\n    if (!this.domNode) {\n      return monospaceAssumptionsAreValid;\n    }\n    const expectedWidth = this.getWidth();\n    const actualWidth = this.domNode.domNode.firstChild.offsetWidth;\n    if (Math.abs(expectedWidth - actualWidth) >= 2) {\n      // more than 2px off\n      console.warn(\"monospace assumptions have been violated, therefore disabling monospace optimizations!\");\n      monospaceAssumptionsAreValid = false;\n    }\n    return monospaceAssumptionsAreValid;\n  }\n  toSlowRenderedLine() {\n    return createRenderedLine(this.domNode, this.input, this._characterMapping, false, 0 /* None */);\n  }\n\n  getVisibleRangesForRange(startColumn, endColumn, context) {\n    const startPosition = this._getCharPosition(startColumn);\n    const endPosition = this._getCharPosition(endColumn);\n    return [new HorizontalRange(startPosition, endPosition - startPosition)];\n  }\n  _getCharPosition(column) {\n    const charOffset = this._characterMapping.getAbsoluteOffsets();\n    if (charOffset.length === 0) {\n      // No characters on this line\n      return 0;\n    }\n    return Math.round(this._charWidth * charOffset[column - 1]);\n  }\n  getColumnOfNodeOffset(lineNumber, spanNode, offset) {\n    const spanNodeTextContentLength = spanNode.textContent.length;\n    let spanIndex = -1;\n    while (spanNode) {\n      spanNode = spanNode.previousSibling;\n      spanIndex++;\n    }\n    const charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);\n    return charOffset + 1;\n  }\n}\n/**\r\n * Every time we render a line, we save what we have rendered in an instance of this class.\r\n */\nclass RenderedViewLine {\n  constructor(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n    this.domNode = domNode;\n    this.input = renderLineInput;\n    this._characterMapping = characterMapping;\n    this._isWhitespaceOnly = /^\\s*$/.test(renderLineInput.lineContent);\n    this._containsForeignElements = containsForeignElements;\n    this._cachedWidth = -1;\n    this._pixelOffsetCache = null;\n    if (!containsRTL || this._characterMapping.length === 0 /* the line is empty */) {\n      this._pixelOffsetCache = new Int32Array(Math.max(2, this._characterMapping.length + 1));\n      for (let column = 0, len = this._characterMapping.length; column <= len; column++) {\n        this._pixelOffsetCache[column] = -1;\n      }\n    }\n  }\n  // --- Reading from the DOM methods\n  _getReadingTarget(myDomNode) {\n    return myDomNode.domNode.firstChild;\n  }\n  /**\r\n   * Width of the line in pixels\r\n   */\n  getWidth() {\n    if (!this.domNode) {\n      return 0;\n    }\n    if (this._cachedWidth === -1) {\n      this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\n    }\n    return this._cachedWidth;\n  }\n  getWidthIsFast() {\n    if (this._cachedWidth === -1) {\n      return false;\n    }\n    return true;\n  }\n  /**\r\n   * Visible ranges for a model range\r\n   */\n  getVisibleRangesForRange(startColumn, endColumn, context) {\n    if (!this.domNode) {\n      return null;\n    }\n    if (this._pixelOffsetCache !== null) {\n      // the text is LTR\n      const startOffset = this._readPixelOffset(this.domNode, startColumn, context);\n      if (startOffset === -1) {\n        return null;\n      }\n      const endOffset = this._readPixelOffset(this.domNode, endColumn, context);\n      if (endOffset === -1) {\n        return null;\n      }\n      return [new HorizontalRange(startOffset, endOffset - startOffset)];\n    }\n    return this._readVisibleRangesForRange(this.domNode, startColumn, endColumn, context);\n  }\n  _readVisibleRangesForRange(domNode, startColumn, endColumn, context) {\n    if (startColumn === endColumn) {\n      const pixelOffset = this._readPixelOffset(domNode, startColumn, context);\n      if (pixelOffset === -1) {\n        return null;\n      } else {\n        return [new HorizontalRange(pixelOffset, 0)];\n      }\n    } else {\n      return this._readRawVisibleRangesForRange(domNode, startColumn, endColumn, context);\n    }\n  }\n  _readPixelOffset(domNode, column, context) {\n    if (this._characterMapping.length === 0) {\n      // This line has no content\n      if (this._containsForeignElements === 0 /* None */) {\n        // We can assume the line is really empty\n        return 0;\n      }\n      if (this._containsForeignElements === 2 /* After */) {\n        // We have foreign elements after the (empty) line\n        return 0;\n      }\n      if (this._containsForeignElements === 1 /* Before */) {\n        // We have foreign elements before the (empty) line\n        return this.getWidth();\n      }\n      // We have foreign elements before & after the (empty) line\n      const readingTarget = this._getReadingTarget(domNode);\n      if (readingTarget.firstChild) {\n        return readingTarget.firstChild.offsetWidth;\n      } else {\n        return 0;\n      }\n    }\n    if (this._pixelOffsetCache !== null) {\n      // the text is LTR\n      const cachedPixelOffset = this._pixelOffsetCache[column];\n      if (cachedPixelOffset !== -1) {\n        return cachedPixelOffset;\n      }\n      const result = this._actualReadPixelOffset(domNode, column, context);\n      this._pixelOffsetCache[column] = result;\n      return result;\n    }\n    return this._actualReadPixelOffset(domNode, column, context);\n  }\n  _actualReadPixelOffset(domNode, column, context) {\n    if (this._characterMapping.length === 0) {\n      // This line has no content\n      const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), 0, 0, 0, 0, context.clientRectDeltaLeft, context.endNode);\n      if (!r || r.length === 0) {\n        return -1;\n      }\n      return r[0].left;\n    }\n    if (column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0 /* None */) {\n      // This branch helps in the case of whitespace only lines which have a width set\n      return this.getWidth();\n    }\n    const partData = this._characterMapping.charOffsetToPartData(column - 1);\n    const partIndex = CharacterMapping.getPartIndex(partData);\n    const charOffsetInPart = CharacterMapping.getCharIndex(partData);\n    const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), partIndex, charOffsetInPart, partIndex, charOffsetInPart, context.clientRectDeltaLeft, context.endNode);\n    if (!r || r.length === 0) {\n      return -1;\n    }\n    const result = r[0].left;\n    if (this.input.isBasicASCII) {\n      const charOffset = this._characterMapping.getAbsoluteOffsets();\n      const expectedResult = Math.round(this.input.spaceWidth * charOffset[column - 1]);\n      if (Math.abs(expectedResult - result) <= 1) {\n        return expectedResult;\n      }\n    }\n    return result;\n  }\n  _readRawVisibleRangesForRange(domNode, startColumn, endColumn, context) {\n    if (startColumn === 1 && endColumn === this._characterMapping.length) {\n      // This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line\n      return [new HorizontalRange(0, this.getWidth())];\n    }\n    const startPartData = this._characterMapping.charOffsetToPartData(startColumn - 1);\n    const startPartIndex = CharacterMapping.getPartIndex(startPartData);\n    const startCharOffsetInPart = CharacterMapping.getCharIndex(startPartData);\n    const endPartData = this._characterMapping.charOffsetToPartData(endColumn - 1);\n    const endPartIndex = CharacterMapping.getPartIndex(endPartData);\n    const endCharOffsetInPart = CharacterMapping.getCharIndex(endPartData);\n    return RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), startPartIndex, startCharOffsetInPart, endPartIndex, endCharOffsetInPart, context.clientRectDeltaLeft, context.endNode);\n  }\n  /**\r\n   * Returns the column for the text found at a specific offset inside a rendered dom node\r\n   */\n  getColumnOfNodeOffset(lineNumber, spanNode, offset) {\n    const spanNodeTextContentLength = spanNode.textContent.length;\n    let spanIndex = -1;\n    while (spanNode) {\n      spanNode = spanNode.previousSibling;\n      spanIndex++;\n    }\n    const charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);\n    return charOffset + 1;\n  }\n}\nclass WebKitRenderedViewLine extends RenderedViewLine {\n  _readVisibleRangesForRange(domNode, startColumn, endColumn, context) {\n    const output = super._readVisibleRangesForRange(domNode, startColumn, endColumn, context);\n    if (!output || output.length === 0 || startColumn === endColumn || startColumn === 1 && endColumn === this._characterMapping.length) {\n      return output;\n    }\n    // WebKit is buggy and returns an expanded range (to contain words in some cases)\n    // The last client rect is enlarged (I think)\n    if (!this.input.containsRTL) {\n      // This is an attempt to patch things up\n      // Find position of last column\n      const endPixelOffset = this._readPixelOffset(domNode, endColumn, context);\n      if (endPixelOffset !== -1) {\n        const lastRange = output[output.length - 1];\n        if (lastRange.left < endPixelOffset) {\n          // Trim down the width of the last visible range to not go after the last column's position\n          lastRange.width = endPixelOffset - lastRange.left;\n        }\n      }\n    }\n    return output;\n  }\n}\nconst createRenderedLine = function () {\n  if (browser.isWebKit) {\n    return createWebKitRenderedLine;\n  }\n  return createNormalRenderedLine;\n}();\nfunction createWebKitRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n  return new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}\nfunction createNormalRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n  return new RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}","map":{"version":3,"names":["browser","createFastDomNode","platform","RangeUtil","HorizontalRange","VisibleRanges","LineDecoration","CharacterMapping","RenderLineInput","renderViewLine","LineRange","ColorScheme","EditorFontLigatures","canUseFastRenderedViewLine","isNative","isLinux","isFirefox","isSafari","monospaceAssumptionsAreValid","alwaysRenderInlineSelection","isEdgeLegacy","DomReadingContext","constructor","domNode","endNode","_domNode","_clientRectDeltaLeft","_clientRectDeltaLeftRead","clientRectDeltaLeft","getBoundingClientRect","left","ViewLineOptions","config","themeType","options","fontInfo","get","renderWhitespace","renderControlCharacters","spaceWidth","middotWidth","wsmiddotWidth","useMonospaceOptimizations","isMonospace","canUseHalfwidthRightwardsArrow","lineHeight","stopRenderingLineAfter","fontLigatures","equals","other","ViewLine","_options","_isMaybeInvalid","_renderedViewLine","getDomNode","setDomNode","Error","onContentChanged","onTokensChanged","onDecorationsChanged","onOptionsChanged","newOptions","onSelectionChanged","HIGH_CONTRAST","renderLine","lineNumber","deltaTop","viewportData","sb","lineData","getViewLineRenderingData","actualInlineDecorations","filter","inlineDecorations","minColumn","maxColumn","selectionsOnLine","selections","selection","endLineNumber","startLineNumber","startColumn","endColumn","push","renderLineInput","content","continuesWithWrappedLine","isBasicASCII","containsRTL","tokens","tabSize","startVisibleColumn","OFF","input","appendASCIIString","String","CLASS_NAME","output","renderedViewLine","containsForeignElements","length","lineTokens","getCount","FastRenderedViewLine","characterMapping","createRenderedLine","layoutLine","setTop","setHeight","getWidth","getWidthIsFast","needsMonospaceFontCheck","onMonospaceAssumptionsInvalidated","toSlowRenderedLine","getVisibleRangesForRange","context","Math","min","lineContent","max","outsideRenderedLine","horizontalRanges","getColumnOfNodeOffset","spanNode","offset","_characterMapping","_charWidth","_getCharPosition","expectedWidth","actualWidth","firstChild","offsetWidth","abs","console","warn","startPosition","endPosition","column","charOffset","getAbsoluteOffsets","round","spanNodeTextContentLength","textContent","spanIndex","previousSibling","partDataToCharOffset","RenderedViewLine","_isWhitespaceOnly","test","_containsForeignElements","_cachedWidth","_pixelOffsetCache","Int32Array","len","_getReadingTarget","myDomNode","startOffset","_readPixelOffset","endOffset","_readVisibleRangesForRange","pixelOffset","_readRawVisibleRangesForRange","readingTarget","cachedPixelOffset","result","_actualReadPixelOffset","r","readHorizontalRanges","partData","charOffsetToPartData","partIndex","getPartIndex","charOffsetInPart","getCharIndex","expectedResult","startPartData","startPartIndex","startCharOffsetInPart","endPartData","endPartIndex","endCharOffsetInPart","WebKitRenderedViewLine","endPixelOffset","lastRange","width","isWebKit","createWebKitRenderedLine","createNormalRenderedLine"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLine.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as browser from '../../../../base/browser/browser.js';\r\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\r\nimport * as platform from '../../../../base/common/platform.js';\r\nimport { RangeUtil } from './rangeUtil.js';\r\nimport { HorizontalRange, VisibleRanges } from '../../../common/view/renderingContext.js';\r\nimport { LineDecoration } from '../../../common/viewLayout/lineDecorations.js';\r\nimport { CharacterMapping, RenderLineInput, renderViewLine, LineRange } from '../../../common/viewLayout/viewLineRenderer.js';\r\nimport { ColorScheme } from '../../../../platform/theme/common/theme.js';\r\nimport { EditorFontLigatures } from '../../../common/config/editorOptions.js';\r\nconst canUseFastRenderedViewLine = (function () {\r\n    if (platform.isNative) {\r\n        // In VSCode we know very well when the zoom level changes\r\n        return true;\r\n    }\r\n    if (platform.isLinux || browser.isFirefox || browser.isSafari) {\r\n        // On Linux, it appears that zooming affects char widths (in pixels), which is unexpected.\r\n        // --\r\n        // Even though we read character widths correctly, having read them at a specific zoom level\r\n        // does not mean they are the same at the current zoom level.\r\n        // --\r\n        // This could be improved if we ever figure out how to get an event when browsers zoom,\r\n        // but until then we have to stick with reading client rects.\r\n        // --\r\n        // The same has been observed with Firefox on Windows7\r\n        // --\r\n        // The same has been oversved with Safari\r\n        return false;\r\n    }\r\n    return true;\r\n})();\r\nlet monospaceAssumptionsAreValid = true;\r\nconst alwaysRenderInlineSelection = (browser.isEdgeLegacy);\r\nexport class DomReadingContext {\r\n    constructor(domNode, endNode) {\r\n        this._domNode = domNode;\r\n        this._clientRectDeltaLeft = 0;\r\n        this._clientRectDeltaLeftRead = false;\r\n        this.endNode = endNode;\r\n    }\r\n    get clientRectDeltaLeft() {\r\n        if (!this._clientRectDeltaLeftRead) {\r\n            this._clientRectDeltaLeftRead = true;\r\n            this._clientRectDeltaLeft = this._domNode.getBoundingClientRect().left;\r\n        }\r\n        return this._clientRectDeltaLeft;\r\n    }\r\n}\r\nexport class ViewLineOptions {\r\n    constructor(config, themeType) {\r\n        this.themeType = themeType;\r\n        const options = config.options;\r\n        const fontInfo = options.get(38 /* fontInfo */);\r\n        this.renderWhitespace = options.get(83 /* renderWhitespace */);\r\n        this.renderControlCharacters = options.get(77 /* renderControlCharacters */);\r\n        this.spaceWidth = fontInfo.spaceWidth;\r\n        this.middotWidth = fontInfo.middotWidth;\r\n        this.wsmiddotWidth = fontInfo.wsmiddotWidth;\r\n        this.useMonospaceOptimizations = (fontInfo.isMonospace\r\n            && !options.get(26 /* disableMonospaceOptimizations */));\r\n        this.canUseHalfwidthRightwardsArrow = fontInfo.canUseHalfwidthRightwardsArrow;\r\n        this.lineHeight = options.get(53 /* lineHeight */);\r\n        this.stopRenderingLineAfter = options.get(100 /* stopRenderingLineAfter */);\r\n        this.fontLigatures = options.get(39 /* fontLigatures */);\r\n    }\r\n    equals(other) {\r\n        return (this.themeType === other.themeType\r\n            && this.renderWhitespace === other.renderWhitespace\r\n            && this.renderControlCharacters === other.renderControlCharacters\r\n            && this.spaceWidth === other.spaceWidth\r\n            && this.middotWidth === other.middotWidth\r\n            && this.wsmiddotWidth === other.wsmiddotWidth\r\n            && this.useMonospaceOptimizations === other.useMonospaceOptimizations\r\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\r\n            && this.lineHeight === other.lineHeight\r\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\r\n            && this.fontLigatures === other.fontLigatures);\r\n    }\r\n}\r\nexport class ViewLine {\r\n    constructor(options) {\r\n        this._options = options;\r\n        this._isMaybeInvalid = true;\r\n        this._renderedViewLine = null;\r\n    }\r\n    // --- begin IVisibleLineData\r\n    getDomNode() {\r\n        if (this._renderedViewLine && this._renderedViewLine.domNode) {\r\n            return this._renderedViewLine.domNode.domNode;\r\n        }\r\n        return null;\r\n    }\r\n    setDomNode(domNode) {\r\n        if (this._renderedViewLine) {\r\n            this._renderedViewLine.domNode = createFastDomNode(domNode);\r\n        }\r\n        else {\r\n            throw new Error('I have no rendered view line to set the dom node to...');\r\n        }\r\n    }\r\n    onContentChanged() {\r\n        this._isMaybeInvalid = true;\r\n    }\r\n    onTokensChanged() {\r\n        this._isMaybeInvalid = true;\r\n    }\r\n    onDecorationsChanged() {\r\n        this._isMaybeInvalid = true;\r\n    }\r\n    onOptionsChanged(newOptions) {\r\n        this._isMaybeInvalid = true;\r\n        this._options = newOptions;\r\n    }\r\n    onSelectionChanged() {\r\n        if (alwaysRenderInlineSelection || this._options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace === 'selection') {\r\n            this._isMaybeInvalid = true;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    renderLine(lineNumber, deltaTop, viewportData, sb) {\r\n        if (this._isMaybeInvalid === false) {\r\n            // it appears that nothing relevant has changed\r\n            return false;\r\n        }\r\n        this._isMaybeInvalid = false;\r\n        const lineData = viewportData.getViewLineRenderingData(lineNumber);\r\n        const options = this._options;\r\n        const actualInlineDecorations = LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn);\r\n        // Only send selection information when needed for rendering whitespace\r\n        let selectionsOnLine = null;\r\n        if (alwaysRenderInlineSelection || options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace === 'selection') {\r\n            const selections = viewportData.selections;\r\n            for (const selection of selections) {\r\n                if (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {\r\n                    // Selection does not intersect line\r\n                    continue;\r\n                }\r\n                const startColumn = (selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn);\r\n                const endColumn = (selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn);\r\n                if (startColumn < endColumn) {\r\n                    if (options.themeType === ColorScheme.HIGH_CONTRAST || this._options.renderWhitespace !== 'selection') {\r\n                        actualInlineDecorations.push(new LineDecoration(startColumn, endColumn, 'inline-selected-text', 0 /* Regular */));\r\n                    }\r\n                    else {\r\n                        if (!selectionsOnLine) {\r\n                            selectionsOnLine = [];\r\n                        }\r\n                        selectionsOnLine.push(new LineRange(startColumn - 1, endColumn - 1));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const renderLineInput = new RenderLineInput(options.useMonospaceOptimizations, options.canUseHalfwidthRightwardsArrow, lineData.content, lineData.continuesWithWrappedLine, lineData.isBasicASCII, lineData.containsRTL, lineData.minColumn - 1, lineData.tokens, actualInlineDecorations, lineData.tabSize, lineData.startVisibleColumn, options.spaceWidth, options.middotWidth, options.wsmiddotWidth, options.stopRenderingLineAfter, options.renderWhitespace, options.renderControlCharacters, options.fontLigatures !== EditorFontLigatures.OFF, selectionsOnLine);\r\n        if (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {\r\n            // no need to do anything, we have the same render input\r\n            return false;\r\n        }\r\n        sb.appendASCIIString('<div style=\"top:');\r\n        sb.appendASCIIString(String(deltaTop));\r\n        sb.appendASCIIString('px;height:');\r\n        sb.appendASCIIString(String(this._options.lineHeight));\r\n        sb.appendASCIIString('px;\" class=\"');\r\n        sb.appendASCIIString(ViewLine.CLASS_NAME);\r\n        sb.appendASCIIString('\">');\r\n        const output = renderViewLine(renderLineInput, sb);\r\n        sb.appendASCIIString('</div>');\r\n        let renderedViewLine = null;\r\n        if (monospaceAssumptionsAreValid && canUseFastRenderedViewLine && lineData.isBasicASCII && options.useMonospaceOptimizations && output.containsForeignElements === 0 /* None */) {\r\n            if (lineData.content.length < 300 && renderLineInput.lineTokens.getCount() < 100) {\r\n                // Browser rounding errors have been observed in Chrome and IE, so using the fast\r\n                // view line only for short lines. Please test before removing the length check...\r\n                // ---\r\n                // Another rounding error has been observed on Linux in VSCode, where <span> width\r\n                // rounding errors add up to an observable large number...\r\n                // ---\r\n                // Also see another example of rounding errors on Windows in\r\n                // https://github.com/microsoft/vscode/issues/33178\r\n                renderedViewLine = new FastRenderedViewLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping);\r\n            }\r\n        }\r\n        if (!renderedViewLine) {\r\n            renderedViewLine = createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping, output.containsRTL, output.containsForeignElements);\r\n        }\r\n        this._renderedViewLine = renderedViewLine;\r\n        return true;\r\n    }\r\n    layoutLine(lineNumber, deltaTop) {\r\n        if (this._renderedViewLine && this._renderedViewLine.domNode) {\r\n            this._renderedViewLine.domNode.setTop(deltaTop);\r\n            this._renderedViewLine.domNode.setHeight(this._options.lineHeight);\r\n        }\r\n    }\r\n    // --- end IVisibleLineData\r\n    getWidth() {\r\n        if (!this._renderedViewLine) {\r\n            return 0;\r\n        }\r\n        return this._renderedViewLine.getWidth();\r\n    }\r\n    getWidthIsFast() {\r\n        if (!this._renderedViewLine) {\r\n            return true;\r\n        }\r\n        return this._renderedViewLine.getWidthIsFast();\r\n    }\r\n    needsMonospaceFontCheck() {\r\n        if (!this._renderedViewLine) {\r\n            return false;\r\n        }\r\n        return (this._renderedViewLine instanceof FastRenderedViewLine);\r\n    }\r\n    monospaceAssumptionsAreValid() {\r\n        if (!this._renderedViewLine) {\r\n            return monospaceAssumptionsAreValid;\r\n        }\r\n        if (this._renderedViewLine instanceof FastRenderedViewLine) {\r\n            return this._renderedViewLine.monospaceAssumptionsAreValid();\r\n        }\r\n        return monospaceAssumptionsAreValid;\r\n    }\r\n    onMonospaceAssumptionsInvalidated() {\r\n        if (this._renderedViewLine && this._renderedViewLine instanceof FastRenderedViewLine) {\r\n            this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine();\r\n        }\r\n    }\r\n    getVisibleRangesForRange(startColumn, endColumn, context) {\r\n        if (!this._renderedViewLine) {\r\n            return null;\r\n        }\r\n        startColumn = startColumn | 0; // @perf\r\n        endColumn = endColumn | 0; // @perf\r\n        startColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));\r\n        endColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));\r\n        const stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter | 0; // @perf\r\n        let outsideRenderedLine = false;\r\n        if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1 && endColumn > stopRenderingLineAfter + 1) {\r\n            // This range is obviously not visible\r\n            outsideRenderedLine = true;\r\n        }\r\n        if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1) {\r\n            startColumn = stopRenderingLineAfter + 1;\r\n        }\r\n        if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter + 1) {\r\n            endColumn = stopRenderingLineAfter + 1;\r\n        }\r\n        const horizontalRanges = this._renderedViewLine.getVisibleRangesForRange(startColumn, endColumn, context);\r\n        if (horizontalRanges && horizontalRanges.length > 0) {\r\n            return new VisibleRanges(outsideRenderedLine, horizontalRanges);\r\n        }\r\n        return null;\r\n    }\r\n    getColumnOfNodeOffset(lineNumber, spanNode, offset) {\r\n        if (!this._renderedViewLine) {\r\n            return 1;\r\n        }\r\n        return this._renderedViewLine.getColumnOfNodeOffset(lineNumber, spanNode, offset);\r\n    }\r\n}\r\nViewLine.CLASS_NAME = 'view-line';\r\n/**\r\n * A rendered line which is guaranteed to contain only regular ASCII and is rendered with a monospace font.\r\n */\r\nclass FastRenderedViewLine {\r\n    constructor(domNode, renderLineInput, characterMapping) {\r\n        this.domNode = domNode;\r\n        this.input = renderLineInput;\r\n        this._characterMapping = characterMapping;\r\n        this._charWidth = renderLineInput.spaceWidth;\r\n    }\r\n    getWidth() {\r\n        return this._getCharPosition(this._characterMapping.length);\r\n    }\r\n    getWidthIsFast() {\r\n        return true;\r\n    }\r\n    monospaceAssumptionsAreValid() {\r\n        if (!this.domNode) {\r\n            return monospaceAssumptionsAreValid;\r\n        }\r\n        const expectedWidth = this.getWidth();\r\n        const actualWidth = this.domNode.domNode.firstChild.offsetWidth;\r\n        if (Math.abs(expectedWidth - actualWidth) >= 2) {\r\n            // more than 2px off\r\n            console.warn(`monospace assumptions have been violated, therefore disabling monospace optimizations!`);\r\n            monospaceAssumptionsAreValid = false;\r\n        }\r\n        return monospaceAssumptionsAreValid;\r\n    }\r\n    toSlowRenderedLine() {\r\n        return createRenderedLine(this.domNode, this.input, this._characterMapping, false, 0 /* None */);\r\n    }\r\n    getVisibleRangesForRange(startColumn, endColumn, context) {\r\n        const startPosition = this._getCharPosition(startColumn);\r\n        const endPosition = this._getCharPosition(endColumn);\r\n        return [new HorizontalRange(startPosition, endPosition - startPosition)];\r\n    }\r\n    _getCharPosition(column) {\r\n        const charOffset = this._characterMapping.getAbsoluteOffsets();\r\n        if (charOffset.length === 0) {\r\n            // No characters on this line\r\n            return 0;\r\n        }\r\n        return Math.round(this._charWidth * charOffset[column - 1]);\r\n    }\r\n    getColumnOfNodeOffset(lineNumber, spanNode, offset) {\r\n        const spanNodeTextContentLength = spanNode.textContent.length;\r\n        let spanIndex = -1;\r\n        while (spanNode) {\r\n            spanNode = spanNode.previousSibling;\r\n            spanIndex++;\r\n        }\r\n        const charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);\r\n        return charOffset + 1;\r\n    }\r\n}\r\n/**\r\n * Every time we render a line, we save what we have rendered in an instance of this class.\r\n */\r\nclass RenderedViewLine {\r\n    constructor(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\r\n        this.domNode = domNode;\r\n        this.input = renderLineInput;\r\n        this._characterMapping = characterMapping;\r\n        this._isWhitespaceOnly = /^\\s*$/.test(renderLineInput.lineContent);\r\n        this._containsForeignElements = containsForeignElements;\r\n        this._cachedWidth = -1;\r\n        this._pixelOffsetCache = null;\r\n        if (!containsRTL || this._characterMapping.length === 0 /* the line is empty */) {\r\n            this._pixelOffsetCache = new Int32Array(Math.max(2, this._characterMapping.length + 1));\r\n            for (let column = 0, len = this._characterMapping.length; column <= len; column++) {\r\n                this._pixelOffsetCache[column] = -1;\r\n            }\r\n        }\r\n    }\r\n    // --- Reading from the DOM methods\r\n    _getReadingTarget(myDomNode) {\r\n        return myDomNode.domNode.firstChild;\r\n    }\r\n    /**\r\n     * Width of the line in pixels\r\n     */\r\n    getWidth() {\r\n        if (!this.domNode) {\r\n            return 0;\r\n        }\r\n        if (this._cachedWidth === -1) {\r\n            this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\r\n        }\r\n        return this._cachedWidth;\r\n    }\r\n    getWidthIsFast() {\r\n        if (this._cachedWidth === -1) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Visible ranges for a model range\r\n     */\r\n    getVisibleRangesForRange(startColumn, endColumn, context) {\r\n        if (!this.domNode) {\r\n            return null;\r\n        }\r\n        if (this._pixelOffsetCache !== null) {\r\n            // the text is LTR\r\n            const startOffset = this._readPixelOffset(this.domNode, startColumn, context);\r\n            if (startOffset === -1) {\r\n                return null;\r\n            }\r\n            const endOffset = this._readPixelOffset(this.domNode, endColumn, context);\r\n            if (endOffset === -1) {\r\n                return null;\r\n            }\r\n            return [new HorizontalRange(startOffset, endOffset - startOffset)];\r\n        }\r\n        return this._readVisibleRangesForRange(this.domNode, startColumn, endColumn, context);\r\n    }\r\n    _readVisibleRangesForRange(domNode, startColumn, endColumn, context) {\r\n        if (startColumn === endColumn) {\r\n            const pixelOffset = this._readPixelOffset(domNode, startColumn, context);\r\n            if (pixelOffset === -1) {\r\n                return null;\r\n            }\r\n            else {\r\n                return [new HorizontalRange(pixelOffset, 0)];\r\n            }\r\n        }\r\n        else {\r\n            return this._readRawVisibleRangesForRange(domNode, startColumn, endColumn, context);\r\n        }\r\n    }\r\n    _readPixelOffset(domNode, column, context) {\r\n        if (this._characterMapping.length === 0) {\r\n            // This line has no content\r\n            if (this._containsForeignElements === 0 /* None */) {\r\n                // We can assume the line is really empty\r\n                return 0;\r\n            }\r\n            if (this._containsForeignElements === 2 /* After */) {\r\n                // We have foreign elements after the (empty) line\r\n                return 0;\r\n            }\r\n            if (this._containsForeignElements === 1 /* Before */) {\r\n                // We have foreign elements before the (empty) line\r\n                return this.getWidth();\r\n            }\r\n            // We have foreign elements before & after the (empty) line\r\n            const readingTarget = this._getReadingTarget(domNode);\r\n            if (readingTarget.firstChild) {\r\n                return readingTarget.firstChild.offsetWidth;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        }\r\n        if (this._pixelOffsetCache !== null) {\r\n            // the text is LTR\r\n            const cachedPixelOffset = this._pixelOffsetCache[column];\r\n            if (cachedPixelOffset !== -1) {\r\n                return cachedPixelOffset;\r\n            }\r\n            const result = this._actualReadPixelOffset(domNode, column, context);\r\n            this._pixelOffsetCache[column] = result;\r\n            return result;\r\n        }\r\n        return this._actualReadPixelOffset(domNode, column, context);\r\n    }\r\n    _actualReadPixelOffset(domNode, column, context) {\r\n        if (this._characterMapping.length === 0) {\r\n            // This line has no content\r\n            const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), 0, 0, 0, 0, context.clientRectDeltaLeft, context.endNode);\r\n            if (!r || r.length === 0) {\r\n                return -1;\r\n            }\r\n            return r[0].left;\r\n        }\r\n        if (column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0 /* None */) {\r\n            // This branch helps in the case of whitespace only lines which have a width set\r\n            return this.getWidth();\r\n        }\r\n        const partData = this._characterMapping.charOffsetToPartData(column - 1);\r\n        const partIndex = CharacterMapping.getPartIndex(partData);\r\n        const charOffsetInPart = CharacterMapping.getCharIndex(partData);\r\n        const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), partIndex, charOffsetInPart, partIndex, charOffsetInPart, context.clientRectDeltaLeft, context.endNode);\r\n        if (!r || r.length === 0) {\r\n            return -1;\r\n        }\r\n        const result = r[0].left;\r\n        if (this.input.isBasicASCII) {\r\n            const charOffset = this._characterMapping.getAbsoluteOffsets();\r\n            const expectedResult = Math.round(this.input.spaceWidth * charOffset[column - 1]);\r\n            if (Math.abs(expectedResult - result) <= 1) {\r\n                return expectedResult;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    _readRawVisibleRangesForRange(domNode, startColumn, endColumn, context) {\r\n        if (startColumn === 1 && endColumn === this._characterMapping.length) {\r\n            // This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line\r\n            return [new HorizontalRange(0, this.getWidth())];\r\n        }\r\n        const startPartData = this._characterMapping.charOffsetToPartData(startColumn - 1);\r\n        const startPartIndex = CharacterMapping.getPartIndex(startPartData);\r\n        const startCharOffsetInPart = CharacterMapping.getCharIndex(startPartData);\r\n        const endPartData = this._characterMapping.charOffsetToPartData(endColumn - 1);\r\n        const endPartIndex = CharacterMapping.getPartIndex(endPartData);\r\n        const endCharOffsetInPart = CharacterMapping.getCharIndex(endPartData);\r\n        return RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), startPartIndex, startCharOffsetInPart, endPartIndex, endCharOffsetInPart, context.clientRectDeltaLeft, context.endNode);\r\n    }\r\n    /**\r\n     * Returns the column for the text found at a specific offset inside a rendered dom node\r\n     */\r\n    getColumnOfNodeOffset(lineNumber, spanNode, offset) {\r\n        const spanNodeTextContentLength = spanNode.textContent.length;\r\n        let spanIndex = -1;\r\n        while (spanNode) {\r\n            spanNode = spanNode.previousSibling;\r\n            spanIndex++;\r\n        }\r\n        const charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);\r\n        return charOffset + 1;\r\n    }\r\n}\r\nclass WebKitRenderedViewLine extends RenderedViewLine {\r\n    _readVisibleRangesForRange(domNode, startColumn, endColumn, context) {\r\n        const output = super._readVisibleRangesForRange(domNode, startColumn, endColumn, context);\r\n        if (!output || output.length === 0 || startColumn === endColumn || (startColumn === 1 && endColumn === this._characterMapping.length)) {\r\n            return output;\r\n        }\r\n        // WebKit is buggy and returns an expanded range (to contain words in some cases)\r\n        // The last client rect is enlarged (I think)\r\n        if (!this.input.containsRTL) {\r\n            // This is an attempt to patch things up\r\n            // Find position of last column\r\n            const endPixelOffset = this._readPixelOffset(domNode, endColumn, context);\r\n            if (endPixelOffset !== -1) {\r\n                const lastRange = output[output.length - 1];\r\n                if (lastRange.left < endPixelOffset) {\r\n                    // Trim down the width of the last visible range to not go after the last column's position\r\n                    lastRange.width = endPixelOffset - lastRange.left;\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n}\r\nconst createRenderedLine = (function () {\r\n    if (browser.isWebKit) {\r\n        return createWebKitRenderedLine;\r\n    }\r\n    return createNormalRenderedLine;\r\n})();\r\nfunction createWebKitRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\r\n    return new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\r\n}\r\nfunction createNormalRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\r\n    return new RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}