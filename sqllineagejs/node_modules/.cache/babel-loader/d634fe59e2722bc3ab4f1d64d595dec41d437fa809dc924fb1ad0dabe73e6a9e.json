{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns, SingleCursorState } from './cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nexport class CursorPosition {\n  constructor(lineNumber, column, leftoverVisibleColumns) {\n    this.lineNumber = lineNumber;\n    this.column = column;\n    this.leftoverVisibleColumns = leftoverVisibleColumns;\n  }\n}\nexport class MoveOperations {\n  static leftPosition(model, lineNumber, column) {\n    if (column > model.getLineMinColumn(lineNumber)) {\n      column = column - strings.prevCharLength(model.getLineContent(lineNumber), column - 1);\n    } else if (lineNumber > 1) {\n      lineNumber = lineNumber - 1;\n      column = model.getLineMaxColumn(lineNumber);\n    }\n    return new Position(lineNumber, column);\n  }\n  static leftPositionAtomicSoftTabs(model, lineNumber, column, tabSize) {\n    const minColumn = model.getLineMinColumn(lineNumber);\n    const lineContent = model.getLineContent(lineNumber);\n    const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 0 /* Left */);\n    if (newPosition === -1 || newPosition + 1 < minColumn) {\n      return this.leftPosition(model, lineNumber, column);\n    }\n    return new Position(lineNumber, newPosition + 1);\n  }\n  static left(config, model, lineNumber, column) {\n    const pos = config.stickyTabStops ? MoveOperations.leftPositionAtomicSoftTabs(model, lineNumber, column, config.tabSize) : MoveOperations.leftPosition(model, lineNumber, column);\n    return new CursorPosition(pos.lineNumber, pos.column, 0);\n  }\n  static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n    let lineNumber, column;\n    if (cursor.hasSelection() && !inSelectionMode) {\n      // If we are in selection mode, move left without selection cancels selection and puts cursor at the beginning of the selection\n      lineNumber = cursor.selection.startLineNumber;\n      column = cursor.selection.startColumn;\n    } else {\n      let r = MoveOperations.left(config, model, cursor.position.lineNumber, cursor.position.column - (noOfColumns - 1));\n      lineNumber = r.lineNumber;\n      column = r.column;\n    }\n    return cursor.move(inSelectionMode, lineNumber, column, 0);\n  }\n  static rightPosition(model, lineNumber, column) {\n    if (column < model.getLineMaxColumn(lineNumber)) {\n      column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n    } else if (lineNumber < model.getLineCount()) {\n      lineNumber = lineNumber + 1;\n      column = model.getLineMinColumn(lineNumber);\n    }\n    return new Position(lineNumber, column);\n  }\n  static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n    const lineContent = model.getLineContent(lineNumber);\n    const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Right */);\n    if (newPosition === -1) {\n      return this.rightPosition(model, lineNumber, column);\n    }\n    return new Position(lineNumber, newPosition + 1);\n  }\n  static right(config, model, lineNumber, column) {\n    const pos = config.stickyTabStops ? MoveOperations.rightPositionAtomicSoftTabs(model, lineNumber, column, config.tabSize, config.indentSize) : MoveOperations.rightPosition(model, lineNumber, column);\n    return new CursorPosition(pos.lineNumber, pos.column, 0);\n  }\n  static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n    let lineNumber, column;\n    if (cursor.hasSelection() && !inSelectionMode) {\n      // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n      lineNumber = cursor.selection.endLineNumber;\n      column = cursor.selection.endColumn;\n    } else {\n      let r = MoveOperations.right(config, model, cursor.position.lineNumber, cursor.position.column + (noOfColumns - 1));\n      lineNumber = r.lineNumber;\n      column = r.column;\n    }\n    return cursor.move(inSelectionMode, lineNumber, column, 0);\n  }\n  static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n    const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n    const lineCount = model.getLineCount();\n    const wasOnLastPosition = lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber);\n    lineNumber = lineNumber + count;\n    if (lineNumber > lineCount) {\n      lineNumber = lineCount;\n      if (allowMoveOnLastLine) {\n        column = model.getLineMaxColumn(lineNumber);\n      } else {\n        column = Math.min(model.getLineMaxColumn(lineNumber), column);\n      }\n    } else {\n      column = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, currentVisibleColumn);\n    }\n    if (wasOnLastPosition) {\n      leftoverVisibleColumns = 0;\n    } else {\n      leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n    }\n    return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n  }\n  static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n    let lineNumber, column;\n    if (cursor.hasSelection() && !inSelectionMode) {\n      // If we are in selection mode, move down acts relative to the end of selection\n      lineNumber = cursor.selection.endLineNumber;\n      column = cursor.selection.endColumn;\n    } else {\n      lineNumber = cursor.position.lineNumber;\n      column = cursor.position.column;\n    }\n    let r = MoveOperations.down(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n    return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n  }\n  static translateDown(config, model, cursor) {\n    let selection = cursor.selection;\n    let selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n    let position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n    return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n  }\n  static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n    const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n    const wasOnFirstPosition = lineNumber === 1 && column === 1;\n    lineNumber = lineNumber - count;\n    if (lineNumber < 1) {\n      lineNumber = 1;\n      if (allowMoveOnFirstLine) {\n        column = model.getLineMinColumn(lineNumber);\n      } else {\n        column = Math.min(model.getLineMaxColumn(lineNumber), column);\n      }\n    } else {\n      column = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, currentVisibleColumn);\n    }\n    if (wasOnFirstPosition) {\n      leftoverVisibleColumns = 0;\n    } else {\n      leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n    }\n    return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n  }\n  static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n    let lineNumber, column;\n    if (cursor.hasSelection() && !inSelectionMode) {\n      // If we are in selection mode, move up acts relative to the beginning of selection\n      lineNumber = cursor.selection.startLineNumber;\n      column = cursor.selection.startColumn;\n    } else {\n      lineNumber = cursor.position.lineNumber;\n      column = cursor.position.column;\n    }\n    let r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n    return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n  }\n  static translateUp(config, model, cursor) {\n    let selection = cursor.selection;\n    let selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n    let position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n    return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n  }\n  static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n    let lineNumber = cursor.position.lineNumber;\n    let minColumn = model.getLineMinColumn(lineNumber);\n    let firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n    let column;\n    let relevantColumnNumber = cursor.position.column;\n    if (relevantColumnNumber === firstNonBlankColumn) {\n      column = minColumn;\n    } else {\n      column = firstNonBlankColumn;\n    }\n    return cursor.move(inSelectionMode, lineNumber, column, 0);\n  }\n  static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n    let lineNumber = cursor.position.lineNumber;\n    let maxColumn = model.getLineMaxColumn(lineNumber);\n    return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n  }\n  static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n    return cursor.move(inSelectionMode, 1, 1, 0);\n  }\n  static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n    let lastLineNumber = model.getLineCount();\n    let lastColumn = model.getLineMaxColumn(lastLineNumber);\n    return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n  }\n}","map":{"version":3,"names":["CursorColumns","SingleCursorState","Position","Range","strings","AtomicTabMoveOperations","CursorPosition","constructor","lineNumber","column","leftoverVisibleColumns","MoveOperations","leftPosition","model","getLineMinColumn","prevCharLength","getLineContent","getLineMaxColumn","leftPositionAtomicSoftTabs","tabSize","minColumn","lineContent","newPosition","atomicPosition","left","config","pos","stickyTabStops","moveLeft","cursor","inSelectionMode","noOfColumns","hasSelection","selection","startLineNumber","startColumn","r","position","move","rightPosition","nextCharLength","getLineCount","rightPositionAtomicSoftTabs","indentSize","right","moveRight","endLineNumber","endColumn","down","count","allowMoveOnLastLine","currentVisibleColumn","visibleColumnFromColumn","lineCount","wasOnLastPosition","Math","min","columnFromVisibleColumn2","moveDown","linesCount","translateDown","selectionStart","selectionStartLineNumber","selectionStartColumn","selectionStartLeftoverVisibleColumns","positionLineNumber","positionColumn","up","allowMoveOnFirstLine","wasOnFirstPosition","moveUp","translateUp","moveToBeginningOfLine","firstNonBlankColumn","getLineFirstNonWhitespaceColumn","relevantColumnNumber","moveToEndOfLine","sticky","maxColumn","moveToBeginningOfBuffer","moveToEndOfBuffer","lastLineNumber","lastColumn"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/controller/cursorMoveOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { CursorColumns, SingleCursorState } from './cursorCommon.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\r\nexport class CursorPosition {\r\n    constructor(lineNumber, column, leftoverVisibleColumns) {\r\n        this.lineNumber = lineNumber;\r\n        this.column = column;\r\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\r\n    }\r\n}\r\nexport class MoveOperations {\r\n    static leftPosition(model, lineNumber, column) {\r\n        if (column > model.getLineMinColumn(lineNumber)) {\r\n            column = column - strings.prevCharLength(model.getLineContent(lineNumber), column - 1);\r\n        }\r\n        else if (lineNumber > 1) {\r\n            lineNumber = lineNumber - 1;\r\n            column = model.getLineMaxColumn(lineNumber);\r\n        }\r\n        return new Position(lineNumber, column);\r\n    }\r\n    static leftPositionAtomicSoftTabs(model, lineNumber, column, tabSize) {\r\n        const minColumn = model.getLineMinColumn(lineNumber);\r\n        const lineContent = model.getLineContent(lineNumber);\r\n        const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 0 /* Left */);\r\n        if (newPosition === -1 || newPosition + 1 < minColumn) {\r\n            return this.leftPosition(model, lineNumber, column);\r\n        }\r\n        return new Position(lineNumber, newPosition + 1);\r\n    }\r\n    static left(config, model, lineNumber, column) {\r\n        const pos = config.stickyTabStops\r\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, lineNumber, column, config.tabSize)\r\n            : MoveOperations.leftPosition(model, lineNumber, column);\r\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\r\n    }\r\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\r\n        let lineNumber, column;\r\n        if (cursor.hasSelection() && !inSelectionMode) {\r\n            // If we are in selection mode, move left without selection cancels selection and puts cursor at the beginning of the selection\r\n            lineNumber = cursor.selection.startLineNumber;\r\n            column = cursor.selection.startColumn;\r\n        }\r\n        else {\r\n            let r = MoveOperations.left(config, model, cursor.position.lineNumber, cursor.position.column - (noOfColumns - 1));\r\n            lineNumber = r.lineNumber;\r\n            column = r.column;\r\n        }\r\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\r\n    }\r\n    static rightPosition(model, lineNumber, column) {\r\n        if (column < model.getLineMaxColumn(lineNumber)) {\r\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\r\n        }\r\n        else if (lineNumber < model.getLineCount()) {\r\n            lineNumber = lineNumber + 1;\r\n            column = model.getLineMinColumn(lineNumber);\r\n        }\r\n        return new Position(lineNumber, column);\r\n    }\r\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\r\n        const lineContent = model.getLineContent(lineNumber);\r\n        const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Right */);\r\n        if (newPosition === -1) {\r\n            return this.rightPosition(model, lineNumber, column);\r\n        }\r\n        return new Position(lineNumber, newPosition + 1);\r\n    }\r\n    static right(config, model, lineNumber, column) {\r\n        const pos = config.stickyTabStops\r\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, lineNumber, column, config.tabSize, config.indentSize)\r\n            : MoveOperations.rightPosition(model, lineNumber, column);\r\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\r\n    }\r\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\r\n        let lineNumber, column;\r\n        if (cursor.hasSelection() && !inSelectionMode) {\r\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\r\n            lineNumber = cursor.selection.endLineNumber;\r\n            column = cursor.selection.endColumn;\r\n        }\r\n        else {\r\n            let r = MoveOperations.right(config, model, cursor.position.lineNumber, cursor.position.column + (noOfColumns - 1));\r\n            lineNumber = r.lineNumber;\r\n            column = r.column;\r\n        }\r\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\r\n    }\r\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\r\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\r\n        const lineCount = model.getLineCount();\r\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\r\n        lineNumber = lineNumber + count;\r\n        if (lineNumber > lineCount) {\r\n            lineNumber = lineCount;\r\n            if (allowMoveOnLastLine) {\r\n                column = model.getLineMaxColumn(lineNumber);\r\n            }\r\n            else {\r\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\r\n            }\r\n        }\r\n        else {\r\n            column = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, currentVisibleColumn);\r\n        }\r\n        if (wasOnLastPosition) {\r\n            leftoverVisibleColumns = 0;\r\n        }\r\n        else {\r\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\r\n        }\r\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\r\n    }\r\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\r\n        let lineNumber, column;\r\n        if (cursor.hasSelection() && !inSelectionMode) {\r\n            // If we are in selection mode, move down acts relative to the end of selection\r\n            lineNumber = cursor.selection.endLineNumber;\r\n            column = cursor.selection.endColumn;\r\n        }\r\n        else {\r\n            lineNumber = cursor.position.lineNumber;\r\n            column = cursor.position.column;\r\n        }\r\n        let r = MoveOperations.down(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\r\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\r\n    }\r\n    static translateDown(config, model, cursor) {\r\n        let selection = cursor.selection;\r\n        let selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\r\n        let position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\r\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\r\n    }\r\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\r\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\r\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\r\n        lineNumber = lineNumber - count;\r\n        if (lineNumber < 1) {\r\n            lineNumber = 1;\r\n            if (allowMoveOnFirstLine) {\r\n                column = model.getLineMinColumn(lineNumber);\r\n            }\r\n            else {\r\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\r\n            }\r\n        }\r\n        else {\r\n            column = CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, currentVisibleColumn);\r\n        }\r\n        if (wasOnFirstPosition) {\r\n            leftoverVisibleColumns = 0;\r\n        }\r\n        else {\r\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\r\n        }\r\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\r\n    }\r\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\r\n        let lineNumber, column;\r\n        if (cursor.hasSelection() && !inSelectionMode) {\r\n            // If we are in selection mode, move up acts relative to the beginning of selection\r\n            lineNumber = cursor.selection.startLineNumber;\r\n            column = cursor.selection.startColumn;\r\n        }\r\n        else {\r\n            lineNumber = cursor.position.lineNumber;\r\n            column = cursor.position.column;\r\n        }\r\n        let r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\r\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\r\n    }\r\n    static translateUp(config, model, cursor) {\r\n        let selection = cursor.selection;\r\n        let selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\r\n        let position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\r\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\r\n    }\r\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\r\n        let lineNumber = cursor.position.lineNumber;\r\n        let minColumn = model.getLineMinColumn(lineNumber);\r\n        let firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\r\n        let column;\r\n        let relevantColumnNumber = cursor.position.column;\r\n        if (relevantColumnNumber === firstNonBlankColumn) {\r\n            column = minColumn;\r\n        }\r\n        else {\r\n            column = firstNonBlankColumn;\r\n        }\r\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\r\n    }\r\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\r\n        let lineNumber = cursor.position.lineNumber;\r\n        let maxColumn = model.getLineMaxColumn(lineNumber);\r\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\r\n    }\r\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\r\n        return cursor.move(inSelectionMode, 1, 1, 0);\r\n    }\r\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\r\n        let lastLineNumber = model.getLineCount();\r\n        let lastColumn = model.getLineMaxColumn(lastLineNumber);\r\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}