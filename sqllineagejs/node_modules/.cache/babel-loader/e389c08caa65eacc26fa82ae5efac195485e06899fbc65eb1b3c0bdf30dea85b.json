{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { fuzzyScore, fuzzyScoreGracefulAggressive, FuzzyScore, anyScore } from '../../../base/common/filters.js';\nimport { compareIgnoreCase } from '../../../base/common/strings.js';\nimport { quickSelect } from '../../../base/common/arrays.js';\nexport class LineContext {\n  constructor(leadingLineContent, characterCountDelta) {\n    this.leadingLineContent = leadingLineContent;\n    this.characterCountDelta = characterCountDelta;\n  }\n}\n/**\r\n * Sorted, filtered completion view model\r\n * */\nexport class CompletionModel {\n  constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, clipboardText) {\n    this.clipboardText = clipboardText;\n    this._snippetCompareFn = CompletionModel._compareCompletionItems;\n    this._items = items;\n    this._column = column;\n    this._wordDistance = wordDistance;\n    this._options = options;\n    this._refilterKind = 1 /* All */;\n    this._lineContext = lineContext;\n    if (snippetSuggestions === 'top') {\n      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\n    } else if (snippetSuggestions === 'bottom') {\n      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\n    }\n  }\n  get lineContext() {\n    return this._lineContext;\n  }\n  set lineContext(value) {\n    if (this._lineContext.leadingLineContent !== value.leadingLineContent || this._lineContext.characterCountDelta !== value.characterCountDelta) {\n      this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 /* Incr */ : 1 /* All */;\n      this._lineContext = value;\n    }\n  }\n  get items() {\n    this._ensureCachedState();\n    return this._filteredItems;\n  }\n  get allProvider() {\n    this._ensureCachedState();\n    return this._providerInfo.keys();\n  }\n  get incomplete() {\n    this._ensureCachedState();\n    const result = new Set();\n    for (let [provider, incomplete] of this._providerInfo) {\n      if (incomplete) {\n        result.add(provider);\n      }\n    }\n    return result;\n  }\n  adopt(except) {\n    let res = [];\n    for (let i = 0; i < this._items.length;) {\n      if (!except.has(this._items[i].provider)) {\n        res.push(this._items[i]);\n        // unordered removed\n        this._items[i] = this._items[this._items.length - 1];\n        this._items.pop();\n      } else {\n        // continue with next item\n        i++;\n      }\n    }\n    this._refilterKind = 1 /* All */;\n    return res;\n  }\n  get stats() {\n    this._ensureCachedState();\n    return this._stats;\n  }\n  _ensureCachedState() {\n    if (this._refilterKind !== 0 /* Nothing */) {\n      this._createCachedState();\n    }\n  }\n  _createCachedState() {\n    this._providerInfo = new Map();\n    const labelLengths = [];\n    const {\n      leadingLineContent,\n      characterCountDelta\n    } = this._lineContext;\n    let word = '';\n    let wordLow = '';\n    // incrementally filter less\n    const source = this._refilterKind === 1 /* All */ ? this._items : this._filteredItems;\n    const target = [];\n    // picks a score function based on the number of\n    // items that we have to score/filter and based on the\n    // user-configuration\n    const scoreFn = !this._options.filterGraceful || source.length > 2000 ? fuzzyScore : fuzzyScoreGracefulAggressive;\n    for (let i = 0; i < source.length; i++) {\n      const item = source[i];\n      if (item.isInvalid) {\n        continue; // SKIP invalid items\n      }\n      // collect all support, know if their result is incomplete\n      this._providerInfo.set(item.provider, Boolean(item.container.incomplete));\n      // 'word' is that remainder of the current line that we\n      // filter and score against. In theory each suggestion uses a\n      // different word, but in practice not - that's why we cache\n      const overwriteBefore = item.position.column - item.editStart.column;\n      const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\n      if (word.length !== wordLen) {\n        word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n        wordLow = word.toLowerCase();\n      }\n      const textLabel = typeof item.completion.label === 'string' ? item.completion.label : item.completion.label.name;\n      // remember the word against which this item was\n      // scored\n      item.word = word;\n      if (wordLen === 0) {\n        // when there is nothing to score against, don't\n        // event try to do. Use a const rank and rely on\n        // the fallback-sort using the initial sort order.\n        // use a score of `-100` because that is out of the\n        // bound of values `fuzzyScore` will return\n        item.score = FuzzyScore.Default;\n      } else {\n        // skip word characters that are whitespace until\n        // we have hit the replace range (overwriteBefore)\n        let wordPos = 0;\n        while (wordPos < overwriteBefore) {\n          const ch = word.charCodeAt(wordPos);\n          if (ch === 32 /* Space */ || ch === 9 /* Tab */) {\n            wordPos += 1;\n          } else {\n            break;\n          }\n        }\n        if (wordPos >= wordLen) {\n          // the wordPos at which scoring starts is the whole word\n          // and therefore the same rules as not having a word apply\n          item.score = FuzzyScore.Default;\n        } else if (typeof item.completion.filterText === 'string') {\n          // when there is a `filterText` it must match the `word`.\n          // if it matches we check with the label to compute highlights\n          // and if that doesn't yield a result we have no highlights,\n          // despite having the match\n          let match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, false);\n          if (!match) {\n            continue; // NO match\n          }\n\n          if (compareIgnoreCase(item.completion.filterText, textLabel) === 0) {\n            // filterText and label are actually the same -> use good highlights\n            item.score = match;\n          } else {\n            // re-run the scorer on the label in the hope of a result BUT use the rank\n            // of the filterText-match\n            item.score = anyScore(word, wordLow, wordPos, textLabel, item.labelLow, 0);\n            item.score[0] = match[0]; // use score from filterText\n          }\n        } else {\n          // by default match `word` against the `label`\n          let match = scoreFn(word, wordLow, wordPos, textLabel, item.labelLow, 0, false);\n          if (!match) {\n            continue; // NO match\n          }\n\n          item.score = match;\n        }\n      }\n      item.idx = i;\n      item.distance = this._wordDistance.distance(item.position, item.completion);\n      target.push(item);\n      // update stats\n      labelLengths.push(textLabel.length);\n    }\n    this._filteredItems = target.sort(this._snippetCompareFn);\n    this._refilterKind = 0 /* Nothing */;\n    this._stats = {\n      pLabelLen: labelLengths.length ? quickSelect(labelLengths.length - .85, labelLengths, (a, b) => a - b) : 0\n    };\n  }\n  static _compareCompletionItems(a, b) {\n    if (a.score[0] > b.score[0]) {\n      return -1;\n    } else if (a.score[0] < b.score[0]) {\n      return 1;\n    } else if (a.distance < b.distance) {\n      return -1;\n    } else if (a.distance > b.distance) {\n      return 1;\n    } else if (a.idx < b.idx) {\n      return -1;\n    } else if (a.idx > b.idx) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  static _compareCompletionItemsSnippetsDown(a, b) {\n    if (a.completion.kind !== b.completion.kind) {\n      if (a.completion.kind === 27 /* Snippet */) {\n        return 1;\n      } else if (b.completion.kind === 27 /* Snippet */) {\n        return -1;\n      }\n    }\n    return CompletionModel._compareCompletionItems(a, b);\n  }\n  static _compareCompletionItemsSnippetsUp(a, b) {\n    if (a.completion.kind !== b.completion.kind) {\n      if (a.completion.kind === 27 /* Snippet */) {\n        return -1;\n      } else if (b.completion.kind === 27 /* Snippet */) {\n        return 1;\n      }\n    }\n    return CompletionModel._compareCompletionItems(a, b);\n  }\n}","map":{"version":3,"names":["fuzzyScore","fuzzyScoreGracefulAggressive","FuzzyScore","anyScore","compareIgnoreCase","quickSelect","LineContext","constructor","leadingLineContent","characterCountDelta","CompletionModel","items","column","lineContext","wordDistance","options","snippetSuggestions","clipboardText","_snippetCompareFn","_compareCompletionItems","_items","_column","_wordDistance","_options","_refilterKind","_lineContext","_compareCompletionItemsSnippetsUp","_compareCompletionItemsSnippetsDown","value","_filteredItems","_ensureCachedState","allProvider","_providerInfo","keys","incomplete","result","Set","provider","add","adopt","except","res","i","length","has","push","pop","stats","_stats","_createCachedState","Map","labelLengths","word","wordLow","source","target","scoreFn","filterGraceful","item","isInvalid","set","Boolean","container","overwriteBefore","position","editStart","wordLen","slice","toLowerCase","textLabel","completion","label","name","score","Default","wordPos","ch","charCodeAt","filterText","match","filterTextLow","labelLow","idx","distance","sort","pLabelLen","a","b","kind"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/suggest/completionModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { fuzzyScore, fuzzyScoreGracefulAggressive, FuzzyScore, anyScore } from '../../../base/common/filters.js';\r\nimport { compareIgnoreCase } from '../../../base/common/strings.js';\r\nimport { quickSelect } from '../../../base/common/arrays.js';\r\nexport class LineContext {\r\n    constructor(leadingLineContent, characterCountDelta) {\r\n        this.leadingLineContent = leadingLineContent;\r\n        this.characterCountDelta = characterCountDelta;\r\n    }\r\n}\r\n/**\r\n * Sorted, filtered completion view model\r\n * */\r\nexport class CompletionModel {\r\n    constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, clipboardText) {\r\n        this.clipboardText = clipboardText;\r\n        this._snippetCompareFn = CompletionModel._compareCompletionItems;\r\n        this._items = items;\r\n        this._column = column;\r\n        this._wordDistance = wordDistance;\r\n        this._options = options;\r\n        this._refilterKind = 1 /* All */;\r\n        this._lineContext = lineContext;\r\n        if (snippetSuggestions === 'top') {\r\n            this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\r\n        }\r\n        else if (snippetSuggestions === 'bottom') {\r\n            this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\r\n        }\r\n    }\r\n    get lineContext() {\r\n        return this._lineContext;\r\n    }\r\n    set lineContext(value) {\r\n        if (this._lineContext.leadingLineContent !== value.leadingLineContent\r\n            || this._lineContext.characterCountDelta !== value.characterCountDelta) {\r\n            this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 /* Incr */ : 1 /* All */;\r\n            this._lineContext = value;\r\n        }\r\n    }\r\n    get items() {\r\n        this._ensureCachedState();\r\n        return this._filteredItems;\r\n    }\r\n    get allProvider() {\r\n        this._ensureCachedState();\r\n        return this._providerInfo.keys();\r\n    }\r\n    get incomplete() {\r\n        this._ensureCachedState();\r\n        const result = new Set();\r\n        for (let [provider, incomplete] of this._providerInfo) {\r\n            if (incomplete) {\r\n                result.add(provider);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    adopt(except) {\r\n        let res = [];\r\n        for (let i = 0; i < this._items.length;) {\r\n            if (!except.has(this._items[i].provider)) {\r\n                res.push(this._items[i]);\r\n                // unordered removed\r\n                this._items[i] = this._items[this._items.length - 1];\r\n                this._items.pop();\r\n            }\r\n            else {\r\n                // continue with next item\r\n                i++;\r\n            }\r\n        }\r\n        this._refilterKind = 1 /* All */;\r\n        return res;\r\n    }\r\n    get stats() {\r\n        this._ensureCachedState();\r\n        return this._stats;\r\n    }\r\n    _ensureCachedState() {\r\n        if (this._refilterKind !== 0 /* Nothing */) {\r\n            this._createCachedState();\r\n        }\r\n    }\r\n    _createCachedState() {\r\n        this._providerInfo = new Map();\r\n        const labelLengths = [];\r\n        const { leadingLineContent, characterCountDelta } = this._lineContext;\r\n        let word = '';\r\n        let wordLow = '';\r\n        // incrementally filter less\r\n        const source = this._refilterKind === 1 /* All */ ? this._items : this._filteredItems;\r\n        const target = [];\r\n        // picks a score function based on the number of\r\n        // items that we have to score/filter and based on the\r\n        // user-configuration\r\n        const scoreFn = (!this._options.filterGraceful || source.length > 2000) ? fuzzyScore : fuzzyScoreGracefulAggressive;\r\n        for (let i = 0; i < source.length; i++) {\r\n            const item = source[i];\r\n            if (item.isInvalid) {\r\n                continue; // SKIP invalid items\r\n            }\r\n            // collect all support, know if their result is incomplete\r\n            this._providerInfo.set(item.provider, Boolean(item.container.incomplete));\r\n            // 'word' is that remainder of the current line that we\r\n            // filter and score against. In theory each suggestion uses a\r\n            // different word, but in practice not - that's why we cache\r\n            const overwriteBefore = item.position.column - item.editStart.column;\r\n            const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\r\n            if (word.length !== wordLen) {\r\n                word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\r\n                wordLow = word.toLowerCase();\r\n            }\r\n            const textLabel = typeof item.completion.label === 'string' ? item.completion.label : item.completion.label.name;\r\n            // remember the word against which this item was\r\n            // scored\r\n            item.word = word;\r\n            if (wordLen === 0) {\r\n                // when there is nothing to score against, don't\r\n                // event try to do. Use a const rank and rely on\r\n                // the fallback-sort using the initial sort order.\r\n                // use a score of `-100` because that is out of the\r\n                // bound of values `fuzzyScore` will return\r\n                item.score = FuzzyScore.Default;\r\n            }\r\n            else {\r\n                // skip word characters that are whitespace until\r\n                // we have hit the replace range (overwriteBefore)\r\n                let wordPos = 0;\r\n                while (wordPos < overwriteBefore) {\r\n                    const ch = word.charCodeAt(wordPos);\r\n                    if (ch === 32 /* Space */ || ch === 9 /* Tab */) {\r\n                        wordPos += 1;\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                if (wordPos >= wordLen) {\r\n                    // the wordPos at which scoring starts is the whole word\r\n                    // and therefore the same rules as not having a word apply\r\n                    item.score = FuzzyScore.Default;\r\n                }\r\n                else if (typeof item.completion.filterText === 'string') {\r\n                    // when there is a `filterText` it must match the `word`.\r\n                    // if it matches we check with the label to compute highlights\r\n                    // and if that doesn't yield a result we have no highlights,\r\n                    // despite having the match\r\n                    let match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, false);\r\n                    if (!match) {\r\n                        continue; // NO match\r\n                    }\r\n                    if (compareIgnoreCase(item.completion.filterText, textLabel) === 0) {\r\n                        // filterText and label are actually the same -> use good highlights\r\n                        item.score = match;\r\n                    }\r\n                    else {\r\n                        // re-run the scorer on the label in the hope of a result BUT use the rank\r\n                        // of the filterText-match\r\n                        item.score = anyScore(word, wordLow, wordPos, textLabel, item.labelLow, 0);\r\n                        item.score[0] = match[0]; // use score from filterText\r\n                    }\r\n                }\r\n                else {\r\n                    // by default match `word` against the `label`\r\n                    let match = scoreFn(word, wordLow, wordPos, textLabel, item.labelLow, 0, false);\r\n                    if (!match) {\r\n                        continue; // NO match\r\n                    }\r\n                    item.score = match;\r\n                }\r\n            }\r\n            item.idx = i;\r\n            item.distance = this._wordDistance.distance(item.position, item.completion);\r\n            target.push(item);\r\n            // update stats\r\n            labelLengths.push(textLabel.length);\r\n        }\r\n        this._filteredItems = target.sort(this._snippetCompareFn);\r\n        this._refilterKind = 0 /* Nothing */;\r\n        this._stats = {\r\n            pLabelLen: labelLengths.length ?\r\n                quickSelect(labelLengths.length - .85, labelLengths, (a, b) => a - b)\r\n                : 0\r\n        };\r\n    }\r\n    static _compareCompletionItems(a, b) {\r\n        if (a.score[0] > b.score[0]) {\r\n            return -1;\r\n        }\r\n        else if (a.score[0] < b.score[0]) {\r\n            return 1;\r\n        }\r\n        else if (a.distance < b.distance) {\r\n            return -1;\r\n        }\r\n        else if (a.distance > b.distance) {\r\n            return 1;\r\n        }\r\n        else if (a.idx < b.idx) {\r\n            return -1;\r\n        }\r\n        else if (a.idx > b.idx) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    static _compareCompletionItemsSnippetsDown(a, b) {\r\n        if (a.completion.kind !== b.completion.kind) {\r\n            if (a.completion.kind === 27 /* Snippet */) {\r\n                return 1;\r\n            }\r\n            else if (b.completion.kind === 27 /* Snippet */) {\r\n                return -1;\r\n            }\r\n        }\r\n        return CompletionModel._compareCompletionItems(a, b);\r\n    }\r\n    static _compareCompletionItemsSnippetsUp(a, b) {\r\n        if (a.completion.kind !== b.completion.kind) {\r\n            if (a.completion.kind === 27 /* Snippet */) {\r\n                return -1;\r\n            }\r\n            else if (b.completion.kind === 27 /* Snippet */) {\r\n                return 1;\r\n            }\r\n        }\r\n        return CompletionModel._compareCompletionItems(a, b);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}