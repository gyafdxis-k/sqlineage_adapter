{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { DisposableStore, Disposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { timeout } from '../../../base/common/async.js';\nexport var TriggerAction;\n(function (TriggerAction) {\n  /**\r\n   * Do nothing after the button was clicked.\r\n   */\n  TriggerAction[TriggerAction[\"NO_ACTION\"] = 0] = \"NO_ACTION\";\n  /**\r\n   * Close the picker.\r\n   */\n  TriggerAction[TriggerAction[\"CLOSE_PICKER\"] = 1] = \"CLOSE_PICKER\";\n  /**\r\n   * Update the results of the picker.\r\n   */\n  TriggerAction[TriggerAction[\"REFRESH_PICKER\"] = 2] = \"REFRESH_PICKER\";\n  /**\r\n   * Remove the item from the picker.\r\n   */\n  TriggerAction[TriggerAction[\"REMOVE_ITEM\"] = 3] = \"REMOVE_ITEM\";\n})(TriggerAction || (TriggerAction = {}));\nfunction isPicksWithActive(obj) {\n  const candidate = obj;\n  return Array.isArray(candidate.items);\n}\nfunction isFastAndSlowPicks(obj) {\n  const candidate = obj;\n  return !!candidate.picks && candidate.additionalPicks instanceof Promise;\n}\nexport class PickerQuickAccessProvider extends Disposable {\n  constructor(prefix, options) {\n    super();\n    this.prefix = prefix;\n    this.options = options;\n  }\n  provide(picker, token) {\n    var _a;\n    const disposables = new DisposableStore();\n    // Apply options if any\n    picker.canAcceptInBackground = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.canAcceptInBackground);\n    // Disable filtering & sorting, we control the results\n    picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;\n    // Set initial picks and update on type\n    let picksCts = undefined;\n    const picksDisposable = disposables.add(new MutableDisposable());\n    const updatePickerItems = () => __awaiter(this, void 0, void 0, function* () {\n      const picksDisposables = picksDisposable.value = new DisposableStore();\n      // Cancel any previous ask for picks and busy\n      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\n      picker.busy = false;\n      // Create new cancellation source for this run\n      picksCts = new CancellationTokenSource(token);\n      // Collect picks and support both long running and short or combined\n      const picksToken = picksCts.token;\n      const picksFilter = picker.value.substr(this.prefix.length).trim();\n      const providedPicks = this.getPicks(picksFilter, picksDisposables, picksToken);\n      const applyPicks = (picks, skipEmpty) => {\n        var _a;\n        let items;\n        let activeItem = undefined;\n        if (isPicksWithActive(picks)) {\n          items = picks.items;\n          activeItem = picks.active;\n        } else {\n          items = picks;\n        }\n        if (items.length === 0) {\n          if (skipEmpty) {\n            return false;\n          }\n          if (picksFilter.length > 0 && ((_a = this.options) === null || _a === void 0 ? void 0 : _a.noResultsPick)) {\n            items = [this.options.noResultsPick];\n          }\n        }\n        picker.items = items;\n        if (activeItem) {\n          picker.activeItems = [activeItem];\n        }\n        return true;\n      };\n      // No Picks\n      if (providedPicks === null) {\n        // Ignore\n      }\n      // Fast and Slow Picks\n      else if (isFastAndSlowPicks(providedPicks)) {\n        let fastPicksApplied = false;\n        let slowPicksApplied = false;\n        yield Promise.all([\n        // Fast Picks: to reduce amount of flicker, we race against\n        // the slow picks over 500ms and then set the fast picks.\n        // If the slow picks are faster, we reduce the flicker by\n        // only setting the items once.\n        (() => __awaiter(this, void 0, void 0, function* () {\n          yield timeout(PickerQuickAccessProvider.FAST_PICKS_RACE_DELAY);\n          if (picksToken.isCancellationRequested) {\n            return;\n          }\n          if (!slowPicksApplied) {\n            fastPicksApplied = applyPicks(providedPicks.picks, true /* skip over empty to reduce flicker */);\n          }\n        }))(),\n        // Slow Picks: we await the slow picks and then set them at\n        // once together with the fast picks, but only if we actually\n        // have additional results.\n        (() => __awaiter(this, void 0, void 0, function* () {\n          picker.busy = true;\n          try {\n            const awaitedAdditionalPicks = yield providedPicks.additionalPicks;\n            if (picksToken.isCancellationRequested) {\n              return;\n            }\n            let picks;\n            let activePick = undefined;\n            if (isPicksWithActive(providedPicks.picks)) {\n              picks = providedPicks.picks.items;\n              activePick = providedPicks.picks.active;\n            } else {\n              picks = providedPicks.picks;\n            }\n            let additionalPicks;\n            let additionalActivePick = undefined;\n            if (isPicksWithActive(awaitedAdditionalPicks)) {\n              additionalPicks = awaitedAdditionalPicks.items;\n              additionalActivePick = awaitedAdditionalPicks.active;\n            } else {\n              additionalPicks = awaitedAdditionalPicks;\n            }\n            if (additionalPicks.length > 0 || !fastPicksApplied) {\n              // If we do not have any activePick or additionalActivePick\n              // we try to preserve the currently active pick from the\n              // fast results. This fixes an issue where the user might\n              // have made a pick active before the additional results\n              // kick in.\n              // See https://github.com/microsoft/vscode/issues/102480\n              let fallbackActivePick = undefined;\n              if (!activePick && !additionalActivePick) {\n                const fallbackActivePickCandidate = picker.activeItems[0];\n                if (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {\n                  fallbackActivePick = fallbackActivePickCandidate;\n                }\n              }\n              applyPicks({\n                items: [...picks, ...additionalPicks],\n                active: activePick || additionalActivePick || fallbackActivePick\n              });\n            }\n          } finally {\n            if (!picksToken.isCancellationRequested) {\n              picker.busy = false;\n            }\n            slowPicksApplied = true;\n          }\n        }))()]);\n      }\n      // Fast Picks\n      else if (!(providedPicks instanceof Promise)) {\n        applyPicks(providedPicks);\n      }\n      // Slow Picks\n      else {\n        picker.busy = true;\n        try {\n          const awaitedPicks = yield providedPicks;\n          if (picksToken.isCancellationRequested) {\n            return;\n          }\n          applyPicks(awaitedPicks);\n        } finally {\n          if (!picksToken.isCancellationRequested) {\n            picker.busy = false;\n          }\n        }\n      }\n    });\n    disposables.add(picker.onDidChangeValue(() => updatePickerItems()));\n    updatePickerItems();\n    // Accept the pick on accept and hide picker\n    disposables.add(picker.onDidAccept(event => {\n      const [item] = picker.selectedItems;\n      if (typeof (item === null || item === void 0 ? void 0 : item.accept) === 'function') {\n        if (!event.inBackground) {\n          picker.hide(); // hide picker unless we accept in background\n        }\n\n        item.accept(picker.keyMods, event);\n      }\n    }));\n    // Trigger the pick with button index if button triggered\n    disposables.add(picker.onDidTriggerItemButton(_ref => {\n      let {\n        button,\n        item\n      } = _ref;\n      return __awaiter(this, void 0, void 0, function* () {\n        var _b, _c;\n        if (typeof item.trigger === 'function') {\n          const buttonIndex = (_c = (_b = item.buttons) === null || _b === void 0 ? void 0 : _b.indexOf(button)) !== null && _c !== void 0 ? _c : -1;\n          if (buttonIndex >= 0) {\n            const result = item.trigger(buttonIndex, picker.keyMods);\n            const action = typeof result === 'number' ? result : yield result;\n            if (token.isCancellationRequested) {\n              return;\n            }\n            switch (action) {\n              case TriggerAction.NO_ACTION:\n                break;\n              case TriggerAction.CLOSE_PICKER:\n                picker.hide();\n                break;\n              case TriggerAction.REFRESH_PICKER:\n                updatePickerItems();\n                break;\n              case TriggerAction.REMOVE_ITEM:\n                const index = picker.items.indexOf(item);\n                if (index !== -1) {\n                  const items = picker.items.slice();\n                  items.splice(index, 1);\n                  picker.items = items;\n                }\n                break;\n            }\n          }\n        }\n      });\n    }));\n    return disposables;\n  }\n}\nPickerQuickAccessProvider.FAST_PICKS_RACE_DELAY = 200; // timeout before we accept fast results before slow results are present","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","CancellationTokenSource","DisposableStore","Disposable","MutableDisposable","timeout","TriggerAction","isPicksWithActive","obj","candidate","Array","isArray","items","isFastAndSlowPicks","picks","additionalPicks","PickerQuickAccessProvider","constructor","prefix","options","provide","picker","token","_a","disposables","canAcceptInBackground","matchOnLabel","matchOnDescription","matchOnDetail","sortByLabel","picksCts","undefined","picksDisposable","add","updatePickerItems","picksDisposables","dispose","busy","picksToken","picksFilter","substr","length","trim","providedPicks","getPicks","applyPicks","skipEmpty","activeItem","active","noResultsPick","activeItems","fastPicksApplied","slowPicksApplied","all","FAST_PICKS_RACE_DELAY","isCancellationRequested","awaitedAdditionalPicks","activePick","additionalActivePick","fallbackActivePick","fallbackActivePickCandidate","indexOf","awaitedPicks","onDidChangeValue","onDidAccept","event","item","selectedItems","accept","inBackground","hide","keyMods","onDidTriggerItemButton","_ref","button","_b","_c","trigger","buttonIndex","buttons","action","NO_ACTION","CLOSE_PICKER","REFRESH_PICKER","REMOVE_ITEM","index","slice","splice"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { CancellationTokenSource } from '../../../base/common/cancellation.js';\r\nimport { DisposableStore, Disposable, MutableDisposable } from '../../../base/common/lifecycle.js';\r\nimport { timeout } from '../../../base/common/async.js';\r\nexport var TriggerAction;\r\n(function (TriggerAction) {\r\n    /**\r\n     * Do nothing after the button was clicked.\r\n     */\r\n    TriggerAction[TriggerAction[\"NO_ACTION\"] = 0] = \"NO_ACTION\";\r\n    /**\r\n     * Close the picker.\r\n     */\r\n    TriggerAction[TriggerAction[\"CLOSE_PICKER\"] = 1] = \"CLOSE_PICKER\";\r\n    /**\r\n     * Update the results of the picker.\r\n     */\r\n    TriggerAction[TriggerAction[\"REFRESH_PICKER\"] = 2] = \"REFRESH_PICKER\";\r\n    /**\r\n     * Remove the item from the picker.\r\n     */\r\n    TriggerAction[TriggerAction[\"REMOVE_ITEM\"] = 3] = \"REMOVE_ITEM\";\r\n})(TriggerAction || (TriggerAction = {}));\r\nfunction isPicksWithActive(obj) {\r\n    const candidate = obj;\r\n    return Array.isArray(candidate.items);\r\n}\r\nfunction isFastAndSlowPicks(obj) {\r\n    const candidate = obj;\r\n    return !!candidate.picks && candidate.additionalPicks instanceof Promise;\r\n}\r\nexport class PickerQuickAccessProvider extends Disposable {\r\n    constructor(prefix, options) {\r\n        super();\r\n        this.prefix = prefix;\r\n        this.options = options;\r\n    }\r\n    provide(picker, token) {\r\n        var _a;\r\n        const disposables = new DisposableStore();\r\n        // Apply options if any\r\n        picker.canAcceptInBackground = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.canAcceptInBackground);\r\n        // Disable filtering & sorting, we control the results\r\n        picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;\r\n        // Set initial picks and update on type\r\n        let picksCts = undefined;\r\n        const picksDisposable = disposables.add(new MutableDisposable());\r\n        const updatePickerItems = () => __awaiter(this, void 0, void 0, function* () {\r\n            const picksDisposables = picksDisposable.value = new DisposableStore();\r\n            // Cancel any previous ask for picks and busy\r\n            picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);\r\n            picker.busy = false;\r\n            // Create new cancellation source for this run\r\n            picksCts = new CancellationTokenSource(token);\r\n            // Collect picks and support both long running and short or combined\r\n            const picksToken = picksCts.token;\r\n            const picksFilter = picker.value.substr(this.prefix.length).trim();\r\n            const providedPicks = this.getPicks(picksFilter, picksDisposables, picksToken);\r\n            const applyPicks = (picks, skipEmpty) => {\r\n                var _a;\r\n                let items;\r\n                let activeItem = undefined;\r\n                if (isPicksWithActive(picks)) {\r\n                    items = picks.items;\r\n                    activeItem = picks.active;\r\n                }\r\n                else {\r\n                    items = picks;\r\n                }\r\n                if (items.length === 0) {\r\n                    if (skipEmpty) {\r\n                        return false;\r\n                    }\r\n                    if (picksFilter.length > 0 && ((_a = this.options) === null || _a === void 0 ? void 0 : _a.noResultsPick)) {\r\n                        items = [this.options.noResultsPick];\r\n                    }\r\n                }\r\n                picker.items = items;\r\n                if (activeItem) {\r\n                    picker.activeItems = [activeItem];\r\n                }\r\n                return true;\r\n            };\r\n            // No Picks\r\n            if (providedPicks === null) {\r\n                // Ignore\r\n            }\r\n            // Fast and Slow Picks\r\n            else if (isFastAndSlowPicks(providedPicks)) {\r\n                let fastPicksApplied = false;\r\n                let slowPicksApplied = false;\r\n                yield Promise.all([\r\n                    // Fast Picks: to reduce amount of flicker, we race against\r\n                    // the slow picks over 500ms and then set the fast picks.\r\n                    // If the slow picks are faster, we reduce the flicker by\r\n                    // only setting the items once.\r\n                    (() => __awaiter(this, void 0, void 0, function* () {\r\n                        yield timeout(PickerQuickAccessProvider.FAST_PICKS_RACE_DELAY);\r\n                        if (picksToken.isCancellationRequested) {\r\n                            return;\r\n                        }\r\n                        if (!slowPicksApplied) {\r\n                            fastPicksApplied = applyPicks(providedPicks.picks, true /* skip over empty to reduce flicker */);\r\n                        }\r\n                    }))(),\r\n                    // Slow Picks: we await the slow picks and then set them at\r\n                    // once together with the fast picks, but only if we actually\r\n                    // have additional results.\r\n                    (() => __awaiter(this, void 0, void 0, function* () {\r\n                        picker.busy = true;\r\n                        try {\r\n                            const awaitedAdditionalPicks = yield providedPicks.additionalPicks;\r\n                            if (picksToken.isCancellationRequested) {\r\n                                return;\r\n                            }\r\n                            let picks;\r\n                            let activePick = undefined;\r\n                            if (isPicksWithActive(providedPicks.picks)) {\r\n                                picks = providedPicks.picks.items;\r\n                                activePick = providedPicks.picks.active;\r\n                            }\r\n                            else {\r\n                                picks = providedPicks.picks;\r\n                            }\r\n                            let additionalPicks;\r\n                            let additionalActivePick = undefined;\r\n                            if (isPicksWithActive(awaitedAdditionalPicks)) {\r\n                                additionalPicks = awaitedAdditionalPicks.items;\r\n                                additionalActivePick = awaitedAdditionalPicks.active;\r\n                            }\r\n                            else {\r\n                                additionalPicks = awaitedAdditionalPicks;\r\n                            }\r\n                            if (additionalPicks.length > 0 || !fastPicksApplied) {\r\n                                // If we do not have any activePick or additionalActivePick\r\n                                // we try to preserve the currently active pick from the\r\n                                // fast results. This fixes an issue where the user might\r\n                                // have made a pick active before the additional results\r\n                                // kick in.\r\n                                // See https://github.com/microsoft/vscode/issues/102480\r\n                                let fallbackActivePick = undefined;\r\n                                if (!activePick && !additionalActivePick) {\r\n                                    const fallbackActivePickCandidate = picker.activeItems[0];\r\n                                    if (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {\r\n                                        fallbackActivePick = fallbackActivePickCandidate;\r\n                                    }\r\n                                }\r\n                                applyPicks({\r\n                                    items: [...picks, ...additionalPicks],\r\n                                    active: activePick || additionalActivePick || fallbackActivePick\r\n                                });\r\n                            }\r\n                        }\r\n                        finally {\r\n                            if (!picksToken.isCancellationRequested) {\r\n                                picker.busy = false;\r\n                            }\r\n                            slowPicksApplied = true;\r\n                        }\r\n                    }))()\r\n                ]);\r\n            }\r\n            // Fast Picks\r\n            else if (!(providedPicks instanceof Promise)) {\r\n                applyPicks(providedPicks);\r\n            }\r\n            // Slow Picks\r\n            else {\r\n                picker.busy = true;\r\n                try {\r\n                    const awaitedPicks = yield providedPicks;\r\n                    if (picksToken.isCancellationRequested) {\r\n                        return;\r\n                    }\r\n                    applyPicks(awaitedPicks);\r\n                }\r\n                finally {\r\n                    if (!picksToken.isCancellationRequested) {\r\n                        picker.busy = false;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        disposables.add(picker.onDidChangeValue(() => updatePickerItems()));\r\n        updatePickerItems();\r\n        // Accept the pick on accept and hide picker\r\n        disposables.add(picker.onDidAccept(event => {\r\n            const [item] = picker.selectedItems;\r\n            if (typeof (item === null || item === void 0 ? void 0 : item.accept) === 'function') {\r\n                if (!event.inBackground) {\r\n                    picker.hide(); // hide picker unless we accept in background\r\n                }\r\n                item.accept(picker.keyMods, event);\r\n            }\r\n        }));\r\n        // Trigger the pick with button index if button triggered\r\n        disposables.add(picker.onDidTriggerItemButton(({ button, item }) => __awaiter(this, void 0, void 0, function* () {\r\n            var _b, _c;\r\n            if (typeof item.trigger === 'function') {\r\n                const buttonIndex = (_c = (_b = item.buttons) === null || _b === void 0 ? void 0 : _b.indexOf(button)) !== null && _c !== void 0 ? _c : -1;\r\n                if (buttonIndex >= 0) {\r\n                    const result = item.trigger(buttonIndex, picker.keyMods);\r\n                    const action = (typeof result === 'number') ? result : yield result;\r\n                    if (token.isCancellationRequested) {\r\n                        return;\r\n                    }\r\n                    switch (action) {\r\n                        case TriggerAction.NO_ACTION:\r\n                            break;\r\n                        case TriggerAction.CLOSE_PICKER:\r\n                            picker.hide();\r\n                            break;\r\n                        case TriggerAction.REFRESH_PICKER:\r\n                            updatePickerItems();\r\n                            break;\r\n                        case TriggerAction.REMOVE_ITEM:\r\n                            const index = picker.items.indexOf(item);\r\n                            if (index !== -1) {\r\n                                const items = picker.items.slice();\r\n                                items.splice(index, 1);\r\n                                picker.items = items;\r\n                            }\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        })));\r\n        return disposables;\r\n    }\r\n}\r\nPickerQuickAccessProvider.FAST_PICKS_RACE_DELAY = 200; // timeout before we accept fast results before slow results are present\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}