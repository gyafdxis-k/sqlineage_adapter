{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport { PageCoordinates } from '../editorDom.js';\nimport { PartFingerprints } from '../view/viewPart.js';\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range as EditorRange } from '../../common/core/range.js';\nimport { CursorColumns } from '../../common/controller/cursorCommon.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { AtomicTabMoveOperations } from '../../common/controller/cursorAtomicMoveOperations.js';\nexport class PointerHandlerLastRenderData {\n  constructor(lastViewCursorsRenderData, lastTextareaPosition) {\n    this.lastViewCursorsRenderData = lastViewCursorsRenderData;\n    this.lastTextareaPosition = lastTextareaPosition;\n  }\n}\nexport class MouseTarget {\n  constructor(element, type) {\n    let mouseColumn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let position = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let range = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    let detail = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    this.element = element;\n    this.type = type;\n    this.mouseColumn = mouseColumn;\n    this.position = position;\n    if (!range && position) {\n      range = new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\n    }\n    this.range = range;\n    this.detail = detail;\n  }\n  static _typeToString(type) {\n    if (type === 1 /* TEXTAREA */) {\n      return 'TEXTAREA';\n    }\n    if (type === 2 /* GUTTER_GLYPH_MARGIN */) {\n      return 'GUTTER_GLYPH_MARGIN';\n    }\n    if (type === 3 /* GUTTER_LINE_NUMBERS */) {\n      return 'GUTTER_LINE_NUMBERS';\n    }\n    if (type === 4 /* GUTTER_LINE_DECORATIONS */) {\n      return 'GUTTER_LINE_DECORATIONS';\n    }\n    if (type === 5 /* GUTTER_VIEW_ZONE */) {\n      return 'GUTTER_VIEW_ZONE';\n    }\n    if (type === 6 /* CONTENT_TEXT */) {\n      return 'CONTENT_TEXT';\n    }\n    if (type === 7 /* CONTENT_EMPTY */) {\n      return 'CONTENT_EMPTY';\n    }\n    if (type === 8 /* CONTENT_VIEW_ZONE */) {\n      return 'CONTENT_VIEW_ZONE';\n    }\n    if (type === 9 /* CONTENT_WIDGET */) {\n      return 'CONTENT_WIDGET';\n    }\n    if (type === 10 /* OVERVIEW_RULER */) {\n      return 'OVERVIEW_RULER';\n    }\n    if (type === 11 /* SCROLLBAR */) {\n      return 'SCROLLBAR';\n    }\n    if (type === 12 /* OVERLAY_WIDGET */) {\n      return 'OVERLAY_WIDGET';\n    }\n    return 'UNKNOWN';\n  }\n  static toString(target) {\n    return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + target.detail;\n  }\n  toString() {\n    return MouseTarget.toString(this);\n  }\n}\nclass ElementPath {\n  static isTextArea(path) {\n    return path.length === 2 && path[0] === 3 /* OverflowGuard */ && path[1] === 6 /* TextArea */;\n  }\n\n  static isChildOfViewLines(path) {\n    return path.length >= 4 && path[0] === 3 /* OverflowGuard */ && path[3] === 7 /* ViewLines */;\n  }\n\n  static isStrictChildOfViewLines(path) {\n    return path.length > 4 && path[0] === 3 /* OverflowGuard */ && path[3] === 7 /* ViewLines */;\n  }\n\n  static isChildOfScrollableElement(path) {\n    return path.length >= 2 && path[0] === 3 /* OverflowGuard */ && path[1] === 5 /* ScrollableElement */;\n  }\n\n  static isChildOfMinimap(path) {\n    return path.length >= 2 && path[0] === 3 /* OverflowGuard */ && path[1] === 8 /* Minimap */;\n  }\n\n  static isChildOfContentWidgets(path) {\n    return path.length >= 4 && path[0] === 3 /* OverflowGuard */ && path[3] === 1 /* ContentWidgets */;\n  }\n\n  static isChildOfOverflowingContentWidgets(path) {\n    return path.length >= 1 && path[0] === 2 /* OverflowingContentWidgets */;\n  }\n\n  static isChildOfOverlayWidgets(path) {\n    return path.length >= 2 && path[0] === 3 /* OverflowGuard */ && path[1] === 4 /* OverlayWidgets */;\n  }\n}\n\nexport class HitTestContext {\n  constructor(context, viewHelper, lastRenderData) {\n    this.model = context.model;\n    const options = context.configuration.options;\n    this.layoutInfo = options.get(124 /* layoutInfo */);\n    this.viewDomNode = viewHelper.viewDomNode;\n    this.lineHeight = options.get(53 /* lineHeight */);\n    this.stickyTabStops = options.get(99 /* stickyTabStops */);\n    this.typicalHalfwidthCharacterWidth = options.get(38 /* fontInfo */).typicalHalfwidthCharacterWidth;\n    this.lastRenderData = lastRenderData;\n    this._context = context;\n    this._viewHelper = viewHelper;\n  }\n  getZoneAtCoord(mouseVerticalOffset) {\n    return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\n  }\n  static getZoneAtCoord(context, mouseVerticalOffset) {\n    // The target is either a view zone or the empty space after the last view-line\n    const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\n    if (viewZoneWhitespace) {\n      const viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\n      const lineCount = context.model.getLineCount();\n      let positionBefore = null;\n      let position;\n      let positionAfter = null;\n      if (viewZoneWhitespace.afterLineNumber !== lineCount) {\n        // There are more lines after this view zone\n        positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\n      }\n      if (viewZoneWhitespace.afterLineNumber > 0) {\n        // There are more lines above this view zone\n        positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\n      }\n      if (positionAfter === null) {\n        position = positionBefore;\n      } else if (positionBefore === null) {\n        position = positionAfter;\n      } else if (mouseVerticalOffset < viewZoneMiddle) {\n        position = positionBefore;\n      } else {\n        position = positionAfter;\n      }\n      return {\n        viewZoneId: viewZoneWhitespace.id,\n        afterLineNumber: viewZoneWhitespace.afterLineNumber,\n        positionBefore: positionBefore,\n        positionAfter: positionAfter,\n        position: position\n      };\n    }\n    return null;\n  }\n  getFullLineRangeAtCoord(mouseVerticalOffset) {\n    if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\n      // Below the last line\n      const lineNumber = this._context.model.getLineCount();\n      const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\n      return {\n        range: new EditorRange(lineNumber, maxLineColumn, lineNumber, maxLineColumn),\n        isAfterLines: true\n      };\n    }\n    const lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n    const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\n    return {\n      range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\n      isAfterLines: false\n    };\n  }\n  getLineNumberAtVerticalOffset(mouseVerticalOffset) {\n    return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n  }\n  isAfterLines(mouseVerticalOffset) {\n    return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\n  }\n  isInTopPadding(mouseVerticalOffset) {\n    return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\n  }\n  isInBottomPadding(mouseVerticalOffset) {\n    return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\n  }\n  getVerticalOffsetForLineNumber(lineNumber) {\n    return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n  }\n  findAttribute(element, attr) {\n    return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\n  }\n  static _findAttribute(element, attr, stopAt) {\n    while (element && element !== document.body) {\n      if (element.hasAttribute && element.hasAttribute(attr)) {\n        return element.getAttribute(attr);\n      }\n      if (element === stopAt) {\n        return null;\n      }\n      element = element.parentNode;\n    }\n    return null;\n  }\n  getLineWidth(lineNumber) {\n    return this._viewHelper.getLineWidth(lineNumber);\n  }\n  visibleRangeForPosition(lineNumber, column) {\n    return this._viewHelper.visibleRangeForPosition(lineNumber, column);\n  }\n  getPositionFromDOMInfo(spanNode, offset) {\n    return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\n  }\n  getCurrentScrollTop() {\n    return this._context.viewLayout.getCurrentScrollTop();\n  }\n  getCurrentScrollLeft() {\n    return this._context.viewLayout.getCurrentScrollLeft();\n  }\n}\nclass BareHitTestRequest {\n  constructor(ctx, editorPos, pos) {\n    this.editorPos = editorPos;\n    this.pos = pos;\n    this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + pos.y - editorPos.y);\n    this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + pos.x - editorPos.x - ctx.layoutInfo.contentLeft;\n    this.isInMarginArea = pos.x - editorPos.x < ctx.layoutInfo.contentLeft && pos.x - editorPos.x >= ctx.layoutInfo.glyphMarginLeft;\n    this.isInContentArea = !this.isInMarginArea;\n    this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\n  }\n}\nclass HitTestRequest extends BareHitTestRequest {\n  constructor(ctx, editorPos, pos, target) {\n    super(ctx, editorPos, pos);\n    this._ctx = ctx;\n    if (target) {\n      this.target = target;\n      this.targetPath = PartFingerprints.collect(target, ctx.viewDomNode);\n    } else {\n      this.target = null;\n      this.targetPath = new Uint8Array(0);\n    }\n  }\n  toString() {\n    return \"pos(\".concat(this.pos.x, \",\").concat(this.pos.y, \"), editorPos(\").concat(this.editorPos.x, \",\").concat(this.editorPos.y, \"), mouseVerticalOffset: \").concat(this.mouseVerticalOffset, \", mouseContentHorizontalOffset: \").concat(this.mouseContentHorizontalOffset, \"\\n\\ttarget: \").concat(this.target ? this.target.outerHTML : null);\n  }\n  fulfill(type) {\n    let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let range = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let detail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let mouseColumn = this.mouseColumn;\n    if (position && position.column < this._ctx.model.getLineMaxColumn(position.lineNumber)) {\n      // Most likely, the line contains foreign decorations...\n      mouseColumn = CursorColumns.visibleColumnFromColumn(this._ctx.model.getLineContent(position.lineNumber), position.column, this._ctx.model.getTextModelOptions().tabSize) + 1;\n    }\n    return new MouseTarget(this.target, type, mouseColumn, position, range, detail);\n  }\n  withTarget(target) {\n    return new HitTestRequest(this._ctx, this.editorPos, this.pos, target);\n  }\n}\nconst EMPTY_CONTENT_AFTER_LINES = {\n  isAfterLines: true\n};\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\n  return {\n    isAfterLines: false,\n    horizontalDistanceToText: horizontalDistanceToText\n  };\n}\nexport class MouseTargetFactory {\n  constructor(context, viewHelper) {\n    this._context = context;\n    this._viewHelper = viewHelper;\n  }\n  mouseTargetIsWidget(e) {\n    const t = e.target;\n    const path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);\n    // Is it a content widget?\n    if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\n      return true;\n    }\n    // Is it an overlay widget?\n    if (ElementPath.isChildOfOverlayWidgets(path)) {\n      return true;\n    }\n    return false;\n  }\n  createMouseTarget(lastRenderData, editorPos, pos, target) {\n    const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n    const request = new HitTestRequest(ctx, editorPos, pos, target);\n    try {\n      const r = MouseTargetFactory._createMouseTarget(ctx, request, false);\n      // console.log(r.toString());\n      return r;\n    } catch (err) {\n      // console.log(err);\n      return request.fulfill(0 /* UNKNOWN */);\n    }\n  }\n\n  static _createMouseTarget(ctx, request, domHitTestExecuted) {\n    // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\n    // First ensure the request has a target\n    if (request.target === null) {\n      if (domHitTestExecuted) {\n        // Still no target... and we have already executed hit test...\n        return request.fulfill(0 /* UNKNOWN */);\n      }\n\n      const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n      if (hitTestResult.position) {\n        return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);\n      }\n      return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n    }\n    // we know for a fact that request.target is not null\n    const resolvedRequest = request;\n    let result = null;\n    result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest, domHitTestExecuted);\n    result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\n    return result || request.fulfill(0 /* UNKNOWN */);\n  }\n\n  static _hitTestContentWidget(ctx, request) {\n    // Is it a content widget?\n    if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\n      const widgetId = ctx.findAttribute(request.target, 'widgetId');\n      if (widgetId) {\n        return request.fulfill(9 /* CONTENT_WIDGET */, null, null, widgetId);\n      } else {\n        return request.fulfill(0 /* UNKNOWN */);\n      }\n    }\n\n    return null;\n  }\n  static _hitTestOverlayWidget(ctx, request) {\n    // Is it an overlay widget?\n    if (ElementPath.isChildOfOverlayWidgets(request.targetPath)) {\n      const widgetId = ctx.findAttribute(request.target, 'widgetId');\n      if (widgetId) {\n        return request.fulfill(12 /* OVERLAY_WIDGET */, null, null, widgetId);\n      } else {\n        return request.fulfill(0 /* UNKNOWN */);\n      }\n    }\n\n    return null;\n  }\n  static _hitTestViewCursor(ctx, request) {\n    if (request.target) {\n      // Check if we've hit a painted cursor\n      const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n      for (const d of lastViewCursorsRenderData) {\n        if (request.target === d.domNode) {\n          return request.fulfill(6 /* CONTENT_TEXT */, d.position);\n        }\n      }\n    }\n    if (request.isInContentArea) {\n      // Edge has a bug when hit-testing the exact position of a cursor,\n      // instead of returning the correct dom node, it returns the\n      // first or last rendered view line dom node, therefore help it out\n      // and first check if we are on top of a cursor\n      const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n      const mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\n      const mouseVerticalOffset = request.mouseVerticalOffset;\n      for (const d of lastViewCursorsRenderData) {\n        if (mouseContentHorizontalOffset < d.contentLeft) {\n          // mouse position is to the left of the cursor\n          continue;\n        }\n        if (mouseContentHorizontalOffset > d.contentLeft + d.width) {\n          // mouse position is to the right of the cursor\n          continue;\n        }\n        const cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);\n        if (cursorVerticalOffset <= mouseVerticalOffset && mouseVerticalOffset <= cursorVerticalOffset + d.height) {\n          return request.fulfill(6 /* CONTENT_TEXT */, d.position);\n        }\n      }\n    }\n    return null;\n  }\n  static _hitTestViewZone(ctx, request) {\n    const viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\n    if (viewZoneData) {\n      const mouseTargetType = request.isInContentArea ? 8 /* CONTENT_VIEW_ZONE */ : 5 /* GUTTER_VIEW_ZONE */;\n      return request.fulfill(mouseTargetType, viewZoneData.position, null, viewZoneData);\n    }\n    return null;\n  }\n  static _hitTestTextArea(ctx, request) {\n    // Is it the textarea?\n    if (ElementPath.isTextArea(request.targetPath)) {\n      if (ctx.lastRenderData.lastTextareaPosition) {\n        return request.fulfill(6 /* CONTENT_TEXT */, ctx.lastRenderData.lastTextareaPosition);\n      }\n      return request.fulfill(1 /* TEXTAREA */, ctx.lastRenderData.lastTextareaPosition);\n    }\n    return null;\n  }\n  static _hitTestMargin(ctx, request) {\n    if (request.isInMarginArea) {\n      const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\n      const pos = res.range.getStartPosition();\n      let offset = Math.abs(request.pos.x - request.editorPos.x);\n      const detail = {\n        isAfterLines: res.isAfterLines,\n        glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\n        glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\n        lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\n        offsetX: offset\n      };\n      offset -= ctx.layoutInfo.glyphMarginLeft;\n      if (offset <= ctx.layoutInfo.glyphMarginWidth) {\n        // On the glyph margin\n        return request.fulfill(2 /* GUTTER_GLYPH_MARGIN */, pos, res.range, detail);\n      }\n      offset -= ctx.layoutInfo.glyphMarginWidth;\n      if (offset <= ctx.layoutInfo.lineNumbersWidth) {\n        // On the line numbers\n        return request.fulfill(3 /* GUTTER_LINE_NUMBERS */, pos, res.range, detail);\n      }\n      offset -= ctx.layoutInfo.lineNumbersWidth;\n      // On the line decorations\n      return request.fulfill(4 /* GUTTER_LINE_DECORATIONS */, pos, res.range, detail);\n    }\n    return null;\n  }\n  static _hitTestViewLines(ctx, request, domHitTestExecuted) {\n    if (!ElementPath.isChildOfViewLines(request.targetPath)) {\n      return null;\n    }\n    if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\n      return request.fulfill(7 /* CONTENT_EMPTY */, new Position(1, 1), undefined, EMPTY_CONTENT_AFTER_LINES);\n    }\n    // Check if it is below any lines and any view zones\n    if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\n      // This most likely indicates it happened after the last view-line\n      const lineCount = ctx.model.getLineCount();\n      const maxLineColumn = ctx.model.getLineMaxColumn(lineCount);\n      return request.fulfill(7 /* CONTENT_EMPTY */, new Position(lineCount, maxLineColumn), undefined, EMPTY_CONTENT_AFTER_LINES);\n    }\n    if (domHitTestExecuted) {\n      // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\n      // See https://github.com/microsoft/vscode/issues/46942\n      if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\n        const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n        if (ctx.model.getLineLength(lineNumber) === 0) {\n          const lineWidth = ctx.getLineWidth(lineNumber);\n          const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n          return request.fulfill(7 /* CONTENT_EMPTY */, new Position(lineNumber, 1), undefined, detail);\n        }\n        const lineWidth = ctx.getLineWidth(lineNumber);\n        if (request.mouseContentHorizontalOffset >= lineWidth) {\n          const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n          const pos = new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber));\n          return request.fulfill(7 /* CONTENT_EMPTY */, pos, undefined, detail);\n        }\n      }\n      // We have already executed hit test...\n      return request.fulfill(0 /* UNKNOWN */);\n    }\n\n    const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n    if (hitTestResult.position) {\n      return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);\n    }\n    return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n  }\n  static _hitTestMinimap(ctx, request) {\n    if (ElementPath.isChildOfMinimap(request.targetPath)) {\n      const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n      const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n      return request.fulfill(11 /* SCROLLBAR */, new Position(possibleLineNumber, maxColumn));\n    }\n    return null;\n  }\n  static _hitTestScrollbarSlider(ctx, request) {\n    if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n      if (request.target && request.target.nodeType === 1) {\n        const className = request.target.className;\n        if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\n          const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n          const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n          return request.fulfill(11 /* SCROLLBAR */, new Position(possibleLineNumber, maxColumn));\n        }\n      }\n    }\n    return null;\n  }\n  static _hitTestScrollbar(ctx, request) {\n    // Is it the overview ruler?\n    // Is it a child of the scrollable element?\n    if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n      const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n      const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n      return request.fulfill(11 /* SCROLLBAR */, new Position(possibleLineNumber, maxColumn));\n    }\n    return null;\n  }\n  getMouseColumn(editorPos, pos) {\n    const options = this._context.configuration.options;\n    const layoutInfo = options.get(124 /* layoutInfo */);\n    const mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + pos.x - editorPos.x - layoutInfo.contentLeft;\n    return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(38 /* fontInfo */).typicalHalfwidthCharacterWidth);\n  }\n  static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\n    if (mouseContentHorizontalOffset < 0) {\n      return 1;\n    }\n    const chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\n    return chars + 1;\n  }\n  static createMouseTargetFromHitTestPosition(ctx, request, lineNumber, column) {\n    const pos = new Position(lineNumber, column);\n    const lineWidth = ctx.getLineWidth(lineNumber);\n    if (request.mouseContentHorizontalOffset > lineWidth) {\n      if (browser.isEdgeLegacy && pos.column === 1) {\n        // See https://github.com/microsoft/vscode/issues/10875\n        const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n        return request.fulfill(7 /* CONTENT_EMPTY */, new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber)), undefined, detail);\n      }\n      const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n      return request.fulfill(7 /* CONTENT_EMPTY */, pos, undefined, detail);\n    }\n    const visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\n    if (!visibleRange) {\n      return request.fulfill(0 /* UNKNOWN */, pos);\n    }\n    const columnHorizontalOffset = visibleRange.left;\n    if (request.mouseContentHorizontalOffset === columnHorizontalOffset) {\n      return request.fulfill(6 /* CONTENT_TEXT */, pos);\n    }\n    const points = [];\n    points.push({\n      offset: visibleRange.left,\n      column: column\n    });\n    if (column > 1) {\n      const visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\n      if (visibleRange) {\n        points.push({\n          offset: visibleRange.left,\n          column: column - 1\n        });\n      }\n    }\n    const lineMaxColumn = ctx.model.getLineMaxColumn(lineNumber);\n    if (column < lineMaxColumn) {\n      const visibleRange = ctx.visibleRangeForPosition(lineNumber, column + 1);\n      if (visibleRange) {\n        points.push({\n          offset: visibleRange.left,\n          column: column + 1\n        });\n      }\n    }\n    points.sort((a, b) => a.offset - b.offset);\n    for (let i = 1; i < points.length; i++) {\n      const prev = points[i - 1];\n      const curr = points[i];\n      if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\n        const rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\n        return request.fulfill(6 /* CONTENT_TEXT */, pos, rng);\n      }\n    }\n    return request.fulfill(6 /* CONTENT_TEXT */, pos);\n  }\n  /**\r\n   * Most probably WebKit browsers and Edge\r\n   */\n  static _doHitTestWithCaretRangeFromPoint(ctx, request) {\n    // In Chrome, especially on Linux it is possible to click between lines,\n    // so try to adjust the `hity` below so that it lands in the center of a line\n    const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n    const lineVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\n    const lineCenteredVerticalOffset = lineVerticalOffset + Math.floor(ctx.lineHeight / 2);\n    let adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\n    if (adjustedPageY <= request.editorPos.y) {\n      adjustedPageY = request.editorPos.y + 1;\n    }\n    if (adjustedPageY >= request.editorPos.y + ctx.layoutInfo.height) {\n      adjustedPageY = request.editorPos.y + ctx.layoutInfo.height - 1;\n    }\n    const adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\n    const r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates());\n    if (r.position) {\n      return r;\n    }\n    // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\n    return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates());\n  }\n  static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\n    const shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\n    let range;\n    if (shadowRoot) {\n      if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\n        range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\n      } else {\n        range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\n      }\n    } else {\n      range = document.caretRangeFromPoint(coords.clientX, coords.clientY);\n    }\n    if (!range || !range.startContainer) {\n      return {\n        position: null,\n        hitTarget: null\n      };\n    }\n    // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\n    const startContainer = range.startContainer;\n    let hitTarget = null;\n    if (startContainer.nodeType === startContainer.TEXT_NODE) {\n      // startContainer is expected to be the token text\n      const parent1 = startContainer.parentNode; // expected to be the token span\n      const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n      const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n      const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n      if (parent3ClassName === ViewLine.CLASS_NAME) {\n        const p = ctx.getPositionFromDOMInfo(parent1, range.startOffset);\n        return {\n          position: p,\n          hitTarget: null\n        };\n      } else {\n        hitTarget = startContainer.parentNode;\n      }\n    } else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\n      // startContainer is expected to be the token span\n      const parent1 = startContainer.parentNode; // expected to be the view line container span\n      const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div\n      const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n      if (parent2ClassName === ViewLine.CLASS_NAME) {\n        const p = ctx.getPositionFromDOMInfo(startContainer, startContainer.textContent.length);\n        return {\n          position: p,\n          hitTarget: null\n        };\n      } else {\n        hitTarget = startContainer;\n      }\n    }\n    return {\n      position: null,\n      hitTarget: hitTarget\n    };\n  }\n  /**\r\n   * Most probably Gecko\r\n   */\n  static _doHitTestWithCaretPositionFromPoint(ctx, coords) {\n    const hitResult = document.caretPositionFromPoint(coords.clientX, coords.clientY);\n    if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\n      // offsetNode is expected to be the token text\n      const parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\n      const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n      const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n      const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n      if (parent3ClassName === ViewLine.CLASS_NAME) {\n        const p = ctx.getPositionFromDOMInfo(hitResult.offsetNode.parentNode, hitResult.offset);\n        return {\n          position: p,\n          hitTarget: null\n        };\n      } else {\n        return {\n          position: null,\n          hitTarget: hitResult.offsetNode.parentNode\n        };\n      }\n    }\n    // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\n    // Some other times, it returns the `<span>` with the inline decoration\n    if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\n      const parent1 = hitResult.offsetNode.parentNode;\n      const parent1ClassName = parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null;\n      const parent2 = parent1 ? parent1.parentNode : null;\n      const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n      if (parent1ClassName === ViewLine.CLASS_NAME) {\n        // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\n        const tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\n        if (tokenSpan) {\n          const p = ctx.getPositionFromDOMInfo(tokenSpan, 0);\n          return {\n            position: p,\n            hitTarget: null\n          };\n        }\n      } else if (parent2ClassName === ViewLine.CLASS_NAME) {\n        // it returned the `<span>` with the inline decoration\n        const p = ctx.getPositionFromDOMInfo(hitResult.offsetNode, 0);\n        return {\n          position: p,\n          hitTarget: null\n        };\n      }\n    }\n    return {\n      position: null,\n      hitTarget: hitResult.offsetNode\n    };\n  }\n  /**\r\n   * Most probably IE\r\n   */\n  static _doHitTestWithMoveToPoint(ctx, coords) {\n    let resultPosition = null;\n    let resultHitTarget = null;\n    const textRange = document.body.createTextRange();\n    try {\n      textRange.moveToPoint(coords.clientX, coords.clientY);\n    } catch (err) {\n      return {\n        position: null,\n        hitTarget: null\n      };\n    }\n    textRange.collapse(true);\n    // Now, let's do our best to figure out what we hit :)\n    const parentElement = textRange ? textRange.parentElement() : null;\n    const parent1 = parentElement ? parentElement.parentNode : null;\n    const parent2 = parent1 ? parent1.parentNode : null;\n    const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : '';\n    if (parent2ClassName === ViewLine.CLASS_NAME) {\n      const rangeToContainEntireSpan = textRange.duplicate();\n      rangeToContainEntireSpan.moveToElementText(parentElement);\n      rangeToContainEntireSpan.setEndPoint('EndToStart', textRange);\n      resultPosition = ctx.getPositionFromDOMInfo(parentElement, rangeToContainEntireSpan.text.length);\n      // Move range out of the span node, IE doesn't like having many ranges in\n      // the same spot and will act badly for lines containing dashes ('-')\n      rangeToContainEntireSpan.moveToElementText(ctx.viewDomNode);\n    } else {\n      // Looks like we've hit the hover or something foreign\n      resultHitTarget = parentElement;\n    }\n    // Move range out of the span node, IE doesn't like having many ranges in\n    // the same spot and will act badly for lines containing dashes ('-')\n    textRange.moveToElementText(ctx.viewDomNode);\n    return {\n      position: resultPosition,\n      hitTarget: resultHitTarget\n    };\n  }\n  static _snapToSoftTabBoundary(position, viewModel) {\n    const lineContent = viewModel.getLineContent(position.lineNumber);\n    const {\n      tabSize\n    } = viewModel.getTextModelOptions();\n    const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2 /* Nearest */);\n    if (newPosition !== -1) {\n      return new Position(position.lineNumber, newPosition + 1);\n    }\n    return position;\n  }\n  static _doHitTest(ctx, request) {\n    // State of the art (18.10.2012):\n    // The spec says browsers should support document.caretPositionFromPoint, but nobody implemented it (http://dev.w3.org/csswg/cssom-view/)\n    // Gecko:\n    //    - they tried to implement it once, but failed: https://bugzilla.mozilla.org/show_bug.cgi?id=654352\n    //    - however, they do give out rangeParent/rangeOffset properties on mouse events\n    // Webkit:\n    //    - they have implemented a previous version of the spec which was using document.caretRangeFromPoint\n    // IE:\n    //    - they have a proprietary method on ranges, moveToPoint: https://msdn.microsoft.com/en-us/library/ie/ms536632(v=vs.85).aspx\n    // 24.08.2016: Edge has added WebKit's document.caretRangeFromPoint, but it is quite buggy\n    //    - when hit testing the cursor it returns the first or the last line in the viewport\n    //    - it inconsistently hits text nodes or span nodes, while WebKit only hits text nodes\n    //    - when toggling render whitespace on, and hit testing in the empty content after a line, it always hits offset 0 of the first span of the line\n    // Thank you browsers for making this so 'easy' :)\n    let result;\n    if (typeof document.caretRangeFromPoint === 'function') {\n      result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\n    } else if (document.caretPositionFromPoint) {\n      result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates());\n    } else if (document.body.createTextRange) {\n      result = this._doHitTestWithMoveToPoint(ctx, request.pos.toClientCoordinates());\n    } else {\n      result = {\n        position: null,\n        hitTarget: null\n      };\n    }\n    // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\n    if (result.position && ctx.stickyTabStops) {\n      result.position = this._snapToSoftTabBoundary(result.position, ctx.model);\n    }\n    return result;\n  }\n}\nexport function shadowCaretRangeFromPoint(shadowRoot, x, y) {\n  const range = document.createRange();\n  // Get the element under the point\n  let el = shadowRoot.elementFromPoint(x, y);\n  if (el !== null) {\n    // Get the last child of the element until its firstChild is a text node\n    // This assumes that the pointer is on the right of the line, out of the tokens\n    // and that we want to get the offset of the last token of the line\n    while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\n      el = el.lastChild;\n    }\n    // Grab its rect\n    const rect = el.getBoundingClientRect();\n    // And its font\n    const font = window.getComputedStyle(el, null).getPropertyValue('font');\n    // And also its txt content\n    const text = el.innerText;\n    // Position the pixel cursor at the left of the element\n    let pixelCursor = rect.left;\n    let offset = 0;\n    let step;\n    // If the point is on the right of the box put the cursor after the last character\n    if (x > rect.left + rect.width) {\n      offset = text.length;\n    } else {\n      const charWidthReader = CharWidthReader.getInstance();\n      // Goes through all the characters of the innerText, and checks if the x of the point\n      // belongs to the character.\n      for (let i = 0; i < text.length + 1; i++) {\n        // The step is half the width of the character\n        step = charWidthReader.getCharWidth(text.charAt(i), font) / 2;\n        // Move to the center of the character\n        pixelCursor += step;\n        // If the x of the point is smaller that the position of the cursor, the point is over that character\n        if (x < pixelCursor) {\n          offset = i;\n          break;\n        }\n        // Move between the current character and the next\n        pixelCursor += step;\n      }\n    }\n    // Creates a range with the text node of the element and set the offset found\n    range.setStart(el.firstChild, offset);\n    range.setEnd(el.firstChild, offset);\n  }\n  return range;\n}\nclass CharWidthReader {\n  constructor() {\n    this._cache = {};\n    this._canvas = document.createElement('canvas');\n  }\n  static getInstance() {\n    if (!CharWidthReader._INSTANCE) {\n      CharWidthReader._INSTANCE = new CharWidthReader();\n    }\n    return CharWidthReader._INSTANCE;\n  }\n  getCharWidth(char, font) {\n    const cacheKey = char + font;\n    if (this._cache[cacheKey]) {\n      return this._cache[cacheKey];\n    }\n    const context = this._canvas.getContext('2d');\n    context.font = font;\n    const metrics = context.measureText(char);\n    const width = metrics.width;\n    this._cache[cacheKey] = width;\n    return width;\n  }\n}\nCharWidthReader._INSTANCE = null;","map":{"version":3,"names":["browser","PageCoordinates","PartFingerprints","ViewLine","Position","Range","EditorRange","CursorColumns","dom","AtomicTabMoveOperations","PointerHandlerLastRenderData","constructor","lastViewCursorsRenderData","lastTextareaPosition","MouseTarget","element","type","mouseColumn","arguments","length","undefined","position","range","detail","lineNumber","column","_typeToString","toString","target","ElementPath","isTextArea","path","isChildOfViewLines","isStrictChildOfViewLines","isChildOfScrollableElement","isChildOfMinimap","isChildOfContentWidgets","isChildOfOverflowingContentWidgets","isChildOfOverlayWidgets","HitTestContext","context","viewHelper","lastRenderData","model","options","configuration","layoutInfo","get","viewDomNode","lineHeight","stickyTabStops","typicalHalfwidthCharacterWidth","_context","_viewHelper","getZoneAtCoord","mouseVerticalOffset","viewZoneWhitespace","viewLayout","getWhitespaceAtVerticalOffset","viewZoneMiddle","verticalOffset","height","lineCount","getLineCount","positionBefore","positionAfter","afterLineNumber","getLineMaxColumn","viewZoneId","id","getFullLineRangeAtCoord","isAfterLines","maxLineColumn","getLineNumberAtVerticalOffset","isInTopPadding","isInBottomPadding","getVerticalOffsetForLineNumber","findAttribute","attr","_findAttribute","stopAt","document","body","hasAttribute","getAttribute","parentNode","getLineWidth","visibleRangeForPosition","getPositionFromDOMInfo","spanNode","offset","getCurrentScrollTop","getCurrentScrollLeft","BareHitTestRequest","ctx","editorPos","pos","Math","max","y","mouseContentHorizontalOffset","x","contentLeft","isInMarginArea","glyphMarginLeft","isInContentArea","MouseTargetFactory","_getMouseColumn","HitTestRequest","_ctx","targetPath","collect","Uint8Array","concat","outerHTML","fulfill","visibleColumnFromColumn","getLineContent","getTextModelOptions","tabSize","withTarget","EMPTY_CONTENT_AFTER_LINES","createEmptyContentDataInLines","horizontalDistanceToText","mouseTargetIsWidget","e","t","createMouseTarget","request","r","_createMouseTarget","err","domHitTestExecuted","hitTestResult","_doHitTest","createMouseTargetFromHitTestPosition","hitTarget","resolvedRequest","result","_hitTestContentWidget","_hitTestOverlayWidget","_hitTestMinimap","_hitTestScrollbarSlider","_hitTestViewZone","_hitTestMargin","_hitTestViewCursor","_hitTestTextArea","_hitTestViewLines","_hitTestScrollbar","widgetId","d","domNode","width","cursorVerticalOffset","viewZoneData","mouseTargetType","res","getStartPosition","abs","glyphMarginWidth","lineNumbersWidth","offsetX","getLineLength","lineWidth","possibleLineNumber","maxColumn","nodeType","className","test","getMouseColumn","chars","round","isEdgeLegacy","visibleRange","columnHorizontalOffset","left","points","push","lineMaxColumn","sort","a","b","i","prev","curr","rng","_doHitTestWithCaretRangeFromPoint","lineVerticalOffset","lineCenteredVerticalOffset","floor","adjustedPageY","adjustedPage","_actualDoHitTestWithCaretRangeFromPoint","toClientCoordinates","coords","shadowRoot","getShadowRoot","caretRangeFromPoint","shadowCaretRangeFromPoint","clientX","clientY","startContainer","TEXT_NODE","parent1","parent2","parent3","parent3ClassName","ELEMENT_NODE","CLASS_NAME","p","startOffset","parent2ClassName","textContent","_doHitTestWithCaretPositionFromPoint","hitResult","caretPositionFromPoint","offsetNode","parent1ClassName","tokenSpan","childNodes","min","_doHitTestWithMoveToPoint","resultPosition","resultHitTarget","textRange","createTextRange","moveToPoint","collapse","parentElement","rangeToContainEntireSpan","duplicate","moveToElementText","setEndPoint","text","_snapToSoftTabBoundary","viewModel","lineContent","newPosition","atomicPosition","createRange","el","elementFromPoint","firstChild","lastChild","rect","getBoundingClientRect","font","window","getComputedStyle","getPropertyValue","innerText","pixelCursor","step","charWidthReader","CharWidthReader","getInstance","getCharWidth","charAt","setStart","setEnd","_cache","_canvas","createElement","_INSTANCE","char","cacheKey","getContext","metrics","measureText"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/browser/controller/mouseTarget.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as browser from '../../../base/browser/browser.js';\r\nimport { PageCoordinates } from '../editorDom.js';\r\nimport { PartFingerprints } from '../view/viewPart.js';\r\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Range as EditorRange } from '../../common/core/range.js';\r\nimport { CursorColumns } from '../../common/controller/cursorCommon.js';\r\nimport * as dom from '../../../base/browser/dom.js';\r\nimport { AtomicTabMoveOperations } from '../../common/controller/cursorAtomicMoveOperations.js';\r\nexport class PointerHandlerLastRenderData {\r\n    constructor(lastViewCursorsRenderData, lastTextareaPosition) {\r\n        this.lastViewCursorsRenderData = lastViewCursorsRenderData;\r\n        this.lastTextareaPosition = lastTextareaPosition;\r\n    }\r\n}\r\nexport class MouseTarget {\r\n    constructor(element, type, mouseColumn = 0, position = null, range = null, detail = null) {\r\n        this.element = element;\r\n        this.type = type;\r\n        this.mouseColumn = mouseColumn;\r\n        this.position = position;\r\n        if (!range && position) {\r\n            range = new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\r\n        }\r\n        this.range = range;\r\n        this.detail = detail;\r\n    }\r\n    static _typeToString(type) {\r\n        if (type === 1 /* TEXTAREA */) {\r\n            return 'TEXTAREA';\r\n        }\r\n        if (type === 2 /* GUTTER_GLYPH_MARGIN */) {\r\n            return 'GUTTER_GLYPH_MARGIN';\r\n        }\r\n        if (type === 3 /* GUTTER_LINE_NUMBERS */) {\r\n            return 'GUTTER_LINE_NUMBERS';\r\n        }\r\n        if (type === 4 /* GUTTER_LINE_DECORATIONS */) {\r\n            return 'GUTTER_LINE_DECORATIONS';\r\n        }\r\n        if (type === 5 /* GUTTER_VIEW_ZONE */) {\r\n            return 'GUTTER_VIEW_ZONE';\r\n        }\r\n        if (type === 6 /* CONTENT_TEXT */) {\r\n            return 'CONTENT_TEXT';\r\n        }\r\n        if (type === 7 /* CONTENT_EMPTY */) {\r\n            return 'CONTENT_EMPTY';\r\n        }\r\n        if (type === 8 /* CONTENT_VIEW_ZONE */) {\r\n            return 'CONTENT_VIEW_ZONE';\r\n        }\r\n        if (type === 9 /* CONTENT_WIDGET */) {\r\n            return 'CONTENT_WIDGET';\r\n        }\r\n        if (type === 10 /* OVERVIEW_RULER */) {\r\n            return 'OVERVIEW_RULER';\r\n        }\r\n        if (type === 11 /* SCROLLBAR */) {\r\n            return 'SCROLLBAR';\r\n        }\r\n        if (type === 12 /* OVERLAY_WIDGET */) {\r\n            return 'OVERLAY_WIDGET';\r\n        }\r\n        return 'UNKNOWN';\r\n    }\r\n    static toString(target) {\r\n        return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + target.detail;\r\n    }\r\n    toString() {\r\n        return MouseTarget.toString(this);\r\n    }\r\n}\r\nclass ElementPath {\r\n    static isTextArea(path) {\r\n        return (path.length === 2\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[1] === 6 /* TextArea */);\r\n    }\r\n    static isChildOfViewLines(path) {\r\n        return (path.length >= 4\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[3] === 7 /* ViewLines */);\r\n    }\r\n    static isStrictChildOfViewLines(path) {\r\n        return (path.length > 4\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[3] === 7 /* ViewLines */);\r\n    }\r\n    static isChildOfScrollableElement(path) {\r\n        return (path.length >= 2\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[1] === 5 /* ScrollableElement */);\r\n    }\r\n    static isChildOfMinimap(path) {\r\n        return (path.length >= 2\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[1] === 8 /* Minimap */);\r\n    }\r\n    static isChildOfContentWidgets(path) {\r\n        return (path.length >= 4\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[3] === 1 /* ContentWidgets */);\r\n    }\r\n    static isChildOfOverflowingContentWidgets(path) {\r\n        return (path.length >= 1\r\n            && path[0] === 2 /* OverflowingContentWidgets */);\r\n    }\r\n    static isChildOfOverlayWidgets(path) {\r\n        return (path.length >= 2\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[1] === 4 /* OverlayWidgets */);\r\n    }\r\n}\r\nexport class HitTestContext {\r\n    constructor(context, viewHelper, lastRenderData) {\r\n        this.model = context.model;\r\n        const options = context.configuration.options;\r\n        this.layoutInfo = options.get(124 /* layoutInfo */);\r\n        this.viewDomNode = viewHelper.viewDomNode;\r\n        this.lineHeight = options.get(53 /* lineHeight */);\r\n        this.stickyTabStops = options.get(99 /* stickyTabStops */);\r\n        this.typicalHalfwidthCharacterWidth = options.get(38 /* fontInfo */).typicalHalfwidthCharacterWidth;\r\n        this.lastRenderData = lastRenderData;\r\n        this._context = context;\r\n        this._viewHelper = viewHelper;\r\n    }\r\n    getZoneAtCoord(mouseVerticalOffset) {\r\n        return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\r\n    }\r\n    static getZoneAtCoord(context, mouseVerticalOffset) {\r\n        // The target is either a view zone or the empty space after the last view-line\r\n        const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\r\n        if (viewZoneWhitespace) {\r\n            const viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\r\n            const lineCount = context.model.getLineCount();\r\n            let positionBefore = null;\r\n            let position;\r\n            let positionAfter = null;\r\n            if (viewZoneWhitespace.afterLineNumber !== lineCount) {\r\n                // There are more lines after this view zone\r\n                positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\r\n            }\r\n            if (viewZoneWhitespace.afterLineNumber > 0) {\r\n                // There are more lines above this view zone\r\n                positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\r\n            }\r\n            if (positionAfter === null) {\r\n                position = positionBefore;\r\n            }\r\n            else if (positionBefore === null) {\r\n                position = positionAfter;\r\n            }\r\n            else if (mouseVerticalOffset < viewZoneMiddle) {\r\n                position = positionBefore;\r\n            }\r\n            else {\r\n                position = positionAfter;\r\n            }\r\n            return {\r\n                viewZoneId: viewZoneWhitespace.id,\r\n                afterLineNumber: viewZoneWhitespace.afterLineNumber,\r\n                positionBefore: positionBefore,\r\n                positionAfter: positionAfter,\r\n                position: position\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n    getFullLineRangeAtCoord(mouseVerticalOffset) {\r\n        if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\r\n            // Below the last line\r\n            const lineNumber = this._context.model.getLineCount();\r\n            const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\r\n            return {\r\n                range: new EditorRange(lineNumber, maxLineColumn, lineNumber, maxLineColumn),\r\n                isAfterLines: true\r\n            };\r\n        }\r\n        const lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\r\n        const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\r\n        return {\r\n            range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\r\n            isAfterLines: false\r\n        };\r\n    }\r\n    getLineNumberAtVerticalOffset(mouseVerticalOffset) {\r\n        return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\r\n    }\r\n    isAfterLines(mouseVerticalOffset) {\r\n        return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\r\n    }\r\n    isInTopPadding(mouseVerticalOffset) {\r\n        return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\r\n    }\r\n    isInBottomPadding(mouseVerticalOffset) {\r\n        return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\r\n    }\r\n    getVerticalOffsetForLineNumber(lineNumber) {\r\n        return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\r\n    }\r\n    findAttribute(element, attr) {\r\n        return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\r\n    }\r\n    static _findAttribute(element, attr, stopAt) {\r\n        while (element && element !== document.body) {\r\n            if (element.hasAttribute && element.hasAttribute(attr)) {\r\n                return element.getAttribute(attr);\r\n            }\r\n            if (element === stopAt) {\r\n                return null;\r\n            }\r\n            element = element.parentNode;\r\n        }\r\n        return null;\r\n    }\r\n    getLineWidth(lineNumber) {\r\n        return this._viewHelper.getLineWidth(lineNumber);\r\n    }\r\n    visibleRangeForPosition(lineNumber, column) {\r\n        return this._viewHelper.visibleRangeForPosition(lineNumber, column);\r\n    }\r\n    getPositionFromDOMInfo(spanNode, offset) {\r\n        return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\r\n    }\r\n    getCurrentScrollTop() {\r\n        return this._context.viewLayout.getCurrentScrollTop();\r\n    }\r\n    getCurrentScrollLeft() {\r\n        return this._context.viewLayout.getCurrentScrollLeft();\r\n    }\r\n}\r\nclass BareHitTestRequest {\r\n    constructor(ctx, editorPos, pos) {\r\n        this.editorPos = editorPos;\r\n        this.pos = pos;\r\n        this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + pos.y - editorPos.y);\r\n        this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + pos.x - editorPos.x - ctx.layoutInfo.contentLeft;\r\n        this.isInMarginArea = (pos.x - editorPos.x < ctx.layoutInfo.contentLeft && pos.x - editorPos.x >= ctx.layoutInfo.glyphMarginLeft);\r\n        this.isInContentArea = !this.isInMarginArea;\r\n        this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\r\n    }\r\n}\r\nclass HitTestRequest extends BareHitTestRequest {\r\n    constructor(ctx, editorPos, pos, target) {\r\n        super(ctx, editorPos, pos);\r\n        this._ctx = ctx;\r\n        if (target) {\r\n            this.target = target;\r\n            this.targetPath = PartFingerprints.collect(target, ctx.viewDomNode);\r\n        }\r\n        else {\r\n            this.target = null;\r\n            this.targetPath = new Uint8Array(0);\r\n        }\r\n    }\r\n    toString() {\r\n        return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}\\n\\ttarget: ${this.target ? this.target.outerHTML : null}`;\r\n    }\r\n    fulfill(type, position = null, range = null, detail = null) {\r\n        let mouseColumn = this.mouseColumn;\r\n        if (position && position.column < this._ctx.model.getLineMaxColumn(position.lineNumber)) {\r\n            // Most likely, the line contains foreign decorations...\r\n            mouseColumn = CursorColumns.visibleColumnFromColumn(this._ctx.model.getLineContent(position.lineNumber), position.column, this._ctx.model.getTextModelOptions().tabSize) + 1;\r\n        }\r\n        return new MouseTarget(this.target, type, mouseColumn, position, range, detail);\r\n    }\r\n    withTarget(target) {\r\n        return new HitTestRequest(this._ctx, this.editorPos, this.pos, target);\r\n    }\r\n}\r\nconst EMPTY_CONTENT_AFTER_LINES = { isAfterLines: true };\r\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\r\n    return {\r\n        isAfterLines: false,\r\n        horizontalDistanceToText: horizontalDistanceToText\r\n    };\r\n}\r\nexport class MouseTargetFactory {\r\n    constructor(context, viewHelper) {\r\n        this._context = context;\r\n        this._viewHelper = viewHelper;\r\n    }\r\n    mouseTargetIsWidget(e) {\r\n        const t = e.target;\r\n        const path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);\r\n        // Is it a content widget?\r\n        if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\r\n            return true;\r\n        }\r\n        // Is it an overlay widget?\r\n        if (ElementPath.isChildOfOverlayWidgets(path)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    createMouseTarget(lastRenderData, editorPos, pos, target) {\r\n        const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\r\n        const request = new HitTestRequest(ctx, editorPos, pos, target);\r\n        try {\r\n            const r = MouseTargetFactory._createMouseTarget(ctx, request, false);\r\n            // console.log(r.toString());\r\n            return r;\r\n        }\r\n        catch (err) {\r\n            // console.log(err);\r\n            return request.fulfill(0 /* UNKNOWN */);\r\n        }\r\n    }\r\n    static _createMouseTarget(ctx, request, domHitTestExecuted) {\r\n        // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\r\n        // First ensure the request has a target\r\n        if (request.target === null) {\r\n            if (domHitTestExecuted) {\r\n                // Still no target... and we have already executed hit test...\r\n                return request.fulfill(0 /* UNKNOWN */);\r\n            }\r\n            const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\r\n            if (hitTestResult.position) {\r\n                return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);\r\n            }\r\n            return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\r\n        }\r\n        // we know for a fact that request.target is not null\r\n        const resolvedRequest = request;\r\n        let result = null;\r\n        result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest, domHitTestExecuted);\r\n        result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\r\n        return (result || request.fulfill(0 /* UNKNOWN */));\r\n    }\r\n    static _hitTestContentWidget(ctx, request) {\r\n        // Is it a content widget?\r\n        if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\r\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\r\n            if (widgetId) {\r\n                return request.fulfill(9 /* CONTENT_WIDGET */, null, null, widgetId);\r\n            }\r\n            else {\r\n                return request.fulfill(0 /* UNKNOWN */);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestOverlayWidget(ctx, request) {\r\n        // Is it an overlay widget?\r\n        if (ElementPath.isChildOfOverlayWidgets(request.targetPath)) {\r\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\r\n            if (widgetId) {\r\n                return request.fulfill(12 /* OVERLAY_WIDGET */, null, null, widgetId);\r\n            }\r\n            else {\r\n                return request.fulfill(0 /* UNKNOWN */);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestViewCursor(ctx, request) {\r\n        if (request.target) {\r\n            // Check if we've hit a painted cursor\r\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\r\n            for (const d of lastViewCursorsRenderData) {\r\n                if (request.target === d.domNode) {\r\n                    return request.fulfill(6 /* CONTENT_TEXT */, d.position);\r\n                }\r\n            }\r\n        }\r\n        if (request.isInContentArea) {\r\n            // Edge has a bug when hit-testing the exact position of a cursor,\r\n            // instead of returning the correct dom node, it returns the\r\n            // first or last rendered view line dom node, therefore help it out\r\n            // and first check if we are on top of a cursor\r\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\r\n            const mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\r\n            const mouseVerticalOffset = request.mouseVerticalOffset;\r\n            for (const d of lastViewCursorsRenderData) {\r\n                if (mouseContentHorizontalOffset < d.contentLeft) {\r\n                    // mouse position is to the left of the cursor\r\n                    continue;\r\n                }\r\n                if (mouseContentHorizontalOffset > d.contentLeft + d.width) {\r\n                    // mouse position is to the right of the cursor\r\n                    continue;\r\n                }\r\n                const cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);\r\n                if (cursorVerticalOffset <= mouseVerticalOffset\r\n                    && mouseVerticalOffset <= cursorVerticalOffset + d.height) {\r\n                    return request.fulfill(6 /* CONTENT_TEXT */, d.position);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestViewZone(ctx, request) {\r\n        const viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\r\n        if (viewZoneData) {\r\n            const mouseTargetType = (request.isInContentArea ? 8 /* CONTENT_VIEW_ZONE */ : 5 /* GUTTER_VIEW_ZONE */);\r\n            return request.fulfill(mouseTargetType, viewZoneData.position, null, viewZoneData);\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestTextArea(ctx, request) {\r\n        // Is it the textarea?\r\n        if (ElementPath.isTextArea(request.targetPath)) {\r\n            if (ctx.lastRenderData.lastTextareaPosition) {\r\n                return request.fulfill(6 /* CONTENT_TEXT */, ctx.lastRenderData.lastTextareaPosition);\r\n            }\r\n            return request.fulfill(1 /* TEXTAREA */, ctx.lastRenderData.lastTextareaPosition);\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestMargin(ctx, request) {\r\n        if (request.isInMarginArea) {\r\n            const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\r\n            const pos = res.range.getStartPosition();\r\n            let offset = Math.abs(request.pos.x - request.editorPos.x);\r\n            const detail = {\r\n                isAfterLines: res.isAfterLines,\r\n                glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\r\n                glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\r\n                lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\r\n                offsetX: offset\r\n            };\r\n            offset -= ctx.layoutInfo.glyphMarginLeft;\r\n            if (offset <= ctx.layoutInfo.glyphMarginWidth) {\r\n                // On the glyph margin\r\n                return request.fulfill(2 /* GUTTER_GLYPH_MARGIN */, pos, res.range, detail);\r\n            }\r\n            offset -= ctx.layoutInfo.glyphMarginWidth;\r\n            if (offset <= ctx.layoutInfo.lineNumbersWidth) {\r\n                // On the line numbers\r\n                return request.fulfill(3 /* GUTTER_LINE_NUMBERS */, pos, res.range, detail);\r\n            }\r\n            offset -= ctx.layoutInfo.lineNumbersWidth;\r\n            // On the line decorations\r\n            return request.fulfill(4 /* GUTTER_LINE_DECORATIONS */, pos, res.range, detail);\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestViewLines(ctx, request, domHitTestExecuted) {\r\n        if (!ElementPath.isChildOfViewLines(request.targetPath)) {\r\n            return null;\r\n        }\r\n        if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\r\n            return request.fulfill(7 /* CONTENT_EMPTY */, new Position(1, 1), undefined, EMPTY_CONTENT_AFTER_LINES);\r\n        }\r\n        // Check if it is below any lines and any view zones\r\n        if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\r\n            // This most likely indicates it happened after the last view-line\r\n            const lineCount = ctx.model.getLineCount();\r\n            const maxLineColumn = ctx.model.getLineMaxColumn(lineCount);\r\n            return request.fulfill(7 /* CONTENT_EMPTY */, new Position(lineCount, maxLineColumn), undefined, EMPTY_CONTENT_AFTER_LINES);\r\n        }\r\n        if (domHitTestExecuted) {\r\n            // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\r\n            // See https://github.com/microsoft/vscode/issues/46942\r\n            if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\r\n                const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\r\n                if (ctx.model.getLineLength(lineNumber) === 0) {\r\n                    const lineWidth = ctx.getLineWidth(lineNumber);\r\n                    const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\r\n                    return request.fulfill(7 /* CONTENT_EMPTY */, new Position(lineNumber, 1), undefined, detail);\r\n                }\r\n                const lineWidth = ctx.getLineWidth(lineNumber);\r\n                if (request.mouseContentHorizontalOffset >= lineWidth) {\r\n                    const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\r\n                    const pos = new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber));\r\n                    return request.fulfill(7 /* CONTENT_EMPTY */, pos, undefined, detail);\r\n                }\r\n            }\r\n            // We have already executed hit test...\r\n            return request.fulfill(0 /* UNKNOWN */);\r\n        }\r\n        const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\r\n        if (hitTestResult.position) {\r\n            return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);\r\n        }\r\n        return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\r\n    }\r\n    static _hitTestMinimap(ctx, request) {\r\n        if (ElementPath.isChildOfMinimap(request.targetPath)) {\r\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\r\n            const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\r\n            return request.fulfill(11 /* SCROLLBAR */, new Position(possibleLineNumber, maxColumn));\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestScrollbarSlider(ctx, request) {\r\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\r\n            if (request.target && request.target.nodeType === 1) {\r\n                const className = request.target.className;\r\n                if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\r\n                    const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\r\n                    const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\r\n                    return request.fulfill(11 /* SCROLLBAR */, new Position(possibleLineNumber, maxColumn));\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestScrollbar(ctx, request) {\r\n        // Is it the overview ruler?\r\n        // Is it a child of the scrollable element?\r\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\r\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\r\n            const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\r\n            return request.fulfill(11 /* SCROLLBAR */, new Position(possibleLineNumber, maxColumn));\r\n        }\r\n        return null;\r\n    }\r\n    getMouseColumn(editorPos, pos) {\r\n        const options = this._context.configuration.options;\r\n        const layoutInfo = options.get(124 /* layoutInfo */);\r\n        const mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + pos.x - editorPos.x - layoutInfo.contentLeft;\r\n        return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(38 /* fontInfo */).typicalHalfwidthCharacterWidth);\r\n    }\r\n    static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\r\n        if (mouseContentHorizontalOffset < 0) {\r\n            return 1;\r\n        }\r\n        const chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\r\n        return (chars + 1);\r\n    }\r\n    static createMouseTargetFromHitTestPosition(ctx, request, lineNumber, column) {\r\n        const pos = new Position(lineNumber, column);\r\n        const lineWidth = ctx.getLineWidth(lineNumber);\r\n        if (request.mouseContentHorizontalOffset > lineWidth) {\r\n            if (browser.isEdgeLegacy && pos.column === 1) {\r\n                // See https://github.com/microsoft/vscode/issues/10875\r\n                const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\r\n                return request.fulfill(7 /* CONTENT_EMPTY */, new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber)), undefined, detail);\r\n            }\r\n            const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\r\n            return request.fulfill(7 /* CONTENT_EMPTY */, pos, undefined, detail);\r\n        }\r\n        const visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\r\n        if (!visibleRange) {\r\n            return request.fulfill(0 /* UNKNOWN */, pos);\r\n        }\r\n        const columnHorizontalOffset = visibleRange.left;\r\n        if (request.mouseContentHorizontalOffset === columnHorizontalOffset) {\r\n            return request.fulfill(6 /* CONTENT_TEXT */, pos);\r\n        }\r\n        const points = [];\r\n        points.push({ offset: visibleRange.left, column: column });\r\n        if (column > 1) {\r\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\r\n            if (visibleRange) {\r\n                points.push({ offset: visibleRange.left, column: column - 1 });\r\n            }\r\n        }\r\n        const lineMaxColumn = ctx.model.getLineMaxColumn(lineNumber);\r\n        if (column < lineMaxColumn) {\r\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column + 1);\r\n            if (visibleRange) {\r\n                points.push({ offset: visibleRange.left, column: column + 1 });\r\n            }\r\n        }\r\n        points.sort((a, b) => a.offset - b.offset);\r\n        for (let i = 1; i < points.length; i++) {\r\n            const prev = points[i - 1];\r\n            const curr = points[i];\r\n            if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\r\n                const rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\r\n                return request.fulfill(6 /* CONTENT_TEXT */, pos, rng);\r\n            }\r\n        }\r\n        return request.fulfill(6 /* CONTENT_TEXT */, pos);\r\n    }\r\n    /**\r\n     * Most probably WebKit browsers and Edge\r\n     */\r\n    static _doHitTestWithCaretRangeFromPoint(ctx, request) {\r\n        // In Chrome, especially on Linux it is possible to click between lines,\r\n        // so try to adjust the `hity` below so that it lands in the center of a line\r\n        const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\r\n        const lineVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\r\n        const lineCenteredVerticalOffset = lineVerticalOffset + Math.floor(ctx.lineHeight / 2);\r\n        let adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\r\n        if (adjustedPageY <= request.editorPos.y) {\r\n            adjustedPageY = request.editorPos.y + 1;\r\n        }\r\n        if (adjustedPageY >= request.editorPos.y + ctx.layoutInfo.height) {\r\n            adjustedPageY = request.editorPos.y + ctx.layoutInfo.height - 1;\r\n        }\r\n        const adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\r\n        const r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates());\r\n        if (r.position) {\r\n            return r;\r\n        }\r\n        // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\r\n        return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates());\r\n    }\r\n    static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\r\n        const shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\r\n        let range;\r\n        if (shadowRoot) {\r\n            if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\r\n                range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\r\n            }\r\n            else {\r\n                range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\r\n            }\r\n        }\r\n        else {\r\n            range = document.caretRangeFromPoint(coords.clientX, coords.clientY);\r\n        }\r\n        if (!range || !range.startContainer) {\r\n            return {\r\n                position: null,\r\n                hitTarget: null\r\n            };\r\n        }\r\n        // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\r\n        const startContainer = range.startContainer;\r\n        let hitTarget = null;\r\n        if (startContainer.nodeType === startContainer.TEXT_NODE) {\r\n            // startContainer is expected to be the token text\r\n            const parent1 = startContainer.parentNode; // expected to be the token span\r\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\r\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\r\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\r\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\r\n                const p = ctx.getPositionFromDOMInfo(parent1, range.startOffset);\r\n                return {\r\n                    position: p,\r\n                    hitTarget: null\r\n                };\r\n            }\r\n            else {\r\n                hitTarget = startContainer.parentNode;\r\n            }\r\n        }\r\n        else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\r\n            // startContainer is expected to be the token span\r\n            const parent1 = startContainer.parentNode; // expected to be the view line container span\r\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div\r\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\r\n            if (parent2ClassName === ViewLine.CLASS_NAME) {\r\n                const p = ctx.getPositionFromDOMInfo(startContainer, startContainer.textContent.length);\r\n                return {\r\n                    position: p,\r\n                    hitTarget: null\r\n                };\r\n            }\r\n            else {\r\n                hitTarget = startContainer;\r\n            }\r\n        }\r\n        return {\r\n            position: null,\r\n            hitTarget: hitTarget\r\n        };\r\n    }\r\n    /**\r\n     * Most probably Gecko\r\n     */\r\n    static _doHitTestWithCaretPositionFromPoint(ctx, coords) {\r\n        const hitResult = document.caretPositionFromPoint(coords.clientX, coords.clientY);\r\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\r\n            // offsetNode is expected to be the token text\r\n            const parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\r\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\r\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\r\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\r\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\r\n                const p = ctx.getPositionFromDOMInfo(hitResult.offsetNode.parentNode, hitResult.offset);\r\n                return {\r\n                    position: p,\r\n                    hitTarget: null\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    position: null,\r\n                    hitTarget: hitResult.offsetNode.parentNode\r\n                };\r\n            }\r\n        }\r\n        // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\r\n        // Some other times, it returns the `<span>` with the inline decoration\r\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\r\n            const parent1 = hitResult.offsetNode.parentNode;\r\n            const parent1ClassName = parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null;\r\n            const parent2 = parent1 ? parent1.parentNode : null;\r\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\r\n            if (parent1ClassName === ViewLine.CLASS_NAME) {\r\n                // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\r\n                const tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\r\n                if (tokenSpan) {\r\n                    const p = ctx.getPositionFromDOMInfo(tokenSpan, 0);\r\n                    return {\r\n                        position: p,\r\n                        hitTarget: null\r\n                    };\r\n                }\r\n            }\r\n            else if (parent2ClassName === ViewLine.CLASS_NAME) {\r\n                // it returned the `<span>` with the inline decoration\r\n                const p = ctx.getPositionFromDOMInfo(hitResult.offsetNode, 0);\r\n                return {\r\n                    position: p,\r\n                    hitTarget: null\r\n                };\r\n            }\r\n        }\r\n        return {\r\n            position: null,\r\n            hitTarget: hitResult.offsetNode\r\n        };\r\n    }\r\n    /**\r\n     * Most probably IE\r\n     */\r\n    static _doHitTestWithMoveToPoint(ctx, coords) {\r\n        let resultPosition = null;\r\n        let resultHitTarget = null;\r\n        const textRange = document.body.createTextRange();\r\n        try {\r\n            textRange.moveToPoint(coords.clientX, coords.clientY);\r\n        }\r\n        catch (err) {\r\n            return {\r\n                position: null,\r\n                hitTarget: null\r\n            };\r\n        }\r\n        textRange.collapse(true);\r\n        // Now, let's do our best to figure out what we hit :)\r\n        const parentElement = textRange ? textRange.parentElement() : null;\r\n        const parent1 = parentElement ? parentElement.parentNode : null;\r\n        const parent2 = parent1 ? parent1.parentNode : null;\r\n        const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : '';\r\n        if (parent2ClassName === ViewLine.CLASS_NAME) {\r\n            const rangeToContainEntireSpan = textRange.duplicate();\r\n            rangeToContainEntireSpan.moveToElementText(parentElement);\r\n            rangeToContainEntireSpan.setEndPoint('EndToStart', textRange);\r\n            resultPosition = ctx.getPositionFromDOMInfo(parentElement, rangeToContainEntireSpan.text.length);\r\n            // Move range out of the span node, IE doesn't like having many ranges in\r\n            // the same spot and will act badly for lines containing dashes ('-')\r\n            rangeToContainEntireSpan.moveToElementText(ctx.viewDomNode);\r\n        }\r\n        else {\r\n            // Looks like we've hit the hover or something foreign\r\n            resultHitTarget = parentElement;\r\n        }\r\n        // Move range out of the span node, IE doesn't like having many ranges in\r\n        // the same spot and will act badly for lines containing dashes ('-')\r\n        textRange.moveToElementText(ctx.viewDomNode);\r\n        return {\r\n            position: resultPosition,\r\n            hitTarget: resultHitTarget\r\n        };\r\n    }\r\n    static _snapToSoftTabBoundary(position, viewModel) {\r\n        const lineContent = viewModel.getLineContent(position.lineNumber);\r\n        const { tabSize } = viewModel.getTextModelOptions();\r\n        const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2 /* Nearest */);\r\n        if (newPosition !== -1) {\r\n            return new Position(position.lineNumber, newPosition + 1);\r\n        }\r\n        return position;\r\n    }\r\n    static _doHitTest(ctx, request) {\r\n        // State of the art (18.10.2012):\r\n        // The spec says browsers should support document.caretPositionFromPoint, but nobody implemented it (http://dev.w3.org/csswg/cssom-view/)\r\n        // Gecko:\r\n        //    - they tried to implement it once, but failed: https://bugzilla.mozilla.org/show_bug.cgi?id=654352\r\n        //    - however, they do give out rangeParent/rangeOffset properties on mouse events\r\n        // Webkit:\r\n        //    - they have implemented a previous version of the spec which was using document.caretRangeFromPoint\r\n        // IE:\r\n        //    - they have a proprietary method on ranges, moveToPoint: https://msdn.microsoft.com/en-us/library/ie/ms536632(v=vs.85).aspx\r\n        // 24.08.2016: Edge has added WebKit's document.caretRangeFromPoint, but it is quite buggy\r\n        //    - when hit testing the cursor it returns the first or the last line in the viewport\r\n        //    - it inconsistently hits text nodes or span nodes, while WebKit only hits text nodes\r\n        //    - when toggling render whitespace on, and hit testing in the empty content after a line, it always hits offset 0 of the first span of the line\r\n        // Thank you browsers for making this so 'easy' :)\r\n        let result;\r\n        if (typeof document.caretRangeFromPoint === 'function') {\r\n            result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\r\n        }\r\n        else if (document.caretPositionFromPoint) {\r\n            result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates());\r\n        }\r\n        else if (document.body.createTextRange) {\r\n            result = this._doHitTestWithMoveToPoint(ctx, request.pos.toClientCoordinates());\r\n        }\r\n        else {\r\n            result = {\r\n                position: null,\r\n                hitTarget: null\r\n            };\r\n        }\r\n        // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\r\n        if (result.position && ctx.stickyTabStops) {\r\n            result.position = this._snapToSoftTabBoundary(result.position, ctx.model);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexport function shadowCaretRangeFromPoint(shadowRoot, x, y) {\r\n    const range = document.createRange();\r\n    // Get the element under the point\r\n    let el = shadowRoot.elementFromPoint(x, y);\r\n    if (el !== null) {\r\n        // Get the last child of the element until its firstChild is a text node\r\n        // This assumes that the pointer is on the right of the line, out of the tokens\r\n        // and that we want to get the offset of the last token of the line\r\n        while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\r\n            el = el.lastChild;\r\n        }\r\n        // Grab its rect\r\n        const rect = el.getBoundingClientRect();\r\n        // And its font\r\n        const font = window.getComputedStyle(el, null).getPropertyValue('font');\r\n        // And also its txt content\r\n        const text = el.innerText;\r\n        // Position the pixel cursor at the left of the element\r\n        let pixelCursor = rect.left;\r\n        let offset = 0;\r\n        let step;\r\n        // If the point is on the right of the box put the cursor after the last character\r\n        if (x > rect.left + rect.width) {\r\n            offset = text.length;\r\n        }\r\n        else {\r\n            const charWidthReader = CharWidthReader.getInstance();\r\n            // Goes through all the characters of the innerText, and checks if the x of the point\r\n            // belongs to the character.\r\n            for (let i = 0; i < text.length + 1; i++) {\r\n                // The step is half the width of the character\r\n                step = charWidthReader.getCharWidth(text.charAt(i), font) / 2;\r\n                // Move to the center of the character\r\n                pixelCursor += step;\r\n                // If the x of the point is smaller that the position of the cursor, the point is over that character\r\n                if (x < pixelCursor) {\r\n                    offset = i;\r\n                    break;\r\n                }\r\n                // Move between the current character and the next\r\n                pixelCursor += step;\r\n            }\r\n        }\r\n        // Creates a range with the text node of the element and set the offset found\r\n        range.setStart(el.firstChild, offset);\r\n        range.setEnd(el.firstChild, offset);\r\n    }\r\n    return range;\r\n}\r\nclass CharWidthReader {\r\n    constructor() {\r\n        this._cache = {};\r\n        this._canvas = document.createElement('canvas');\r\n    }\r\n    static getInstance() {\r\n        if (!CharWidthReader._INSTANCE) {\r\n            CharWidthReader._INSTANCE = new CharWidthReader();\r\n        }\r\n        return CharWidthReader._INSTANCE;\r\n    }\r\n    getCharWidth(char, font) {\r\n        const cacheKey = char + font;\r\n        if (this._cache[cacheKey]) {\r\n            return this._cache[cacheKey];\r\n        }\r\n        const context = this._canvas.getContext('2d');\r\n        context.font = font;\r\n        const metrics = context.measureText(char);\r\n        const width = metrics.width;\r\n        this._cache[cacheKey] = width;\r\n        return width;\r\n    }\r\n}\r\nCharWidthReader._INSTANCE = null;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}