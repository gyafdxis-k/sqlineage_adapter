{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { createStringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nclass LinePart {\n  constructor(endIndex, type, metadata) {\n    this.endIndex = endIndex;\n    this.type = type;\n    this.metadata = metadata;\n  }\n  isWhitespace() {\n    return this.metadata & 1 /* IS_WHITESPACE_MASK */ ? true : false;\n  }\n}\nexport class LineRange {\n  constructor(startIndex, endIndex) {\n    this.startOffset = startIndex;\n    this.endOffset = endIndex;\n  }\n  equals(otherLineRange) {\n    return this.startOffset === otherLineRange.startOffset && this.endOffset === otherLineRange.endOffset;\n  }\n}\nexport class RenderLineInput {\n  constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n    this.useMonospaceOptimizations = useMonospaceOptimizations;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.continuesWithWrappedLine = continuesWithWrappedLine;\n    this.isBasicASCII = isBasicASCII;\n    this.containsRTL = containsRTL;\n    this.fauxIndentLength = fauxIndentLength;\n    this.lineTokens = lineTokens;\n    this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n    this.spaceWidth = spaceWidth;\n    this.stopRenderingLineAfter = stopRenderingLineAfter;\n    this.renderWhitespace = renderWhitespace === 'all' ? 4 /* All */ : renderWhitespace === 'boundary' ? 1 /* Boundary */ : renderWhitespace === 'selection' ? 2 /* Selection */ : renderWhitespace === 'trailing' ? 3 /* Trailing */ : 0 /* None */;\n    this.renderControlCharacters = renderControlCharacters;\n    this.fontLigatures = fontLigatures;\n    this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n    const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n    const middotDiff = Math.abs(middotWidth - spaceWidth);\n    if (wsmiddotDiff < middotDiff) {\n      this.renderSpaceWidth = wsmiddotWidth;\n      this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n    } else {\n      this.renderSpaceWidth = middotWidth;\n      this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n    }\n  }\n\n  sameSelection(otherSelections) {\n    if (this.selectionsOnLine === null) {\n      return otherSelections === null;\n    }\n    if (otherSelections === null) {\n      return false;\n    }\n    if (otherSelections.length !== this.selectionsOnLine.length) {\n      return false;\n    }\n    for (let i = 0; i < this.selectionsOnLine.length; i++) {\n      if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  equals(other) {\n    return this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineContent === other.lineContent && this.continuesWithWrappedLine === other.continuesWithWrappedLine && this.isBasicASCII === other.isBasicASCII && this.containsRTL === other.containsRTL && this.fauxIndentLength === other.fauxIndentLength && this.tabSize === other.tabSize && this.startVisibleColumn === other.startVisibleColumn && this.spaceWidth === other.spaceWidth && this.renderSpaceWidth === other.renderSpaceWidth && this.renderSpaceCharCode === other.renderSpaceCharCode && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.fontLigatures === other.fontLigatures && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations) && this.lineTokens.equals(other.lineTokens) && this.sameSelection(other.selectionsOnLine);\n  }\n}\n/**\r\n * Provides a both direction mapping between a line's character and its rendered position.\r\n */\nexport class CharacterMapping {\n  constructor(length, partCount) {\n    this.length = length;\n    this._data = new Uint32Array(this.length);\n    this._absoluteOffsets = new Uint32Array(this.length);\n  }\n  static getPartIndex(partData) {\n    return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;\n  }\n\n  static getCharIndex(partData) {\n    return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;\n  }\n\n  setPartData(charOffset, partIndex, charIndex, partAbsoluteOffset) {\n    let partData = (partIndex << 16 /* PART_INDEX_OFFSET */ | charIndex << 0 /* CHAR_INDEX_OFFSET */) >>> 0;\n    this._data[charOffset] = partData;\n    this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\n  }\n  getAbsoluteOffsets() {\n    return this._absoluteOffsets;\n  }\n  charOffsetToPartData(charOffset) {\n    if (this.length === 0) {\n      return 0;\n    }\n    if (charOffset < 0) {\n      return this._data[0];\n    }\n    if (charOffset >= this.length) {\n      return this._data[this.length - 1];\n    }\n    return this._data[charOffset];\n  }\n  partDataToCharOffset(partIndex, partLength, charIndex) {\n    if (this.length === 0) {\n      return 0;\n    }\n    let searchEntry = (partIndex << 16 /* PART_INDEX_OFFSET */ | charIndex << 0 /* CHAR_INDEX_OFFSET */) >>> 0;\n    let min = 0;\n    let max = this.length - 1;\n    while (min + 1 < max) {\n      let mid = min + max >>> 1;\n      let midEntry = this._data[mid];\n      if (midEntry === searchEntry) {\n        return mid;\n      } else if (midEntry > searchEntry) {\n        max = mid;\n      } else {\n        min = mid;\n      }\n    }\n    if (min === max) {\n      return min;\n    }\n    let minEntry = this._data[min];\n    let maxEntry = this._data[max];\n    if (minEntry === searchEntry) {\n      return min;\n    }\n    if (maxEntry === searchEntry) {\n      return max;\n    }\n    let minPartIndex = CharacterMapping.getPartIndex(minEntry);\n    let minCharIndex = CharacterMapping.getCharIndex(minEntry);\n    let maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n    let maxCharIndex;\n    if (minPartIndex !== maxPartIndex) {\n      // sitting between parts\n      maxCharIndex = partLength;\n    } else {\n      maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n    }\n    let minEntryDistance = charIndex - minCharIndex;\n    let maxEntryDistance = maxCharIndex - charIndex;\n    if (minEntryDistance <= maxEntryDistance) {\n      return min;\n    }\n    return max;\n  }\n}\nexport class RenderLineOutput {\n  constructor(characterMapping, containsRTL, containsForeignElements) {\n    this.characterMapping = characterMapping;\n    this.containsRTL = containsRTL;\n    this.containsForeignElements = containsForeignElements;\n  }\n}\nexport function renderViewLine(input, sb) {\n  if (input.lineContent.length === 0) {\n    let containsForeignElements = 0 /* None */;\n    let content = '<span><span></span></span>';\n    if (input.lineDecorations.length > 0) {\n      // This line is empty, but it contains inline decorations\n      const beforeClassNames = [];\n      const afterClassNames = [];\n      for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n        const lineDecoration = input.lineDecorations[i];\n        if (lineDecoration.type === 1 /* Before */) {\n          beforeClassNames.push(input.lineDecorations[i].className);\n          containsForeignElements |= 1 /* Before */;\n        }\n\n        if (lineDecoration.type === 2 /* After */) {\n          afterClassNames.push(input.lineDecorations[i].className);\n          containsForeignElements |= 2 /* After */;\n        }\n      }\n\n      if (containsForeignElements !== 0 /* None */) {\n        const beforeSpan = beforeClassNames.length > 0 ? \"<span class=\\\"\".concat(beforeClassNames.join(' '), \"\\\"></span>\") : \"\";\n        const afterSpan = afterClassNames.length > 0 ? \"<span class=\\\"\".concat(afterClassNames.join(' '), \"\\\"></span>\") : \"\";\n        content = \"<span>\".concat(beforeSpan).concat(afterSpan, \"</span>\");\n      }\n    }\n    sb.appendASCIIString(content);\n    return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);\n  }\n  return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n  constructor(characterMapping, html, containsRTL, containsForeignElements) {\n    this.characterMapping = characterMapping;\n    this.html = html;\n    this.containsRTL = containsRTL;\n    this.containsForeignElements = containsForeignElements;\n  }\n}\nexport function renderViewLine2(input) {\n  let sb = createStringBuilder(10000);\n  let out = renderViewLine(input, sb);\n  return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n  constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n    this.fontIsMonospace = fontIsMonospace;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.len = len;\n    this.isOverflowing = isOverflowing;\n    this.parts = parts;\n    this.containsForeignElements = containsForeignElements;\n    this.fauxIndentLength = fauxIndentLength;\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n    this.containsRTL = containsRTL;\n    this.spaceWidth = spaceWidth;\n    this.renderSpaceCharCode = renderSpaceCharCode;\n    this.renderWhitespace = renderWhitespace;\n    this.renderControlCharacters = renderControlCharacters;\n    //\n  }\n}\n\nfunction resolveRenderLineInput(input) {\n  const lineContent = input.lineContent;\n  let isOverflowing;\n  let len;\n  if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n    isOverflowing = true;\n    len = input.stopRenderingLineAfter;\n  } else {\n    isOverflowing = false;\n    len = lineContent.length;\n  }\n  let tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n  if (input.renderWhitespace === 4 /* All */ || input.renderWhitespace === 1 /* Boundary */ || input.renderWhitespace === 2 /* Selection */ && !!input.selectionsOnLine || input.renderWhitespace === 3 /* Trailing */) {\n    tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n  }\n  let containsForeignElements = 0 /* None */;\n  if (input.lineDecorations.length > 0) {\n    for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n      const lineDecoration = input.lineDecorations[i];\n      if (lineDecoration.type === 3 /* RegularAffectingLetterSpacing */) {\n        // Pretend there are foreign elements... although not 100% accurate.\n        containsForeignElements |= 1 /* Before */;\n      } else if (lineDecoration.type === 1 /* Before */) {\n        containsForeignElements |= 1 /* Before */;\n      } else if (lineDecoration.type === 2 /* After */) {\n        containsForeignElements |= 2 /* After */;\n      }\n    }\n\n    tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n  }\n  if (!input.containsRTL) {\n    // We can never split RTL text, as it ruins the rendering\n    tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n  }\n  return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\r\n * In the rendering phase, characters are always looped until token.endIndex.\r\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\r\n */\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\n  let result = [],\n    resultLen = 0;\n  // The faux indent part of the line should have no token type\n  if (fauxIndentLength > 0) {\n    result[resultLen++] = new LinePart(fauxIndentLength, '', 0);\n  }\n  for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n    const endIndex = tokens.getEndOffset(tokenIndex);\n    if (endIndex <= fauxIndentLength) {\n      // The faux indent part of the line should have no token type\n      continue;\n    }\n    const type = tokens.getClassName(tokenIndex);\n    if (endIndex >= len) {\n      result[resultLen++] = new LinePart(len, type, 0);\n      break;\n    }\n    result[resultLen++] = new LinePart(endIndex, type, 0);\n  }\n  return result;\n}\n/**\r\n * See https://github.com/microsoft/vscode/issues/6885.\r\n * It appears that having very large spans causes very slow reading of character positions.\r\n * So here we try to avoid that.\r\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n  let lastTokenEndIndex = 0;\n  let result = [],\n    resultLen = 0;\n  if (onlyAtSpaces) {\n    // Split only at spaces => we need to walk each character\n    for (let i = 0, len = tokens.length; i < len; i++) {\n      const token = tokens[i];\n      const tokenEndIndex = token.endIndex;\n      if (lastTokenEndIndex + 50 /* LongToken */ < tokenEndIndex) {\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        let lastSpaceOffset = -1;\n        let currTokenStart = lastTokenEndIndex;\n        for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n          if (lineContent.charCodeAt(j) === 32 /* Space */) {\n            lastSpaceOffset = j;\n          }\n          if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* LongToken */) {\n            // Split at `lastSpaceOffset` + 1\n            result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata);\n            currTokenStart = lastSpaceOffset + 1;\n            lastSpaceOffset = -1;\n          }\n        }\n        if (currTokenStart !== tokenEndIndex) {\n          result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n        }\n      } else {\n        result[resultLen++] = token;\n      }\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  } else {\n    // Split anywhere => we don't need to walk each character\n    for (let i = 0, len = tokens.length; i < len; i++) {\n      const token = tokens[i];\n      const tokenEndIndex = token.endIndex;\n      let diff = tokenEndIndex - lastTokenEndIndex;\n      if (diff > 50 /* LongToken */) {\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        const piecesCount = Math.ceil(diff / 50 /* LongToken */);\n        for (let j = 1; j < piecesCount; j++) {\n          let pieceEndIndex = lastTokenEndIndex + j * 50 /* LongToken */;\n          result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata);\n        }\n        result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n      } else {\n        result[resultLen++] = token;\n      }\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  }\n  return result;\n}\n/**\r\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\r\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\r\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\r\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n  const continuesWithWrappedLine = input.continuesWithWrappedLine;\n  const fauxIndentLength = input.fauxIndentLength;\n  const tabSize = input.tabSize;\n  const startVisibleColumn = input.startVisibleColumn;\n  const useMonospaceOptimizations = input.useMonospaceOptimizations;\n  const selections = input.selectionsOnLine;\n  const onlyBoundary = input.renderWhitespace === 1 /* Boundary */;\n  const onlyTrailing = input.renderWhitespace === 3 /* Trailing */;\n  const generateLinePartForEachWhitespace = input.renderSpaceWidth !== input.spaceWidth;\n  let result = [],\n    resultLen = 0;\n  let tokenIndex = 0;\n  let tokenType = tokens[tokenIndex].type;\n  let tokenEndIndex = tokens[tokenIndex].endIndex;\n  const tokensLength = tokens.length;\n  let lineIsEmptyOrWhitespace = false;\n  let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n  let lastNonWhitespaceIndex;\n  if (firstNonWhitespaceIndex === -1) {\n    lineIsEmptyOrWhitespace = true;\n    firstNonWhitespaceIndex = len;\n    lastNonWhitespaceIndex = len;\n  } else {\n    lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n  }\n  let wasInWhitespace = false;\n  let currentSelectionIndex = 0;\n  let currentSelection = selections && selections[currentSelectionIndex];\n  let tmpIndent = startVisibleColumn % tabSize;\n  for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n    const chCode = lineContent.charCodeAt(charIndex);\n    if (currentSelection && charIndex >= currentSelection.endOffset) {\n      currentSelectionIndex++;\n      currentSelection = selections && selections[currentSelectionIndex];\n    }\n    let isInWhitespace;\n    if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n      // in leading or trailing whitespace\n      isInWhitespace = true;\n    } else if (chCode === 9 /* Tab */) {\n      // a tab character is rendered both in all and boundary cases\n      isInWhitespace = true;\n    } else if (chCode === 32 /* Space */) {\n      // hit a space character\n      if (onlyBoundary) {\n        // rendering only boundary whitespace\n        if (wasInWhitespace) {\n          isInWhitespace = true;\n        } else {\n          const nextChCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */;\n          isInWhitespace = nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */;\n        }\n      } else {\n        isInWhitespace = true;\n      }\n    } else {\n      isInWhitespace = false;\n    }\n    // If rendering whitespace on selection, check that the charIndex falls within a selection\n    if (isInWhitespace && selections) {\n      isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n    }\n    // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n    if (isInWhitespace && onlyTrailing) {\n      isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n    }\n    if (wasInWhitespace) {\n      // was in whitespace token\n      if (!isInWhitespace || !useMonospaceOptimizations && tmpIndent >= tabSize) {\n        // leaving whitespace token or entering a new indent\n        if (generateLinePartForEachWhitespace) {\n          const lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;\n          for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n            result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\n          }\n        } else {\n          result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* IS_WHITESPACE */);\n        }\n\n        tmpIndent = tmpIndent % tabSize;\n      }\n    } else {\n      // was in regular token\n      if (charIndex === tokenEndIndex || isInWhitespace && charIndex > fauxIndentLength) {\n        result[resultLen++] = new LinePart(charIndex, tokenType, 0);\n        tmpIndent = tmpIndent % tabSize;\n      }\n    }\n    if (chCode === 9 /* Tab */) {\n      tmpIndent = tabSize;\n    } else if (strings.isFullWidthCharacter(chCode)) {\n      tmpIndent += 2;\n    } else {\n      tmpIndent++;\n    }\n    wasInWhitespace = isInWhitespace;\n    while (charIndex === tokenEndIndex) {\n      tokenIndex++;\n      if (tokenIndex < tokensLength) {\n        tokenType = tokens[tokenIndex].type;\n        tokenEndIndex = tokens[tokenIndex].endIndex;\n      }\n    }\n  }\n  let generateWhitespace = false;\n  if (wasInWhitespace) {\n    // was in whitespace token\n    if (continuesWithWrappedLine && onlyBoundary) {\n      let lastCharCode = len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* Null */;\n      let prevCharCode = len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* Null */;\n      let isSingleTrailingSpace = lastCharCode === 32 /* Space */ && prevCharCode !== 32 /* Space */ && prevCharCode !== 9 /* Tab */;\n      if (!isSingleTrailingSpace) {\n        generateWhitespace = true;\n      }\n    } else {\n      generateWhitespace = true;\n    }\n  }\n  if (generateWhitespace) {\n    if (generateLinePartForEachWhitespace) {\n      const lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;\n      for (let i = lastEndIndex + 1; i <= len; i++) {\n        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\n      }\n    } else {\n      result[resultLen++] = new LinePart(len, 'mtkw', 1 /* IS_WHITESPACE */);\n    }\n  } else {\n    result[resultLen++] = new LinePart(len, tokenType, 0);\n  }\n  return result;\n}\n/**\r\n * Inline decorations are \"merged\" on top of tokens.\r\n * Special care must be taken when multiple inline decorations are at play and they overlap.\r\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n  _lineDecorations.sort(LineDecoration.compare);\n  const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n  const lineDecorationsLen = lineDecorations.length;\n  let lineDecorationIndex = 0;\n  let result = [],\n    resultLen = 0,\n    lastResultEndIndex = 0;\n  for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n    const token = tokens[tokenIndex];\n    const tokenEndIndex = token.endIndex;\n    const tokenType = token.type;\n    const tokenMetadata = token.metadata;\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n      const lineDecoration = lineDecorations[lineDecorationIndex];\n      if (lineDecoration.startOffset > lastResultEndIndex) {\n        lastResultEndIndex = lineDecoration.startOffset;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n      }\n      if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n        // This line decoration ends before this token ends\n        lastResultEndIndex = lineDecoration.endOffset + 1;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n        lineDecorationIndex++;\n      } else {\n        // This line decoration continues on to the next token\n        lastResultEndIndex = tokenEndIndex;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n        break;\n      }\n    }\n    if (tokenEndIndex > lastResultEndIndex) {\n      lastResultEndIndex = tokenEndIndex;\n      result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n    }\n  }\n  const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n  if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n    let classNames = [];\n    let metadata = 0;\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n      classNames.push(lineDecorations[lineDecorationIndex].className);\n      metadata |= lineDecorations[lineDecorationIndex].metadata;\n      lineDecorationIndex++;\n    }\n    result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '), metadata);\n  }\n  return result;\n}\n/**\r\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\r\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\r\n */\nfunction _renderLine(input, sb) {\n  const fontIsMonospace = input.fontIsMonospace;\n  const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n  const containsForeignElements = input.containsForeignElements;\n  const lineContent = input.lineContent;\n  const len = input.len;\n  const isOverflowing = input.isOverflowing;\n  const parts = input.parts;\n  const fauxIndentLength = input.fauxIndentLength;\n  const tabSize = input.tabSize;\n  const startVisibleColumn = input.startVisibleColumn;\n  const containsRTL = input.containsRTL;\n  const spaceWidth = input.spaceWidth;\n  const renderSpaceCharCode = input.renderSpaceCharCode;\n  const renderWhitespace = input.renderWhitespace;\n  const renderControlCharacters = input.renderControlCharacters;\n  const characterMapping = new CharacterMapping(len + 1, parts.length);\n  let charIndex = 0;\n  let visibleColumn = startVisibleColumn;\n  let charOffsetInPart = 0;\n  let partDisplacement = 0;\n  let prevPartContentCnt = 0;\n  let partAbsoluteOffset = 0;\n  if (containsRTL) {\n    sb.appendASCIIString('<span dir=\"ltr\">');\n  } else {\n    sb.appendASCIIString('<span>');\n  }\n  for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n    partAbsoluteOffset += prevPartContentCnt;\n    const part = parts[partIndex];\n    const partEndIndex = part.endIndex;\n    const partType = part.type;\n    const partRendersWhitespace = renderWhitespace !== 0 /* None */ && part.isWhitespace();\n    const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n    const partIsEmptyAndHasPseudoAfter = charIndex === partEndIndex && part.metadata === 4 /* PSEUDO_AFTER */;\n    charOffsetInPart = 0;\n    sb.appendASCIIString('<span class=\"');\n    sb.appendASCIIString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n    sb.appendASCII(34 /* DoubleQuote */);\n    if (partRendersWhitespace) {\n      let partContentCnt = 0;\n      {\n        let _charIndex = charIndex;\n        let _visibleColumn = visibleColumn;\n        for (; _charIndex < partEndIndex; _charIndex++) {\n          const charCode = lineContent.charCodeAt(_charIndex);\n          const charWidth = (charCode === 9 /* Tab */ ? tabSize - _visibleColumn % tabSize : 1) | 0;\n          partContentCnt += charWidth;\n          if (_charIndex >= fauxIndentLength) {\n            _visibleColumn += charWidth;\n          }\n        }\n      }\n      if (partRendersWhitespaceWithWidth) {\n        sb.appendASCIIString(' style=\"width:');\n        sb.appendASCIIString(String(spaceWidth * partContentCnt));\n        sb.appendASCIIString('px\"');\n      }\n      sb.appendASCII(62 /* GreaterThan */);\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setPartData(charIndex, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n        partDisplacement = 0;\n        const charCode = lineContent.charCodeAt(charIndex);\n        let charWidth;\n        if (charCode === 9 /* Tab */) {\n          charWidth = tabSize - visibleColumn % tabSize | 0;\n          if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n            sb.write1(0x2192); // RIGHTWARDS ARROW\n          } else {\n            sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n          }\n\n          for (let space = 2; space <= charWidth; space++) {\n            sb.write1(0xA0); // &nbsp;\n          }\n        } else {\n          // must be CharCode.Space\n          charWidth = 1;\n          sb.write1(renderSpaceCharCode); // &middot; or word separator middle dot\n        }\n\n        charOffsetInPart += charWidth;\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += charWidth;\n        }\n      }\n      prevPartContentCnt = partContentCnt;\n    } else {\n      let partContentCnt = 0;\n      sb.appendASCII(62 /* GreaterThan */);\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setPartData(charIndex, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n        partDisplacement = 0;\n        const charCode = lineContent.charCodeAt(charIndex);\n        let producedCharacters = 1;\n        let charWidth = 1;\n        switch (charCode) {\n          case 9 /* Tab */:\n            producedCharacters = tabSize - visibleColumn % tabSize;\n            charWidth = producedCharacters;\n            for (let space = 1; space <= producedCharacters; space++) {\n              sb.write1(0xA0); // &nbsp;\n            }\n\n            break;\n          case 32 /* Space */:\n            sb.write1(0xA0); // &nbsp;\n            break;\n          case 60 /* LessThan */:\n            sb.appendASCIIString('&lt;');\n            break;\n          case 62 /* GreaterThan */:\n            sb.appendASCIIString('&gt;');\n            break;\n          case 38 /* Ampersand */:\n            sb.appendASCIIString('&amp;');\n            break;\n          case 0 /* Null */:\n            sb.appendASCIIString('&#00;');\n            break;\n          case 65279 /* UTF8_BOM */:\n          case 8232 /* LINE_SEPARATOR */:\n          case 8233 /* PARAGRAPH_SEPARATOR */:\n          case 133 /* NEXT_LINE */:\n            sb.write1(0xFFFD);\n            break;\n          default:\n            if (strings.isFullWidthCharacter(charCode)) {\n              charWidth++;\n            }\n            if (renderControlCharacters && charCode < 32) {\n              sb.write1(9216 + charCode);\n            } else {\n              sb.write1(charCode);\n            }\n        }\n        charOffsetInPart += producedCharacters;\n        partContentCnt += producedCharacters;\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += charWidth;\n        }\n      }\n      prevPartContentCnt = partContentCnt;\n    }\n    if (partIsEmptyAndHasPseudoAfter) {\n      partDisplacement++;\n    } else {\n      partDisplacement = 0;\n    }\n    sb.appendASCIIString('</span>');\n  }\n  // When getting client rects for the last character, we will position the\n  // text range at the end of the span, insteaf of at the beginning of next span\n  characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n  if (isOverflowing) {\n    sb.appendASCIIString('<span>&hellip;</span>');\n  }\n  sb.appendASCIIString('</span>');\n  return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}","map":{"version":3,"names":["strings","createStringBuilder","LineDecoration","LineDecorationsNormalizer","LinePart","constructor","endIndex","type","metadata","isWhitespace","LineRange","startIndex","startOffset","endOffset","equals","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","lineContent","continuesWithWrappedLine","isBasicASCII","containsRTL","fauxIndentLength","lineTokens","lineDecorations","tabSize","startVisibleColumn","spaceWidth","middotWidth","wsmiddotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","sort","compare","a","b","wsmiddotDiff","Math","abs","middotDiff","renderSpaceWidth","renderSpaceCharCode","sameSelection","otherSelections","length","i","other","equalsArr","CharacterMapping","partCount","_data","Uint32Array","_absoluteOffsets","getPartIndex","partData","getCharIndex","setPartData","charOffset","partIndex","charIndex","partAbsoluteOffset","getAbsoluteOffsets","charOffsetToPartData","partDataToCharOffset","partLength","searchEntry","min","max","mid","midEntry","minEntry","maxEntry","minPartIndex","minCharIndex","maxPartIndex","maxCharIndex","minEntryDistance","maxEntryDistance","RenderLineOutput","characterMapping","containsForeignElements","renderViewLine","input","sb","content","beforeClassNames","afterClassNames","len","lineDecoration","push","className","beforeSpan","concat","join","afterSpan","appendASCIIString","_renderLine","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","out","build","ResolvedRenderLineInput","fontIsMonospace","isOverflowing","parts","tokens","transformAndRemoveOverflowing","_applyRenderWhitespace","_applyInlineDecorations","splitLargeTokens","result","resultLen","tokenIndex","tokensLen","getCount","getEndOffset","getClassName","onlyAtSpaces","lastTokenEndIndex","token","tokenEndIndex","tokenType","tokenMetadata","lastSpaceOffset","currTokenStart","j","charCodeAt","diff","piecesCount","ceil","pieceEndIndex","selections","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokensLength","lineIsEmptyOrWhitespace","firstNonWhitespaceIndex","lastNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","lastEndIndex","isFullWidthCharacter","generateWhitespace","lastCharCode","prevCharCode","isSingleTrailingSpace","_lineDecorations","normalize","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","classNames","visibleColumn","charOffsetInPart","partDisplacement","prevPartContentCnt","part","partEndIndex","partType","partRendersWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","appendASCII","partContentCnt","_charIndex","_visibleColumn","charCode","charWidth","String","write1","space","producedCharacters"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { createStringBuilder } from '../core/stringBuilder.js';\r\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\r\nclass LinePart {\r\n    constructor(endIndex, type, metadata) {\r\n        this.endIndex = endIndex;\r\n        this.type = type;\r\n        this.metadata = metadata;\r\n    }\r\n    isWhitespace() {\r\n        return (this.metadata & 1 /* IS_WHITESPACE_MASK */ ? true : false);\r\n    }\r\n}\r\nexport class LineRange {\r\n    constructor(startIndex, endIndex) {\r\n        this.startOffset = startIndex;\r\n        this.endOffset = endIndex;\r\n    }\r\n    equals(otherLineRange) {\r\n        return this.startOffset === otherLineRange.startOffset\r\n            && this.endOffset === otherLineRange.endOffset;\r\n    }\r\n}\r\nexport class RenderLineInput {\r\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\r\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\r\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\r\n        this.lineContent = lineContent;\r\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\r\n        this.isBasicASCII = isBasicASCII;\r\n        this.containsRTL = containsRTL;\r\n        this.fauxIndentLength = fauxIndentLength;\r\n        this.lineTokens = lineTokens;\r\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\r\n        this.tabSize = tabSize;\r\n        this.startVisibleColumn = startVisibleColumn;\r\n        this.spaceWidth = spaceWidth;\r\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\r\n        this.renderWhitespace = (renderWhitespace === 'all'\r\n            ? 4 /* All */\r\n            : renderWhitespace === 'boundary'\r\n                ? 1 /* Boundary */\r\n                : renderWhitespace === 'selection'\r\n                    ? 2 /* Selection */\r\n                    : renderWhitespace === 'trailing'\r\n                        ? 3 /* Trailing */\r\n                        : 0 /* None */);\r\n        this.renderControlCharacters = renderControlCharacters;\r\n        this.fontLigatures = fontLigatures;\r\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\r\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\r\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\r\n        if (wsmiddotDiff < middotDiff) {\r\n            this.renderSpaceWidth = wsmiddotWidth;\r\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\r\n        }\r\n        else {\r\n            this.renderSpaceWidth = middotWidth;\r\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\r\n        }\r\n    }\r\n    sameSelection(otherSelections) {\r\n        if (this.selectionsOnLine === null) {\r\n            return otherSelections === null;\r\n        }\r\n        if (otherSelections === null) {\r\n            return false;\r\n        }\r\n        if (otherSelections.length !== this.selectionsOnLine.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\r\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    equals(other) {\r\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\r\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\r\n            && this.lineContent === other.lineContent\r\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\r\n            && this.isBasicASCII === other.isBasicASCII\r\n            && this.containsRTL === other.containsRTL\r\n            && this.fauxIndentLength === other.fauxIndentLength\r\n            && this.tabSize === other.tabSize\r\n            && this.startVisibleColumn === other.startVisibleColumn\r\n            && this.spaceWidth === other.spaceWidth\r\n            && this.renderSpaceWidth === other.renderSpaceWidth\r\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\r\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\r\n            && this.renderWhitespace === other.renderWhitespace\r\n            && this.renderControlCharacters === other.renderControlCharacters\r\n            && this.fontLigatures === other.fontLigatures\r\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\r\n            && this.lineTokens.equals(other.lineTokens)\r\n            && this.sameSelection(other.selectionsOnLine));\r\n    }\r\n}\r\n/**\r\n * Provides a both direction mapping between a line's character and its rendered position.\r\n */\r\nexport class CharacterMapping {\r\n    constructor(length, partCount) {\r\n        this.length = length;\r\n        this._data = new Uint32Array(this.length);\r\n        this._absoluteOffsets = new Uint32Array(this.length);\r\n    }\r\n    static getPartIndex(partData) {\r\n        return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;\r\n    }\r\n    static getCharIndex(partData) {\r\n        return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;\r\n    }\r\n    setPartData(charOffset, partIndex, charIndex, partAbsoluteOffset) {\r\n        let partData = ((partIndex << 16 /* PART_INDEX_OFFSET */)\r\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\r\n        this._data[charOffset] = partData;\r\n        this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\r\n    }\r\n    getAbsoluteOffsets() {\r\n        return this._absoluteOffsets;\r\n    }\r\n    charOffsetToPartData(charOffset) {\r\n        if (this.length === 0) {\r\n            return 0;\r\n        }\r\n        if (charOffset < 0) {\r\n            return this._data[0];\r\n        }\r\n        if (charOffset >= this.length) {\r\n            return this._data[this.length - 1];\r\n        }\r\n        return this._data[charOffset];\r\n    }\r\n    partDataToCharOffset(partIndex, partLength, charIndex) {\r\n        if (this.length === 0) {\r\n            return 0;\r\n        }\r\n        let searchEntry = ((partIndex << 16 /* PART_INDEX_OFFSET */)\r\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\r\n        let min = 0;\r\n        let max = this.length - 1;\r\n        while (min + 1 < max) {\r\n            let mid = ((min + max) >>> 1);\r\n            let midEntry = this._data[mid];\r\n            if (midEntry === searchEntry) {\r\n                return mid;\r\n            }\r\n            else if (midEntry > searchEntry) {\r\n                max = mid;\r\n            }\r\n            else {\r\n                min = mid;\r\n            }\r\n        }\r\n        if (min === max) {\r\n            return min;\r\n        }\r\n        let minEntry = this._data[min];\r\n        let maxEntry = this._data[max];\r\n        if (minEntry === searchEntry) {\r\n            return min;\r\n        }\r\n        if (maxEntry === searchEntry) {\r\n            return max;\r\n        }\r\n        let minPartIndex = CharacterMapping.getPartIndex(minEntry);\r\n        let minCharIndex = CharacterMapping.getCharIndex(minEntry);\r\n        let maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\r\n        let maxCharIndex;\r\n        if (minPartIndex !== maxPartIndex) {\r\n            // sitting between parts\r\n            maxCharIndex = partLength;\r\n        }\r\n        else {\r\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\r\n        }\r\n        let minEntryDistance = charIndex - minCharIndex;\r\n        let maxEntryDistance = maxCharIndex - charIndex;\r\n        if (minEntryDistance <= maxEntryDistance) {\r\n            return min;\r\n        }\r\n        return max;\r\n    }\r\n}\r\nexport class RenderLineOutput {\r\n    constructor(characterMapping, containsRTL, containsForeignElements) {\r\n        this.characterMapping = characterMapping;\r\n        this.containsRTL = containsRTL;\r\n        this.containsForeignElements = containsForeignElements;\r\n    }\r\n}\r\nexport function renderViewLine(input, sb) {\r\n    if (input.lineContent.length === 0) {\r\n        let containsForeignElements = 0 /* None */;\r\n        let content = '<span><span></span></span>';\r\n        if (input.lineDecorations.length > 0) {\r\n            // This line is empty, but it contains inline decorations\r\n            const beforeClassNames = [];\r\n            const afterClassNames = [];\r\n            for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\r\n                const lineDecoration = input.lineDecorations[i];\r\n                if (lineDecoration.type === 1 /* Before */) {\r\n                    beforeClassNames.push(input.lineDecorations[i].className);\r\n                    containsForeignElements |= 1 /* Before */;\r\n                }\r\n                if (lineDecoration.type === 2 /* After */) {\r\n                    afterClassNames.push(input.lineDecorations[i].className);\r\n                    containsForeignElements |= 2 /* After */;\r\n                }\r\n            }\r\n            if (containsForeignElements !== 0 /* None */) {\r\n                const beforeSpan = (beforeClassNames.length > 0 ? `<span class=\"${beforeClassNames.join(' ')}\"></span>` : ``);\r\n                const afterSpan = (afterClassNames.length > 0 ? `<span class=\"${afterClassNames.join(' ')}\"></span>` : ``);\r\n                content = `<span>${beforeSpan}${afterSpan}</span>`;\r\n            }\r\n        }\r\n        sb.appendASCIIString(content);\r\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);\r\n    }\r\n    return _renderLine(resolveRenderLineInput(input), sb);\r\n}\r\nexport class RenderLineOutput2 {\r\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\r\n        this.characterMapping = characterMapping;\r\n        this.html = html;\r\n        this.containsRTL = containsRTL;\r\n        this.containsForeignElements = containsForeignElements;\r\n    }\r\n}\r\nexport function renderViewLine2(input) {\r\n    let sb = createStringBuilder(10000);\r\n    let out = renderViewLine(input, sb);\r\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\r\n}\r\nclass ResolvedRenderLineInput {\r\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\r\n        this.fontIsMonospace = fontIsMonospace;\r\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\r\n        this.lineContent = lineContent;\r\n        this.len = len;\r\n        this.isOverflowing = isOverflowing;\r\n        this.parts = parts;\r\n        this.containsForeignElements = containsForeignElements;\r\n        this.fauxIndentLength = fauxIndentLength;\r\n        this.tabSize = tabSize;\r\n        this.startVisibleColumn = startVisibleColumn;\r\n        this.containsRTL = containsRTL;\r\n        this.spaceWidth = spaceWidth;\r\n        this.renderSpaceCharCode = renderSpaceCharCode;\r\n        this.renderWhitespace = renderWhitespace;\r\n        this.renderControlCharacters = renderControlCharacters;\r\n        //\r\n    }\r\n}\r\nfunction resolveRenderLineInput(input) {\r\n    const lineContent = input.lineContent;\r\n    let isOverflowing;\r\n    let len;\r\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\r\n        isOverflowing = true;\r\n        len = input.stopRenderingLineAfter;\r\n    }\r\n    else {\r\n        isOverflowing = false;\r\n        len = lineContent.length;\r\n    }\r\n    let tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\r\n    if (input.renderWhitespace === 4 /* All */ ||\r\n        input.renderWhitespace === 1 /* Boundary */ ||\r\n        (input.renderWhitespace === 2 /* Selection */ && !!input.selectionsOnLine) ||\r\n        input.renderWhitespace === 3 /* Trailing */) {\r\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\r\n    }\r\n    let containsForeignElements = 0 /* None */;\r\n    if (input.lineDecorations.length > 0) {\r\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\r\n            const lineDecoration = input.lineDecorations[i];\r\n            if (lineDecoration.type === 3 /* RegularAffectingLetterSpacing */) {\r\n                // Pretend there are foreign elements... although not 100% accurate.\r\n                containsForeignElements |= 1 /* Before */;\r\n            }\r\n            else if (lineDecoration.type === 1 /* Before */) {\r\n                containsForeignElements |= 1 /* Before */;\r\n            }\r\n            else if (lineDecoration.type === 2 /* After */) {\r\n                containsForeignElements |= 2 /* After */;\r\n            }\r\n        }\r\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\r\n    }\r\n    if (!input.containsRTL) {\r\n        // We can never split RTL text, as it ruins the rendering\r\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\r\n    }\r\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\r\n}\r\n/**\r\n * In the rendering phase, characters are always looped until token.endIndex.\r\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\r\n */\r\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\r\n    let result = [], resultLen = 0;\r\n    // The faux indent part of the line should have no token type\r\n    if (fauxIndentLength > 0) {\r\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0);\r\n    }\r\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\r\n        const endIndex = tokens.getEndOffset(tokenIndex);\r\n        if (endIndex <= fauxIndentLength) {\r\n            // The faux indent part of the line should have no token type\r\n            continue;\r\n        }\r\n        const type = tokens.getClassName(tokenIndex);\r\n        if (endIndex >= len) {\r\n            result[resultLen++] = new LinePart(len, type, 0);\r\n            break;\r\n        }\r\n        result[resultLen++] = new LinePart(endIndex, type, 0);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * See https://github.com/microsoft/vscode/issues/6885.\r\n * It appears that having very large spans causes very slow reading of character positions.\r\n * So here we try to avoid that.\r\n */\r\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\r\n    let lastTokenEndIndex = 0;\r\n    let result = [], resultLen = 0;\r\n    if (onlyAtSpaces) {\r\n        // Split only at spaces => we need to walk each character\r\n        for (let i = 0, len = tokens.length; i < len; i++) {\r\n            const token = tokens[i];\r\n            const tokenEndIndex = token.endIndex;\r\n            if (lastTokenEndIndex + 50 /* LongToken */ < tokenEndIndex) {\r\n                const tokenType = token.type;\r\n                const tokenMetadata = token.metadata;\r\n                let lastSpaceOffset = -1;\r\n                let currTokenStart = lastTokenEndIndex;\r\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\r\n                    if (lineContent.charCodeAt(j) === 32 /* Space */) {\r\n                        lastSpaceOffset = j;\r\n                    }\r\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* LongToken */) {\r\n                        // Split at `lastSpaceOffset` + 1\r\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata);\r\n                        currTokenStart = lastSpaceOffset + 1;\r\n                        lastSpaceOffset = -1;\r\n                    }\r\n                }\r\n                if (currTokenStart !== tokenEndIndex) {\r\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\r\n                }\r\n            }\r\n            else {\r\n                result[resultLen++] = token;\r\n            }\r\n            lastTokenEndIndex = tokenEndIndex;\r\n        }\r\n    }\r\n    else {\r\n        // Split anywhere => we don't need to walk each character\r\n        for (let i = 0, len = tokens.length; i < len; i++) {\r\n            const token = tokens[i];\r\n            const tokenEndIndex = token.endIndex;\r\n            let diff = (tokenEndIndex - lastTokenEndIndex);\r\n            if (diff > 50 /* LongToken */) {\r\n                const tokenType = token.type;\r\n                const tokenMetadata = token.metadata;\r\n                const piecesCount = Math.ceil(diff / 50 /* LongToken */);\r\n                for (let j = 1; j < piecesCount; j++) {\r\n                    let pieceEndIndex = lastTokenEndIndex + (j * 50 /* LongToken */);\r\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata);\r\n                }\r\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\r\n            }\r\n            else {\r\n                result[resultLen++] = token;\r\n            }\r\n            lastTokenEndIndex = tokenEndIndex;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\r\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\r\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\r\n */\r\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\r\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\r\n    const fauxIndentLength = input.fauxIndentLength;\r\n    const tabSize = input.tabSize;\r\n    const startVisibleColumn = input.startVisibleColumn;\r\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\r\n    const selections = input.selectionsOnLine;\r\n    const onlyBoundary = (input.renderWhitespace === 1 /* Boundary */);\r\n    const onlyTrailing = (input.renderWhitespace === 3 /* Trailing */);\r\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\r\n    let result = [], resultLen = 0;\r\n    let tokenIndex = 0;\r\n    let tokenType = tokens[tokenIndex].type;\r\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\r\n    const tokensLength = tokens.length;\r\n    let lineIsEmptyOrWhitespace = false;\r\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\r\n    let lastNonWhitespaceIndex;\r\n    if (firstNonWhitespaceIndex === -1) {\r\n        lineIsEmptyOrWhitespace = true;\r\n        firstNonWhitespaceIndex = len;\r\n        lastNonWhitespaceIndex = len;\r\n    }\r\n    else {\r\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\r\n    }\r\n    let wasInWhitespace = false;\r\n    let currentSelectionIndex = 0;\r\n    let currentSelection = selections && selections[currentSelectionIndex];\r\n    let tmpIndent = startVisibleColumn % tabSize;\r\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\r\n        const chCode = lineContent.charCodeAt(charIndex);\r\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\r\n            currentSelectionIndex++;\r\n            currentSelection = selections && selections[currentSelectionIndex];\r\n        }\r\n        let isInWhitespace;\r\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\r\n            // in leading or trailing whitespace\r\n            isInWhitespace = true;\r\n        }\r\n        else if (chCode === 9 /* Tab */) {\r\n            // a tab character is rendered both in all and boundary cases\r\n            isInWhitespace = true;\r\n        }\r\n        else if (chCode === 32 /* Space */) {\r\n            // hit a space character\r\n            if (onlyBoundary) {\r\n                // rendering only boundary whitespace\r\n                if (wasInWhitespace) {\r\n                    isInWhitespace = true;\r\n                }\r\n                else {\r\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\r\n                    isInWhitespace = (nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */);\r\n                }\r\n            }\r\n            else {\r\n                isInWhitespace = true;\r\n            }\r\n        }\r\n        else {\r\n            isInWhitespace = false;\r\n        }\r\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\r\n        if (isInWhitespace && selections) {\r\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\r\n        }\r\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\r\n        if (isInWhitespace && onlyTrailing) {\r\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\r\n        }\r\n        if (wasInWhitespace) {\r\n            // was in whitespace token\r\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\r\n                // leaving whitespace token or entering a new indent\r\n                if (generateLinePartForEachWhitespace) {\r\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\r\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\r\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\r\n                    }\r\n                }\r\n                else {\r\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* IS_WHITESPACE */);\r\n                }\r\n                tmpIndent = tmpIndent % tabSize;\r\n            }\r\n        }\r\n        else {\r\n            // was in regular token\r\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\r\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0);\r\n                tmpIndent = tmpIndent % tabSize;\r\n            }\r\n        }\r\n        if (chCode === 9 /* Tab */) {\r\n            tmpIndent = tabSize;\r\n        }\r\n        else if (strings.isFullWidthCharacter(chCode)) {\r\n            tmpIndent += 2;\r\n        }\r\n        else {\r\n            tmpIndent++;\r\n        }\r\n        wasInWhitespace = isInWhitespace;\r\n        while (charIndex === tokenEndIndex) {\r\n            tokenIndex++;\r\n            if (tokenIndex < tokensLength) {\r\n                tokenType = tokens[tokenIndex].type;\r\n                tokenEndIndex = tokens[tokenIndex].endIndex;\r\n            }\r\n        }\r\n    }\r\n    let generateWhitespace = false;\r\n    if (wasInWhitespace) {\r\n        // was in whitespace token\r\n        if (continuesWithWrappedLine && onlyBoundary) {\r\n            let lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* Null */);\r\n            let prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* Null */);\r\n            let isSingleTrailingSpace = (lastCharCode === 32 /* Space */ && (prevCharCode !== 32 /* Space */ && prevCharCode !== 9 /* Tab */));\r\n            if (!isSingleTrailingSpace) {\r\n                generateWhitespace = true;\r\n            }\r\n        }\r\n        else {\r\n            generateWhitespace = true;\r\n        }\r\n    }\r\n    if (generateWhitespace) {\r\n        if (generateLinePartForEachWhitespace) {\r\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\r\n            for (let i = lastEndIndex + 1; i <= len; i++) {\r\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\r\n            }\r\n        }\r\n        else {\r\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* IS_WHITESPACE */);\r\n        }\r\n    }\r\n    else {\r\n        result[resultLen++] = new LinePart(len, tokenType, 0);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Inline decorations are \"merged\" on top of tokens.\r\n * Special care must be taken when multiple inline decorations are at play and they overlap.\r\n */\r\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\r\n    _lineDecorations.sort(LineDecoration.compare);\r\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\r\n    const lineDecorationsLen = lineDecorations.length;\r\n    let lineDecorationIndex = 0;\r\n    let result = [], resultLen = 0, lastResultEndIndex = 0;\r\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\r\n        const token = tokens[tokenIndex];\r\n        const tokenEndIndex = token.endIndex;\r\n        const tokenType = token.type;\r\n        const tokenMetadata = token.metadata;\r\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\r\n            const lineDecoration = lineDecorations[lineDecorationIndex];\r\n            if (lineDecoration.startOffset > lastResultEndIndex) {\r\n                lastResultEndIndex = lineDecoration.startOffset;\r\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\r\n            }\r\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\r\n                // This line decoration ends before this token ends\r\n                lastResultEndIndex = lineDecoration.endOffset + 1;\r\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\r\n                lineDecorationIndex++;\r\n            }\r\n            else {\r\n                // This line decoration continues on to the next token\r\n                lastResultEndIndex = tokenEndIndex;\r\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\r\n                break;\r\n            }\r\n        }\r\n        if (tokenEndIndex > lastResultEndIndex) {\r\n            lastResultEndIndex = tokenEndIndex;\r\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\r\n        }\r\n    }\r\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\r\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\r\n        let classNames = [];\r\n        let metadata = 0;\r\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\r\n            classNames.push(lineDecorations[lineDecorationIndex].className);\r\n            metadata |= lineDecorations[lineDecorationIndex].metadata;\r\n            lineDecorationIndex++;\r\n        }\r\n        result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '), metadata);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\r\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\r\n */\r\nfunction _renderLine(input, sb) {\r\n    const fontIsMonospace = input.fontIsMonospace;\r\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\r\n    const containsForeignElements = input.containsForeignElements;\r\n    const lineContent = input.lineContent;\r\n    const len = input.len;\r\n    const isOverflowing = input.isOverflowing;\r\n    const parts = input.parts;\r\n    const fauxIndentLength = input.fauxIndentLength;\r\n    const tabSize = input.tabSize;\r\n    const startVisibleColumn = input.startVisibleColumn;\r\n    const containsRTL = input.containsRTL;\r\n    const spaceWidth = input.spaceWidth;\r\n    const renderSpaceCharCode = input.renderSpaceCharCode;\r\n    const renderWhitespace = input.renderWhitespace;\r\n    const renderControlCharacters = input.renderControlCharacters;\r\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\r\n    let charIndex = 0;\r\n    let visibleColumn = startVisibleColumn;\r\n    let charOffsetInPart = 0;\r\n    let partDisplacement = 0;\r\n    let prevPartContentCnt = 0;\r\n    let partAbsoluteOffset = 0;\r\n    if (containsRTL) {\r\n        sb.appendASCIIString('<span dir=\"ltr\">');\r\n    }\r\n    else {\r\n        sb.appendASCIIString('<span>');\r\n    }\r\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\r\n        partAbsoluteOffset += prevPartContentCnt;\r\n        const part = parts[partIndex];\r\n        const partEndIndex = part.endIndex;\r\n        const partType = part.type;\r\n        const partRendersWhitespace = (renderWhitespace !== 0 /* None */ && part.isWhitespace());\r\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\r\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.metadata === 4 /* PSEUDO_AFTER */);\r\n        charOffsetInPart = 0;\r\n        sb.appendASCIIString('<span class=\"');\r\n        sb.appendASCIIString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\r\n        sb.appendASCII(34 /* DoubleQuote */);\r\n        if (partRendersWhitespace) {\r\n            let partContentCnt = 0;\r\n            {\r\n                let _charIndex = charIndex;\r\n                let _visibleColumn = visibleColumn;\r\n                for (; _charIndex < partEndIndex; _charIndex++) {\r\n                    const charCode = lineContent.charCodeAt(_charIndex);\r\n                    const charWidth = (charCode === 9 /* Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\r\n                    partContentCnt += charWidth;\r\n                    if (_charIndex >= fauxIndentLength) {\r\n                        _visibleColumn += charWidth;\r\n                    }\r\n                }\r\n            }\r\n            if (partRendersWhitespaceWithWidth) {\r\n                sb.appendASCIIString(' style=\"width:');\r\n                sb.appendASCIIString(String(spaceWidth * partContentCnt));\r\n                sb.appendASCIIString('px\"');\r\n            }\r\n            sb.appendASCII(62 /* GreaterThan */);\r\n            for (; charIndex < partEndIndex; charIndex++) {\r\n                characterMapping.setPartData(charIndex, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\r\n                partDisplacement = 0;\r\n                const charCode = lineContent.charCodeAt(charIndex);\r\n                let charWidth;\r\n                if (charCode === 9 /* Tab */) {\r\n                    charWidth = (tabSize - (visibleColumn % tabSize)) | 0;\r\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\r\n                        sb.write1(0x2192); // RIGHTWARDS ARROW\r\n                    }\r\n                    else {\r\n                        sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\r\n                    }\r\n                    for (let space = 2; space <= charWidth; space++) {\r\n                        sb.write1(0xA0); // &nbsp;\r\n                    }\r\n                }\r\n                else { // must be CharCode.Space\r\n                    charWidth = 1;\r\n                    sb.write1(renderSpaceCharCode); // &middot; or word separator middle dot\r\n                }\r\n                charOffsetInPart += charWidth;\r\n                if (charIndex >= fauxIndentLength) {\r\n                    visibleColumn += charWidth;\r\n                }\r\n            }\r\n            prevPartContentCnt = partContentCnt;\r\n        }\r\n        else {\r\n            let partContentCnt = 0;\r\n            sb.appendASCII(62 /* GreaterThan */);\r\n            for (; charIndex < partEndIndex; charIndex++) {\r\n                characterMapping.setPartData(charIndex, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\r\n                partDisplacement = 0;\r\n                const charCode = lineContent.charCodeAt(charIndex);\r\n                let producedCharacters = 1;\r\n                let charWidth = 1;\r\n                switch (charCode) {\r\n                    case 9 /* Tab */:\r\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\r\n                        charWidth = producedCharacters;\r\n                        for (let space = 1; space <= producedCharacters; space++) {\r\n                            sb.write1(0xA0); // &nbsp;\r\n                        }\r\n                        break;\r\n                    case 32 /* Space */:\r\n                        sb.write1(0xA0); // &nbsp;\r\n                        break;\r\n                    case 60 /* LessThan */:\r\n                        sb.appendASCIIString('&lt;');\r\n                        break;\r\n                    case 62 /* GreaterThan */:\r\n                        sb.appendASCIIString('&gt;');\r\n                        break;\r\n                    case 38 /* Ampersand */:\r\n                        sb.appendASCIIString('&amp;');\r\n                        break;\r\n                    case 0 /* Null */:\r\n                        sb.appendASCIIString('&#00;');\r\n                        break;\r\n                    case 65279 /* UTF8_BOM */:\r\n                    case 8232 /* LINE_SEPARATOR */:\r\n                    case 8233 /* PARAGRAPH_SEPARATOR */:\r\n                    case 133 /* NEXT_LINE */:\r\n                        sb.write1(0xFFFD);\r\n                        break;\r\n                    default:\r\n                        if (strings.isFullWidthCharacter(charCode)) {\r\n                            charWidth++;\r\n                        }\r\n                        if (renderControlCharacters && charCode < 32) {\r\n                            sb.write1(9216 + charCode);\r\n                        }\r\n                        else {\r\n                            sb.write1(charCode);\r\n                        }\r\n                }\r\n                charOffsetInPart += producedCharacters;\r\n                partContentCnt += producedCharacters;\r\n                if (charIndex >= fauxIndentLength) {\r\n                    visibleColumn += charWidth;\r\n                }\r\n            }\r\n            prevPartContentCnt = partContentCnt;\r\n        }\r\n        if (partIsEmptyAndHasPseudoAfter) {\r\n            partDisplacement++;\r\n        }\r\n        else {\r\n            partDisplacement = 0;\r\n        }\r\n        sb.appendASCIIString('</span>');\r\n    }\r\n    // When getting client rects for the last character, we will position the\r\n    // text range at the end of the span, insteaf of at the beginning of next span\r\n    characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\r\n    if (isOverflowing) {\r\n        sb.appendASCIIString('<span>&hellip;</span>');\r\n    }\r\n    sb.appendASCIIString('</span>');\r\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}