{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\r\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\r\n */\nexport class Range {\n  constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n    if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {\n      this.startLineNumber = endLineNumber;\n      this.startColumn = endColumn;\n      this.endLineNumber = startLineNumber;\n      this.endColumn = startColumn;\n    } else {\n      this.startLineNumber = startLineNumber;\n      this.startColumn = startColumn;\n      this.endLineNumber = endLineNumber;\n      this.endColumn = endColumn;\n    }\n  }\n  /**\r\n   * Test if this range is empty.\r\n   */\n  isEmpty() {\n    return Range.isEmpty(this);\n  }\n  /**\r\n   * Test if `range` is empty.\r\n   */\n  static isEmpty(range) {\n    return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;\n  }\n  /**\r\n   * Test if position is in this range. If the position is at the edges, will return true.\r\n   */\n  containsPosition(position) {\n    return Range.containsPosition(this, position);\n  }\n  /**\r\n   * Test if `position` is in `range`. If the position is at the edges, will return true.\r\n   */\n  static containsPosition(range, position) {\n    if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n      return false;\n    }\n    if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n      return false;\n    }\n    if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\r\n   * Test if range is in this range. If the range is equal to this range, will return true.\r\n   */\n  containsRange(range) {\n    return Range.containsRange(this, range);\n  }\n  /**\r\n   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\r\n   */\n  static containsRange(range, otherRange) {\n    if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n      return false;\n    }\n    if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\r\n   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\r\n   */\n  strictContainsRange(range) {\n    return Range.strictContainsRange(this, range);\n  }\n  /**\r\n   * Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.\r\n   */\n  static strictContainsRange(range, otherRange) {\n    if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n      return false;\n    }\n    if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n      return false;\n    }\n    if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n      return false;\n    }\n    return true;\n  }\n  /**\r\n   * A reunion of the two ranges.\r\n   * The smallest position will be used as the start point, and the largest one as the end point.\r\n   */\n  plusRange(range) {\n    return Range.plusRange(this, range);\n  }\n  /**\r\n   * A reunion of the two ranges.\r\n   * The smallest position will be used as the start point, and the largest one as the end point.\r\n   */\n  static plusRange(a, b) {\n    let startLineNumber;\n    let startColumn;\n    let endLineNumber;\n    let endColumn;\n    if (b.startLineNumber < a.startLineNumber) {\n      startLineNumber = b.startLineNumber;\n      startColumn = b.startColumn;\n    } else if (b.startLineNumber === a.startLineNumber) {\n      startLineNumber = b.startLineNumber;\n      startColumn = Math.min(b.startColumn, a.startColumn);\n    } else {\n      startLineNumber = a.startLineNumber;\n      startColumn = a.startColumn;\n    }\n    if (b.endLineNumber > a.endLineNumber) {\n      endLineNumber = b.endLineNumber;\n      endColumn = b.endColumn;\n    } else if (b.endLineNumber === a.endLineNumber) {\n      endLineNumber = b.endLineNumber;\n      endColumn = Math.max(b.endColumn, a.endColumn);\n    } else {\n      endLineNumber = a.endLineNumber;\n      endColumn = a.endColumn;\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  /**\r\n   * A intersection of the two ranges.\r\n   */\n  intersectRanges(range) {\n    return Range.intersectRanges(this, range);\n  }\n  /**\r\n   * A intersection of the two ranges.\r\n   */\n  static intersectRanges(a, b) {\n    let resultStartLineNumber = a.startLineNumber;\n    let resultStartColumn = a.startColumn;\n    let resultEndLineNumber = a.endLineNumber;\n    let resultEndColumn = a.endColumn;\n    let otherStartLineNumber = b.startLineNumber;\n    let otherStartColumn = b.startColumn;\n    let otherEndLineNumber = b.endLineNumber;\n    let otherEndColumn = b.endColumn;\n    if (resultStartLineNumber < otherStartLineNumber) {\n      resultStartLineNumber = otherStartLineNumber;\n      resultStartColumn = otherStartColumn;\n    } else if (resultStartLineNumber === otherStartLineNumber) {\n      resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n    }\n    if (resultEndLineNumber > otherEndLineNumber) {\n      resultEndLineNumber = otherEndLineNumber;\n      resultEndColumn = otherEndColumn;\n    } else if (resultEndLineNumber === otherEndLineNumber) {\n      resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n    }\n    // Check if selection is now empty\n    if (resultStartLineNumber > resultEndLineNumber) {\n      return null;\n    }\n    if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n      return null;\n    }\n    return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n  }\n  /**\r\n   * Test if this range equals other.\r\n   */\n  equalsRange(other) {\n    return Range.equalsRange(this, other);\n  }\n  /**\r\n   * Test if range `a` equals `b`.\r\n   */\n  static equalsRange(a, b) {\n    return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;\n  }\n  /**\r\n   * Return the end position (which will be after or equal to the start position)\r\n   */\n  getEndPosition() {\n    return Range.getEndPosition(this);\n  }\n  /**\r\n   * Return the end position (which will be after or equal to the start position)\r\n   */\n  static getEndPosition(range) {\n    return new Position(range.endLineNumber, range.endColumn);\n  }\n  /**\r\n   * Return the start position (which will be before or equal to the end position)\r\n   */\n  getStartPosition() {\n    return Range.getStartPosition(this);\n  }\n  /**\r\n   * Return the start position (which will be before or equal to the end position)\r\n   */\n  static getStartPosition(range) {\n    return new Position(range.startLineNumber, range.startColumn);\n  }\n  /**\r\n   * Transform to a user presentable string representation.\r\n   */\n  toString() {\n    return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n  }\n  /**\r\n   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\r\n   */\n  setEndPosition(endLineNumber, endColumn) {\n    return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n  }\n  /**\r\n   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\r\n   */\n  setStartPosition(startLineNumber, startColumn) {\n    return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n  }\n  /**\r\n   * Create a new empty range using this range's start position.\r\n   */\n  collapseToStart() {\n    return Range.collapseToStart(this);\n  }\n  /**\r\n   * Create a new empty range using this range's start position.\r\n   */\n  static collapseToStart(range) {\n    return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n  }\n  // ---\n  static fromPositions(start) {\n    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n  }\n  static lift(range) {\n    if (!range) {\n      return null;\n    }\n    return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n  }\n  /**\r\n   * Test if `obj` is an `IRange`.\r\n   */\n  static isIRange(obj) {\n    return obj && typeof obj.startLineNumber === 'number' && typeof obj.startColumn === 'number' && typeof obj.endLineNumber === 'number' && typeof obj.endColumn === 'number';\n  }\n  /**\r\n   * Test if the two ranges are touching in any way.\r\n   */\n  static areIntersectingOrTouching(a, b) {\n    // Check if `a` is before `b`\n    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {\n      return false;\n    }\n    // Check if `b` is before `a`\n    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {\n      return false;\n    }\n    // These ranges must intersect\n    return true;\n  }\n  /**\r\n   * Test if the two ranges are intersecting. If the ranges are touching it returns true.\r\n   */\n  static areIntersecting(a, b) {\n    // Check if `a` is before `b`\n    if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {\n      return false;\n    }\n    // Check if `b` is before `a`\n    if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {\n      return false;\n    }\n    // These ranges must intersect\n    return true;\n  }\n  /**\r\n   * A function that compares ranges, useful for sorting ranges\r\n   * It will first compare ranges on the startPosition and then on the endPosition\r\n   */\n  static compareRangesUsingStarts(a, b) {\n    if (a && b) {\n      const aStartLineNumber = a.startLineNumber | 0;\n      const bStartLineNumber = b.startLineNumber | 0;\n      if (aStartLineNumber === bStartLineNumber) {\n        const aStartColumn = a.startColumn | 0;\n        const bStartColumn = b.startColumn | 0;\n        if (aStartColumn === bStartColumn) {\n          const aEndLineNumber = a.endLineNumber | 0;\n          const bEndLineNumber = b.endLineNumber | 0;\n          if (aEndLineNumber === bEndLineNumber) {\n            const aEndColumn = a.endColumn | 0;\n            const bEndColumn = b.endColumn | 0;\n            return aEndColumn - bEndColumn;\n          }\n          return aEndLineNumber - bEndLineNumber;\n        }\n        return aStartColumn - bStartColumn;\n      }\n      return aStartLineNumber - bStartLineNumber;\n    }\n    const aExists = a ? 1 : 0;\n    const bExists = b ? 1 : 0;\n    return aExists - bExists;\n  }\n  /**\r\n   * A function that compares ranges, useful for sorting ranges\r\n   * It will first compare ranges on the endPosition and then on the startPosition\r\n   */\n  static compareRangesUsingEnds(a, b) {\n    if (a.endLineNumber === b.endLineNumber) {\n      if (a.endColumn === b.endColumn) {\n        if (a.startLineNumber === b.startLineNumber) {\n          return a.startColumn - b.startColumn;\n        }\n        return a.startLineNumber - b.startLineNumber;\n      }\n      return a.endColumn - b.endColumn;\n    }\n    return a.endLineNumber - b.endLineNumber;\n  }\n  /**\r\n   * Test if the range spans multiple lines.\r\n   */\n  static spansMultipleLines(range) {\n    return range.endLineNumber > range.startLineNumber;\n  }\n}","map":{"version":3,"names":["Position","Range","constructor","startLineNumber","startColumn","endLineNumber","endColumn","isEmpty","range","containsPosition","position","lineNumber","column","containsRange","otherRange","strictContainsRange","plusRange","a","b","Math","min","max","intersectRanges","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","equalsRange","other","getEndPosition","getStartPosition","toString","setEndPosition","setStartPosition","collapseToStart","fromPositions","start","end","arguments","length","undefined","lift","isIRange","obj","areIntersectingOrTouching","areIntersecting","compareRangesUsingStarts","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","aEndColumn","bEndColumn","aExists","bExists","compareRangesUsingEnds","spansMultipleLines"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/core/range.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Position } from './position.js';\r\n/**\r\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\r\n */\r\nexport class Range {\r\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\r\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\r\n            this.startLineNumber = endLineNumber;\r\n            this.startColumn = endColumn;\r\n            this.endLineNumber = startLineNumber;\r\n            this.endColumn = startColumn;\r\n        }\r\n        else {\r\n            this.startLineNumber = startLineNumber;\r\n            this.startColumn = startColumn;\r\n            this.endLineNumber = endLineNumber;\r\n            this.endColumn = endColumn;\r\n        }\r\n    }\r\n    /**\r\n     * Test if this range is empty.\r\n     */\r\n    isEmpty() {\r\n        return Range.isEmpty(this);\r\n    }\r\n    /**\r\n     * Test if `range` is empty.\r\n     */\r\n    static isEmpty(range) {\r\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\r\n    }\r\n    /**\r\n     * Test if position is in this range. If the position is at the edges, will return true.\r\n     */\r\n    containsPosition(position) {\r\n        return Range.containsPosition(this, position);\r\n    }\r\n    /**\r\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\r\n     */\r\n    static containsPosition(range, position) {\r\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\r\n            return false;\r\n        }\r\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if range is in this range. If the range is equal to this range, will return true.\r\n     */\r\n    containsRange(range) {\r\n        return Range.containsRange(this, range);\r\n    }\r\n    /**\r\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\r\n     */\r\n    static containsRange(range, otherRange) {\r\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\r\n            return false;\r\n        }\r\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\r\n     */\r\n    strictContainsRange(range) {\r\n        return Range.strictContainsRange(this, range);\r\n    }\r\n    /**\r\n     * Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.\r\n     */\r\n    static strictContainsRange(range, otherRange) {\r\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\r\n            return false;\r\n        }\r\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * A reunion of the two ranges.\r\n     * The smallest position will be used as the start point, and the largest one as the end point.\r\n     */\r\n    plusRange(range) {\r\n        return Range.plusRange(this, range);\r\n    }\r\n    /**\r\n     * A reunion of the two ranges.\r\n     * The smallest position will be used as the start point, and the largest one as the end point.\r\n     */\r\n    static plusRange(a, b) {\r\n        let startLineNumber;\r\n        let startColumn;\r\n        let endLineNumber;\r\n        let endColumn;\r\n        if (b.startLineNumber < a.startLineNumber) {\r\n            startLineNumber = b.startLineNumber;\r\n            startColumn = b.startColumn;\r\n        }\r\n        else if (b.startLineNumber === a.startLineNumber) {\r\n            startLineNumber = b.startLineNumber;\r\n            startColumn = Math.min(b.startColumn, a.startColumn);\r\n        }\r\n        else {\r\n            startLineNumber = a.startLineNumber;\r\n            startColumn = a.startColumn;\r\n        }\r\n        if (b.endLineNumber > a.endLineNumber) {\r\n            endLineNumber = b.endLineNumber;\r\n            endColumn = b.endColumn;\r\n        }\r\n        else if (b.endLineNumber === a.endLineNumber) {\r\n            endLineNumber = b.endLineNumber;\r\n            endColumn = Math.max(b.endColumn, a.endColumn);\r\n        }\r\n        else {\r\n            endLineNumber = a.endLineNumber;\r\n            endColumn = a.endColumn;\r\n        }\r\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n    }\r\n    /**\r\n     * A intersection of the two ranges.\r\n     */\r\n    intersectRanges(range) {\r\n        return Range.intersectRanges(this, range);\r\n    }\r\n    /**\r\n     * A intersection of the two ranges.\r\n     */\r\n    static intersectRanges(a, b) {\r\n        let resultStartLineNumber = a.startLineNumber;\r\n        let resultStartColumn = a.startColumn;\r\n        let resultEndLineNumber = a.endLineNumber;\r\n        let resultEndColumn = a.endColumn;\r\n        let otherStartLineNumber = b.startLineNumber;\r\n        let otherStartColumn = b.startColumn;\r\n        let otherEndLineNumber = b.endLineNumber;\r\n        let otherEndColumn = b.endColumn;\r\n        if (resultStartLineNumber < otherStartLineNumber) {\r\n            resultStartLineNumber = otherStartLineNumber;\r\n            resultStartColumn = otherStartColumn;\r\n        }\r\n        else if (resultStartLineNumber === otherStartLineNumber) {\r\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\r\n        }\r\n        if (resultEndLineNumber > otherEndLineNumber) {\r\n            resultEndLineNumber = otherEndLineNumber;\r\n            resultEndColumn = otherEndColumn;\r\n        }\r\n        else if (resultEndLineNumber === otherEndLineNumber) {\r\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\r\n        }\r\n        // Check if selection is now empty\r\n        if (resultStartLineNumber > resultEndLineNumber) {\r\n            return null;\r\n        }\r\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\r\n            return null;\r\n        }\r\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\r\n    }\r\n    /**\r\n     * Test if this range equals other.\r\n     */\r\n    equalsRange(other) {\r\n        return Range.equalsRange(this, other);\r\n    }\r\n    /**\r\n     * Test if range `a` equals `b`.\r\n     */\r\n    static equalsRange(a, b) {\r\n        return (!!a &&\r\n            !!b &&\r\n            a.startLineNumber === b.startLineNumber &&\r\n            a.startColumn === b.startColumn &&\r\n            a.endLineNumber === b.endLineNumber &&\r\n            a.endColumn === b.endColumn);\r\n    }\r\n    /**\r\n     * Return the end position (which will be after or equal to the start position)\r\n     */\r\n    getEndPosition() {\r\n        return Range.getEndPosition(this);\r\n    }\r\n    /**\r\n     * Return the end position (which will be after or equal to the start position)\r\n     */\r\n    static getEndPosition(range) {\r\n        return new Position(range.endLineNumber, range.endColumn);\r\n    }\r\n    /**\r\n     * Return the start position (which will be before or equal to the end position)\r\n     */\r\n    getStartPosition() {\r\n        return Range.getStartPosition(this);\r\n    }\r\n    /**\r\n     * Return the start position (which will be before or equal to the end position)\r\n     */\r\n    static getStartPosition(range) {\r\n        return new Position(range.startLineNumber, range.startColumn);\r\n    }\r\n    /**\r\n     * Transform to a user presentable string representation.\r\n     */\r\n    toString() {\r\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\r\n    }\r\n    /**\r\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\r\n     */\r\n    setEndPosition(endLineNumber, endColumn) {\r\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\r\n    }\r\n    /**\r\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\r\n     */\r\n    setStartPosition(startLineNumber, startColumn) {\r\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\r\n    }\r\n    /**\r\n     * Create a new empty range using this range's start position.\r\n     */\r\n    collapseToStart() {\r\n        return Range.collapseToStart(this);\r\n    }\r\n    /**\r\n     * Create a new empty range using this range's start position.\r\n     */\r\n    static collapseToStart(range) {\r\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\r\n    }\r\n    // ---\r\n    static fromPositions(start, end = start) {\r\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\r\n    }\r\n    static lift(range) {\r\n        if (!range) {\r\n            return null;\r\n        }\r\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\r\n    }\r\n    /**\r\n     * Test if `obj` is an `IRange`.\r\n     */\r\n    static isIRange(obj) {\r\n        return (obj\r\n            && (typeof obj.startLineNumber === 'number')\r\n            && (typeof obj.startColumn === 'number')\r\n            && (typeof obj.endLineNumber === 'number')\r\n            && (typeof obj.endColumn === 'number'));\r\n    }\r\n    /**\r\n     * Test if the two ranges are touching in any way.\r\n     */\r\n    static areIntersectingOrTouching(a, b) {\r\n        // Check if `a` is before `b`\r\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\r\n            return false;\r\n        }\r\n        // Check if `b` is before `a`\r\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\r\n            return false;\r\n        }\r\n        // These ranges must intersect\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\r\n     */\r\n    static areIntersecting(a, b) {\r\n        // Check if `a` is before `b`\r\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\r\n            return false;\r\n        }\r\n        // Check if `b` is before `a`\r\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\r\n            return false;\r\n        }\r\n        // These ranges must intersect\r\n        return true;\r\n    }\r\n    /**\r\n     * A function that compares ranges, useful for sorting ranges\r\n     * It will first compare ranges on the startPosition and then on the endPosition\r\n     */\r\n    static compareRangesUsingStarts(a, b) {\r\n        if (a && b) {\r\n            const aStartLineNumber = a.startLineNumber | 0;\r\n            const bStartLineNumber = b.startLineNumber | 0;\r\n            if (aStartLineNumber === bStartLineNumber) {\r\n                const aStartColumn = a.startColumn | 0;\r\n                const bStartColumn = b.startColumn | 0;\r\n                if (aStartColumn === bStartColumn) {\r\n                    const aEndLineNumber = a.endLineNumber | 0;\r\n                    const bEndLineNumber = b.endLineNumber | 0;\r\n                    if (aEndLineNumber === bEndLineNumber) {\r\n                        const aEndColumn = a.endColumn | 0;\r\n                        const bEndColumn = b.endColumn | 0;\r\n                        return aEndColumn - bEndColumn;\r\n                    }\r\n                    return aEndLineNumber - bEndLineNumber;\r\n                }\r\n                return aStartColumn - bStartColumn;\r\n            }\r\n            return aStartLineNumber - bStartLineNumber;\r\n        }\r\n        const aExists = (a ? 1 : 0);\r\n        const bExists = (b ? 1 : 0);\r\n        return aExists - bExists;\r\n    }\r\n    /**\r\n     * A function that compares ranges, useful for sorting ranges\r\n     * It will first compare ranges on the endPosition and then on the startPosition\r\n     */\r\n    static compareRangesUsingEnds(a, b) {\r\n        if (a.endLineNumber === b.endLineNumber) {\r\n            if (a.endColumn === b.endColumn) {\r\n                if (a.startLineNumber === b.startLineNumber) {\r\n                    return a.startColumn - b.startColumn;\r\n                }\r\n                return a.startLineNumber - b.startLineNumber;\r\n            }\r\n            return a.endColumn - b.endColumn;\r\n        }\r\n        return a.endLineNumber - b.endLineNumber;\r\n    }\r\n    /**\r\n     * Test if the range spans multiple lines.\r\n     */\r\n    static spansMultipleLines(range) {\r\n        return range.endLineNumber > range.startLineNumber;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}