{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport class KeybindingResolver {\n  constructor(defaultKeybindings, overrides, log) {\n    this._log = log;\n    this._defaultKeybindings = defaultKeybindings;\n    this._defaultBoundCommands = new Map();\n    for (let i = 0, len = defaultKeybindings.length; i < len; i++) {\n      const command = defaultKeybindings[i].command;\n      if (command) {\n        this._defaultBoundCommands.set(command, true);\n      }\n    }\n    this._map = new Map();\n    this._lookupMap = new Map();\n    this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\n    for (let i = 0, len = this._keybindings.length; i < len; i++) {\n      let k = this._keybindings[i];\n      if (k.keypressParts.length === 0) {\n        // unbound\n        continue;\n      }\n      if (k.when && k.when.type === 0 /* False */) {\n        // when condition is false\n        continue;\n      }\n      // TODO@chords\n      this._addKeyPress(k.keypressParts[0], k);\n    }\n  }\n  static _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, command, when) {\n    if (defaultKb.command !== command) {\n      return false;\n    }\n    // TODO@chords\n    if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n      return false;\n    }\n    // TODO@chords\n    if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n      return false;\n    }\n    if (when) {\n      if (!defaultKb.when) {\n        return false;\n      }\n      if (!when.equals(defaultKb.when)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\r\n   * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\r\n   */\n  static combine(defaults, rawOverrides) {\n    defaults = defaults.slice(0);\n    let overrides = [];\n    for (const override of rawOverrides) {\n      if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\n        overrides.push(override);\n        continue;\n      }\n      const command = override.command.substr(1);\n      // TODO@chords\n      const keypressFirstPart = override.keypressParts[0];\n      const keypressChordPart = override.keypressParts[1];\n      const when = override.when;\n      for (let j = defaults.length - 1; j >= 0; j--) {\n        if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\n          defaults.splice(j, 1);\n        }\n      }\n    }\n    return defaults.concat(overrides);\n  }\n  _addKeyPress(keypress, item) {\n    const conflicts = this._map.get(keypress);\n    if (typeof conflicts === 'undefined') {\n      // There is no conflict so far\n      this._map.set(keypress, [item]);\n      this._addToLookupMap(item);\n      return;\n    }\n    for (let i = conflicts.length - 1; i >= 0; i--) {\n      let conflict = conflicts[i];\n      if (conflict.command === item.command) {\n        continue;\n      }\n      const conflictIsChord = conflict.keypressParts.length > 1;\n      const itemIsChord = item.keypressParts.length > 1;\n      // TODO@chords\n      if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n        // The conflict only shares the chord start with this command\n        continue;\n      }\n      if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n        // `item` completely overwrites `conflict`\n        // Remove conflict from the lookupMap\n        this._removeFromLookupMap(conflict);\n      }\n    }\n    conflicts.push(item);\n    this._addToLookupMap(item);\n  }\n  _addToLookupMap(item) {\n    if (!item.command) {\n      return;\n    }\n    let arr = this._lookupMap.get(item.command);\n    if (typeof arr === 'undefined') {\n      arr = [item];\n      this._lookupMap.set(item.command, arr);\n    } else {\n      arr.push(item);\n    }\n  }\n  _removeFromLookupMap(item) {\n    if (!item.command) {\n      return;\n    }\n    let arr = this._lookupMap.get(item.command);\n    if (typeof arr === 'undefined') {\n      return;\n    }\n    for (let i = 0, len = arr.length; i < len; i++) {\n      if (arr[i] === item) {\n        arr.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\r\n   * Returns true if it is provable `a` implies `b`.\r\n   */\n  static whenIsEntirelyIncluded(a, b) {\n    if (!b) {\n      return true;\n    }\n    if (!a) {\n      return false;\n    }\n    return this._implies(a, b);\n  }\n  /**\r\n   * Returns true if it is provable `p` implies `q`.\r\n   */\n  static _implies(p, q) {\n    const notP = p.negate();\n    const terminals = node => {\n      if (node.type === 9 /* Or */) {\n        return node.expr;\n      }\n      return [node];\n    };\n    let expr = terminals(notP).concat(terminals(q));\n    for (let i = 0; i < expr.length; i++) {\n      const a = expr[i];\n      const notA = a.negate();\n      for (let j = i + 1; j < expr.length; j++) {\n        const b = expr[j];\n        if (notA.equals(b)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  getKeybindings() {\n    return this._keybindings;\n  }\n  lookupPrimaryKeybinding(commandId) {\n    let items = this._lookupMap.get(commandId);\n    if (typeof items === 'undefined' || items.length === 0) {\n      return null;\n    }\n    return items[items.length - 1];\n  }\n  resolve(context, currentChord, keypress) {\n    this._log(\"| Resolving \".concat(keypress).concat(currentChord ? \" chorded from \".concat(currentChord) : \"\"));\n    let lookupMap = null;\n    if (currentChord !== null) {\n      // Fetch all chord bindings for `currentChord`\n      const candidates = this._map.get(currentChord);\n      if (typeof candidates === 'undefined') {\n        // No chords starting with `currentChord`\n        this._log(\"\\\\ No keybinding entries.\");\n        return null;\n      }\n      lookupMap = [];\n      for (let i = 0, len = candidates.length; i < len; i++) {\n        let candidate = candidates[i];\n        // TODO@chords\n        if (candidate.keypressParts[1] === keypress) {\n          lookupMap.push(candidate);\n        }\n      }\n    } else {\n      const candidates = this._map.get(keypress);\n      if (typeof candidates === 'undefined') {\n        // No bindings with `keypress`\n        this._log(\"\\\\ No keybinding entries.\");\n        return null;\n      }\n      lookupMap = candidates;\n    }\n    let result = this._findCommand(context, lookupMap);\n    if (!result) {\n      this._log(\"\\\\ From \".concat(lookupMap.length, \" keybinding entries, no when clauses matched the context.\"));\n      return null;\n    }\n    // TODO@chords\n    if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n      this._log(\"\\\\ From \".concat(lookupMap.length, \" keybinding entries, matched chord, when: \").concat(printWhenExplanation(result.when), \", source: \").concat(printSourceExplanation(result), \".\"));\n      return {\n        enterChord: true,\n        leaveChord: false,\n        commandId: null,\n        commandArgs: null,\n        bubble: false\n      };\n    }\n    this._log(\"\\\\ From \".concat(lookupMap.length, \" keybinding entries, matched \").concat(result.command, \", when: \").concat(printWhenExplanation(result.when), \", source: \").concat(printSourceExplanation(result), \".\"));\n    return {\n      enterChord: false,\n      leaveChord: result.keypressParts.length > 1,\n      commandId: result.command,\n      commandArgs: result.commandArgs,\n      bubble: result.bubble\n    };\n  }\n  _findCommand(context, matches) {\n    for (let i = matches.length - 1; i >= 0; i--) {\n      let k = matches[i];\n      if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\n        continue;\n      }\n      return k;\n    }\n    return null;\n  }\n  static contextMatchesRules(context, rules) {\n    if (!rules) {\n      return true;\n    }\n    return rules.evaluate(context);\n  }\n}\nfunction printWhenExplanation(when) {\n  if (!when) {\n    return \"no when condition\";\n  }\n  return \"\".concat(when.serialize());\n}\nfunction printSourceExplanation(kb) {\n  return kb.extensionId ? kb.isBuiltinExtension ? \"built-in extension \".concat(kb.extensionId) : \"user extension \".concat(kb.extensionId) : kb.isDefault ? \"built-in\" : \"user\";\n}","map":{"version":3,"names":["KeybindingResolver","constructor","defaultKeybindings","overrides","log","_log","_defaultKeybindings","_defaultBoundCommands","Map","i","len","length","command","set","_map","_lookupMap","_keybindings","combine","k","keypressParts","when","type","_addKeyPress","_isTargetedForRemoval","defaultKb","keypressFirstPart","keypressChordPart","equals","defaults","rawOverrides","slice","override","charAt","push","substr","j","splice","concat","keypress","item","conflicts","get","_addToLookupMap","conflict","conflictIsChord","itemIsChord","whenIsEntirelyIncluded","_removeFromLookupMap","arr","a","b","_implies","p","q","notP","negate","terminals","node","expr","notA","getKeybindings","lookupPrimaryKeybinding","commandId","items","resolve","context","currentChord","lookupMap","candidates","candidate","result","_findCommand","printWhenExplanation","printSourceExplanation","enterChord","leaveChord","commandArgs","bubble","matches","contextMatchesRules","rules","evaluate","serialize","kb","extensionId","isBuiltinExtension","isDefault"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport class KeybindingResolver {\r\n    constructor(defaultKeybindings, overrides, log) {\r\n        this._log = log;\r\n        this._defaultKeybindings = defaultKeybindings;\r\n        this._defaultBoundCommands = new Map();\r\n        for (let i = 0, len = defaultKeybindings.length; i < len; i++) {\r\n            const command = defaultKeybindings[i].command;\r\n            if (command) {\r\n                this._defaultBoundCommands.set(command, true);\r\n            }\r\n        }\r\n        this._map = new Map();\r\n        this._lookupMap = new Map();\r\n        this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\r\n        for (let i = 0, len = this._keybindings.length; i < len; i++) {\r\n            let k = this._keybindings[i];\r\n            if (k.keypressParts.length === 0) {\r\n                // unbound\r\n                continue;\r\n            }\r\n            if (k.when && k.when.type === 0 /* False */) {\r\n                // when condition is false\r\n                continue;\r\n            }\r\n            // TODO@chords\r\n            this._addKeyPress(k.keypressParts[0], k);\r\n        }\r\n    }\r\n    static _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, command, when) {\r\n        if (defaultKb.command !== command) {\r\n            return false;\r\n        }\r\n        // TODO@chords\r\n        if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\r\n            return false;\r\n        }\r\n        // TODO@chords\r\n        if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\r\n            return false;\r\n        }\r\n        if (when) {\r\n            if (!defaultKb.when) {\r\n                return false;\r\n            }\r\n            if (!when.equals(defaultKb.when)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\r\n     */\r\n    static combine(defaults, rawOverrides) {\r\n        defaults = defaults.slice(0);\r\n        let overrides = [];\r\n        for (const override of rawOverrides) {\r\n            if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\r\n                overrides.push(override);\r\n                continue;\r\n            }\r\n            const command = override.command.substr(1);\r\n            // TODO@chords\r\n            const keypressFirstPart = override.keypressParts[0];\r\n            const keypressChordPart = override.keypressParts[1];\r\n            const when = override.when;\r\n            for (let j = defaults.length - 1; j >= 0; j--) {\r\n                if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\r\n                    defaults.splice(j, 1);\r\n                }\r\n            }\r\n        }\r\n        return defaults.concat(overrides);\r\n    }\r\n    _addKeyPress(keypress, item) {\r\n        const conflicts = this._map.get(keypress);\r\n        if (typeof conflicts === 'undefined') {\r\n            // There is no conflict so far\r\n            this._map.set(keypress, [item]);\r\n            this._addToLookupMap(item);\r\n            return;\r\n        }\r\n        for (let i = conflicts.length - 1; i >= 0; i--) {\r\n            let conflict = conflicts[i];\r\n            if (conflict.command === item.command) {\r\n                continue;\r\n            }\r\n            const conflictIsChord = (conflict.keypressParts.length > 1);\r\n            const itemIsChord = (item.keypressParts.length > 1);\r\n            // TODO@chords\r\n            if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\r\n                // The conflict only shares the chord start with this command\r\n                continue;\r\n            }\r\n            if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\r\n                // `item` completely overwrites `conflict`\r\n                // Remove conflict from the lookupMap\r\n                this._removeFromLookupMap(conflict);\r\n            }\r\n        }\r\n        conflicts.push(item);\r\n        this._addToLookupMap(item);\r\n    }\r\n    _addToLookupMap(item) {\r\n        if (!item.command) {\r\n            return;\r\n        }\r\n        let arr = this._lookupMap.get(item.command);\r\n        if (typeof arr === 'undefined') {\r\n            arr = [item];\r\n            this._lookupMap.set(item.command, arr);\r\n        }\r\n        else {\r\n            arr.push(item);\r\n        }\r\n    }\r\n    _removeFromLookupMap(item) {\r\n        if (!item.command) {\r\n            return;\r\n        }\r\n        let arr = this._lookupMap.get(item.command);\r\n        if (typeof arr === 'undefined') {\r\n            return;\r\n        }\r\n        for (let i = 0, len = arr.length; i < len; i++) {\r\n            if (arr[i] === item) {\r\n                arr.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if it is provable `a` implies `b`.\r\n     */\r\n    static whenIsEntirelyIncluded(a, b) {\r\n        if (!b) {\r\n            return true;\r\n        }\r\n        if (!a) {\r\n            return false;\r\n        }\r\n        return this._implies(a, b);\r\n    }\r\n    /**\r\n     * Returns true if it is provable `p` implies `q`.\r\n     */\r\n    static _implies(p, q) {\r\n        const notP = p.negate();\r\n        const terminals = (node) => {\r\n            if (node.type === 9 /* Or */) {\r\n                return node.expr;\r\n            }\r\n            return [node];\r\n        };\r\n        let expr = terminals(notP).concat(terminals(q));\r\n        for (let i = 0; i < expr.length; i++) {\r\n            const a = expr[i];\r\n            const notA = a.negate();\r\n            for (let j = i + 1; j < expr.length; j++) {\r\n                const b = expr[j];\r\n                if (notA.equals(b)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    getKeybindings() {\r\n        return this._keybindings;\r\n    }\r\n    lookupPrimaryKeybinding(commandId) {\r\n        let items = this._lookupMap.get(commandId);\r\n        if (typeof items === 'undefined' || items.length === 0) {\r\n            return null;\r\n        }\r\n        return items[items.length - 1];\r\n    }\r\n    resolve(context, currentChord, keypress) {\r\n        this._log(`| Resolving ${keypress}${currentChord ? ` chorded from ${currentChord}` : ``}`);\r\n        let lookupMap = null;\r\n        if (currentChord !== null) {\r\n            // Fetch all chord bindings for `currentChord`\r\n            const candidates = this._map.get(currentChord);\r\n            if (typeof candidates === 'undefined') {\r\n                // No chords starting with `currentChord`\r\n                this._log(`\\\\ No keybinding entries.`);\r\n                return null;\r\n            }\r\n            lookupMap = [];\r\n            for (let i = 0, len = candidates.length; i < len; i++) {\r\n                let candidate = candidates[i];\r\n                // TODO@chords\r\n                if (candidate.keypressParts[1] === keypress) {\r\n                    lookupMap.push(candidate);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            const candidates = this._map.get(keypress);\r\n            if (typeof candidates === 'undefined') {\r\n                // No bindings with `keypress`\r\n                this._log(`\\\\ No keybinding entries.`);\r\n                return null;\r\n            }\r\n            lookupMap = candidates;\r\n        }\r\n        let result = this._findCommand(context, lookupMap);\r\n        if (!result) {\r\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\r\n            return null;\r\n        }\r\n        // TODO@chords\r\n        if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\r\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched chord, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\r\n            return {\r\n                enterChord: true,\r\n                leaveChord: false,\r\n                commandId: null,\r\n                commandArgs: null,\r\n                bubble: false\r\n            };\r\n        }\r\n        this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\r\n        return {\r\n            enterChord: false,\r\n            leaveChord: result.keypressParts.length > 1,\r\n            commandId: result.command,\r\n            commandArgs: result.commandArgs,\r\n            bubble: result.bubble\r\n        };\r\n    }\r\n    _findCommand(context, matches) {\r\n        for (let i = matches.length - 1; i >= 0; i--) {\r\n            let k = matches[i];\r\n            if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\r\n                continue;\r\n            }\r\n            return k;\r\n        }\r\n        return null;\r\n    }\r\n    static contextMatchesRules(context, rules) {\r\n        if (!rules) {\r\n            return true;\r\n        }\r\n        return rules.evaluate(context);\r\n    }\r\n}\r\nfunction printWhenExplanation(when) {\r\n    if (!when) {\r\n        return `no when condition`;\r\n    }\r\n    return `${when.serialize()}`;\r\n}\r\nfunction printSourceExplanation(kb) {\r\n    return (kb.extensionId\r\n        ? (kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}`)\r\n        : (kb.isDefault ? `built-in` : `user`));\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}