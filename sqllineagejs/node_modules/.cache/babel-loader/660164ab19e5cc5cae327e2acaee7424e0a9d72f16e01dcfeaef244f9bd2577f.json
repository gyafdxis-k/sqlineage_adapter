{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n  constructor(opts) {\n    opts = opts || {};\n    opts.brackets = opts.brackets || [['(', ')'], ['{', '}'], ['[', ']']];\n    this._brackets = [];\n    opts.brackets.forEach(bracket => {\n      const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n      const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n      if (openRegExp && closeRegExp) {\n        this._brackets.push({\n          open: bracket[0],\n          openRegExp: openRegExp,\n          close: bracket[1],\n          closeRegExp: closeRegExp\n        });\n      }\n    });\n    this._regExpRules = opts.onEnterRules || [];\n  }\n  onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n    // (1): `regExpRules`\n    if (autoIndent >= 3 /* Advanced */) {\n      for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n        let rule = this._regExpRules[i];\n        const regResult = [{\n          reg: rule.beforeText,\n          text: beforeEnterText\n        }, {\n          reg: rule.afterText,\n          text: afterEnterText\n        }, {\n          reg: rule.previousLineText,\n          text: previousLineText\n        }].every(obj => {\n          return obj.reg ? obj.reg.test(obj.text) : true;\n        });\n        if (regResult) {\n          return rule.action;\n        }\n      }\n    }\n    // (2): Special indent-outdent\n    if (autoIndent >= 2 /* Brackets */) {\n      if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n        for (let i = 0, len = this._brackets.length; i < len; i++) {\n          let bracket = this._brackets[i];\n          if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n            return {\n              indentAction: IndentAction.IndentOutdent\n            };\n          }\n        }\n      }\n    }\n    // (4): Open bracket based logic\n    if (autoIndent >= 2 /* Brackets */) {\n      if (beforeEnterText.length > 0) {\n        for (let i = 0, len = this._brackets.length; i < len; i++) {\n          let bracket = this._brackets[i];\n          if (bracket.openRegExp.test(beforeEnterText)) {\n            return {\n              indentAction: IndentAction.Indent\n            };\n          }\n        }\n      }\n    }\n    return null;\n  }\n  static _createOpenBracketRegExp(bracket) {\n    let str = strings.escapeRegExpCharacters(bracket);\n    if (!/\\B/.test(str.charAt(0))) {\n      str = '\\\\b' + str;\n    }\n    str += '\\\\s*$';\n    return OnEnterSupport._safeRegExp(str);\n  }\n  static _createCloseBracketRegExp(bracket) {\n    let str = strings.escapeRegExpCharacters(bracket);\n    if (!/\\B/.test(str.charAt(str.length - 1))) {\n      str = str + '\\\\b';\n    }\n    str = '^\\\\s*' + str;\n    return OnEnterSupport._safeRegExp(str);\n  }\n  static _safeRegExp(def) {\n    try {\n      return new RegExp(def);\n    } catch (err) {\n      onUnexpectedError(err);\n      return null;\n    }\n  }\n}","map":{"version":3,"names":["onUnexpectedError","strings","IndentAction","OnEnterSupport","constructor","opts","brackets","_brackets","forEach","bracket","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","push","open","close","_regExpRules","onEnterRules","onEnter","autoIndent","previousLineText","beforeEnterText","afterEnterText","i","len","length","rule","regResult","reg","beforeText","text","afterText","every","obj","test","action","indentAction","IndentOutdent","Indent","str","escapeRegExpCharacters","charAt","_safeRegExp","def","RegExp","err"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/modes/supports/onEnter.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\r\nimport * as strings from '../../../../base/common/strings.js';\r\nimport { IndentAction } from '../languageConfiguration.js';\r\nexport class OnEnterSupport {\r\n    constructor(opts) {\r\n        opts = opts || {};\r\n        opts.brackets = opts.brackets || [\r\n            ['(', ')'],\r\n            ['{', '}'],\r\n            ['[', ']']\r\n        ];\r\n        this._brackets = [];\r\n        opts.brackets.forEach((bracket) => {\r\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\r\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\r\n            if (openRegExp && closeRegExp) {\r\n                this._brackets.push({\r\n                    open: bracket[0],\r\n                    openRegExp: openRegExp,\r\n                    close: bracket[1],\r\n                    closeRegExp: closeRegExp,\r\n                });\r\n            }\r\n        });\r\n        this._regExpRules = opts.onEnterRules || [];\r\n    }\r\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\r\n        // (1): `regExpRules`\r\n        if (autoIndent >= 3 /* Advanced */) {\r\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\r\n                let rule = this._regExpRules[i];\r\n                const regResult = [{\r\n                        reg: rule.beforeText,\r\n                        text: beforeEnterText\r\n                    }, {\r\n                        reg: rule.afterText,\r\n                        text: afterEnterText\r\n                    }, {\r\n                        reg: rule.previousLineText,\r\n                        text: previousLineText\r\n                    }].every((obj) => {\r\n                    return obj.reg ? obj.reg.test(obj.text) : true;\r\n                });\r\n                if (regResult) {\r\n                    return rule.action;\r\n                }\r\n            }\r\n        }\r\n        // (2): Special indent-outdent\r\n        if (autoIndent >= 2 /* Brackets */) {\r\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\r\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\r\n                    let bracket = this._brackets[i];\r\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\r\n                        return { indentAction: IndentAction.IndentOutdent };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // (4): Open bracket based logic\r\n        if (autoIndent >= 2 /* Brackets */) {\r\n            if (beforeEnterText.length > 0) {\r\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\r\n                    let bracket = this._brackets[i];\r\n                    if (bracket.openRegExp.test(beforeEnterText)) {\r\n                        return { indentAction: IndentAction.Indent };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _createOpenBracketRegExp(bracket) {\r\n        let str = strings.escapeRegExpCharacters(bracket);\r\n        if (!/\\B/.test(str.charAt(0))) {\r\n            str = '\\\\b' + str;\r\n        }\r\n        str += '\\\\s*$';\r\n        return OnEnterSupport._safeRegExp(str);\r\n    }\r\n    static _createCloseBracketRegExp(bracket) {\r\n        let str = strings.escapeRegExpCharacters(bracket);\r\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\r\n            str = str + '\\\\b';\r\n        }\r\n        str = '^\\\\s*' + str;\r\n        return OnEnterSupport._safeRegExp(str);\r\n    }\r\n    static _safeRegExp(def) {\r\n        try {\r\n            return new RegExp(def);\r\n        }\r\n        catch (err) {\r\n            onUnexpectedError(err);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,iBAAiB,QAAQ,mCAAmC;AACrE,OAAO,KAAKC,OAAO,MAAM,oCAAoC;AAC7D,SAASC,YAAY,QAAQ,6BAA6B;AAC1D,OAAO,MAAMC,cAAc,CAAC;EACxBC,WAAWA,CAACC,IAAI,EAAE;IACdA,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;IACjBA,IAAI,CAACC,QAAQ,GAAGD,IAAI,CAACC,QAAQ,IAAI,CAC7B,CAAC,GAAG,EAAE,GAAG,CAAC,EACV,CAAC,GAAG,EAAE,GAAG,CAAC,EACV,CAAC,GAAG,EAAE,GAAG,CAAC,CACb;IACD,IAAI,CAACC,SAAS,GAAG,EAAE;IACnBF,IAAI,CAACC,QAAQ,CAACE,OAAO,CAAEC,OAAO,IAAK;MAC/B,MAAMC,UAAU,GAAGP,cAAc,CAACQ,wBAAwB,CAACF,OAAO,CAAC,CAAC,CAAC,CAAC;MACtE,MAAMG,WAAW,GAAGT,cAAc,CAACU,yBAAyB,CAACJ,OAAO,CAAC,CAAC,CAAC,CAAC;MACxE,IAAIC,UAAU,IAAIE,WAAW,EAAE;QAC3B,IAAI,CAACL,SAAS,CAACO,IAAI,CAAC;UAChBC,IAAI,EAAEN,OAAO,CAAC,CAAC,CAAC;UAChBC,UAAU,EAAEA,UAAU;UACtBM,KAAK,EAAEP,OAAO,CAAC,CAAC,CAAC;UACjBG,WAAW,EAAEA;QACjB,CAAC,CAAC;MACN;IACJ,CAAC,CAAC;IACF,IAAI,CAACK,YAAY,GAAGZ,IAAI,CAACa,YAAY,IAAI,EAAE;EAC/C;EACAC,OAAOA,CAACC,UAAU,EAAEC,gBAAgB,EAAEC,eAAe,EAAEC,cAAc,EAAE;IACnE;IACA,IAAIH,UAAU,IAAI,CAAC,CAAC,gBAAgB;MAChC,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACR,YAAY,CAACS,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QAC1D,IAAIG,IAAI,GAAG,IAAI,CAACV,YAAY,CAACO,CAAC,CAAC;QAC/B,MAAMI,SAAS,GAAG,CAAC;UACXC,GAAG,EAAEF,IAAI,CAACG,UAAU;UACpBC,IAAI,EAAET;QACV,CAAC,EAAE;UACCO,GAAG,EAAEF,IAAI,CAACK,SAAS;UACnBD,IAAI,EAAER;QACV,CAAC,EAAE;UACCM,GAAG,EAAEF,IAAI,CAACN,gBAAgB;UAC1BU,IAAI,EAAEV;QACV,CAAC,CAAC,CAACY,KAAK,CAAEC,GAAG,IAAK;UAClB,OAAOA,GAAG,CAACL,GAAG,GAAGK,GAAG,CAACL,GAAG,CAACM,IAAI,CAACD,GAAG,CAACH,IAAI,CAAC,GAAG,IAAI;QAClD,CAAC,CAAC;QACF,IAAIH,SAAS,EAAE;UACX,OAAOD,IAAI,CAACS,MAAM;QACtB;MACJ;IACJ;IACA;IACA,IAAIhB,UAAU,IAAI,CAAC,CAAC,gBAAgB;MAChC,IAAIE,eAAe,CAACI,MAAM,GAAG,CAAC,IAAIH,cAAc,CAACG,MAAM,GAAG,CAAC,EAAE;QACzD,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAAClB,SAAS,CAACmB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;UACvD,IAAIf,OAAO,GAAG,IAAI,CAACF,SAAS,CAACiB,CAAC,CAAC;UAC/B,IAAIf,OAAO,CAACC,UAAU,CAACyB,IAAI,CAACb,eAAe,CAAC,IAAIb,OAAO,CAACG,WAAW,CAACuB,IAAI,CAACZ,cAAc,CAAC,EAAE;YACtF,OAAO;cAAEc,YAAY,EAAEnC,YAAY,CAACoC;YAAc,CAAC;UACvD;QACJ;MACJ;IACJ;IACA;IACA,IAAIlB,UAAU,IAAI,CAAC,CAAC,gBAAgB;MAChC,IAAIE,eAAe,CAACI,MAAM,GAAG,CAAC,EAAE;QAC5B,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAAClB,SAAS,CAACmB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;UACvD,IAAIf,OAAO,GAAG,IAAI,CAACF,SAAS,CAACiB,CAAC,CAAC;UAC/B,IAAIf,OAAO,CAACC,UAAU,CAACyB,IAAI,CAACb,eAAe,CAAC,EAAE;YAC1C,OAAO;cAAEe,YAAY,EAAEnC,YAAY,CAACqC;YAAO,CAAC;UAChD;QACJ;MACJ;IACJ;IACA,OAAO,IAAI;EACf;EACA,OAAO5B,wBAAwBA,CAACF,OAAO,EAAE;IACrC,IAAI+B,GAAG,GAAGvC,OAAO,CAACwC,sBAAsB,CAAChC,OAAO,CAAC;IACjD,IAAI,CAAC,IAAI,CAAC0B,IAAI,CAACK,GAAG,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;MAC3BF,GAAG,GAAG,KAAK,GAAGA,GAAG;IACrB;IACAA,GAAG,IAAI,OAAO;IACd,OAAOrC,cAAc,CAACwC,WAAW,CAACH,GAAG,CAAC;EAC1C;EACA,OAAO3B,yBAAyBA,CAACJ,OAAO,EAAE;IACtC,IAAI+B,GAAG,GAAGvC,OAAO,CAACwC,sBAAsB,CAAChC,OAAO,CAAC;IACjD,IAAI,CAAC,IAAI,CAAC0B,IAAI,CAACK,GAAG,CAACE,MAAM,CAACF,GAAG,CAACd,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;MACxCc,GAAG,GAAGA,GAAG,GAAG,KAAK;IACrB;IACAA,GAAG,GAAG,OAAO,GAAGA,GAAG;IACnB,OAAOrC,cAAc,CAACwC,WAAW,CAACH,GAAG,CAAC;EAC1C;EACA,OAAOG,WAAWA,CAACC,GAAG,EAAE;IACpB,IAAI;MACA,OAAO,IAAIC,MAAM,CAACD,GAAG,CAAC;IAC1B,CAAC,CACD,OAAOE,GAAG,EAAE;MACR9C,iBAAiB,CAAC8C,GAAG,CAAC;MACtB,OAAO,IAAI;IACf;EACJ;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}