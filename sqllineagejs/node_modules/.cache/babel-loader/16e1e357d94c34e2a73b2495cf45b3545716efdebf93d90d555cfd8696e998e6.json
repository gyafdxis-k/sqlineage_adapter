{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nexport class BlockCommentCommand {\n  constructor(selection, insertSpace) {\n    this._selection = selection;\n    this._insertSpace = insertSpace;\n    this._usedEndToken = null;\n  }\n  static _haystackHasNeedleAtOffset(haystack, needle, offset) {\n    if (offset < 0) {\n      return false;\n    }\n    const needleLength = needle.length;\n    const haystackLength = haystack.length;\n    if (offset + needleLength > haystackLength) {\n      return false;\n    }\n    for (let i = 0; i < needleLength; i++) {\n      const codeA = haystack.charCodeAt(offset + i);\n      const codeB = needle.charCodeAt(i);\n      if (codeA === codeB) {\n        continue;\n      }\n      if (codeA >= 65 /* A */ && codeA <= 90 /* Z */ && codeA + 32 === codeB) {\n        // codeA is upper-case variant of codeB\n        continue;\n      }\n      if (codeB >= 65 /* A */ && codeB <= 90 /* Z */ && codeB + 32 === codeA) {\n        // codeB is upper-case variant of codeA\n        continue;\n      }\n      return false;\n    }\n    return true;\n  }\n  _createOperationsForBlockComment(selection, startToken, endToken, insertSpace, model, builder) {\n    const startLineNumber = selection.startLineNumber;\n    const startColumn = selection.startColumn;\n    const endLineNumber = selection.endLineNumber;\n    const endColumn = selection.endColumn;\n    const startLineText = model.getLineContent(startLineNumber);\n    const endLineText = model.getLineContent(endLineNumber);\n    let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);\n    let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      if (startLineNumber === endLineNumber) {\n        const lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);\n        if (lineBetweenTokens.indexOf(endToken) >= 0) {\n          // force to add a block comment\n          startTokenIndex = -1;\n          endTokenIndex = -1;\n        }\n      } else {\n        const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);\n        const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);\n        if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {\n          // force to add a block comment\n          startTokenIndex = -1;\n          endTokenIndex = -1;\n        }\n      }\n    }\n    let ops;\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      // Consider spaces as part of the comment tokens\n      if (insertSpace && startTokenIndex + startToken.length < startLineText.length && startLineText.charCodeAt(startTokenIndex + startToken.length) === 32 /* Space */) {\n        // Pretend the start token contains a trailing space\n        startToken = startToken + ' ';\n      }\n      if (insertSpace && endTokenIndex > 0 && endLineText.charCodeAt(endTokenIndex - 1) === 32 /* Space */) {\n        // Pretend the end token contains a leading space\n        endToken = ' ' + endToken;\n        endTokenIndex -= 1;\n      }\n      ops = BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n    } else {\n      ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken, this._insertSpace);\n      this._usedEndToken = ops.length === 1 ? endToken : null;\n    }\n    for (const op of ops) {\n      builder.addTrackedEditOperation(op.range, op.text);\n    }\n  }\n  static _createRemoveBlockCommentOperations(r, startToken, endToken) {\n    let res = [];\n    if (!Range.isEmpty(r)) {\n      // Remove block comment start\n      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));\n      // Remove block comment end\n      res.push(EditOperation.delete(new Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));\n    } else {\n      // Remove both continuously\n      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));\n    }\n    return res;\n  }\n  static _createAddBlockCommentOperations(r, startToken, endToken, insertSpace) {\n    let res = [];\n    if (!Range.isEmpty(r)) {\n      // Insert block comment start\n      res.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + (insertSpace ? ' ' : '')));\n      // Insert block comment end\n      res.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), (insertSpace ? ' ' : '') + endToken));\n    } else {\n      // Insert both continuously\n      res.push(EditOperation.replace(new Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + '  ' + endToken));\n    }\n    return res;\n  }\n  getEditOperations(model, builder) {\n    const startLineNumber = this._selection.startLineNumber;\n    const startColumn = this._selection.startColumn;\n    model.tokenizeIfCheap(startLineNumber);\n    const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);\n    const config = LanguageConfigurationRegistry.getComments(languageId);\n    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n      // Mode does not support block comments\n      return;\n    }\n    this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, this._insertSpace, model, builder);\n  }\n  computeCursorState(model, helper) {\n    const inverseEditOperations = helper.getInverseEditOperations();\n    if (inverseEditOperations.length === 2) {\n      const startTokenEditOperation = inverseEditOperations[0];\n      const endTokenEditOperation = inverseEditOperations[1];\n      return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);\n    } else {\n      const srcRange = inverseEditOperations[0].range;\n      const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0; // minus 1 space before endToken\n      return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);\n    }\n  }\n}","map":{"version":3,"names":["EditOperation","Position","Range","Selection","LanguageConfigurationRegistry","BlockCommentCommand","constructor","selection","insertSpace","_selection","_insertSpace","_usedEndToken","_haystackHasNeedleAtOffset","haystack","needle","offset","needleLength","length","haystackLength","i","codeA","charCodeAt","codeB","_createOperationsForBlockComment","startToken","endToken","model","builder","startLineNumber","startColumn","endLineNumber","endColumn","startLineText","getLineContent","endLineText","startTokenIndex","lastIndexOf","endTokenIndex","indexOf","lineBetweenTokens","substring","startLineAfterStartToken","endLineBeforeEndToken","ops","_createRemoveBlockCommentOperations","_createAddBlockCommentOperations","op","addTrackedEditOperation","range","text","r","res","isEmpty","push","delete","insert","replace","getEditOperations","tokenizeIfCheap","languageId","getLanguageIdAtPosition","config","getComments","blockCommentStartToken","blockCommentEndToken","computeCursorState","helper","inverseEditOperations","getInverseEditOperations","startTokenEditOperation","endTokenEditOperation","srcRange","deltaColumn"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/comment/blockCommentCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { EditOperation } from '../../common/core/editOperation.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Range } from '../../common/core/range.js';\r\nimport { Selection } from '../../common/core/selection.js';\r\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\r\nexport class BlockCommentCommand {\r\n    constructor(selection, insertSpace) {\r\n        this._selection = selection;\r\n        this._insertSpace = insertSpace;\r\n        this._usedEndToken = null;\r\n    }\r\n    static _haystackHasNeedleAtOffset(haystack, needle, offset) {\r\n        if (offset < 0) {\r\n            return false;\r\n        }\r\n        const needleLength = needle.length;\r\n        const haystackLength = haystack.length;\r\n        if (offset + needleLength > haystackLength) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < needleLength; i++) {\r\n            const codeA = haystack.charCodeAt(offset + i);\r\n            const codeB = needle.charCodeAt(i);\r\n            if (codeA === codeB) {\r\n                continue;\r\n            }\r\n            if (codeA >= 65 /* A */ && codeA <= 90 /* Z */ && codeA + 32 === codeB) {\r\n                // codeA is upper-case variant of codeB\r\n                continue;\r\n            }\r\n            if (codeB >= 65 /* A */ && codeB <= 90 /* Z */ && codeB + 32 === codeA) {\r\n                // codeB is upper-case variant of codeA\r\n                continue;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    _createOperationsForBlockComment(selection, startToken, endToken, insertSpace, model, builder) {\r\n        const startLineNumber = selection.startLineNumber;\r\n        const startColumn = selection.startColumn;\r\n        const endLineNumber = selection.endLineNumber;\r\n        const endColumn = selection.endColumn;\r\n        const startLineText = model.getLineContent(startLineNumber);\r\n        const endLineText = model.getLineContent(endLineNumber);\r\n        let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);\r\n        let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);\r\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\r\n            if (startLineNumber === endLineNumber) {\r\n                const lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);\r\n                if (lineBetweenTokens.indexOf(endToken) >= 0) {\r\n                    // force to add a block comment\r\n                    startTokenIndex = -1;\r\n                    endTokenIndex = -1;\r\n                }\r\n            }\r\n            else {\r\n                const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);\r\n                const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);\r\n                if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {\r\n                    // force to add a block comment\r\n                    startTokenIndex = -1;\r\n                    endTokenIndex = -1;\r\n                }\r\n            }\r\n        }\r\n        let ops;\r\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\r\n            // Consider spaces as part of the comment tokens\r\n            if (insertSpace && startTokenIndex + startToken.length < startLineText.length && startLineText.charCodeAt(startTokenIndex + startToken.length) === 32 /* Space */) {\r\n                // Pretend the start token contains a trailing space\r\n                startToken = startToken + ' ';\r\n            }\r\n            if (insertSpace && endTokenIndex > 0 && endLineText.charCodeAt(endTokenIndex - 1) === 32 /* Space */) {\r\n                // Pretend the end token contains a leading space\r\n                endToken = ' ' + endToken;\r\n                endTokenIndex -= 1;\r\n            }\r\n            ops = BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\r\n        }\r\n        else {\r\n            ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken, this._insertSpace);\r\n            this._usedEndToken = ops.length === 1 ? endToken : null;\r\n        }\r\n        for (const op of ops) {\r\n            builder.addTrackedEditOperation(op.range, op.text);\r\n        }\r\n    }\r\n    static _createRemoveBlockCommentOperations(r, startToken, endToken) {\r\n        let res = [];\r\n        if (!Range.isEmpty(r)) {\r\n            // Remove block comment start\r\n            res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));\r\n            // Remove block comment end\r\n            res.push(EditOperation.delete(new Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));\r\n        }\r\n        else {\r\n            // Remove both continuously\r\n            res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));\r\n        }\r\n        return res;\r\n    }\r\n    static _createAddBlockCommentOperations(r, startToken, endToken, insertSpace) {\r\n        let res = [];\r\n        if (!Range.isEmpty(r)) {\r\n            // Insert block comment start\r\n            res.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + (insertSpace ? ' ' : '')));\r\n            // Insert block comment end\r\n            res.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), (insertSpace ? ' ' : '') + endToken));\r\n        }\r\n        else {\r\n            // Insert both continuously\r\n            res.push(EditOperation.replace(new Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + '  ' + endToken));\r\n        }\r\n        return res;\r\n    }\r\n    getEditOperations(model, builder) {\r\n        const startLineNumber = this._selection.startLineNumber;\r\n        const startColumn = this._selection.startColumn;\r\n        model.tokenizeIfCheap(startLineNumber);\r\n        const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);\r\n        const config = LanguageConfigurationRegistry.getComments(languageId);\r\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\r\n            // Mode does not support block comments\r\n            return;\r\n        }\r\n        this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, this._insertSpace, model, builder);\r\n    }\r\n    computeCursorState(model, helper) {\r\n        const inverseEditOperations = helper.getInverseEditOperations();\r\n        if (inverseEditOperations.length === 2) {\r\n            const startTokenEditOperation = inverseEditOperations[0];\r\n            const endTokenEditOperation = inverseEditOperations[1];\r\n            return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);\r\n        }\r\n        else {\r\n            const srcRange = inverseEditOperations[0].range;\r\n            const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0; // minus 1 space before endToken\r\n            return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}