{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport * as strings from './strings.js';\n// Combined filters\n/**\r\n * @returns A filter which combines the provided set\r\n * of filters with an or. The *first* filters that\r\n * matches defined the return value of the returned\r\n * filter.\r\n */\nexport function or() {\n  for (var _len = arguments.length, filter = new Array(_len), _key = 0; _key < _len; _key++) {\n    filter[_key] = arguments[_key];\n  }\n  return function (word, wordToMatchAgainst) {\n    for (let i = 0, len = filter.length; i < len; i++) {\n      const match = filter[i](word, wordToMatchAgainst);\n      if (match) {\n        return match;\n      }\n    }\n    return null;\n  };\n}\nexport const matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n    return null;\n  }\n  let matches;\n  if (ignoreCase) {\n    matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n  } else {\n    matches = wordToMatchAgainst.indexOf(word) === 0;\n  }\n  if (!matches) {\n    return null;\n  }\n  return word.length > 0 ? [{\n    start: 0,\n    end: word.length\n  }] : [];\n}\n// Contiguous Substring\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n  const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n  if (index === -1) {\n    return null;\n  }\n  return [{\n    start: index,\n    end: index + word.length\n  }];\n}\n// Substring\nexport function matchesSubString(word, wordToMatchAgainst) {\n  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === wordToMatchAgainst.length) {\n    return null;\n  } else {\n    if (word[i] === wordToMatchAgainst[j]) {\n      let result = null;\n      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n        return join({\n          start: j,\n          end: j + 1\n        }, result);\n      }\n      return null;\n    }\n    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n  }\n}\n// CamelCase\nfunction isLower(code) {\n  return 97 /* a */ <= code && code <= 122 /* z */;\n}\n\nexport function isUpper(code) {\n  return 65 /* A */ <= code && code <= 90 /* Z */;\n}\n\nfunction isNumber(code) {\n  return 48 /* Digit0 */ <= code && code <= 57 /* Digit9 */;\n}\n\nfunction isWhitespace(code) {\n  return code === 32 /* Space */ || code === 9 /* Tab */ || code === 10 /* LineFeed */ || code === 13 /* CarriageReturn */;\n}\n\nconst wordSeparators = new Set();\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'.split('').forEach(s => wordSeparators.add(s.charCodeAt(0)));\nfunction isWordSeparator(code) {\n  return isWhitespace(code) || wordSeparators.has(code);\n}\nfunction charactersMatch(codeA, codeB) {\n  return codeA === codeB || isWordSeparator(codeA) && isWordSeparator(codeB);\n}\nfunction isAlphanumeric(code) {\n  return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n  if (tail.length === 0) {\n    tail = [head];\n  } else if (head.end === tail[0].start) {\n    tail[0].start = head.start;\n  } else {\n    tail.unshift(head);\n  }\n  return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n  for (let i = start; i < camelCaseWord.length; i++) {\n    const c = camelCaseWord.charCodeAt(i);\n    if (isUpper(c) || isNumber(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n  return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === camelCaseWord.length) {\n    return null;\n  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n    return null;\n  } else {\n    let result = null;\n    let nextUpperIndex = j + 1;\n    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n      nextUpperIndex++;\n    }\n    return result === null ? null : join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word) {\n  let upper = 0,\n    lower = 0,\n    alpha = 0,\n    numeric = 0,\n    code = 0;\n  for (let i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n    if (isUpper(code)) {\n      upper++;\n    }\n    if (isLower(code)) {\n      lower++;\n    }\n    if (isAlphanumeric(code)) {\n      alpha++;\n    }\n    if (isNumber(code)) {\n      numeric++;\n    }\n  }\n  const upperPercent = upper / word.length;\n  const lowerPercent = lower / word.length;\n  const alphaPercent = alpha / word.length;\n  const numericPercent = numeric / word.length;\n  return {\n    upperPercent,\n    lowerPercent,\n    alphaPercent,\n    numericPercent\n  };\n}\nfunction isUpperCaseWord(analysis) {\n  const {\n    upperPercent,\n    lowerPercent\n  } = analysis;\n  return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n  const {\n    upperPercent,\n    lowerPercent,\n    alphaPercent,\n    numericPercent\n  } = analysis;\n  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word) {\n  let upper = 0,\n    lower = 0,\n    code = 0,\n    whitespace = 0;\n  for (let i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n    if (isUpper(code)) {\n      upper++;\n    }\n    if (isLower(code)) {\n      lower++;\n    }\n    if (isWhitespace(code)) {\n      whitespace++;\n    }\n  }\n  if ((upper === 0 || lower === 0) && whitespace === 0) {\n    return word.length <= 30;\n  } else {\n    return upper <= 5;\n  }\n}\nexport function matchesCamelCase(word, camelCaseWord) {\n  if (!camelCaseWord) {\n    return null;\n  }\n  camelCaseWord = camelCaseWord.trim();\n  if (camelCaseWord.length === 0) {\n    return null;\n  }\n  if (!isCamelCasePattern(word)) {\n    return null;\n  }\n  if (camelCaseWord.length > 60) {\n    return null;\n  }\n  const analysis = analyzeCamelCaseWord(camelCaseWord);\n  if (!isCamelCaseWord(analysis)) {\n    if (!isUpperCaseWord(analysis)) {\n      return null;\n    }\n    camelCaseWord = camelCaseWord.toLowerCase();\n  }\n  let result = null;\n  let i = 0;\n  word = word.toLowerCase();\n  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n    i = nextAnchor(camelCaseWord, i + 1);\n  }\n  return result;\n}\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\nexport function matchesWords(word, target) {\n  let contiguous = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!target || target.length === 0) {\n    return null;\n  }\n  let result = null;\n  let i = 0;\n  word = word.toLowerCase();\n  target = target.toLowerCase();\n  while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n    i = nextWord(target, i + 1);\n  }\n  return result;\n}\nfunction _matchesWords(word, target, i, j, contiguous) {\n  if (i === word.length) {\n    return [];\n  } else if (j === target.length) {\n    return null;\n  } else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {\n    return null;\n  } else {\n    let result = null;\n    let nextWordIndex = j + 1;\n    result = _matchesWords(word, target, i + 1, j + 1, contiguous);\n    if (!contiguous) {\n      while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n        result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n        nextWordIndex++;\n      }\n    }\n    return result === null ? null : join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n}\nfunction nextWord(word, start) {\n  for (let i = start; i < word.length; i++) {\n    if (isWordSeparator(word.charCodeAt(i)) || i > 0 && isWordSeparator(word.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n  return word.length;\n}\n// Fuzzy\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\nexport function matchesFuzzy(word, wordToMatchAgainst) {\n  let enableSeparateSubstringMatching = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n    return null; // return early for invalid input\n  }\n  // Form RegExp for wildcard matches\n  let regexp = fuzzyRegExpCache.get(word);\n  if (!regexp) {\n    regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n    fuzzyRegExpCache.set(word, regexp);\n  }\n  // RegExp Filter\n  const match = regexp.exec(wordToMatchAgainst);\n  if (match) {\n    return [{\n      start: match.index,\n      end: match.index + match[0].length\n    }];\n  }\n  // Default Filter\n  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\nexport function anyScore(pattern, lowPattern, _patternPos, word, lowWord, _wordPos) {\n  const result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\n  if (result) {\n    return result;\n  }\n  let matches = [];\n  let score = 0;\n  let idx = _wordPos;\n  for (let patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\n    const wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\n    if (wordPos >= 0) {\n      score += 1;\n      matches.unshift(wordPos);\n      idx = wordPos + 1;\n    } else if (matches.length > 0) {\n      // once we have started matching things\n      // we need to match the remaining pattern\n      // characters\n      break;\n    }\n  }\n  return [score, _wordPos, ...matches];\n}\n//#region --- fuzzyScore ---\nexport function createMatches(score) {\n  if (typeof score === 'undefined') {\n    return [];\n  }\n  const res = [];\n  const wordPos = score[1];\n  for (let i = score.length - 1; i > 1; i--) {\n    const pos = score[i] + wordPos;\n    const last = res[res.length - 1];\n    if (last && last.end === pos) {\n      last.end = pos + 1;\n    } else {\n      res.push({\n        start: pos,\n        end: pos + 1\n      });\n    }\n  }\n  return res;\n}\nconst _maxLen = 128;\nfunction initTable() {\n  const table = [];\n  const row = [];\n  for (let i = 0; i <= _maxLen; i++) {\n    row[i] = 0;\n  }\n  for (let i = 0; i <= _maxLen; i++) {\n    table.push(row.slice(0));\n  }\n  return table;\n}\nfunction initArr(maxLen) {\n  const row = [];\n  for (let i = 0; i <= maxLen; i++) {\n    row[i] = 0;\n  }\n  return row;\n}\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = initTable();\nconst _debug = false;\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n  function pad(s, n) {\n    let pad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' ';\n    while (s.length < n) {\n      s = pad + s;\n    }\n    return s;\n  }\n  let ret = \" |   |\".concat(word.split('').map(c => pad(c, 3)).join('|'), \"\\n\");\n  for (let i = 0; i <= patternLen; i++) {\n    if (i === 0) {\n      ret += ' |';\n    } else {\n      ret += \"\".concat(pattern[i - 1], \"|\");\n    }\n    ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n  }\n  return ret;\n}\nfunction printTables(pattern, patternStart, word, wordStart) {\n  pattern = pattern.substr(patternStart);\n  word = word.substr(wordStart);\n  console.log(printTable(_table, pattern, pattern.length, word, word.length));\n  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n  console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\nfunction isSeparatorAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  const code = value.codePointAt(index);\n  switch (code) {\n    case 95 /* Underline */:\n    case 45 /* Dash */:\n    case 46 /* Period */:\n    case 32 /* Space */:\n    case 47 /* Slash */:\n    case 92 /* Backslash */:\n    case 39 /* SingleQuote */:\n    case 34 /* DoubleQuote */:\n    case 58 /* Colon */:\n    case 36 /* DollarSign */:\n    case 60 /* LessThan */:\n    case 40 /* OpenParen */:\n    case 91 /* OpenSquareBracket */:\n      return true;\n    case undefined:\n      return false;\n    default:\n      if (strings.isEmojiImprecise(code)) {\n        return true;\n      }\n      return false;\n  }\n}\nfunction isWhitespaceAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  const code = value.charCodeAt(index);\n  switch (code) {\n    case 32 /* Space */:\n    case 9 /* Tab */:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n  return word[pos] !== wordLow[pos];\n}\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen) {\n  let fillMinWordPosArr = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  while (patternPos < patternLen && wordPos < wordLen) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      if (fillMinWordPosArr) {\n        // Remember the min word position for each pattern position\n        _minWordMatchPos[patternPos] = wordPos;\n      }\n      patternPos += 1;\n    }\n    wordPos += 1;\n  }\n  return patternPos === patternLen; // pattern must be exhausted\n}\n\nexport var FuzzyScore;\n(function (FuzzyScore) {\n  /**\r\n   * No matches and value `-100`\r\n   */\n  FuzzyScore.Default = [-100, 0];\n  function isDefault(score) {\n    return !score || score[0] === -100 && score[1] === 0 && score[2] === 0;\n  }\n  FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\n  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n  const wordLen = word.length > _maxLen ? _maxLen : word.length;\n  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {\n    return undefined;\n  }\n  // Run a simple check if the characters of pattern occur\n  // (in order) at all in word. If that isn't the case we\n  // stop because no match will be possible\n  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n    return undefined;\n  }\n  // Find the max matching word position for each pattern position\n  // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n  let row = 1;\n  let column = 1;\n  let patternPos = patternStart;\n  let wordPos = wordStart;\n  const hasStrongFirstMatch = [false];\n  // There will be a match, fill in tables\n  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n    // Reduce search space to possible matching word positions and to possible access from next row\n    const minWordMatchPos = _minWordMatchPos[patternPos];\n    const maxWordMatchPos = _maxWordMatchPos[patternPos];\n    const nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;\n    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n      let score = Number.MIN_SAFE_INTEGER;\n      let canComeDiag = false;\n      if (wordPos <= maxWordMatchPos) {\n        score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n      }\n      let diagScore = 0;\n      if (score !== Number.MAX_SAFE_INTEGER) {\n        canComeDiag = true;\n        diagScore = score + _table[row - 1][column - 1];\n      }\n      const canComeLeft = wordPos > minWordMatchPos;\n      const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n      const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n      const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n        // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n        _table[row][column] = leftLeftScore;\n        _arrows[row][column] = 3 /* LeftLeft */;\n        _diag[row][column] = 0;\n      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n        // always prefer choosing left since that means a match is earlier in the word\n        _table[row][column] = leftScore;\n        _arrows[row][column] = 2 /* Left */;\n        _diag[row][column] = 0;\n      } else if (canComeDiag) {\n        _table[row][column] = diagScore;\n        _arrows[row][column] = 1 /* Diag */;\n        _diag[row][column] = _diag[row - 1][column - 1] + 1;\n      } else {\n        throw new Error(\"not possible\");\n      }\n    }\n  }\n  if (_debug) {\n    printTables(pattern, patternStart, word, wordStart);\n  }\n  if (!hasStrongFirstMatch[0] && !firstMatchCanBeWeak) {\n    return undefined;\n  }\n  row--;\n  column--;\n  const result = [_table[row][column], wordStart];\n  let backwardsDiagLength = 0;\n  let maxMatchColumn = 0;\n  while (row >= 1) {\n    // Find the column where we go diagonally up\n    let diagColumn = column;\n    do {\n      const arrow = _arrows[row][diagColumn];\n      if (arrow === 3 /* LeftLeft */) {\n        diagColumn = diagColumn - 2;\n      } else if (arrow === 2 /* Left */) {\n        diagColumn = diagColumn - 1;\n      } else {\n        // found the diagonal\n        break;\n      }\n    } while (diagColumn >= 1);\n    // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n    if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n    && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n    && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n    && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n    ) {\n      diagColumn = column;\n    }\n    if (diagColumn === column) {\n      // this is a contiguous match\n      backwardsDiagLength++;\n    } else {\n      backwardsDiagLength = 1;\n    }\n    if (!maxMatchColumn) {\n      // remember the last matched column\n      maxMatchColumn = diagColumn;\n    }\n    row--;\n    column = diagColumn - 1;\n    result.push(column);\n  }\n  if (wordLen === patternLen) {\n    // the word matches the pattern with all characters!\n    // giving the score a total match boost (to come up ahead other words)\n    result[0] += 2;\n  }\n  // Add 1 penalty for each skipped character in the word\n  const skippedCharsCount = maxMatchColumn - patternLen;\n  result[0] -= skippedCharsCount;\n  return result;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n  let patternPos = patternLen - 1;\n  let wordPos = wordLen - 1;\n  while (patternPos >= patternStart && wordPos >= wordStart) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      _maxWordMatchPos[patternPos] = wordPos;\n      patternPos--;\n    }\n    wordPos--;\n  }\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n  if (patternLow[patternPos] !== wordLow[wordPos]) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n  let score = 1;\n  let isGapLocation = false;\n  if (wordPos === patternPos - patternStart) {\n    // common prefix: `foobar <-> foobaz`\n    //                            ^^^^^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n    // hitting upper-case: `foo <-> forOthers`\n    //                              ^^ ^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    isGapLocation = true;\n  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n    // hitting a separator: `. <-> foo.bar`\n    //                                ^\n    score = 5;\n  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n    // post separator: `foo <-> bar_foo`\n    //                              ^^^\n    score = 5;\n    isGapLocation = true;\n  }\n  if (score > 1 && patternPos === patternStart) {\n    outFirstMatchStrong[0] = true;\n  }\n  if (!isGapLocation) {\n    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n  }\n  //\n  if (patternPos === patternStart) {\n    // first character in pattern\n    if (wordPos > wordStart) {\n      // the first pattern character would match a word character that is not at the word start\n      // so introduce a penalty to account for the gap preceding this match\n      score -= isGapLocation ? 3 : 5;\n    }\n  } else {\n    if (newMatchStart) {\n      // this would be the beginning of a new match (i.e. there would be a gap before this location)\n      score += isGapLocation ? 2 : 0;\n    } else {\n      // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a prefered gap location\n      score += isGapLocation ? 0 : 1;\n    }\n  }\n  if (wordPos + 1 === wordLen) {\n    // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n    // so pretend there is a gap after the last character in the word to normalize things\n    score -= isGapLocation ? 3 : 5;\n  }\n  return score;\n}\n//#endregion\n//#region --- graceful ---\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\n  let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n  if (top && !aggressive) {\n    // when using the original pattern yield a result we`\n    // return it unless we are aggressive and try to find\n    // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n    return top;\n  }\n  if (pattern.length >= 3) {\n    // When the pattern is long enough then try a few (max 7)\n    // permutations of the pattern to find a better match. The\n    // permutations only swap neighbouring characters, e.g\n    // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n    const tries = Math.min(7, pattern.length - 1);\n    for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n      const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n      if (newPattern) {\n        const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n        if (candidate) {\n          candidate[0] -= 3; // permutation penalty\n          if (!top || candidate[0] > top[0]) {\n            top = candidate;\n          }\n        }\n      }\n    }\n  }\n  return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n  if (patternPos + 1 >= pattern.length) {\n    return undefined;\n  }\n  const swap1 = pattern[patternPos];\n  const swap2 = pattern[patternPos + 1];\n  if (swap1 === swap2) {\n    return undefined;\n  }\n  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);\n}\n//#endregion","map":{"version":3,"names":["LRUCache","strings","or","_len","arguments","length","filter","Array","_key","word","wordToMatchAgainst","i","len","match","matchesPrefix","_matchesPrefix","bind","undefined","ignoreCase","matches","startsWithIgnoreCase","indexOf","start","end","matchesContiguousSubString","index","toLowerCase","matchesSubString","_matchesSubString","j","result","join","isLower","code","isUpper","isNumber","isWhitespace","wordSeparators","Set","split","forEach","s","add","charCodeAt","isWordSeparator","has","charactersMatch","codeA","codeB","isAlphanumeric","head","tail","unshift","nextAnchor","camelCaseWord","c","_matchesCamelCase","nextUpperIndex","analyzeCamelCaseWord","upper","lower","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","isUpperCaseWord","analysis","isCamelCaseWord","isCamelCasePattern","whitespace","matchesCamelCase","trim","matchesWords","target","contiguous","_matchesWords","nextWord","nextWordIndex","fuzzyContiguousFilter","fuzzySeparateFilter","fuzzyRegExpCache","matchesFuzzy","enableSeparateSubstringMatching","regexp","get","RegExp","convertSimple2RegExpPattern","set","exec","anyScore","pattern","lowPattern","_patternPos","lowWord","_wordPos","fuzzyScore","score","idx","patternPos","_maxLen","wordPos","charAt","createMatches","res","pos","last","push","initTable","table","row","slice","initArr","maxLen","_minWordMatchPos","_maxWordMatchPos","_diag","_table","_arrows","_debug","printTable","patternLen","wordLen","pad","n","ret","concat","map","toString","printTables","patternStart","wordStart","substr","console","log","isSeparatorAtPos","value","codePointAt","isEmojiImprecise","isWhitespaceAtPos","isUpperCaseAtPos","wordLow","isPatternInWord","patternLow","fillMinWordPosArr","FuzzyScore","Default","isDefault","firstMatchCanBeWeak","_fillInMaxWordMatchPos","column","hasStrongFirstMatch","minWordMatchPos","maxWordMatchPos","nextMaxWordMatchPos","Number","MIN_SAFE_INTEGER","canComeDiag","_doScore","diagScore","MAX_SAFE_INTEGER","canComeLeft","leftScore","canComeLeftLeft","leftLeftScore","Error","backwardsDiagLength","maxMatchColumn","diagColumn","arrow","skippedCharsCount","newMatchStart","outFirstMatchStrong","isGapLocation","fuzzyScoreGracefulAggressive","fuzzyScoreWithPermutations","aggressive","top","tries","Math","min","movingPatternPos","newPattern","nextTypoPermutation","candidate","swap1","swap2"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/filters.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { LRUCache } from './map.js';\r\nimport * as strings from './strings.js';\r\n// Combined filters\r\n/**\r\n * @returns A filter which combines the provided set\r\n * of filters with an or. The *first* filters that\r\n * matches defined the return value of the returned\r\n * filter.\r\n */\r\nexport function or(...filter) {\r\n    return function (word, wordToMatchAgainst) {\r\n        for (let i = 0, len = filter.length; i < len; i++) {\r\n            const match = filter[i](word, wordToMatchAgainst);\r\n            if (match) {\r\n                return match;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n}\r\nexport const matchesPrefix = _matchesPrefix.bind(undefined, true);\r\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\r\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\r\n        return null;\r\n    }\r\n    let matches;\r\n    if (ignoreCase) {\r\n        matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\r\n    }\r\n    else {\r\n        matches = wordToMatchAgainst.indexOf(word) === 0;\r\n    }\r\n    if (!matches) {\r\n        return null;\r\n    }\r\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\r\n}\r\n// Contiguous Substring\r\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\r\n    const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\r\n    if (index === -1) {\r\n        return null;\r\n    }\r\n    return [{ start: index, end: index + word.length }];\r\n}\r\n// Substring\r\nexport function matchesSubString(word, wordToMatchAgainst) {\r\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\r\n}\r\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\r\n    if (i === word.length) {\r\n        return [];\r\n    }\r\n    else if (j === wordToMatchAgainst.length) {\r\n        return null;\r\n    }\r\n    else {\r\n        if (word[i] === wordToMatchAgainst[j]) {\r\n            let result = null;\r\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\r\n                return join({ start: j, end: j + 1 }, result);\r\n            }\r\n            return null;\r\n        }\r\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\r\n    }\r\n}\r\n// CamelCase\r\nfunction isLower(code) {\r\n    return 97 /* a */ <= code && code <= 122 /* z */;\r\n}\r\nexport function isUpper(code) {\r\n    return 65 /* A */ <= code && code <= 90 /* Z */;\r\n}\r\nfunction isNumber(code) {\r\n    return 48 /* Digit0 */ <= code && code <= 57 /* Digit9 */;\r\n}\r\nfunction isWhitespace(code) {\r\n    return (code === 32 /* Space */\r\n        || code === 9 /* Tab */\r\n        || code === 10 /* LineFeed */\r\n        || code === 13 /* CarriageReturn */);\r\n}\r\nconst wordSeparators = new Set();\r\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'\r\n    .split('')\r\n    .forEach(s => wordSeparators.add(s.charCodeAt(0)));\r\nfunction isWordSeparator(code) {\r\n    return isWhitespace(code) || wordSeparators.has(code);\r\n}\r\nfunction charactersMatch(codeA, codeB) {\r\n    return (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\r\n}\r\nfunction isAlphanumeric(code) {\r\n    return isLower(code) || isUpper(code) || isNumber(code);\r\n}\r\nfunction join(head, tail) {\r\n    if (tail.length === 0) {\r\n        tail = [head];\r\n    }\r\n    else if (head.end === tail[0].start) {\r\n        tail[0].start = head.start;\r\n    }\r\n    else {\r\n        tail.unshift(head);\r\n    }\r\n    return tail;\r\n}\r\nfunction nextAnchor(camelCaseWord, start) {\r\n    for (let i = start; i < camelCaseWord.length; i++) {\r\n        const c = camelCaseWord.charCodeAt(i);\r\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\r\n            return i;\r\n        }\r\n    }\r\n    return camelCaseWord.length;\r\n}\r\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\r\n    if (i === word.length) {\r\n        return [];\r\n    }\r\n    else if (j === camelCaseWord.length) {\r\n        return null;\r\n    }\r\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\r\n        return null;\r\n    }\r\n    else {\r\n        let result = null;\r\n        let nextUpperIndex = j + 1;\r\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\r\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\r\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\r\n            nextUpperIndex++;\r\n        }\r\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\r\n    }\r\n}\r\n// Heuristic to avoid computing camel case matcher for words that don't\r\n// look like camelCaseWords.\r\nfunction analyzeCamelCaseWord(word) {\r\n    let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\r\n    for (let i = 0; i < word.length; i++) {\r\n        code = word.charCodeAt(i);\r\n        if (isUpper(code)) {\r\n            upper++;\r\n        }\r\n        if (isLower(code)) {\r\n            lower++;\r\n        }\r\n        if (isAlphanumeric(code)) {\r\n            alpha++;\r\n        }\r\n        if (isNumber(code)) {\r\n            numeric++;\r\n        }\r\n    }\r\n    const upperPercent = upper / word.length;\r\n    const lowerPercent = lower / word.length;\r\n    const alphaPercent = alpha / word.length;\r\n    const numericPercent = numeric / word.length;\r\n    return { upperPercent, lowerPercent, alphaPercent, numericPercent };\r\n}\r\nfunction isUpperCaseWord(analysis) {\r\n    const { upperPercent, lowerPercent } = analysis;\r\n    return lowerPercent === 0 && upperPercent > 0.6;\r\n}\r\nfunction isCamelCaseWord(analysis) {\r\n    const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\r\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\r\n}\r\n// Heuristic to avoid computing camel case matcher for words that don't\r\n// look like camel case patterns.\r\nfunction isCamelCasePattern(word) {\r\n    let upper = 0, lower = 0, code = 0, whitespace = 0;\r\n    for (let i = 0; i < word.length; i++) {\r\n        code = word.charCodeAt(i);\r\n        if (isUpper(code)) {\r\n            upper++;\r\n        }\r\n        if (isLower(code)) {\r\n            lower++;\r\n        }\r\n        if (isWhitespace(code)) {\r\n            whitespace++;\r\n        }\r\n    }\r\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\r\n        return word.length <= 30;\r\n    }\r\n    else {\r\n        return upper <= 5;\r\n    }\r\n}\r\nexport function matchesCamelCase(word, camelCaseWord) {\r\n    if (!camelCaseWord) {\r\n        return null;\r\n    }\r\n    camelCaseWord = camelCaseWord.trim();\r\n    if (camelCaseWord.length === 0) {\r\n        return null;\r\n    }\r\n    if (!isCamelCasePattern(word)) {\r\n        return null;\r\n    }\r\n    if (camelCaseWord.length > 60) {\r\n        return null;\r\n    }\r\n    const analysis = analyzeCamelCaseWord(camelCaseWord);\r\n    if (!isCamelCaseWord(analysis)) {\r\n        if (!isUpperCaseWord(analysis)) {\r\n            return null;\r\n        }\r\n        camelCaseWord = camelCaseWord.toLowerCase();\r\n    }\r\n    let result = null;\r\n    let i = 0;\r\n    word = word.toLowerCase();\r\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\r\n        i = nextAnchor(camelCaseWord, i + 1);\r\n    }\r\n    return result;\r\n}\r\n// Matches beginning of words supporting non-ASCII languages\r\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\r\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\r\n// Useful in cases where the target is words (e.g. command labels)\r\nexport function matchesWords(word, target, contiguous = false) {\r\n    if (!target || target.length === 0) {\r\n        return null;\r\n    }\r\n    let result = null;\r\n    let i = 0;\r\n    word = word.toLowerCase();\r\n    target = target.toLowerCase();\r\n    while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\r\n        i = nextWord(target, i + 1);\r\n    }\r\n    return result;\r\n}\r\nfunction _matchesWords(word, target, i, j, contiguous) {\r\n    if (i === word.length) {\r\n        return [];\r\n    }\r\n    else if (j === target.length) {\r\n        return null;\r\n    }\r\n    else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {\r\n        return null;\r\n    }\r\n    else {\r\n        let result = null;\r\n        let nextWordIndex = j + 1;\r\n        result = _matchesWords(word, target, i + 1, j + 1, contiguous);\r\n        if (!contiguous) {\r\n            while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\r\n                result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\r\n                nextWordIndex++;\r\n            }\r\n        }\r\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\r\n    }\r\n}\r\nfunction nextWord(word, start) {\r\n    for (let i = start; i < word.length; i++) {\r\n        if (isWordSeparator(word.charCodeAt(i)) ||\r\n            (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\r\n            return i;\r\n        }\r\n    }\r\n    return word.length;\r\n}\r\n// Fuzzy\r\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\r\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\r\nconst fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\r\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\r\n    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\r\n        return null; // return early for invalid input\r\n    }\r\n    // Form RegExp for wildcard matches\r\n    let regexp = fuzzyRegExpCache.get(word);\r\n    if (!regexp) {\r\n        regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\r\n        fuzzyRegExpCache.set(word, regexp);\r\n    }\r\n    // RegExp Filter\r\n    const match = regexp.exec(wordToMatchAgainst);\r\n    if (match) {\r\n        return [{ start: match.index, end: match.index + match[0].length }];\r\n    }\r\n    // Default Filter\r\n    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\r\n}\r\nexport function anyScore(pattern, lowPattern, _patternPos, word, lowWord, _wordPos) {\r\n    const result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\r\n    if (result) {\r\n        return result;\r\n    }\r\n    let matches = [];\r\n    let score = 0;\r\n    let idx = _wordPos;\r\n    for (let patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\r\n        const wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\r\n        if (wordPos >= 0) {\r\n            score += 1;\r\n            matches.unshift(wordPos);\r\n            idx = wordPos + 1;\r\n        }\r\n        else if (matches.length > 0) {\r\n            // once we have started matching things\r\n            // we need to match the remaining pattern\r\n            // characters\r\n            break;\r\n        }\r\n    }\r\n    return [score, _wordPos, ...matches];\r\n}\r\n//#region --- fuzzyScore ---\r\nexport function createMatches(score) {\r\n    if (typeof score === 'undefined') {\r\n        return [];\r\n    }\r\n    const res = [];\r\n    const wordPos = score[1];\r\n    for (let i = score.length - 1; i > 1; i--) {\r\n        const pos = score[i] + wordPos;\r\n        const last = res[res.length - 1];\r\n        if (last && last.end === pos) {\r\n            last.end = pos + 1;\r\n        }\r\n        else {\r\n            res.push({ start: pos, end: pos + 1 });\r\n        }\r\n    }\r\n    return res;\r\n}\r\nconst _maxLen = 128;\r\nfunction initTable() {\r\n    const table = [];\r\n    const row = [];\r\n    for (let i = 0; i <= _maxLen; i++) {\r\n        row[i] = 0;\r\n    }\r\n    for (let i = 0; i <= _maxLen; i++) {\r\n        table.push(row.slice(0));\r\n    }\r\n    return table;\r\n}\r\nfunction initArr(maxLen) {\r\n    const row = [];\r\n    for (let i = 0; i <= maxLen; i++) {\r\n        row[i] = 0;\r\n    }\r\n    return row;\r\n}\r\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\r\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\r\nconst _diag = initTable(); // the length of a contiguous diagonal match\r\nconst _table = initTable();\r\nconst _arrows = initTable();\r\nconst _debug = false;\r\nfunction printTable(table, pattern, patternLen, word, wordLen) {\r\n    function pad(s, n, pad = ' ') {\r\n        while (s.length < n) {\r\n            s = pad + s;\r\n        }\r\n        return s;\r\n    }\r\n    let ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\r\n    for (let i = 0; i <= patternLen; i++) {\r\n        if (i === 0) {\r\n            ret += ' |';\r\n        }\r\n        else {\r\n            ret += `${pattern[i - 1]}|`;\r\n        }\r\n        ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\r\n    }\r\n    return ret;\r\n}\r\nfunction printTables(pattern, patternStart, word, wordStart) {\r\n    pattern = pattern.substr(patternStart);\r\n    word = word.substr(wordStart);\r\n    console.log(printTable(_table, pattern, pattern.length, word, word.length));\r\n    console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\r\n    console.log(printTable(_diag, pattern, pattern.length, word, word.length));\r\n}\r\nfunction isSeparatorAtPos(value, index) {\r\n    if (index < 0 || index >= value.length) {\r\n        return false;\r\n    }\r\n    const code = value.codePointAt(index);\r\n    switch (code) {\r\n        case 95 /* Underline */:\r\n        case 45 /* Dash */:\r\n        case 46 /* Period */:\r\n        case 32 /* Space */:\r\n        case 47 /* Slash */:\r\n        case 92 /* Backslash */:\r\n        case 39 /* SingleQuote */:\r\n        case 34 /* DoubleQuote */:\r\n        case 58 /* Colon */:\r\n        case 36 /* DollarSign */:\r\n        case 60 /* LessThan */:\r\n        case 40 /* OpenParen */:\r\n        case 91 /* OpenSquareBracket */:\r\n            return true;\r\n        case undefined:\r\n            return false;\r\n        default:\r\n            if (strings.isEmojiImprecise(code)) {\r\n                return true;\r\n            }\r\n            return false;\r\n    }\r\n}\r\nfunction isWhitespaceAtPos(value, index) {\r\n    if (index < 0 || index >= value.length) {\r\n        return false;\r\n    }\r\n    const code = value.charCodeAt(index);\r\n    switch (code) {\r\n        case 32 /* Space */:\r\n        case 9 /* Tab */:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction isUpperCaseAtPos(pos, word, wordLow) {\r\n    return word[pos] !== wordLow[pos];\r\n}\r\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\r\n    while (patternPos < patternLen && wordPos < wordLen) {\r\n        if (patternLow[patternPos] === wordLow[wordPos]) {\r\n            if (fillMinWordPosArr) {\r\n                // Remember the min word position for each pattern position\r\n                _minWordMatchPos[patternPos] = wordPos;\r\n            }\r\n            patternPos += 1;\r\n        }\r\n        wordPos += 1;\r\n    }\r\n    return patternPos === patternLen; // pattern must be exhausted\r\n}\r\nexport var FuzzyScore;\r\n(function (FuzzyScore) {\r\n    /**\r\n     * No matches and value `-100`\r\n     */\r\n    FuzzyScore.Default = ([-100, 0]);\r\n    function isDefault(score) {\r\n        return !score || (score[0] === -100 && score[1] === 0 && score[2] === 0);\r\n    }\r\n    FuzzyScore.isDefault = isDefault;\r\n})(FuzzyScore || (FuzzyScore = {}));\r\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\r\n    const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\r\n    const wordLen = word.length > _maxLen ? _maxLen : word.length;\r\n    if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\r\n        return undefined;\r\n    }\r\n    // Run a simple check if the characters of pattern occur\r\n    // (in order) at all in word. If that isn't the case we\r\n    // stop because no match will be possible\r\n    if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\r\n        return undefined;\r\n    }\r\n    // Find the max matching word position for each pattern position\r\n    // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\r\n    _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\r\n    let row = 1;\r\n    let column = 1;\r\n    let patternPos = patternStart;\r\n    let wordPos = wordStart;\r\n    const hasStrongFirstMatch = [false];\r\n    // There will be a match, fill in tables\r\n    for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\r\n        // Reduce search space to possible matching word positions and to possible access from next row\r\n        const minWordMatchPos = _minWordMatchPos[patternPos];\r\n        const maxWordMatchPos = _maxWordMatchPos[patternPos];\r\n        const nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\r\n        for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\r\n            let score = Number.MIN_SAFE_INTEGER;\r\n            let canComeDiag = false;\r\n            if (wordPos <= maxWordMatchPos) {\r\n                score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\r\n            }\r\n            let diagScore = 0;\r\n            if (score !== Number.MAX_SAFE_INTEGER) {\r\n                canComeDiag = true;\r\n                diagScore = score + _table[row - 1][column - 1];\r\n            }\r\n            const canComeLeft = wordPos > minWordMatchPos;\r\n            const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\r\n            const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\r\n            const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\r\n            if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\r\n                // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\r\n                _table[row][column] = leftLeftScore;\r\n                _arrows[row][column] = 3 /* LeftLeft */;\r\n                _diag[row][column] = 0;\r\n            }\r\n            else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\r\n                // always prefer choosing left since that means a match is earlier in the word\r\n                _table[row][column] = leftScore;\r\n                _arrows[row][column] = 2 /* Left */;\r\n                _diag[row][column] = 0;\r\n            }\r\n            else if (canComeDiag) {\r\n                _table[row][column] = diagScore;\r\n                _arrows[row][column] = 1 /* Diag */;\r\n                _diag[row][column] = _diag[row - 1][column - 1] + 1;\r\n            }\r\n            else {\r\n                throw new Error(`not possible`);\r\n            }\r\n        }\r\n    }\r\n    if (_debug) {\r\n        printTables(pattern, patternStart, word, wordStart);\r\n    }\r\n    if (!hasStrongFirstMatch[0] && !firstMatchCanBeWeak) {\r\n        return undefined;\r\n    }\r\n    row--;\r\n    column--;\r\n    const result = [_table[row][column], wordStart];\r\n    let backwardsDiagLength = 0;\r\n    let maxMatchColumn = 0;\r\n    while (row >= 1) {\r\n        // Find the column where we go diagonally up\r\n        let diagColumn = column;\r\n        do {\r\n            const arrow = _arrows[row][diagColumn];\r\n            if (arrow === 3 /* LeftLeft */) {\r\n                diagColumn = diagColumn - 2;\r\n            }\r\n            else if (arrow === 2 /* Left */) {\r\n                diagColumn = diagColumn - 1;\r\n            }\r\n            else {\r\n                // found the diagonal\r\n                break;\r\n            }\r\n        } while (diagColumn >= 1);\r\n        // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\r\n        if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\r\n            && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\r\n            && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\r\n            && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\r\n        ) {\r\n            diagColumn = column;\r\n        }\r\n        if (diagColumn === column) {\r\n            // this is a contiguous match\r\n            backwardsDiagLength++;\r\n        }\r\n        else {\r\n            backwardsDiagLength = 1;\r\n        }\r\n        if (!maxMatchColumn) {\r\n            // remember the last matched column\r\n            maxMatchColumn = diagColumn;\r\n        }\r\n        row--;\r\n        column = diagColumn - 1;\r\n        result.push(column);\r\n    }\r\n    if (wordLen === patternLen) {\r\n        // the word matches the pattern with all characters!\r\n        // giving the score a total match boost (to come up ahead other words)\r\n        result[0] += 2;\r\n    }\r\n    // Add 1 penalty for each skipped character in the word\r\n    const skippedCharsCount = maxMatchColumn - patternLen;\r\n    result[0] -= skippedCharsCount;\r\n    return result;\r\n}\r\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\r\n    let patternPos = patternLen - 1;\r\n    let wordPos = wordLen - 1;\r\n    while (patternPos >= patternStart && wordPos >= wordStart) {\r\n        if (patternLow[patternPos] === wordLow[wordPos]) {\r\n            _maxWordMatchPos[patternPos] = wordPos;\r\n            patternPos--;\r\n        }\r\n        wordPos--;\r\n    }\r\n}\r\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\r\n    if (patternLow[patternPos] !== wordLow[wordPos]) {\r\n        return Number.MIN_SAFE_INTEGER;\r\n    }\r\n    let score = 1;\r\n    let isGapLocation = false;\r\n    if (wordPos === (patternPos - patternStart)) {\r\n        // common prefix: `foobar <-> foobaz`\r\n        //                            ^^^^^\r\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\r\n    }\r\n    else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\r\n        // hitting upper-case: `foo <-> forOthers`\r\n        //                              ^^ ^\r\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\r\n        isGapLocation = true;\r\n    }\r\n    else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\r\n        // hitting a separator: `. <-> foo.bar`\r\n        //                                ^\r\n        score = 5;\r\n    }\r\n    else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\r\n        // post separator: `foo <-> bar_foo`\r\n        //                              ^^^\r\n        score = 5;\r\n        isGapLocation = true;\r\n    }\r\n    if (score > 1 && patternPos === patternStart) {\r\n        outFirstMatchStrong[0] = true;\r\n    }\r\n    if (!isGapLocation) {\r\n        isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\r\n    }\r\n    //\r\n    if (patternPos === patternStart) { // first character in pattern\r\n        if (wordPos > wordStart) {\r\n            // the first pattern character would match a word character that is not at the word start\r\n            // so introduce a penalty to account for the gap preceding this match\r\n            score -= isGapLocation ? 3 : 5;\r\n        }\r\n    }\r\n    else {\r\n        if (newMatchStart) {\r\n            // this would be the beginning of a new match (i.e. there would be a gap before this location)\r\n            score += isGapLocation ? 2 : 0;\r\n        }\r\n        else {\r\n            // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a prefered gap location\r\n            score += isGapLocation ? 0 : 1;\r\n        }\r\n    }\r\n    if (wordPos + 1 === wordLen) {\r\n        // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\r\n        // so pretend there is a gap after the last character in the word to normalize things\r\n        score -= isGapLocation ? 3 : 5;\r\n    }\r\n    return score;\r\n}\r\n//#endregion\r\n//#region --- graceful ---\r\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\r\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\r\n}\r\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\r\n    let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\r\n    if (top && !aggressive) {\r\n        // when using the original pattern yield a result we`\r\n        // return it unless we are aggressive and try to find\r\n        // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\r\n        return top;\r\n    }\r\n    if (pattern.length >= 3) {\r\n        // When the pattern is long enough then try a few (max 7)\r\n        // permutations of the pattern to find a better match. The\r\n        // permutations only swap neighbouring characters, e.g\r\n        // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\r\n        const tries = Math.min(7, pattern.length - 1);\r\n        for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\r\n            const newPattern = nextTypoPermutation(pattern, movingPatternPos);\r\n            if (newPattern) {\r\n                const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\r\n                if (candidate) {\r\n                    candidate[0] -= 3; // permutation penalty\r\n                    if (!top || candidate[0] > top[0]) {\r\n                        top = candidate;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return top;\r\n}\r\nfunction nextTypoPermutation(pattern, patternPos) {\r\n    if (patternPos + 1 >= pattern.length) {\r\n        return undefined;\r\n    }\r\n    const swap1 = pattern[patternPos];\r\n    const swap2 = pattern[patternPos + 1];\r\n    if (swap1 === swap2) {\r\n        return undefined;\r\n    }\r\n    return pattern.slice(0, patternPos)\r\n        + swap2\r\n        + swap1\r\n        + pattern.slice(patternPos + 2);\r\n}\r\n//#endregion\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}