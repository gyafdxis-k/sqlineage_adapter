{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { illegalState } from '../../../base/common/errors.js';\nimport { Graph } from './graph.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { IInstantiationService, _util, optional } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\nimport { IdleValue } from '../../../base/common/async.js';\n// TRACING\nconst _enableTracing = false;\nclass CyclicDependencyError extends Error {\n  constructor(graph) {\n    super('cyclic dependency between services');\n    this.message = graph.toString();\n  }\n}\nexport class InstantiationService {\n  constructor() {\n    let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new ServiceCollection();\n    let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let parent = arguments.length > 2 ? arguments[2] : undefined;\n    this._activeInstantiations = new Set();\n    this._services = services;\n    this._strict = strict;\n    this._parent = parent;\n    this._services.set(IInstantiationService, this);\n  }\n  createChild(services) {\n    return new InstantiationService(services, this._strict, this);\n  }\n  invokeFunction(fn) {\n    let _trace = Trace.traceInvocation(fn);\n    let _done = false;\n    try {\n      const accessor = {\n        get: (id, isOptional) => {\n          if (_done) {\n            throw illegalState('service accessor is only valid during the invocation of its target method');\n          }\n          const result = this._getOrCreateServiceInstance(id, _trace);\n          if (!result && isOptional !== optional) {\n            throw new Error(\"[invokeFunction] unknown service '\".concat(id, \"'\"));\n          }\n          return result;\n        }\n      };\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return fn(accessor, ...args);\n    } finally {\n      _done = true;\n      _trace.stop();\n    }\n  }\n  createInstance(ctorOrDescriptor) {\n    let _trace;\n    let result;\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      rest[_key2 - 1] = arguments[_key2];\n    }\n    if (ctorOrDescriptor instanceof SyncDescriptor) {\n      _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n      result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n    } else {\n      _trace = Trace.traceCreation(ctorOrDescriptor);\n      result = this._createInstance(ctorOrDescriptor, rest, _trace);\n    }\n    _trace.stop();\n    return result;\n  }\n  _createInstance(ctor) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let _trace = arguments.length > 2 ? arguments[2] : undefined;\n    // arguments defined by service decorators\n    let serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n    let serviceArgs = [];\n    for (const dependency of serviceDependencies) {\n      let service = this._getOrCreateServiceInstance(dependency.id, _trace);\n      if (!service && this._strict && !dependency.optional) {\n        throw new Error(\"[createInstance] \".concat(ctor.name, \" depends on UNKNOWN service \").concat(dependency.id, \".\"));\n      }\n      serviceArgs.push(service);\n    }\n    let firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n    // check for argument mismatches, adjust static args if needed\n    if (args.length !== firstServiceArgPos) {\n      console.warn(\"[createInstance] First service dependency of \".concat(ctor.name, \" at position \").concat(firstServiceArgPos + 1, \" conflicts with \").concat(args.length, \" static arguments\"));\n      let delta = firstServiceArgPos - args.length;\n      if (delta > 0) {\n        args = args.concat(new Array(delta));\n      } else {\n        args = args.slice(0, firstServiceArgPos);\n      }\n    }\n    // now create the instance\n    return new ctor(...[...args, ...serviceArgs]);\n  }\n  _setServiceInstance(id, instance) {\n    if (this._services.get(id) instanceof SyncDescriptor) {\n      this._services.set(id, instance);\n    } else if (this._parent) {\n      this._parent._setServiceInstance(id, instance);\n    } else {\n      throw new Error('illegalState - setting UNKNOWN service instance');\n    }\n  }\n  _getServiceInstanceOrDescriptor(id) {\n    let instanceOrDesc = this._services.get(id);\n    if (!instanceOrDesc && this._parent) {\n      return this._parent._getServiceInstanceOrDescriptor(id);\n    } else {\n      return instanceOrDesc;\n    }\n  }\n  _getOrCreateServiceInstance(id, _trace) {\n    let thing = this._getServiceInstanceOrDescriptor(id);\n    if (thing instanceof SyncDescriptor) {\n      return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n    } else {\n      _trace.branch(id, false);\n      return thing;\n    }\n  }\n  _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n    if (this._activeInstantiations.has(id)) {\n      throw new Error(\"illegal state - RECURSIVELY instantiating service '\".concat(id, \"'\"));\n    }\n    this._activeInstantiations.add(id);\n    try {\n      return this._createAndCacheServiceInstance(id, desc, _trace);\n    } finally {\n      this._activeInstantiations.delete(id);\n    }\n  }\n  _createAndCacheServiceInstance(id, desc, _trace) {\n    const graph = new Graph(data => data.id.toString());\n    let cycleCount = 0;\n    const stack = [{\n      id,\n      desc,\n      _trace\n    }];\n    while (stack.length) {\n      const item = stack.pop();\n      graph.lookupOrInsertNode(item);\n      // a weak but working heuristic for cycle checks\n      if (cycleCount++ > 1000) {\n        throw new CyclicDependencyError(graph);\n      }\n      // check all dependencies for existence and if they need to be created first\n      for (let dependency of _util.getServiceDependencies(item.desc.ctor)) {\n        let instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n        if (!instanceOrDesc && !dependency.optional) {\n          console.warn(\"[createInstance] \".concat(id, \" depends on \").concat(dependency.id, \" which is NOT registered.\"));\n        }\n        if (instanceOrDesc instanceof SyncDescriptor) {\n          const d = {\n            id: dependency.id,\n            desc: instanceOrDesc,\n            _trace: item._trace.branch(dependency.id, true)\n          };\n          graph.insertEdge(item, d);\n          stack.push(d);\n        }\n      }\n    }\n    while (true) {\n      const roots = graph.roots();\n      // if there is no more roots but still\n      // nodes in the graph we have a cycle\n      if (roots.length === 0) {\n        if (!graph.isEmpty()) {\n          throw new CyclicDependencyError(graph);\n        }\n        break;\n      }\n      for (const {\n        data\n      } of roots) {\n        // Repeat the check for this still being a service sync descriptor. That's because\n        // instantiating a dependency might have side-effect and recursively trigger instantiation\n        // so that some dependencies are now fullfilled already.\n        const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n        if (instanceOrDesc instanceof SyncDescriptor) {\n          // create instance and overwrite the service collections\n          const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n          this._setServiceInstance(data.id, instance);\n        }\n        graph.removeNode(data);\n      }\n    }\n    return this._getServiceInstanceOrDescriptor(id);\n  }\n  _createServiceInstanceWithOwner(id, ctor) {\n    let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let supportsDelayedInstantiation = arguments.length > 3 ? arguments[3] : undefined;\n    let _trace = arguments.length > 4 ? arguments[4] : undefined;\n    if (this._services.get(id) instanceof SyncDescriptor) {\n      return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n    } else if (this._parent) {\n      return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n    } else {\n      throw new Error(\"illegalState - creating UNKNOWN service instance \".concat(ctor.name));\n    }\n  }\n  _createServiceInstance(ctor) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let _supportsDelayedInstantiation = arguments.length > 2 ? arguments[2] : undefined;\n    let _trace = arguments.length > 3 ? arguments[3] : undefined;\n    if (!_supportsDelayedInstantiation) {\n      // eager instantiation\n      return this._createInstance(ctor, args, _trace);\n    } else {\n      // Return a proxy object that's backed by an idle value. That\n      // strategy is to instantiate services in our idle time or when actually\n      // needed but not when injected into a consumer\n      const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));\n      return new Proxy(Object.create(null), {\n        get(target, key) {\n          if (key in target) {\n            return target[key];\n          }\n          let obj = idle.value;\n          let prop = obj[key];\n          if (typeof prop !== 'function') {\n            return prop;\n          }\n          prop = prop.bind(obj);\n          target[key] = prop;\n          return prop;\n        },\n        set(_target, p, value) {\n          idle.value[p] = value;\n          return true;\n        }\n      });\n    }\n  }\n}\nclass Trace {\n  constructor(type, name) {\n    this.type = type;\n    this.name = name;\n    this._start = Date.now();\n    this._dep = [];\n  }\n  static traceInvocation(ctor) {\n    return !_enableTracing ? Trace._None : new Trace(1 /* Invocation */, ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n  }\n  static traceCreation(ctor) {\n    return !_enableTracing ? Trace._None : new Trace(0 /* Creation */, ctor.name);\n  }\n  branch(id, first) {\n    let child = new Trace(2 /* Branch */, id.toString());\n    this._dep.push([id, first, child]);\n    return child;\n  }\n  stop() {\n    let dur = Date.now() - this._start;\n    Trace._totals += dur;\n    let causedCreation = false;\n    function printChild(n, trace) {\n      let res = [];\n      let prefix = new Array(n + 1).join('\\t');\n      for (const [id, first, child] of trace._dep) {\n        if (first && child) {\n          causedCreation = true;\n          res.push(\"\".concat(prefix, \"CREATES -> \").concat(id));\n          let nested = printChild(n + 1, child);\n          if (nested) {\n            res.push(nested);\n          }\n        } else {\n          res.push(\"\".concat(prefix, \"uses -> \").concat(id));\n        }\n      }\n      return res.join('\\n');\n    }\n    let lines = [\"\".concat(this.type === 0 /* Creation */ ? 'CREATE' : 'CALL', \" \").concat(this.name), \"\".concat(printChild(1, this)), \"DONE, took \".concat(dur.toFixed(2), \"ms (grand total \").concat(Trace._totals.toFixed(2), \"ms)\")];\n    if (dur > 2 || causedCreation) {\n      console.log(lines.join('\\n'));\n    }\n  }\n}\nTrace._None = new class extends Trace {\n  constructor() {\n    super(-1, null);\n  }\n  stop() {}\n  branch() {\n    return this;\n  }\n}();\nTrace._totals = 0;\n//#endregion","map":{"version":3,"names":["illegalState","Graph","SyncDescriptor","IInstantiationService","_util","optional","ServiceCollection","IdleValue","_enableTracing","CyclicDependencyError","Error","constructor","graph","message","toString","InstantiationService","services","arguments","length","undefined","strict","parent","_activeInstantiations","Set","_services","_strict","_parent","set","createChild","invokeFunction","fn","_trace","Trace","traceInvocation","_done","accessor","get","id","isOptional","result","_getOrCreateServiceInstance","concat","_len","args","Array","_key","stop","createInstance","ctorOrDescriptor","_len2","rest","_key2","traceCreation","ctor","_createInstance","staticArguments","serviceDependencies","getServiceDependencies","sort","a","b","index","serviceArgs","dependency","service","name","push","firstServiceArgPos","console","warn","delta","slice","_setServiceInstance","instance","_getServiceInstanceOrDescriptor","instanceOrDesc","thing","_safeCreateAndCacheServiceInstance","branch","desc","has","add","_createAndCacheServiceInstance","delete","data","cycleCount","stack","item","pop","lookupOrInsertNode","d","insertEdge","roots","isEmpty","_createServiceInstanceWithOwner","supportsDelayedInstantiation","removeNode","_createServiceInstance","_supportsDelayedInstantiation","idle","Proxy","Object","create","target","key","obj","value","prop","bind","_target","p","type","_start","Date","now","_dep","_None","substring","replace","first","child","dur","_totals","causedCreation","printChild","n","trace","res","prefix","join","nested","lines","toFixed","log"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { illegalState } from '../../../base/common/errors.js';\r\nimport { Graph } from './graph.js';\r\nimport { SyncDescriptor } from './descriptors.js';\r\nimport { IInstantiationService, _util, optional } from './instantiation.js';\r\nimport { ServiceCollection } from './serviceCollection.js';\r\nimport { IdleValue } from '../../../base/common/async.js';\r\n// TRACING\r\nconst _enableTracing = false;\r\nclass CyclicDependencyError extends Error {\r\n    constructor(graph) {\r\n        super('cyclic dependency between services');\r\n        this.message = graph.toString();\r\n    }\r\n}\r\nexport class InstantiationService {\r\n    constructor(services = new ServiceCollection(), strict = false, parent) {\r\n        this._activeInstantiations = new Set();\r\n        this._services = services;\r\n        this._strict = strict;\r\n        this._parent = parent;\r\n        this._services.set(IInstantiationService, this);\r\n    }\r\n    createChild(services) {\r\n        return new InstantiationService(services, this._strict, this);\r\n    }\r\n    invokeFunction(fn, ...args) {\r\n        let _trace = Trace.traceInvocation(fn);\r\n        let _done = false;\r\n        try {\r\n            const accessor = {\r\n                get: (id, isOptional) => {\r\n                    if (_done) {\r\n                        throw illegalState('service accessor is only valid during the invocation of its target method');\r\n                    }\r\n                    const result = this._getOrCreateServiceInstance(id, _trace);\r\n                    if (!result && isOptional !== optional) {\r\n                        throw new Error(`[invokeFunction] unknown service '${id}'`);\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n            return fn(accessor, ...args);\r\n        }\r\n        finally {\r\n            _done = true;\r\n            _trace.stop();\r\n        }\r\n    }\r\n    createInstance(ctorOrDescriptor, ...rest) {\r\n        let _trace;\r\n        let result;\r\n        if (ctorOrDescriptor instanceof SyncDescriptor) {\r\n            _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\r\n            result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\r\n        }\r\n        else {\r\n            _trace = Trace.traceCreation(ctorOrDescriptor);\r\n            result = this._createInstance(ctorOrDescriptor, rest, _trace);\r\n        }\r\n        _trace.stop();\r\n        return result;\r\n    }\r\n    _createInstance(ctor, args = [], _trace) {\r\n        // arguments defined by service decorators\r\n        let serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\r\n        let serviceArgs = [];\r\n        for (const dependency of serviceDependencies) {\r\n            let service = this._getOrCreateServiceInstance(dependency.id, _trace);\r\n            if (!service && this._strict && !dependency.optional) {\r\n                throw new Error(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`);\r\n            }\r\n            serviceArgs.push(service);\r\n        }\r\n        let firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\r\n        // check for argument mismatches, adjust static args if needed\r\n        if (args.length !== firstServiceArgPos) {\r\n            console.warn(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\r\n            let delta = firstServiceArgPos - args.length;\r\n            if (delta > 0) {\r\n                args = args.concat(new Array(delta));\r\n            }\r\n            else {\r\n                args = args.slice(0, firstServiceArgPos);\r\n            }\r\n        }\r\n        // now create the instance\r\n        return new ctor(...[...args, ...serviceArgs]);\r\n    }\r\n    _setServiceInstance(id, instance) {\r\n        if (this._services.get(id) instanceof SyncDescriptor) {\r\n            this._services.set(id, instance);\r\n        }\r\n        else if (this._parent) {\r\n            this._parent._setServiceInstance(id, instance);\r\n        }\r\n        else {\r\n            throw new Error('illegalState - setting UNKNOWN service instance');\r\n        }\r\n    }\r\n    _getServiceInstanceOrDescriptor(id) {\r\n        let instanceOrDesc = this._services.get(id);\r\n        if (!instanceOrDesc && this._parent) {\r\n            return this._parent._getServiceInstanceOrDescriptor(id);\r\n        }\r\n        else {\r\n            return instanceOrDesc;\r\n        }\r\n    }\r\n    _getOrCreateServiceInstance(id, _trace) {\r\n        let thing = this._getServiceInstanceOrDescriptor(id);\r\n        if (thing instanceof SyncDescriptor) {\r\n            return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\r\n        }\r\n        else {\r\n            _trace.branch(id, false);\r\n            return thing;\r\n        }\r\n    }\r\n    _safeCreateAndCacheServiceInstance(id, desc, _trace) {\r\n        if (this._activeInstantiations.has(id)) {\r\n            throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\r\n        }\r\n        this._activeInstantiations.add(id);\r\n        try {\r\n            return this._createAndCacheServiceInstance(id, desc, _trace);\r\n        }\r\n        finally {\r\n            this._activeInstantiations.delete(id);\r\n        }\r\n    }\r\n    _createAndCacheServiceInstance(id, desc, _trace) {\r\n        const graph = new Graph(data => data.id.toString());\r\n        let cycleCount = 0;\r\n        const stack = [{ id, desc, _trace }];\r\n        while (stack.length) {\r\n            const item = stack.pop();\r\n            graph.lookupOrInsertNode(item);\r\n            // a weak but working heuristic for cycle checks\r\n            if (cycleCount++ > 1000) {\r\n                throw new CyclicDependencyError(graph);\r\n            }\r\n            // check all dependencies for existence and if they need to be created first\r\n            for (let dependency of _util.getServiceDependencies(item.desc.ctor)) {\r\n                let instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\r\n                if (!instanceOrDesc && !dependency.optional) {\r\n                    console.warn(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`);\r\n                }\r\n                if (instanceOrDesc instanceof SyncDescriptor) {\r\n                    const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\r\n                    graph.insertEdge(item, d);\r\n                    stack.push(d);\r\n                }\r\n            }\r\n        }\r\n        while (true) {\r\n            const roots = graph.roots();\r\n            // if there is no more roots but still\r\n            // nodes in the graph we have a cycle\r\n            if (roots.length === 0) {\r\n                if (!graph.isEmpty()) {\r\n                    throw new CyclicDependencyError(graph);\r\n                }\r\n                break;\r\n            }\r\n            for (const { data } of roots) {\r\n                // Repeat the check for this still being a service sync descriptor. That's because\r\n                // instantiating a dependency might have side-effect and recursively trigger instantiation\r\n                // so that some dependencies are now fullfilled already.\r\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\r\n                if (instanceOrDesc instanceof SyncDescriptor) {\r\n                    // create instance and overwrite the service collections\r\n                    const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\r\n                    this._setServiceInstance(data.id, instance);\r\n                }\r\n                graph.removeNode(data);\r\n            }\r\n        }\r\n        return this._getServiceInstanceOrDescriptor(id);\r\n    }\r\n    _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\r\n        if (this._services.get(id) instanceof SyncDescriptor) {\r\n            return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\r\n        }\r\n        else if (this._parent) {\r\n            return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\r\n        }\r\n        else {\r\n            throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\r\n        }\r\n    }\r\n    _createServiceInstance(ctor, args = [], _supportsDelayedInstantiation, _trace) {\r\n        if (!_supportsDelayedInstantiation) {\r\n            // eager instantiation\r\n            return this._createInstance(ctor, args, _trace);\r\n        }\r\n        else {\r\n            // Return a proxy object that's backed by an idle value. That\r\n            // strategy is to instantiate services in our idle time or when actually\r\n            // needed but not when injected into a consumer\r\n            const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));\r\n            return new Proxy(Object.create(null), {\r\n                get(target, key) {\r\n                    if (key in target) {\r\n                        return target[key];\r\n                    }\r\n                    let obj = idle.value;\r\n                    let prop = obj[key];\r\n                    if (typeof prop !== 'function') {\r\n                        return prop;\r\n                    }\r\n                    prop = prop.bind(obj);\r\n                    target[key] = prop;\r\n                    return prop;\r\n                },\r\n                set(_target, p, value) {\r\n                    idle.value[p] = value;\r\n                    return true;\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\nclass Trace {\r\n    constructor(type, name) {\r\n        this.type = type;\r\n        this.name = name;\r\n        this._start = Date.now();\r\n        this._dep = [];\r\n    }\r\n    static traceInvocation(ctor) {\r\n        return !_enableTracing ? Trace._None : new Trace(1 /* Invocation */, ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\r\n    }\r\n    static traceCreation(ctor) {\r\n        return !_enableTracing ? Trace._None : new Trace(0 /* Creation */, ctor.name);\r\n    }\r\n    branch(id, first) {\r\n        let child = new Trace(2 /* Branch */, id.toString());\r\n        this._dep.push([id, first, child]);\r\n        return child;\r\n    }\r\n    stop() {\r\n        let dur = Date.now() - this._start;\r\n        Trace._totals += dur;\r\n        let causedCreation = false;\r\n        function printChild(n, trace) {\r\n            let res = [];\r\n            let prefix = new Array(n + 1).join('\\t');\r\n            for (const [id, first, child] of trace._dep) {\r\n                if (first && child) {\r\n                    causedCreation = true;\r\n                    res.push(`${prefix}CREATES -> ${id}`);\r\n                    let nested = printChild(n + 1, child);\r\n                    if (nested) {\r\n                        res.push(nested);\r\n                    }\r\n                }\r\n                else {\r\n                    res.push(`${prefix}uses -> ${id}`);\r\n                }\r\n            }\r\n            return res.join('\\n');\r\n        }\r\n        let lines = [\r\n            `${this.type === 0 /* Creation */ ? 'CREATE' : 'CALL'} ${this.name}`,\r\n            `${printChild(1, this)}`,\r\n            `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\r\n        ];\r\n        if (dur > 2 || causedCreation) {\r\n            console.log(lines.join('\\n'));\r\n        }\r\n    }\r\n}\r\nTrace._None = new class extends Trace {\r\n    constructor() { super(-1, null); }\r\n    stop() { }\r\n    branch() { return this; }\r\n};\r\nTrace._totals = 0;\r\n//#endregion\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}