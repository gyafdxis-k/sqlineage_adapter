{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport class LineDecoration {\n  constructor(startColumn, endColumn, className, type) {\n    this.startColumn = startColumn;\n    this.endColumn = endColumn;\n    this.className = className;\n    this.type = type;\n  }\n  static _equals(a, b) {\n    return a.startColumn === b.startColumn && a.endColumn === b.endColumn && a.className === b.className && a.type === b.type;\n  }\n  static equalsArr(a, b) {\n    const aLen = a.length;\n    const bLen = b.length;\n    if (aLen !== bLen) {\n      return false;\n    }\n    for (let i = 0; i < aLen; i++) {\n      if (!LineDecoration._equals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static extractWrapped(arr, startOffset, endOffset) {\n    if (arr.length === 0) {\n      return arr;\n    }\n    const startColumn = startOffset + 1;\n    const endColumn = endOffset + 1;\n    const lineLength = endOffset - startOffset;\n    const r = [];\n    let rLength = 0;\n    for (const dec of arr) {\n      if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n        continue;\n      }\n      r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n    }\n    return r;\n  }\n  static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n    if (lineDecorations.length === 0) {\n      return [];\n    }\n    let result = [],\n      resultLen = 0;\n    for (let i = 0, len = lineDecorations.length; i < len; i++) {\n      const d = lineDecorations[i];\n      const range = d.range;\n      if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n        // Ignore decorations that sit outside this line\n        continue;\n      }\n      if (range.isEmpty() && (d.type === 0 /* Regular */ || d.type === 3 /* RegularAffectingLetterSpacing */)) {\n        // Ignore empty range decorations\n        continue;\n      }\n      const startColumn = range.startLineNumber === lineNumber ? range.startColumn : minLineColumn;\n      const endColumn = range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn;\n      result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n    }\n    return result;\n  }\n  static _typeCompare(a, b) {\n    const ORDER = [2, 0, 1, 3];\n    return ORDER[a] - ORDER[b];\n  }\n  static compare(a, b) {\n    if (a.startColumn === b.startColumn) {\n      if (a.endColumn === b.endColumn) {\n        const typeCmp = LineDecoration._typeCompare(a.type, b.type);\n        if (typeCmp === 0) {\n          if (a.className < b.className) {\n            return -1;\n          }\n          if (a.className > b.className) {\n            return 1;\n          }\n          return 0;\n        }\n        return typeCmp;\n      }\n      return a.endColumn - b.endColumn;\n    }\n    return a.startColumn - b.startColumn;\n  }\n}\nexport class DecorationSegment {\n  constructor(startOffset, endOffset, className, metadata) {\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    this.className = className;\n    this.metadata = metadata;\n  }\n}\nclass Stack {\n  constructor() {\n    this.stopOffsets = [];\n    this.classNames = [];\n    this.metadata = [];\n    this.count = 0;\n  }\n  static _metadata(metadata) {\n    let result = 0;\n    for (let i = 0, len = metadata.length; i < len; i++) {\n      result |= metadata[i];\n    }\n    return result;\n  }\n  consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n    while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n      let i = 0;\n      // Take all equal stopping offsets\n      while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n        i++;\n      }\n      // Basically we are consuming the first i + 1 elements of the stack\n      result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n      nextStartOffset = this.stopOffsets[i] + 1;\n      // Consume them\n      this.stopOffsets.splice(0, i + 1);\n      this.classNames.splice(0, i + 1);\n      this.metadata.splice(0, i + 1);\n      this.count -= i + 1;\n    }\n    if (this.count > 0 && nextStartOffset < maxStopOffset) {\n      result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n      nextStartOffset = maxStopOffset;\n    }\n    return nextStartOffset;\n  }\n  insert(stopOffset, className, metadata) {\n    if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n      // Insert at the end\n      this.stopOffsets.push(stopOffset);\n      this.classNames.push(className);\n      this.metadata.push(metadata);\n    } else {\n      // Find the insertion position for `stopOffset`\n      for (let i = 0; i < this.count; i++) {\n        if (this.stopOffsets[i] >= stopOffset) {\n          this.stopOffsets.splice(i, 0, stopOffset);\n          this.classNames.splice(i, 0, className);\n          this.metadata.splice(i, 0, metadata);\n          break;\n        }\n      }\n    }\n    this.count++;\n    return;\n  }\n}\nexport class LineDecorationsNormalizer {\n  /**\r\n   * Normalize line decorations. Overlapping decorations will generate multiple segments\r\n   */\n  static normalize(lineContent, lineDecorations) {\n    if (lineDecorations.length === 0) {\n      return [];\n    }\n    let result = [];\n    const stack = new Stack();\n    let nextStartOffset = 0;\n    for (let i = 0, len = lineDecorations.length; i < len; i++) {\n      const d = lineDecorations[i];\n      let startColumn = d.startColumn;\n      let endColumn = d.endColumn;\n      const className = d.className;\n      const metadata = d.type === 1 /* Before */ ? 2 /* PSEUDO_BEFORE */ : d.type === 2 /* After */ ? 4 /* PSEUDO_AFTER */ : 0;\n      // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n      if (startColumn > 1) {\n        const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n        if (strings.isHighSurrogate(charCodeBefore)) {\n          startColumn--;\n        }\n      }\n      if (endColumn > 1) {\n        const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n        if (strings.isHighSurrogate(charCodeBefore)) {\n          endColumn--;\n        }\n      }\n      const currentStartOffset = startColumn - 1;\n      const currentEndOffset = endColumn - 2;\n      nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n      if (stack.count === 0) {\n        nextStartOffset = currentStartOffset;\n      }\n      stack.insert(currentEndOffset, className, metadata);\n    }\n    stack.consumeLowerThan(1073741824 /* MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\n    return result;\n  }\n}","map":{"version":3,"names":["strings","LineDecoration","constructor","startColumn","endColumn","className","type","_equals","a","b","equalsArr","aLen","length","bLen","i","extractWrapped","arr","startOffset","endOffset","lineLength","r","rLength","dec","Math","max","min","filter","lineDecorations","lineNumber","minLineColumn","maxLineColumn","result","resultLen","len","d","range","endLineNumber","startLineNumber","isEmpty","inlineClassName","_typeCompare","ORDER","compare","typeCmp","DecorationSegment","metadata","Stack","stopOffsets","classNames","count","_metadata","consumeLowerThan","maxStopOffset","nextStartOffset","push","join","splice","insert","stopOffset","LineDecorationsNormalizer","normalize","lineContent","stack","charCodeBefore","charCodeAt","isHighSurrogate","currentStartOffset","currentEndOffset"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nexport class LineDecoration {\r\n    constructor(startColumn, endColumn, className, type) {\r\n        this.startColumn = startColumn;\r\n        this.endColumn = endColumn;\r\n        this.className = className;\r\n        this.type = type;\r\n    }\r\n    static _equals(a, b) {\r\n        return (a.startColumn === b.startColumn\r\n            && a.endColumn === b.endColumn\r\n            && a.className === b.className\r\n            && a.type === b.type);\r\n    }\r\n    static equalsArr(a, b) {\r\n        const aLen = a.length;\r\n        const bLen = b.length;\r\n        if (aLen !== bLen) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < aLen; i++) {\r\n            if (!LineDecoration._equals(a[i], b[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static extractWrapped(arr, startOffset, endOffset) {\r\n        if (arr.length === 0) {\r\n            return arr;\r\n        }\r\n        const startColumn = startOffset + 1;\r\n        const endColumn = endOffset + 1;\r\n        const lineLength = endOffset - startOffset;\r\n        const r = [];\r\n        let rLength = 0;\r\n        for (const dec of arr) {\r\n            if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\r\n                continue;\r\n            }\r\n            r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\r\n        }\r\n        return r;\r\n    }\r\n    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\r\n        if (lineDecorations.length === 0) {\r\n            return [];\r\n        }\r\n        let result = [], resultLen = 0;\r\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\r\n            const d = lineDecorations[i];\r\n            const range = d.range;\r\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\r\n                // Ignore decorations that sit outside this line\r\n                continue;\r\n            }\r\n            if (range.isEmpty() && (d.type === 0 /* Regular */ || d.type === 3 /* RegularAffectingLetterSpacing */)) {\r\n                // Ignore empty range decorations\r\n                continue;\r\n            }\r\n            const startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\r\n            const endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\r\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\r\n        }\r\n        return result;\r\n    }\r\n    static _typeCompare(a, b) {\r\n        const ORDER = [2, 0, 1, 3];\r\n        return ORDER[a] - ORDER[b];\r\n    }\r\n    static compare(a, b) {\r\n        if (a.startColumn === b.startColumn) {\r\n            if (a.endColumn === b.endColumn) {\r\n                const typeCmp = LineDecoration._typeCompare(a.type, b.type);\r\n                if (typeCmp === 0) {\r\n                    if (a.className < b.className) {\r\n                        return -1;\r\n                    }\r\n                    if (a.className > b.className) {\r\n                        return 1;\r\n                    }\r\n                    return 0;\r\n                }\r\n                return typeCmp;\r\n            }\r\n            return a.endColumn - b.endColumn;\r\n        }\r\n        return a.startColumn - b.startColumn;\r\n    }\r\n}\r\nexport class DecorationSegment {\r\n    constructor(startOffset, endOffset, className, metadata) {\r\n        this.startOffset = startOffset;\r\n        this.endOffset = endOffset;\r\n        this.className = className;\r\n        this.metadata = metadata;\r\n    }\r\n}\r\nclass Stack {\r\n    constructor() {\r\n        this.stopOffsets = [];\r\n        this.classNames = [];\r\n        this.metadata = [];\r\n        this.count = 0;\r\n    }\r\n    static _metadata(metadata) {\r\n        let result = 0;\r\n        for (let i = 0, len = metadata.length; i < len; i++) {\r\n            result |= metadata[i];\r\n        }\r\n        return result;\r\n    }\r\n    consumeLowerThan(maxStopOffset, nextStartOffset, result) {\r\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\r\n            let i = 0;\r\n            // Take all equal stopping offsets\r\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\r\n                i++;\r\n            }\r\n            // Basically we are consuming the first i + 1 elements of the stack\r\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\r\n            nextStartOffset = this.stopOffsets[i] + 1;\r\n            // Consume them\r\n            this.stopOffsets.splice(0, i + 1);\r\n            this.classNames.splice(0, i + 1);\r\n            this.metadata.splice(0, i + 1);\r\n            this.count -= (i + 1);\r\n        }\r\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\r\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\r\n            nextStartOffset = maxStopOffset;\r\n        }\r\n        return nextStartOffset;\r\n    }\r\n    insert(stopOffset, className, metadata) {\r\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\r\n            // Insert at the end\r\n            this.stopOffsets.push(stopOffset);\r\n            this.classNames.push(className);\r\n            this.metadata.push(metadata);\r\n        }\r\n        else {\r\n            // Find the insertion position for `stopOffset`\r\n            for (let i = 0; i < this.count; i++) {\r\n                if (this.stopOffsets[i] >= stopOffset) {\r\n                    this.stopOffsets.splice(i, 0, stopOffset);\r\n                    this.classNames.splice(i, 0, className);\r\n                    this.metadata.splice(i, 0, metadata);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        this.count++;\r\n        return;\r\n    }\r\n}\r\nexport class LineDecorationsNormalizer {\r\n    /**\r\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\r\n     */\r\n    static normalize(lineContent, lineDecorations) {\r\n        if (lineDecorations.length === 0) {\r\n            return [];\r\n        }\r\n        let result = [];\r\n        const stack = new Stack();\r\n        let nextStartOffset = 0;\r\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\r\n            const d = lineDecorations[i];\r\n            let startColumn = d.startColumn;\r\n            let endColumn = d.endColumn;\r\n            const className = d.className;\r\n            const metadata = (d.type === 1 /* Before */\r\n                ? 2 /* PSEUDO_BEFORE */\r\n                : d.type === 2 /* After */\r\n                    ? 4 /* PSEUDO_AFTER */\r\n                    : 0);\r\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\r\n            if (startColumn > 1) {\r\n                const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\r\n                if (strings.isHighSurrogate(charCodeBefore)) {\r\n                    startColumn--;\r\n                }\r\n            }\r\n            if (endColumn > 1) {\r\n                const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\r\n                if (strings.isHighSurrogate(charCodeBefore)) {\r\n                    endColumn--;\r\n                }\r\n            }\r\n            const currentStartOffset = startColumn - 1;\r\n            const currentEndOffset = endColumn - 2;\r\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\r\n            if (stack.count === 0) {\r\n                nextStartOffset = currentStartOffset;\r\n            }\r\n            stack.insert(currentEndOffset, className, metadata);\r\n        }\r\n        stack.consumeLowerThan(1073741824 /* MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\r\n        return result;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}