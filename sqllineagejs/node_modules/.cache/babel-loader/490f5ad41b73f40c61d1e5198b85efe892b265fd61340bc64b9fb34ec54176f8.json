{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorColumns, CursorContext, CursorState, EditOperationResult } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../view/viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModel/viewModelEventDispatcher.js';\n/**\r\n * A snapshot of the cursor and the model state\r\n */\nexport class CursorModelState {\n  constructor(model, cursor) {\n    this.modelVersionId = model.getVersionId();\n    this.cursorState = cursor.getCursorStates();\n  }\n  equals(other) {\n    if (!other) {\n      return false;\n    }\n    if (this.modelVersionId !== other.modelVersionId) {\n      return false;\n    }\n    if (this.cursorState.length !== other.cursorState.length) {\n      return false;\n    }\n    for (let i = 0, len = this.cursorState.length; i < len; i++) {\n      if (!this.cursorState[i].equals(other.cursorState[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nclass AutoClosedAction {\n  constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n    this._model = model;\n    this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n    this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n  }\n  static getAllAutoClosedCharacters(autoClosedActions) {\n    let autoClosedCharacters = [];\n    for (const autoClosedAction of autoClosedActions) {\n      autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n    }\n    return autoClosedCharacters;\n  }\n  dispose() {\n    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n    this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n  }\n  getAutoClosedCharactersRanges() {\n    let result = [];\n    for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n      const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n      if (decorationRange) {\n        result.push(decorationRange);\n      }\n    }\n    return result;\n  }\n  isValid(selections) {\n    let enclosingRanges = [];\n    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n      const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n      if (decorationRange) {\n        enclosingRanges.push(decorationRange);\n        if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n          // Stop tracking if the range becomes multiline...\n          return false;\n        }\n      }\n    }\n    enclosingRanges.sort(Range.compareRangesUsingStarts);\n    selections.sort(Range.compareRangesUsingStarts);\n    for (let i = 0; i < selections.length; i++) {\n      if (i >= enclosingRanges.length) {\n        return false;\n      }\n      if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nexport class Cursor extends Disposable {\n  constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n    super();\n    this._model = model;\n    this._knownModelVersionId = this._model.getVersionId();\n    this._viewModel = viewModel;\n    this._coordinatesConverter = coordinatesConverter;\n    this.context = new CursorContext(this._model, this._coordinatesConverter, cursorConfig);\n    this._cursors = new CursorCollection(this.context);\n    this._hasFocus = false;\n    this._isHandling = false;\n    this._isDoingComposition = false;\n    this._selectionsWhenCompositionStarted = null;\n    this._columnSelectData = null;\n    this._autoClosedActions = [];\n    this._prevEditOperationType = 0 /* Other */;\n  }\n\n  dispose() {\n    this._cursors.dispose();\n    this._autoClosedActions = dispose(this._autoClosedActions);\n    super.dispose();\n  }\n  updateConfiguration(cursorConfig) {\n    this.context = new CursorContext(this._model, this._coordinatesConverter, cursorConfig);\n    this._cursors.updateContext(this.context);\n  }\n  onLineMappingChanged(eventsCollector) {\n    if (this._knownModelVersionId !== this._model.getVersionId()) {\n      // There are model change events that I didn't yet receive.\n      //\n      // This can happen when editing the model, and the view model receives the change events first,\n      // and the view model emits line mapping changed events, all before the cursor gets a chance to\n      // recover from markers.\n      //\n      // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n      return;\n    }\n    // Ensure valid state\n    this.setStates(eventsCollector, 'viewModel', 0 /* NotSet */, this.getCursorStates());\n  }\n  setHasFocus(hasFocus) {\n    this._hasFocus = hasFocus;\n  }\n  _validateAutoClosedActions() {\n    if (this._autoClosedActions.length > 0) {\n      let selections = this._cursors.getSelections();\n      for (let i = 0; i < this._autoClosedActions.length; i++) {\n        const autoClosedAction = this._autoClosedActions[i];\n        if (!autoClosedAction.isValid(selections)) {\n          autoClosedAction.dispose();\n          this._autoClosedActions.splice(i, 1);\n          i--;\n        }\n      }\n    }\n  }\n  // ------ some getters/setters\n  getPrimaryCursorState() {\n    return this._cursors.getPrimaryCursor();\n  }\n  getLastAddedCursorIndex() {\n    return this._cursors.getLastAddedCursorIndex();\n  }\n  getCursorStates() {\n    return this._cursors.getAll();\n  }\n  setStates(eventsCollector, source, reason, states) {\n    let reachedMaxCursorCount = false;\n    if (states !== null && states.length > Cursor.MAX_CURSOR_COUNT) {\n      states = states.slice(0, Cursor.MAX_CURSOR_COUNT);\n      reachedMaxCursorCount = true;\n    }\n    const oldState = new CursorModelState(this._model, this);\n    this._cursors.setStates(states);\n    this._cursors.normalize();\n    this._columnSelectData = null;\n    this._validateAutoClosedActions();\n    return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n  }\n  setCursorColumnSelectData(columnSelectData) {\n    this._columnSelectData = columnSelectData;\n  }\n  revealPrimary(eventsCollector, source, revealHorizontal, scrollType) {\n    const viewPositions = this._cursors.getViewPositions();\n    if (viewPositions.length > 1) {\n      this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), 0 /* Simple */, revealHorizontal, scrollType);\n      return;\n    } else {\n      const viewPosition = viewPositions[0];\n      const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n      this._emitCursorRevealRange(eventsCollector, source, viewRange, null, 0 /* Simple */, revealHorizontal, scrollType);\n    }\n  }\n  _revealPrimaryCursor(eventsCollector, source, verticalType, revealHorizontal, scrollType) {\n    const viewPositions = this._cursors.getViewPositions();\n    if (viewPositions.length > 1) {\n      this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), verticalType, revealHorizontal, scrollType);\n    } else {\n      const viewPosition = viewPositions[0];\n      const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n      this._emitCursorRevealRange(eventsCollector, source, viewRange, null, verticalType, revealHorizontal, scrollType);\n    }\n  }\n  _emitCursorRevealRange(eventsCollector, source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType) {\n    eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType));\n  }\n  saveState() {\n    let result = [];\n    const selections = this._cursors.getSelections();\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      result.push({\n        inSelectionMode: !selection.isEmpty(),\n        selectionStart: {\n          lineNumber: selection.selectionStartLineNumber,\n          column: selection.selectionStartColumn\n        },\n        position: {\n          lineNumber: selection.positionLineNumber,\n          column: selection.positionColumn\n        }\n      });\n    }\n    return result;\n  }\n  restoreState(eventsCollector, states) {\n    let desiredSelections = [];\n    for (let i = 0, len = states.length; i < len; i++) {\n      const state = states[i];\n      let positionLineNumber = 1;\n      let positionColumn = 1;\n      // Avoid missing properties on the literal\n      if (state.position && state.position.lineNumber) {\n        positionLineNumber = state.position.lineNumber;\n      }\n      if (state.position && state.position.column) {\n        positionColumn = state.position.column;\n      }\n      let selectionStartLineNumber = positionLineNumber;\n      let selectionStartColumn = positionColumn;\n      // Avoid missing properties on the literal\n      if (state.selectionStart && state.selectionStart.lineNumber) {\n        selectionStartLineNumber = state.selectionStart.lineNumber;\n      }\n      if (state.selectionStart && state.selectionStart.column) {\n        selectionStartColumn = state.selectionStart.column;\n      }\n      desiredSelections.push({\n        selectionStartLineNumber: selectionStartLineNumber,\n        selectionStartColumn: selectionStartColumn,\n        positionLineNumber: positionLineNumber,\n        positionColumn: positionColumn\n      });\n    }\n    this.setStates(eventsCollector, 'restoreState', 0 /* NotSet */, CursorState.fromModelSelections(desiredSelections));\n    this.revealPrimary(eventsCollector, 'restoreState', true, 1 /* Immediate */);\n  }\n\n  onModelContentChanged(eventsCollector, e) {\n    this._knownModelVersionId = e.versionId;\n    if (this._isHandling) {\n      return;\n    }\n    const hadFlushEvent = e.containsEvent(1 /* Flush */);\n    this._prevEditOperationType = 0 /* Other */;\n    if (hadFlushEvent) {\n      // a model.setValue() was called\n      this._cursors.dispose();\n      this._cursors = new CursorCollection(this.context);\n      this._validateAutoClosedActions();\n      this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* ContentFlush */, null, false);\n    } else {\n      if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n        const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n        if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* Undo */ : e.isRedoing ? 6 /* Redo */ : 2 /* RecoverFromMarkers */, cursorState)) {\n          this._revealPrimaryCursor(eventsCollector, 'modelChange', 0 /* Simple */, true, 0 /* Smooth */);\n        }\n      } else {\n        const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n        this.setStates(eventsCollector, 'modelChange', 2 /* RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n      }\n    }\n  }\n  getSelection() {\n    return this._cursors.getPrimaryCursor().modelState.selection;\n  }\n  getTopMostViewPosition() {\n    return this._cursors.getTopMostViewPosition();\n  }\n  getBottomMostViewPosition() {\n    return this._cursors.getBottomMostViewPosition();\n  }\n  getCursorColumnSelectData() {\n    if (this._columnSelectData) {\n      return this._columnSelectData;\n    }\n    const primaryCursor = this._cursors.getPrimaryCursor();\n    const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n    const viewPosition = primaryCursor.viewState.position;\n    return {\n      isReal: false,\n      fromViewLineNumber: viewSelectionStart.lineNumber,\n      fromViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewSelectionStart),\n      toViewLineNumber: viewPosition.lineNumber,\n      toViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewPosition)\n    };\n  }\n  getSelections() {\n    return this._cursors.getSelections();\n  }\n  setSelections(eventsCollector, source, selections, reason) {\n    this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n  }\n  getPrevEditOperationType() {\n    return this._prevEditOperationType;\n  }\n  setPrevEditOperationType(type) {\n    this._prevEditOperationType = type;\n  }\n  // ------ auxiliary handling logic\n  _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n    let autoClosedCharactersDeltaDecorations = [];\n    let autoClosedEnclosingDeltaDecorations = [];\n    for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n      autoClosedCharactersDeltaDecorations.push({\n        range: autoClosedCharactersRanges[i],\n        options: {\n          inlineClassName: 'auto-closed-character',\n          stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n        }\n      });\n\n      autoClosedEnclosingDeltaDecorations.push({\n        range: autoClosedEnclosingRanges[i],\n        options: {\n          stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n        }\n      });\n    }\n\n    const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n    const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n    this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n  }\n  _executeEditOperation(opResult) {\n    if (!opResult) {\n      // Nothing to execute\n      return;\n    }\n    if (opResult.shouldPushStackElementBefore) {\n      this._model.pushStackElement();\n    }\n    const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n    if (result) {\n      // The commands were applied correctly\n      this._interpretCommandResult(result);\n      // Check for auto-closing closed characters\n      let autoClosedCharactersRanges = [];\n      let autoClosedEnclosingRanges = [];\n      for (let i = 0; i < opResult.commands.length; i++) {\n        const command = opResult.commands[i];\n        if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n          autoClosedCharactersRanges.push(command.closeCharacterRange);\n          autoClosedEnclosingRanges.push(command.enclosingRange);\n        }\n      }\n      if (autoClosedCharactersRanges.length > 0) {\n        this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n      }\n      this._prevEditOperationType = opResult.type;\n    }\n    if (opResult.shouldPushStackElementAfter) {\n      this._model.pushStackElement();\n    }\n  }\n  _interpretCommandResult(cursorState) {\n    if (!cursorState || cursorState.length === 0) {\n      cursorState = this._cursors.readSelectionFromMarkers();\n    }\n    this._columnSelectData = null;\n    this._cursors.setSelections(cursorState);\n    this._cursors.normalize();\n  }\n  // -----------------------------------------------------------------------------------------------------------\n  // ----- emitting events\n  _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n    const newState = new CursorModelState(this._model, this);\n    if (newState.equals(oldState)) {\n      return false;\n    }\n    const selections = this._cursors.getSelections();\n    const viewSelections = this._cursors.getViewSelections();\n    // Let the view get the event first.\n    eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections));\n    // Only after the view has been notified, let the rest of the world know...\n    if (!oldState || oldState.cursorState.length !== newState.cursorState.length || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n      const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n      const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n      eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n    }\n    return true;\n  }\n  // -----------------------------------------------------------------------------------------------------------\n  // ----- handlers beyond this point\n  _findAutoClosingPairs(edits) {\n    if (!edits.length) {\n      return null;\n    }\n    let indices = [];\n    for (let i = 0, len = edits.length; i < len; i++) {\n      const edit = edits[i];\n      if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n        return null;\n      }\n      const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n      if (!m) {\n        return null;\n      }\n      const closeChar = m[1];\n      const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n      if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n        return null;\n      }\n      const openChar = autoClosingPairsCandidates[0].open;\n      const closeCharIndex = edit.text.length - m[2].length - 1;\n      const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n      if (openCharIndex === -1) {\n        return null;\n      }\n      indices.push([openCharIndex, closeCharIndex]);\n    }\n    return indices;\n  }\n  executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n    let autoClosingIndices = null;\n    if (source === 'snippet') {\n      autoClosingIndices = this._findAutoClosingPairs(edits);\n    }\n    if (autoClosingIndices) {\n      edits[0]._isTracked = true;\n    }\n    let autoClosedCharactersRanges = [];\n    let autoClosedEnclosingRanges = [];\n    const selections = this._model.pushEditOperations(this.getSelections(), edits, undoEdits => {\n      if (autoClosingIndices) {\n        for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n          const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n          const undoEdit = undoEdits[i];\n          const lineNumber = undoEdit.range.startLineNumber;\n          const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n          const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n          autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n          autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n        }\n      }\n      const selections = cursorStateComputer(undoEdits);\n      if (selections) {\n        // Don't recover the selection from markers because\n        // we know what it should be.\n        this._isHandling = true;\n      }\n      return selections;\n    });\n    if (selections) {\n      this._isHandling = false;\n      this.setSelections(eventsCollector, source, selections, 0 /* NotSet */);\n    }\n\n    if (autoClosedCharactersRanges.length > 0) {\n      this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n    }\n  }\n  _executeEdit(callback, eventsCollector, source) {\n    let cursorChangeReason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    if (this.context.cursorConfig.readOnly) {\n      // we cannot edit when read only...\n      return;\n    }\n    const oldState = new CursorModelState(this._model, this);\n    this._cursors.stopTrackingSelections();\n    this._isHandling = true;\n    try {\n      this._cursors.ensureValidState();\n      callback();\n    } catch (err) {\n      onUnexpectedError(err);\n    }\n    this._isHandling = false;\n    this._cursors.startTrackingSelections();\n    this._validateAutoClosedActions();\n    if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n      this._revealPrimaryCursor(eventsCollector, source, 0 /* Simple */, true, 0 /* Smooth */);\n    }\n  }\n\n  setIsDoingComposition(isDoingComposition) {\n    this._isDoingComposition = isDoingComposition;\n  }\n  startComposition(eventsCollector) {\n    this._selectionsWhenCompositionStarted = this.getSelections().slice(0);\n  }\n  endComposition(eventsCollector, source) {\n    this._executeEdit(() => {\n      if (source === 'keyboard') {\n        // composition finishes, let's check if we need to auto complete if necessary.\n        const autoClosedCharacters = AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n        this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), autoClosedCharacters));\n        this._selectionsWhenCompositionStarted = null;\n      }\n    }, eventsCollector, source);\n  }\n  type(eventsCollector, text, source) {\n    this._executeEdit(() => {\n      if (source === 'keyboard') {\n        // If this event is coming straight from the keyboard, look for electric characters and enter\n        const len = text.length;\n        let offset = 0;\n        while (offset < len) {\n          const charLength = strings.nextCharLength(text, offset);\n          const chr = text.substr(offset, charLength);\n          // Here we must interpret each typed character individually\n          const autoClosedCharacters = AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n          this._executeEditOperation(TypeOperations.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), autoClosedCharacters, chr));\n          offset += charLength;\n        }\n      } else {\n        this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n      }\n    }, eventsCollector, source);\n  }\n  replacePreviousChar(eventsCollector, text, replaceCharCnt, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(TypeOperations.replacePreviousChar(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replaceCharCnt));\n    }, eventsCollector, source);\n  }\n  paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n    }, eventsCollector, source, 4 /* Paste */);\n  }\n\n  cut(eventsCollector, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n    }, eventsCollector, source);\n  }\n  executeCommand(eventsCollector, command, source) {\n    this._executeEdit(() => {\n      this._cursors.killSecondaryCursors();\n      this._executeEditOperation(new EditOperationResult(0 /* Other */, [command], {\n        shouldPushStackElementBefore: false,\n        shouldPushStackElementAfter: false\n      }));\n    }, eventsCollector, source);\n  }\n  executeCommands(eventsCollector, commands, source) {\n    this._executeEdit(() => {\n      this._executeEditOperation(new EditOperationResult(0 /* Other */, commands, {\n        shouldPushStackElementBefore: false,\n        shouldPushStackElementAfter: false\n      }));\n    }, eventsCollector, source);\n  }\n}\nCursor.MAX_CURSOR_COUNT = 10000;\nclass CommandExecutor {\n  static executeCommands(model, selectionsBefore, commands) {\n    const ctx = {\n      model: model,\n      selectionsBefore: selectionsBefore,\n      trackedRanges: [],\n      trackedRangesDirection: []\n    };\n    const result = this._innerExecuteCommands(ctx, commands);\n    for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n      ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* AlwaysGrowsWhenTypingAtEdges */);\n    }\n\n    return result;\n  }\n  static _innerExecuteCommands(ctx, commands) {\n    if (this._arrayIsEmpty(commands)) {\n      return null;\n    }\n    const commandsData = this._getEditOperations(ctx, commands);\n    if (commandsData.operations.length === 0) {\n      return null;\n    }\n    const rawOperations = commandsData.operations;\n    const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n    if (loserCursorsMap.hasOwnProperty('0')) {\n      // These commands are very messed up\n      console.warn('Ignoring commands');\n      return null;\n    }\n    // Remove operations belonging to losing cursors\n    let filteredOperations = [];\n    for (let i = 0, len = rawOperations.length; i < len; i++) {\n      if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n        filteredOperations.push(rawOperations[i]);\n      }\n    }\n    // TODO@Alex: find a better way to do this.\n    // give the hint that edit operations are tracked to the model\n    if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n      filteredOperations[0]._isTracked = true;\n    }\n    let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, inverseEditOperations => {\n      let groupedInverseEditOperations = [];\n      for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n        groupedInverseEditOperations[i] = [];\n      }\n      for (const op of inverseEditOperations) {\n        if (!op.identifier) {\n          // perhaps auto whitespace trim edits\n          continue;\n        }\n        groupedInverseEditOperations[op.identifier.major].push(op);\n      }\n      const minorBasedSorter = (a, b) => {\n        return a.identifier.minor - b.identifier.minor;\n      };\n      let cursorSelections = [];\n      for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n        if (groupedInverseEditOperations[i].length > 0) {\n          groupedInverseEditOperations[i].sort(minorBasedSorter);\n          cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n            getInverseEditOperations: () => {\n              return groupedInverseEditOperations[i];\n            },\n            getTrackedSelection: id => {\n              const idx = parseInt(id, 10);\n              const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n              if (ctx.trackedRangesDirection[idx] === 0 /* LTR */) {\n                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n              }\n              return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n            }\n          });\n        } else {\n          cursorSelections[i] = ctx.selectionsBefore[i];\n        }\n      }\n      return cursorSelections;\n    });\n    if (!selectionsAfter) {\n      selectionsAfter = ctx.selectionsBefore;\n    }\n    // Extract losing cursors\n    let losingCursors = [];\n    for (let losingCursorIndex in loserCursorsMap) {\n      if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n        losingCursors.push(parseInt(losingCursorIndex, 10));\n      }\n    }\n    // Sort losing cursors descending\n    losingCursors.sort((a, b) => {\n      return b - a;\n    });\n    // Remove losing cursors\n    for (const losingCursor of losingCursors) {\n      selectionsAfter.splice(losingCursor, 1);\n    }\n    return selectionsAfter;\n  }\n  static _arrayIsEmpty(commands) {\n    for (let i = 0, len = commands.length; i < len; i++) {\n      if (commands[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static _getEditOperations(ctx, commands) {\n    let operations = [];\n    let hadTrackedEditOperation = false;\n    for (let i = 0, len = commands.length; i < len; i++) {\n      const command = commands[i];\n      if (command) {\n        const r = this._getEditOperationsFromCommand(ctx, i, command);\n        operations = operations.concat(r.operations);\n        hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n      }\n    }\n    return {\n      operations: operations,\n      hadTrackedEditOperation: hadTrackedEditOperation\n    };\n  }\n  static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n    // This method acts as a transaction, if the command fails\n    // everything it has done is ignored\n    let operations = [];\n    let operationMinor = 0;\n    const addEditOperation = function (range, text) {\n      let forceMoveMarkers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (Range.isEmpty(range) && text === '') {\n        // This command wants to add a no-op => no thank you\n        return;\n      }\n      operations.push({\n        identifier: {\n          major: majorIdentifier,\n          minor: operationMinor++\n        },\n        range: range,\n        text: text,\n        forceMoveMarkers: forceMoveMarkers,\n        isAutoWhitespaceEdit: command.insertsAutoWhitespace\n      });\n    };\n    let hadTrackedEditOperation = false;\n    const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n      hadTrackedEditOperation = true;\n      addEditOperation(selection, text, forceMoveMarkers);\n    };\n    const trackSelection = (_selection, trackPreviousOnEmpty) => {\n      const selection = Selection.liftSelection(_selection);\n      let stickiness;\n      if (selection.isEmpty()) {\n        if (typeof trackPreviousOnEmpty === 'boolean') {\n          if (trackPreviousOnEmpty) {\n            stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\n          } else {\n            stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\n          }\n        } else {\n          // Try to lock it with surrounding text\n          const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n          if (selection.startColumn === maxLineColumn) {\n            stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\n          } else {\n            stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\n          }\n        }\n      } else {\n        stickiness = 1 /* NeverGrowsWhenTypingAtEdges */;\n      }\n\n      const l = ctx.trackedRanges.length;\n      const id = ctx.model._setTrackedRange(null, selection, stickiness);\n      ctx.trackedRanges[l] = id;\n      ctx.trackedRangesDirection[l] = selection.getDirection();\n      return l.toString();\n    };\n    const editOperationBuilder = {\n      addEditOperation: addEditOperation,\n      addTrackedEditOperation: addTrackedEditOperation,\n      trackSelection: trackSelection\n    };\n    try {\n      command.getEditOperations(ctx.model, editOperationBuilder);\n    } catch (e) {\n      // TODO@Alex use notification service if this should be user facing\n      // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n      onUnexpectedError(e);\n      return {\n        operations: [],\n        hadTrackedEditOperation: false\n      };\n    }\n    return {\n      operations: operations,\n      hadTrackedEditOperation: hadTrackedEditOperation\n    };\n  }\n  static _getLoserCursorMap(operations) {\n    // This is destructive on the array\n    operations = operations.slice(0);\n    // Sort operations with last one first\n    operations.sort((a, b) => {\n      // Note the minus!\n      return -Range.compareRangesUsingEnds(a.range, b.range);\n    });\n    // Operations can not overlap!\n    let loserCursorsMap = {};\n    for (let i = 1; i < operations.length; i++) {\n      const previousOp = operations[i - 1];\n      const currentOp = operations[i];\n      if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n        let loserMajor;\n        if (previousOp.identifier.major > currentOp.identifier.major) {\n          // previousOp loses the battle\n          loserMajor = previousOp.identifier.major;\n        } else {\n          loserMajor = currentOp.identifier.major;\n        }\n        loserCursorsMap[loserMajor.toString()] = true;\n        for (let j = 0; j < operations.length; j++) {\n          if (operations[j].identifier.major === loserMajor) {\n            operations.splice(j, 1);\n            if (j < i) {\n              i--;\n            }\n            j--;\n          }\n        }\n        if (i > 0) {\n          i--;\n        }\n      }\n    }\n    return loserCursorsMap;\n  }\n}","map":{"version":3,"names":["onUnexpectedError","strings","CursorCollection","CursorColumns","CursorContext","CursorState","EditOperationResult","DeleteOperations","TypeOperations","TypeWithAutoClosingCommand","Range","Selection","ViewCursorStateChangedEvent","ViewRevealRangeRequestEvent","dispose","Disposable","CursorStateChangedEvent","CursorModelState","constructor","model","cursor","modelVersionId","getVersionId","cursorState","getCursorStates","equals","other","length","i","len","AutoClosedAction","autoClosedCharactersDecorations","autoClosedEnclosingDecorations","_model","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","getAllAutoClosedCharacters","autoClosedActions","autoClosedCharacters","autoClosedAction","concat","getAutoClosedCharactersRanges","deltaDecorations","result","decorationRange","getDecorationRange","push","isValid","selections","enclosingRanges","startLineNumber","endLineNumber","sort","compareRangesUsingStarts","strictContainsRange","Cursor","viewModel","coordinatesConverter","cursorConfig","_knownModelVersionId","_viewModel","_coordinatesConverter","context","_cursors","_hasFocus","_isHandling","_isDoingComposition","_selectionsWhenCompositionStarted","_columnSelectData","_autoClosedActions","_prevEditOperationType","updateConfiguration","updateContext","onLineMappingChanged","eventsCollector","setStates","setHasFocus","hasFocus","_validateAutoClosedActions","getSelections","splice","getPrimaryCursorState","getPrimaryCursor","getLastAddedCursorIndex","getAll","source","reason","states","reachedMaxCursorCount","MAX_CURSOR_COUNT","slice","oldState","normalize","_emitStateChangedIfNecessary","setCursorColumnSelectData","columnSelectData","revealPrimary","revealHorizontal","scrollType","viewPositions","getViewPositions","_emitCursorRevealRange","getViewSelections","viewPosition","viewRange","lineNumber","column","_revealPrimaryCursor","verticalType","viewSelections","emitViewEvent","saveState","selection","inSelectionMode","isEmpty","selectionStart","selectionStartLineNumber","selectionStartColumn","position","positionLineNumber","positionColumn","restoreState","desiredSelections","state","fromModelSelections","onModelContentChanged","e","versionId","hadFlushEvent","containsEvent","resultingSelection","isUndoing","isRedoing","selectionsFromMarkers","readSelectionFromMarkers","getSelection","modelState","getTopMostViewPosition","getBottomMostViewPosition","getCursorColumnSelectData","primaryCursor","viewSelectionStart","viewState","getStartPosition","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn2","toViewLineNumber","toViewVisualColumn","setSelections","getPrevEditOperationType","setPrevEditOperationType","type","_pushAutoClosedAction","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","range","options","inlineClassName","stickiness","_executeEditOperation","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","enclosingRange","closeCharacterRange","shouldPushStackElementAfter","newState","some","newCursorState","oldSelections","map","s","oldModelVersionId","emitOutgoingEvent","_findAutoClosingPairs","edits","indices","edit","text","indexOf","m","match","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","get","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","executeEdits","cursorStateComputer","autoClosingIndices","_isTracked","pushEditOperations","undoEdits","openCharInnerIndex","closeCharInnerIndex","undoEdit","startColumn","_executeEdit","callback","cursorChangeReason","arguments","undefined","readOnly","stopTrackingSelections","ensureValidState","err","startTrackingSelections","setIsDoingComposition","isDoingComposition","startComposition","endComposition","compositionEndWithInterceptors","offset","charLength","nextCharLength","chr","substr","typeWithInterceptors","typeWithoutInterceptors","replacePreviousChar","replaceCharCnt","paste","pasteOnNewLine","multicursorText","cut","executeCommand","killSecondaryCursors","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_setTrackedRange","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","hasOwnProperty","console","warn","filteredOperations","identifier","major","toString","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","a","b","minor","cursorSelections","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","_getTrackedRange","endColumn","losingCursors","losingCursorIndex","losingCursor","r","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","forceMoveMarkers","isAutoWhitespaceEdit","insertsAutoWhitespace","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","liftSelection","maxLineColumn","getLineMaxColumn","l","getDirection","editOperationBuilder","getEditOperations","compareRangesUsingEnds","previousOp","currentOp","isBefore","getEndPosition","loserMajor","j"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/controller/cursor.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { onUnexpectedError } from '../../../base/common/errors.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { CursorCollection } from './cursorCollection.js';\r\nimport { CursorColumns, CursorContext, CursorState, EditOperationResult } from './cursorCommon.js';\r\nimport { DeleteOperations } from './cursorDeleteOperations.js';\r\nimport { TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\r\nimport { Range } from '../core/range.js';\r\nimport { Selection } from '../core/selection.js';\r\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../view/viewEvents.js';\r\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\r\nimport { CursorStateChangedEvent } from '../viewModel/viewModelEventDispatcher.js';\r\n/**\r\n * A snapshot of the cursor and the model state\r\n */\r\nexport class CursorModelState {\r\n    constructor(model, cursor) {\r\n        this.modelVersionId = model.getVersionId();\r\n        this.cursorState = cursor.getCursorStates();\r\n    }\r\n    equals(other) {\r\n        if (!other) {\r\n            return false;\r\n        }\r\n        if (this.modelVersionId !== other.modelVersionId) {\r\n            return false;\r\n        }\r\n        if (this.cursorState.length !== other.cursorState.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\r\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nclass AutoClosedAction {\r\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\r\n        this._model = model;\r\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\r\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\r\n    }\r\n    static getAllAutoClosedCharacters(autoClosedActions) {\r\n        let autoClosedCharacters = [];\r\n        for (const autoClosedAction of autoClosedActions) {\r\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\r\n        }\r\n        return autoClosedCharacters;\r\n    }\r\n    dispose() {\r\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\r\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\r\n    }\r\n    getAutoClosedCharactersRanges() {\r\n        let result = [];\r\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\r\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\r\n            if (decorationRange) {\r\n                result.push(decorationRange);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    isValid(selections) {\r\n        let enclosingRanges = [];\r\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\r\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\r\n            if (decorationRange) {\r\n                enclosingRanges.push(decorationRange);\r\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\r\n                    // Stop tracking if the range becomes multiline...\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\r\n        selections.sort(Range.compareRangesUsingStarts);\r\n        for (let i = 0; i < selections.length; i++) {\r\n            if (i >= enclosingRanges.length) {\r\n                return false;\r\n            }\r\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexport class Cursor extends Disposable {\r\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\r\n        super();\r\n        this._model = model;\r\n        this._knownModelVersionId = this._model.getVersionId();\r\n        this._viewModel = viewModel;\r\n        this._coordinatesConverter = coordinatesConverter;\r\n        this.context = new CursorContext(this._model, this._coordinatesConverter, cursorConfig);\r\n        this._cursors = new CursorCollection(this.context);\r\n        this._hasFocus = false;\r\n        this._isHandling = false;\r\n        this._isDoingComposition = false;\r\n        this._selectionsWhenCompositionStarted = null;\r\n        this._columnSelectData = null;\r\n        this._autoClosedActions = [];\r\n        this._prevEditOperationType = 0 /* Other */;\r\n    }\r\n    dispose() {\r\n        this._cursors.dispose();\r\n        this._autoClosedActions = dispose(this._autoClosedActions);\r\n        super.dispose();\r\n    }\r\n    updateConfiguration(cursorConfig) {\r\n        this.context = new CursorContext(this._model, this._coordinatesConverter, cursorConfig);\r\n        this._cursors.updateContext(this.context);\r\n    }\r\n    onLineMappingChanged(eventsCollector) {\r\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\r\n            // There are model change events that I didn't yet receive.\r\n            //\r\n            // This can happen when editing the model, and the view model receives the change events first,\r\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\r\n            // recover from markers.\r\n            //\r\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\r\n            return;\r\n        }\r\n        // Ensure valid state\r\n        this.setStates(eventsCollector, 'viewModel', 0 /* NotSet */, this.getCursorStates());\r\n    }\r\n    setHasFocus(hasFocus) {\r\n        this._hasFocus = hasFocus;\r\n    }\r\n    _validateAutoClosedActions() {\r\n        if (this._autoClosedActions.length > 0) {\r\n            let selections = this._cursors.getSelections();\r\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\r\n                const autoClosedAction = this._autoClosedActions[i];\r\n                if (!autoClosedAction.isValid(selections)) {\r\n                    autoClosedAction.dispose();\r\n                    this._autoClosedActions.splice(i, 1);\r\n                    i--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // ------ some getters/setters\r\n    getPrimaryCursorState() {\r\n        return this._cursors.getPrimaryCursor();\r\n    }\r\n    getLastAddedCursorIndex() {\r\n        return this._cursors.getLastAddedCursorIndex();\r\n    }\r\n    getCursorStates() {\r\n        return this._cursors.getAll();\r\n    }\r\n    setStates(eventsCollector, source, reason, states) {\r\n        let reachedMaxCursorCount = false;\r\n        if (states !== null && states.length > Cursor.MAX_CURSOR_COUNT) {\r\n            states = states.slice(0, Cursor.MAX_CURSOR_COUNT);\r\n            reachedMaxCursorCount = true;\r\n        }\r\n        const oldState = new CursorModelState(this._model, this);\r\n        this._cursors.setStates(states);\r\n        this._cursors.normalize();\r\n        this._columnSelectData = null;\r\n        this._validateAutoClosedActions();\r\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\r\n    }\r\n    setCursorColumnSelectData(columnSelectData) {\r\n        this._columnSelectData = columnSelectData;\r\n    }\r\n    revealPrimary(eventsCollector, source, revealHorizontal, scrollType) {\r\n        const viewPositions = this._cursors.getViewPositions();\r\n        if (viewPositions.length > 1) {\r\n            this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), 0 /* Simple */, revealHorizontal, scrollType);\r\n            return;\r\n        }\r\n        else {\r\n            const viewPosition = viewPositions[0];\r\n            const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\r\n            this._emitCursorRevealRange(eventsCollector, source, viewRange, null, 0 /* Simple */, revealHorizontal, scrollType);\r\n        }\r\n    }\r\n    _revealPrimaryCursor(eventsCollector, source, verticalType, revealHorizontal, scrollType) {\r\n        const viewPositions = this._cursors.getViewPositions();\r\n        if (viewPositions.length > 1) {\r\n            this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), verticalType, revealHorizontal, scrollType);\r\n        }\r\n        else {\r\n            const viewPosition = viewPositions[0];\r\n            const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\r\n            this._emitCursorRevealRange(eventsCollector, source, viewRange, null, verticalType, revealHorizontal, scrollType);\r\n        }\r\n    }\r\n    _emitCursorRevealRange(eventsCollector, source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType) {\r\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType));\r\n    }\r\n    saveState() {\r\n        let result = [];\r\n        const selections = this._cursors.getSelections();\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            result.push({\r\n                inSelectionMode: !selection.isEmpty(),\r\n                selectionStart: {\r\n                    lineNumber: selection.selectionStartLineNumber,\r\n                    column: selection.selectionStartColumn,\r\n                },\r\n                position: {\r\n                    lineNumber: selection.positionLineNumber,\r\n                    column: selection.positionColumn,\r\n                }\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    restoreState(eventsCollector, states) {\r\n        let desiredSelections = [];\r\n        for (let i = 0, len = states.length; i < len; i++) {\r\n            const state = states[i];\r\n            let positionLineNumber = 1;\r\n            let positionColumn = 1;\r\n            // Avoid missing properties on the literal\r\n            if (state.position && state.position.lineNumber) {\r\n                positionLineNumber = state.position.lineNumber;\r\n            }\r\n            if (state.position && state.position.column) {\r\n                positionColumn = state.position.column;\r\n            }\r\n            let selectionStartLineNumber = positionLineNumber;\r\n            let selectionStartColumn = positionColumn;\r\n            // Avoid missing properties on the literal\r\n            if (state.selectionStart && state.selectionStart.lineNumber) {\r\n                selectionStartLineNumber = state.selectionStart.lineNumber;\r\n            }\r\n            if (state.selectionStart && state.selectionStart.column) {\r\n                selectionStartColumn = state.selectionStart.column;\r\n            }\r\n            desiredSelections.push({\r\n                selectionStartLineNumber: selectionStartLineNumber,\r\n                selectionStartColumn: selectionStartColumn,\r\n                positionLineNumber: positionLineNumber,\r\n                positionColumn: positionColumn\r\n            });\r\n        }\r\n        this.setStates(eventsCollector, 'restoreState', 0 /* NotSet */, CursorState.fromModelSelections(desiredSelections));\r\n        this.revealPrimary(eventsCollector, 'restoreState', true, 1 /* Immediate */);\r\n    }\r\n    onModelContentChanged(eventsCollector, e) {\r\n        this._knownModelVersionId = e.versionId;\r\n        if (this._isHandling) {\r\n            return;\r\n        }\r\n        const hadFlushEvent = e.containsEvent(1 /* Flush */);\r\n        this._prevEditOperationType = 0 /* Other */;\r\n        if (hadFlushEvent) {\r\n            // a model.setValue() was called\r\n            this._cursors.dispose();\r\n            this._cursors = new CursorCollection(this.context);\r\n            this._validateAutoClosedActions();\r\n            this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* ContentFlush */, null, false);\r\n        }\r\n        else {\r\n            if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\r\n                const cursorState = CursorState.fromModelSelections(e.resultingSelection);\r\n                if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* Undo */ : e.isRedoing ? 6 /* Redo */ : 2 /* RecoverFromMarkers */, cursorState)) {\r\n                    this._revealPrimaryCursor(eventsCollector, 'modelChange', 0 /* Simple */, true, 0 /* Smooth */);\r\n                }\r\n            }\r\n            else {\r\n                const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\r\n                this.setStates(eventsCollector, 'modelChange', 2 /* RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\r\n            }\r\n        }\r\n    }\r\n    getSelection() {\r\n        return this._cursors.getPrimaryCursor().modelState.selection;\r\n    }\r\n    getTopMostViewPosition() {\r\n        return this._cursors.getTopMostViewPosition();\r\n    }\r\n    getBottomMostViewPosition() {\r\n        return this._cursors.getBottomMostViewPosition();\r\n    }\r\n    getCursorColumnSelectData() {\r\n        if (this._columnSelectData) {\r\n            return this._columnSelectData;\r\n        }\r\n        const primaryCursor = this._cursors.getPrimaryCursor();\r\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\r\n        const viewPosition = primaryCursor.viewState.position;\r\n        return {\r\n            isReal: false,\r\n            fromViewLineNumber: viewSelectionStart.lineNumber,\r\n            fromViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewSelectionStart),\r\n            toViewLineNumber: viewPosition.lineNumber,\r\n            toViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewPosition),\r\n        };\r\n    }\r\n    getSelections() {\r\n        return this._cursors.getSelections();\r\n    }\r\n    setSelections(eventsCollector, source, selections, reason) {\r\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\r\n    }\r\n    getPrevEditOperationType() {\r\n        return this._prevEditOperationType;\r\n    }\r\n    setPrevEditOperationType(type) {\r\n        this._prevEditOperationType = type;\r\n    }\r\n    // ------ auxiliary handling logic\r\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\r\n        let autoClosedCharactersDeltaDecorations = [];\r\n        let autoClosedEnclosingDeltaDecorations = [];\r\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\r\n            autoClosedCharactersDeltaDecorations.push({\r\n                range: autoClosedCharactersRanges[i],\r\n                options: {\r\n                    inlineClassName: 'auto-closed-character',\r\n                    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\r\n                }\r\n            });\r\n            autoClosedEnclosingDeltaDecorations.push({\r\n                range: autoClosedEnclosingRanges[i],\r\n                options: {\r\n                    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\r\n                }\r\n            });\r\n        }\r\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\r\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\r\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\r\n    }\r\n    _executeEditOperation(opResult) {\r\n        if (!opResult) {\r\n            // Nothing to execute\r\n            return;\r\n        }\r\n        if (opResult.shouldPushStackElementBefore) {\r\n            this._model.pushStackElement();\r\n        }\r\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\r\n        if (result) {\r\n            // The commands were applied correctly\r\n            this._interpretCommandResult(result);\r\n            // Check for auto-closing closed characters\r\n            let autoClosedCharactersRanges = [];\r\n            let autoClosedEnclosingRanges = [];\r\n            for (let i = 0; i < opResult.commands.length; i++) {\r\n                const command = opResult.commands[i];\r\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\r\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\r\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\r\n                }\r\n            }\r\n            if (autoClosedCharactersRanges.length > 0) {\r\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\r\n            }\r\n            this._prevEditOperationType = opResult.type;\r\n        }\r\n        if (opResult.shouldPushStackElementAfter) {\r\n            this._model.pushStackElement();\r\n        }\r\n    }\r\n    _interpretCommandResult(cursorState) {\r\n        if (!cursorState || cursorState.length === 0) {\r\n            cursorState = this._cursors.readSelectionFromMarkers();\r\n        }\r\n        this._columnSelectData = null;\r\n        this._cursors.setSelections(cursorState);\r\n        this._cursors.normalize();\r\n    }\r\n    // -----------------------------------------------------------------------------------------------------------\r\n    // ----- emitting events\r\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\r\n        const newState = new CursorModelState(this._model, this);\r\n        if (newState.equals(oldState)) {\r\n            return false;\r\n        }\r\n        const selections = this._cursors.getSelections();\r\n        const viewSelections = this._cursors.getViewSelections();\r\n        // Let the view get the event first.\r\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections));\r\n        // Only after the view has been notified, let the rest of the world know...\r\n        if (!oldState\r\n            || oldState.cursorState.length !== newState.cursorState.length\r\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\r\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\r\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\r\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\r\n        }\r\n        return true;\r\n    }\r\n    // -----------------------------------------------------------------------------------------------------------\r\n    // ----- handlers beyond this point\r\n    _findAutoClosingPairs(edits) {\r\n        if (!edits.length) {\r\n            return null;\r\n        }\r\n        let indices = [];\r\n        for (let i = 0, len = edits.length; i < len; i++) {\r\n            const edit = edits[i];\r\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\r\n                return null;\r\n            }\r\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\r\n            if (!m) {\r\n                return null;\r\n            }\r\n            const closeChar = m[1];\r\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\r\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\r\n                return null;\r\n            }\r\n            const openChar = autoClosingPairsCandidates[0].open;\r\n            const closeCharIndex = edit.text.length - m[2].length - 1;\r\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\r\n            if (openCharIndex === -1) {\r\n                return null;\r\n            }\r\n            indices.push([openCharIndex, closeCharIndex]);\r\n        }\r\n        return indices;\r\n    }\r\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\r\n        let autoClosingIndices = null;\r\n        if (source === 'snippet') {\r\n            autoClosingIndices = this._findAutoClosingPairs(edits);\r\n        }\r\n        if (autoClosingIndices) {\r\n            edits[0]._isTracked = true;\r\n        }\r\n        let autoClosedCharactersRanges = [];\r\n        let autoClosedEnclosingRanges = [];\r\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\r\n            if (autoClosingIndices) {\r\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\r\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\r\n                    const undoEdit = undoEdits[i];\r\n                    const lineNumber = undoEdit.range.startLineNumber;\r\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\r\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\r\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\r\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\r\n                }\r\n            }\r\n            const selections = cursorStateComputer(undoEdits);\r\n            if (selections) {\r\n                // Don't recover the selection from markers because\r\n                // we know what it should be.\r\n                this._isHandling = true;\r\n            }\r\n            return selections;\r\n        });\r\n        if (selections) {\r\n            this._isHandling = false;\r\n            this.setSelections(eventsCollector, source, selections, 0 /* NotSet */);\r\n        }\r\n        if (autoClosedCharactersRanges.length > 0) {\r\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\r\n        }\r\n    }\r\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* NotSet */) {\r\n        if (this.context.cursorConfig.readOnly) {\r\n            // we cannot edit when read only...\r\n            return;\r\n        }\r\n        const oldState = new CursorModelState(this._model, this);\r\n        this._cursors.stopTrackingSelections();\r\n        this._isHandling = true;\r\n        try {\r\n            this._cursors.ensureValidState();\r\n            callback();\r\n        }\r\n        catch (err) {\r\n            onUnexpectedError(err);\r\n        }\r\n        this._isHandling = false;\r\n        this._cursors.startTrackingSelections();\r\n        this._validateAutoClosedActions();\r\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\r\n            this._revealPrimaryCursor(eventsCollector, source, 0 /* Simple */, true, 0 /* Smooth */);\r\n        }\r\n    }\r\n    setIsDoingComposition(isDoingComposition) {\r\n        this._isDoingComposition = isDoingComposition;\r\n    }\r\n    startComposition(eventsCollector) {\r\n        this._selectionsWhenCompositionStarted = this.getSelections().slice(0);\r\n    }\r\n    endComposition(eventsCollector, source) {\r\n        this._executeEdit(() => {\r\n            if (source === 'keyboard') {\r\n                // composition finishes, let's check if we need to auto complete if necessary.\r\n                const autoClosedCharacters = AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\r\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), autoClosedCharacters));\r\n                this._selectionsWhenCompositionStarted = null;\r\n            }\r\n        }, eventsCollector, source);\r\n    }\r\n    type(eventsCollector, text, source) {\r\n        this._executeEdit(() => {\r\n            if (source === 'keyboard') {\r\n                // If this event is coming straight from the keyboard, look for electric characters and enter\r\n                const len = text.length;\r\n                let offset = 0;\r\n                while (offset < len) {\r\n                    const charLength = strings.nextCharLength(text, offset);\r\n                    const chr = text.substr(offset, charLength);\r\n                    // Here we must interpret each typed character individually\r\n                    const autoClosedCharacters = AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\r\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), autoClosedCharacters, chr));\r\n                    offset += charLength;\r\n                }\r\n            }\r\n            else {\r\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\r\n            }\r\n        }, eventsCollector, source);\r\n    }\r\n    replacePreviousChar(eventsCollector, text, replaceCharCnt, source) {\r\n        this._executeEdit(() => {\r\n            this._executeEditOperation(TypeOperations.replacePreviousChar(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replaceCharCnt));\r\n        }, eventsCollector, source);\r\n    }\r\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\r\n        this._executeEdit(() => {\r\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\r\n        }, eventsCollector, source, 4 /* Paste */);\r\n    }\r\n    cut(eventsCollector, source) {\r\n        this._executeEdit(() => {\r\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\r\n        }, eventsCollector, source);\r\n    }\r\n    executeCommand(eventsCollector, command, source) {\r\n        this._executeEdit(() => {\r\n            this._cursors.killSecondaryCursors();\r\n            this._executeEditOperation(new EditOperationResult(0 /* Other */, [command], {\r\n                shouldPushStackElementBefore: false,\r\n                shouldPushStackElementAfter: false\r\n            }));\r\n        }, eventsCollector, source);\r\n    }\r\n    executeCommands(eventsCollector, commands, source) {\r\n        this._executeEdit(() => {\r\n            this._executeEditOperation(new EditOperationResult(0 /* Other */, commands, {\r\n                shouldPushStackElementBefore: false,\r\n                shouldPushStackElementAfter: false\r\n            }));\r\n        }, eventsCollector, source);\r\n    }\r\n}\r\nCursor.MAX_CURSOR_COUNT = 10000;\r\nclass CommandExecutor {\r\n    static executeCommands(model, selectionsBefore, commands) {\r\n        const ctx = {\r\n            model: model,\r\n            selectionsBefore: selectionsBefore,\r\n            trackedRanges: [],\r\n            trackedRangesDirection: []\r\n        };\r\n        const result = this._innerExecuteCommands(ctx, commands);\r\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\r\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* AlwaysGrowsWhenTypingAtEdges */);\r\n        }\r\n        return result;\r\n    }\r\n    static _innerExecuteCommands(ctx, commands) {\r\n        if (this._arrayIsEmpty(commands)) {\r\n            return null;\r\n        }\r\n        const commandsData = this._getEditOperations(ctx, commands);\r\n        if (commandsData.operations.length === 0) {\r\n            return null;\r\n        }\r\n        const rawOperations = commandsData.operations;\r\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\r\n        if (loserCursorsMap.hasOwnProperty('0')) {\r\n            // These commands are very messed up\r\n            console.warn('Ignoring commands');\r\n            return null;\r\n        }\r\n        // Remove operations belonging to losing cursors\r\n        let filteredOperations = [];\r\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\r\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\r\n                filteredOperations.push(rawOperations[i]);\r\n            }\r\n        }\r\n        // TODO@Alex: find a better way to do this.\r\n        // give the hint that edit operations are tracked to the model\r\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\r\n            filteredOperations[0]._isTracked = true;\r\n        }\r\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\r\n            let groupedInverseEditOperations = [];\r\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\r\n                groupedInverseEditOperations[i] = [];\r\n            }\r\n            for (const op of inverseEditOperations) {\r\n                if (!op.identifier) {\r\n                    // perhaps auto whitespace trim edits\r\n                    continue;\r\n                }\r\n                groupedInverseEditOperations[op.identifier.major].push(op);\r\n            }\r\n            const minorBasedSorter = (a, b) => {\r\n                return a.identifier.minor - b.identifier.minor;\r\n            };\r\n            let cursorSelections = [];\r\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\r\n                if (groupedInverseEditOperations[i].length > 0) {\r\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\r\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\r\n                        getInverseEditOperations: () => {\r\n                            return groupedInverseEditOperations[i];\r\n                        },\r\n                        getTrackedSelection: (id) => {\r\n                            const idx = parseInt(id, 10);\r\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\r\n                            if (ctx.trackedRangesDirection[idx] === 0 /* LTR */) {\r\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\r\n                            }\r\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    cursorSelections[i] = ctx.selectionsBefore[i];\r\n                }\r\n            }\r\n            return cursorSelections;\r\n        });\r\n        if (!selectionsAfter) {\r\n            selectionsAfter = ctx.selectionsBefore;\r\n        }\r\n        // Extract losing cursors\r\n        let losingCursors = [];\r\n        for (let losingCursorIndex in loserCursorsMap) {\r\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\r\n                losingCursors.push(parseInt(losingCursorIndex, 10));\r\n            }\r\n        }\r\n        // Sort losing cursors descending\r\n        losingCursors.sort((a, b) => {\r\n            return b - a;\r\n        });\r\n        // Remove losing cursors\r\n        for (const losingCursor of losingCursors) {\r\n            selectionsAfter.splice(losingCursor, 1);\r\n        }\r\n        return selectionsAfter;\r\n    }\r\n    static _arrayIsEmpty(commands) {\r\n        for (let i = 0, len = commands.length; i < len; i++) {\r\n            if (commands[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static _getEditOperations(ctx, commands) {\r\n        let operations = [];\r\n        let hadTrackedEditOperation = false;\r\n        for (let i = 0, len = commands.length; i < len; i++) {\r\n            const command = commands[i];\r\n            if (command) {\r\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\r\n                operations = operations.concat(r.operations);\r\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\r\n            }\r\n        }\r\n        return {\r\n            operations: operations,\r\n            hadTrackedEditOperation: hadTrackedEditOperation\r\n        };\r\n    }\r\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\r\n        // This method acts as a transaction, if the command fails\r\n        // everything it has done is ignored\r\n        let operations = [];\r\n        let operationMinor = 0;\r\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\r\n            if (Range.isEmpty(range) && text === '') {\r\n                // This command wants to add a no-op => no thank you\r\n                return;\r\n            }\r\n            operations.push({\r\n                identifier: {\r\n                    major: majorIdentifier,\r\n                    minor: operationMinor++\r\n                },\r\n                range: range,\r\n                text: text,\r\n                forceMoveMarkers: forceMoveMarkers,\r\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\r\n            });\r\n        };\r\n        let hadTrackedEditOperation = false;\r\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\r\n            hadTrackedEditOperation = true;\r\n            addEditOperation(selection, text, forceMoveMarkers);\r\n        };\r\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\r\n            const selection = Selection.liftSelection(_selection);\r\n            let stickiness;\r\n            if (selection.isEmpty()) {\r\n                if (typeof trackPreviousOnEmpty === 'boolean') {\r\n                    if (trackPreviousOnEmpty) {\r\n                        stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\r\n                    }\r\n                    else {\r\n                        stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\r\n                    }\r\n                }\r\n                else {\r\n                    // Try to lock it with surrounding text\r\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\r\n                    if (selection.startColumn === maxLineColumn) {\r\n                        stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\r\n                    }\r\n                    else {\r\n                        stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                stickiness = 1 /* NeverGrowsWhenTypingAtEdges */;\r\n            }\r\n            const l = ctx.trackedRanges.length;\r\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\r\n            ctx.trackedRanges[l] = id;\r\n            ctx.trackedRangesDirection[l] = selection.getDirection();\r\n            return l.toString();\r\n        };\r\n        const editOperationBuilder = {\r\n            addEditOperation: addEditOperation,\r\n            addTrackedEditOperation: addTrackedEditOperation,\r\n            trackSelection: trackSelection\r\n        };\r\n        try {\r\n            command.getEditOperations(ctx.model, editOperationBuilder);\r\n        }\r\n        catch (e) {\r\n            // TODO@Alex use notification service if this should be user facing\r\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\r\n            onUnexpectedError(e);\r\n            return {\r\n                operations: [],\r\n                hadTrackedEditOperation: false\r\n            };\r\n        }\r\n        return {\r\n            operations: operations,\r\n            hadTrackedEditOperation: hadTrackedEditOperation\r\n        };\r\n    }\r\n    static _getLoserCursorMap(operations) {\r\n        // This is destructive on the array\r\n        operations = operations.slice(0);\r\n        // Sort operations with last one first\r\n        operations.sort((a, b) => {\r\n            // Note the minus!\r\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\r\n        });\r\n        // Operations can not overlap!\r\n        let loserCursorsMap = {};\r\n        for (let i = 1; i < operations.length; i++) {\r\n            const previousOp = operations[i - 1];\r\n            const currentOp = operations[i];\r\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\r\n                let loserMajor;\r\n                if (previousOp.identifier.major > currentOp.identifier.major) {\r\n                    // previousOp loses the battle\r\n                    loserMajor = previousOp.identifier.major;\r\n                }\r\n                else {\r\n                    loserMajor = currentOp.identifier.major;\r\n                }\r\n                loserCursorsMap[loserMajor.toString()] = true;\r\n                for (let j = 0; j < operations.length; j++) {\r\n                    if (operations[j].identifier.major === loserMajor) {\r\n                        operations.splice(j, 1);\r\n                        if (j < i) {\r\n                            i--;\r\n                        }\r\n                        j--;\r\n                    }\r\n                }\r\n                if (i > 0) {\r\n                    i--;\r\n                }\r\n            }\r\n        }\r\n        return loserCursorsMap;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}