{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { HorizontalRange } from '../../../common/view/renderingContext.js';\nclass FloatHorizontalRange {\n  constructor(left, width) {\n    this.left = left;\n    this.width = width;\n  }\n  toString() {\n    return \"[\".concat(this.left, \",\").concat(this.width, \"]\");\n  }\n  static compare(a, b) {\n    return a.left - b.left;\n  }\n}\nexport class RangeUtil {\n  static _createRange() {\n    if (!this._handyReadyRange) {\n      this._handyReadyRange = document.createRange();\n    }\n    return this._handyReadyRange;\n  }\n  static _detachRange(range, endNode) {\n    // Move range out of the span node, IE doesn't like having many ranges in\n    // the same spot and will act badly for lines containing dashes ('-')\n    range.selectNodeContents(endNode);\n  }\n  static _readClientRects(startElement, startOffset, endElement, endOffset, endNode) {\n    const range = this._createRange();\n    try {\n      range.setStart(startElement, startOffset);\n      range.setEnd(endElement, endOffset);\n      return range.getClientRects();\n    } catch (e) {\n      // This is life ...\n      return null;\n    } finally {\n      this._detachRange(range, endNode);\n    }\n  }\n  static _mergeAdjacentRanges(ranges) {\n    if (ranges.length === 1) {\n      // There is nothing to merge\n      return [new HorizontalRange(ranges[0].left, ranges[0].width)];\n    }\n    ranges.sort(FloatHorizontalRange.compare);\n    let result = [],\n      resultLen = 0;\n    let prevLeft = ranges[0].left;\n    let prevWidth = ranges[0].width;\n    for (let i = 1, len = ranges.length; i < len; i++) {\n      const range = ranges[i];\n      const myLeft = range.left;\n      const myWidth = range.width;\n      if (prevLeft + prevWidth + 0.9 /* account for browser's rounding errors*/ >= myLeft) {\n        prevWidth = Math.max(prevWidth, myLeft + myWidth - prevLeft);\n      } else {\n        result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);\n        prevLeft = myLeft;\n        prevWidth = myWidth;\n      }\n    }\n    result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);\n    return result;\n  }\n  static _createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft) {\n    if (!clientRects || clientRects.length === 0) {\n      return null;\n    }\n    // We go through FloatHorizontalRange because it has been observed in bi-di text\n    // that the clientRects are not coming in sorted from the browser\n    const result = [];\n    for (let i = 0, len = clientRects.length; i < len; i++) {\n      const clientRect = clientRects[i];\n      result[i] = new FloatHorizontalRange(Math.max(0, clientRect.left - clientRectDeltaLeft), clientRect.width);\n    }\n    return this._mergeAdjacentRanges(result);\n  }\n  static readHorizontalRanges(domNode, startChildIndex, startOffset, endChildIndex, endOffset, clientRectDeltaLeft, endNode) {\n    // Panic check\n    const min = 0;\n    const max = domNode.children.length - 1;\n    if (min > max) {\n      return null;\n    }\n    startChildIndex = Math.min(max, Math.max(min, startChildIndex));\n    endChildIndex = Math.min(max, Math.max(min, endChildIndex));\n    if (startChildIndex === endChildIndex && startOffset === endOffset && startOffset === 0) {\n      // We must find the position at the beginning of a <span>\n      // To cover cases of empty <span>s, aboid using a range and use the <span>'s bounding box\n      const clientRects = domNode.children[startChildIndex].getClientRects();\n      return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);\n    }\n    // If crossing over to a span only to select offset 0, then use the previous span's maximum offset\n    // Chrome is buggy and doesn't handle 0 offsets well sometimes.\n    if (startChildIndex !== endChildIndex) {\n      if (endChildIndex > 0 && endOffset === 0) {\n        endChildIndex--;\n        endOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n      }\n    }\n\n    let startElement = domNode.children[startChildIndex].firstChild;\n    let endElement = domNode.children[endChildIndex].firstChild;\n    if (!startElement || !endElement) {\n      // When having an empty <span> (without any text content), try to move to the previous <span>\n      if (!startElement && startOffset === 0 && startChildIndex > 0) {\n        startElement = domNode.children[startChildIndex - 1].firstChild;\n        startOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n      }\n\n      if (!endElement && endOffset === 0 && endChildIndex > 0) {\n        endElement = domNode.children[endChildIndex - 1].firstChild;\n        endOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n      }\n    }\n\n    if (!startElement || !endElement) {\n      return null;\n    }\n    startOffset = Math.min(startElement.textContent.length, Math.max(0, startOffset));\n    endOffset = Math.min(endElement.textContent.length, Math.max(0, endOffset));\n    const clientRects = this._readClientRects(startElement, startOffset, endElement, endOffset, endNode);\n    return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);\n  }\n}","map":{"version":3,"names":["HorizontalRange","FloatHorizontalRange","constructor","left","width","toString","concat","compare","a","b","RangeUtil","_createRange","_handyReadyRange","document","createRange","_detachRange","range","endNode","selectNodeContents","_readClientRects","startElement","startOffset","endElement","endOffset","setStart","setEnd","getClientRects","e","_mergeAdjacentRanges","ranges","length","sort","result","resultLen","prevLeft","prevWidth","i","len","myLeft","myWidth","Math","max","_createHorizontalRangesFromClientRects","clientRects","clientRectDeltaLeft","clientRect","readHorizontalRanges","domNode","startChildIndex","endChildIndex","min","children","firstChild","textContent"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/rangeUtil.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { HorizontalRange } from '../../../common/view/renderingContext.js';\r\nclass FloatHorizontalRange {\r\n    constructor(left, width) {\r\n        this.left = left;\r\n        this.width = width;\r\n    }\r\n    toString() {\r\n        return `[${this.left},${this.width}]`;\r\n    }\r\n    static compare(a, b) {\r\n        return a.left - b.left;\r\n    }\r\n}\r\nexport class RangeUtil {\r\n    static _createRange() {\r\n        if (!this._handyReadyRange) {\r\n            this._handyReadyRange = document.createRange();\r\n        }\r\n        return this._handyReadyRange;\r\n    }\r\n    static _detachRange(range, endNode) {\r\n        // Move range out of the span node, IE doesn't like having many ranges in\r\n        // the same spot and will act badly for lines containing dashes ('-')\r\n        range.selectNodeContents(endNode);\r\n    }\r\n    static _readClientRects(startElement, startOffset, endElement, endOffset, endNode) {\r\n        const range = this._createRange();\r\n        try {\r\n            range.setStart(startElement, startOffset);\r\n            range.setEnd(endElement, endOffset);\r\n            return range.getClientRects();\r\n        }\r\n        catch (e) {\r\n            // This is life ...\r\n            return null;\r\n        }\r\n        finally {\r\n            this._detachRange(range, endNode);\r\n        }\r\n    }\r\n    static _mergeAdjacentRanges(ranges) {\r\n        if (ranges.length === 1) {\r\n            // There is nothing to merge\r\n            return [new HorizontalRange(ranges[0].left, ranges[0].width)];\r\n        }\r\n        ranges.sort(FloatHorizontalRange.compare);\r\n        let result = [], resultLen = 0;\r\n        let prevLeft = ranges[0].left;\r\n        let prevWidth = ranges[0].width;\r\n        for (let i = 1, len = ranges.length; i < len; i++) {\r\n            const range = ranges[i];\r\n            const myLeft = range.left;\r\n            const myWidth = range.width;\r\n            if (prevLeft + prevWidth + 0.9 /* account for browser's rounding errors*/ >= myLeft) {\r\n                prevWidth = Math.max(prevWidth, myLeft + myWidth - prevLeft);\r\n            }\r\n            else {\r\n                result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);\r\n                prevLeft = myLeft;\r\n                prevWidth = myWidth;\r\n            }\r\n        }\r\n        result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);\r\n        return result;\r\n    }\r\n    static _createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft) {\r\n        if (!clientRects || clientRects.length === 0) {\r\n            return null;\r\n        }\r\n        // We go through FloatHorizontalRange because it has been observed in bi-di text\r\n        // that the clientRects are not coming in sorted from the browser\r\n        const result = [];\r\n        for (let i = 0, len = clientRects.length; i < len; i++) {\r\n            const clientRect = clientRects[i];\r\n            result[i] = new FloatHorizontalRange(Math.max(0, clientRect.left - clientRectDeltaLeft), clientRect.width);\r\n        }\r\n        return this._mergeAdjacentRanges(result);\r\n    }\r\n    static readHorizontalRanges(domNode, startChildIndex, startOffset, endChildIndex, endOffset, clientRectDeltaLeft, endNode) {\r\n        // Panic check\r\n        const min = 0;\r\n        const max = domNode.children.length - 1;\r\n        if (min > max) {\r\n            return null;\r\n        }\r\n        startChildIndex = Math.min(max, Math.max(min, startChildIndex));\r\n        endChildIndex = Math.min(max, Math.max(min, endChildIndex));\r\n        if (startChildIndex === endChildIndex && startOffset === endOffset && startOffset === 0) {\r\n            // We must find the position at the beginning of a <span>\r\n            // To cover cases of empty <span>s, aboid using a range and use the <span>'s bounding box\r\n            const clientRects = domNode.children[startChildIndex].getClientRects();\r\n            return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);\r\n        }\r\n        // If crossing over to a span only to select offset 0, then use the previous span's maximum offset\r\n        // Chrome is buggy and doesn't handle 0 offsets well sometimes.\r\n        if (startChildIndex !== endChildIndex) {\r\n            if (endChildIndex > 0 && endOffset === 0) {\r\n                endChildIndex--;\r\n                endOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n            }\r\n        }\r\n        let startElement = domNode.children[startChildIndex].firstChild;\r\n        let endElement = domNode.children[endChildIndex].firstChild;\r\n        if (!startElement || !endElement) {\r\n            // When having an empty <span> (without any text content), try to move to the previous <span>\r\n            if (!startElement && startOffset === 0 && startChildIndex > 0) {\r\n                startElement = domNode.children[startChildIndex - 1].firstChild;\r\n                startOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n            }\r\n            if (!endElement && endOffset === 0 && endChildIndex > 0) {\r\n                endElement = domNode.children[endChildIndex - 1].firstChild;\r\n                endOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n            }\r\n        }\r\n        if (!startElement || !endElement) {\r\n            return null;\r\n        }\r\n        startOffset = Math.min(startElement.textContent.length, Math.max(0, startOffset));\r\n        endOffset = Math.min(endElement.textContent.length, Math.max(0, endOffset));\r\n        const clientRects = this._readClientRects(startElement, startOffset, endElement, endOffset, endNode);\r\n        return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}