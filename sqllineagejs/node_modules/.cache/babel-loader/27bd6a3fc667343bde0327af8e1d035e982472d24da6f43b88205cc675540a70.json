{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { alert } from '../../../base/browser/ui/aria/aria.js';\nimport { asArray, isNonEmptyArray } from '../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../base/common/cancellation.js';\nimport { illegalArgument, onUnexpectedExternalError } from '../../../base/common/errors.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../browser/core/editorState.js';\nimport { isCodeEditor } from '../../browser/editorBrowser.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { DocumentFormattingEditProviderRegistry, DocumentRangeFormattingEditProviderRegistry, OnTypeFormattingEditProviderRegistry } from '../../common/modes.js';\nimport { IEditorWorkerService } from '../../common/services/editorWorkerService.js';\nimport { IModelService } from '../../common/services/modelService.js';\nimport { FormattingEdit } from './formattingEdit.js';\nimport * as nls from '../../../nls.js';\nimport { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { CommandsRegistry } from '../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../base/common/types.js';\nimport { Iterable } from '../../../base/common/iterator.js';\nexport function alertFormattingEdits(edits) {\n  edits = edits.filter(edit => edit.range);\n  if (!edits.length) {\n    return;\n  }\n  let {\n    range\n  } = edits[0];\n  for (let i = 1; i < edits.length; i++) {\n    range = Range.plusRange(range, edits[i].range);\n  }\n  const {\n    startLineNumber,\n    endLineNumber\n  } = range;\n  if (startLineNumber === endLineNumber) {\n    if (edits.length === 1) {\n      alert(nls.localize('hint11', \"Made 1 formatting edit on line {0}\", startLineNumber));\n    } else {\n      alert(nls.localize('hintn1', \"Made {0} formatting edits on line {1}\", edits.length, startLineNumber));\n    }\n  } else {\n    if (edits.length === 1) {\n      alert(nls.localize('hint1n', \"Made 1 formatting edit between lines {0} and {1}\", startLineNumber, endLineNumber));\n    } else {\n      alert(nls.localize('hintnn', \"Made {0} formatting edits between lines {1} and {2}\", edits.length, startLineNumber, endLineNumber));\n    }\n  }\n}\nexport function getRealAndSyntheticDocumentFormattersOrdered(model) {\n  const result = [];\n  const seen = new Set();\n  // (1) add all document formatter\n  const docFormatter = DocumentFormattingEditProviderRegistry.ordered(model);\n  for (const formatter of docFormatter) {\n    result.push(formatter);\n    if (formatter.extensionId) {\n      seen.add(ExtensionIdentifier.toKey(formatter.extensionId));\n    }\n  }\n  // (2) add all range formatter as document formatter (unless the same extension already did that)\n  const rangeFormatter = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n  for (const formatter of rangeFormatter) {\n    if (formatter.extensionId) {\n      if (seen.has(ExtensionIdentifier.toKey(formatter.extensionId))) {\n        continue;\n      }\n      seen.add(ExtensionIdentifier.toKey(formatter.extensionId));\n    }\n    result.push({\n      displayName: formatter.displayName,\n      extensionId: formatter.extensionId,\n      provideDocumentFormattingEdits(model, options, token) {\n        return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n      }\n    });\n  }\n  return result;\n}\nexport class FormattingConflicts {\n  static setFormatterSelector(selector) {\n    const remove = FormattingConflicts._selectors.unshift(selector);\n    return {\n      dispose: remove\n    };\n  }\n  static select(formatter, document, mode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (formatter.length === 0) {\n        return undefined;\n      }\n      const selector = Iterable.first(FormattingConflicts._selectors);\n      if (selector) {\n        return yield selector(formatter, document, mode);\n      }\n      return undefined;\n    });\n  }\n}\nFormattingConflicts._selectors = new LinkedList();\nexport function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const instaService = accessor.get(IInstantiationService);\n    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n    const provider = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n    const selected = yield FormattingConflicts.select(provider, model, mode);\n    if (selected) {\n      progress.report(selected);\n      yield instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token);\n    }\n  });\n}\nexport function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const workerService = accessor.get(IEditorWorkerService);\n    let model;\n    let cts;\n    if (isCodeEditor(editorOrModel)) {\n      model = editorOrModel.getModel();\n      cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* Value */ | 4 /* Position */, undefined, token);\n    } else {\n      model = editorOrModel;\n      cts = new TextModelCancellationTokenSource(editorOrModel, token);\n    }\n    // make sure that ranges don't overlap nor touch each other\n    let ranges = [];\n    let len = 0;\n    for (let range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {\n      if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {\n        ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());\n      } else {\n        len = ranges.push(range);\n      }\n    }\n    const allEdits = [];\n    for (let range of ranges) {\n      try {\n        const rawEdits = yield provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token);\n        const minEdits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n        if (minEdits) {\n          allEdits.push(...minEdits);\n        }\n        if (cts.token.isCancellationRequested) {\n          return true;\n        }\n      } finally {\n        cts.dispose();\n      }\n    }\n    if (allEdits.length === 0) {\n      return false;\n    }\n    if (isCodeEditor(editorOrModel)) {\n      // use editor to apply edits\n      FormattingEdit.execute(editorOrModel, allEdits, true);\n      alertFormattingEdits(allEdits);\n      editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* Immediate */);\n    } else {\n      // use model to apply edits\n      const [{\n        range\n      }] = allEdits;\n      const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n      model.pushEditOperations([initialSelection], allEdits.map(edit => {\n        return {\n          text: edit.text,\n          range: Range.lift(edit.range),\n          forceMoveMarkers: true\n        };\n      }), undoEdits => {\n        for (const {\n          range\n        } of undoEdits) {\n          if (Range.areIntersectingOrTouching(range, initialSelection)) {\n            return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n          }\n        }\n        return null;\n      });\n    }\n    return true;\n  });\n}\nexport function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const instaService = accessor.get(IInstantiationService);\n    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n    const provider = getRealAndSyntheticDocumentFormattersOrdered(model);\n    const selected = yield FormattingConflicts.select(provider, model, mode);\n    if (selected) {\n      progress.report(selected);\n      yield instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token);\n    }\n  });\n}\nexport function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const workerService = accessor.get(IEditorWorkerService);\n    let model;\n    let cts;\n    if (isCodeEditor(editorOrModel)) {\n      model = editorOrModel.getModel();\n      cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* Value */ | 4 /* Position */, undefined, token);\n    } else {\n      model = editorOrModel;\n      cts = new TextModelCancellationTokenSource(editorOrModel, token);\n    }\n    let edits;\n    try {\n      const rawEdits = yield provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);\n      edits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n      if (cts.token.isCancellationRequested) {\n        return true;\n      }\n    } finally {\n      cts.dispose();\n    }\n    if (!edits || edits.length === 0) {\n      return false;\n    }\n    if (isCodeEditor(editorOrModel)) {\n      // use editor to apply edits\n      FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* Silent */);\n      if (mode !== 2 /* Silent */) {\n        alertFormattingEdits(edits);\n        editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* Immediate */);\n      }\n    } else {\n      // use model to apply edits\n      const [{\n        range\n      }] = edits;\n      const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n      model.pushEditOperations([initialSelection], edits.map(edit => {\n        return {\n          text: edit.text,\n          range: Range.lift(edit.range),\n          forceMoveMarkers: true\n        };\n      }), undoEdits => {\n        for (const {\n          range\n        } of undoEdits) {\n          if (Range.areIntersectingOrTouching(range, initialSelection)) {\n            return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n          }\n        }\n        return null;\n      });\n    }\n    return true;\n  });\n}\nexport function getDocumentRangeFormattingEditsUntilResult(workerService, model, range, options, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = DocumentRangeFormattingEditProviderRegistry.ordered(model);\n    for (const provider of providers) {\n      let rawEdits = yield Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\n      if (isNonEmptyArray(rawEdits)) {\n        return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n      }\n    }\n    return undefined;\n  });\n}\nexport function getDocumentFormattingEditsUntilResult(workerService, model, options, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = getRealAndSyntheticDocumentFormattersOrdered(model);\n    for (const provider of providers) {\n      let rawEdits = yield Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\n      if (isNonEmptyArray(rawEdits)) {\n        return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n      }\n    }\n    return undefined;\n  });\n}\nexport function getOnTypeFormattingEdits(workerService, model, position, ch, options) {\n  const providers = OnTypeFormattingEditProviderRegistry.ordered(model);\n  if (providers.length === 0) {\n    return Promise.resolve(undefined);\n  }\n  if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n    return Promise.resolve(undefined);\n  }\n  return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, CancellationToken.None)).catch(onUnexpectedExternalError).then(edits => {\n    return workerService.computeMoreMinimalEdits(model.uri, edits);\n  });\n}\nCommandsRegistry.registerCommand('_executeFormatRangeProvider', function (accessor) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  const [resource, range, options] = args;\n  assertType(URI.isUri(resource));\n  assertType(Range.isIRange(range));\n  const model = accessor.get(IModelService).getModel(resource);\n  if (!model) {\n    throw illegalArgument('resource');\n  }\n  return getDocumentRangeFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, Range.lift(range), options, CancellationToken.None);\n});\nCommandsRegistry.registerCommand('_executeFormatDocumentProvider', function (accessor) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  const [resource, options] = args;\n  assertType(URI.isUri(resource));\n  const model = accessor.get(IModelService).getModel(resource);\n  if (!model) {\n    throw illegalArgument('resource');\n  }\n  return getDocumentFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, options, CancellationToken.None);\n});\nCommandsRegistry.registerCommand('_executeFormatOnTypeProvider', function (accessor) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n  const [resource, position, ch, options] = args;\n  assertType(URI.isUri(resource));\n  assertType(Position.isIPosition(position));\n  assertType(typeof ch === 'string');\n  const model = accessor.get(IModelService).getModel(resource);\n  if (!model) {\n    throw illegalArgument('resource');\n  }\n  return getOnTypeFormattingEdits(accessor.get(IEditorWorkerService), model, Position.lift(position), ch, options);\n});","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","alert","asArray","isNonEmptyArray","CancellationToken","illegalArgument","onUnexpectedExternalError","URI","EditorStateCancellationTokenSource","TextModelCancellationTokenSource","isCodeEditor","Position","Range","Selection","DocumentFormattingEditProviderRegistry","DocumentRangeFormattingEditProviderRegistry","OnTypeFormattingEditProviderRegistry","IEditorWorkerService","IModelService","FormattingEdit","nls","ExtensionIdentifier","IInstantiationService","LinkedList","CommandsRegistry","assertType","Iterable","alertFormattingEdits","edits","filter","edit","range","length","i","plusRange","startLineNumber","endLineNumber","localize","getRealAndSyntheticDocumentFormattersOrdered","model","seen","Set","docFormatter","ordered","formatter","push","extensionId","add","toKey","rangeFormatter","has","displayName","provideDocumentFormattingEdits","options","token","provideDocumentRangeFormattingEdits","getFullModelRange","FormattingConflicts","setFormatterSelector","selector","remove","_selectors","unshift","dispose","select","document","mode","undefined","first","formatDocumentRangesWithSelectedProvider","accessor","editorOrModel","rangeOrRanges","progress","instaService","get","getModel","provider","selected","report","invokeFunction","formatDocumentRangesWithProvider","workerService","cts","ranges","len","sort","compareRangesUsingStarts","areIntersectingOrTouching","fromPositions","getStartPosition","getEndPosition","allEdits","rawEdits","getFormattingOptions","minEdits","computeMoreMinimalEdits","uri","isCancellationRequested","execute","revealPositionInCenterIfOutsideViewport","getPosition","initialSelection","startColumn","endColumn","pushEditOperations","map","text","lift","forceMoveMarkers","undoEdits","formatDocumentWithSelectedProvider","formatDocumentWithProvider","getDocumentRangeFormattingEditsUntilResult","providers","catch","getDocumentFormattingEditsUntilResult","getOnTypeFormattingEdits","position","ch","autoFormatTriggerCharacters","indexOf","provideOnTypeFormattingEdits","None","registerCommand","_len","arguments","args","Array","_key","resource","isUri","isIRange","_len2","_key2","_len3","_key3","isIPosition"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/format/format.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { alert } from '../../../base/browser/ui/aria/aria.js';\r\nimport { asArray, isNonEmptyArray } from '../../../base/common/arrays.js';\r\nimport { CancellationToken } from '../../../base/common/cancellation.js';\r\nimport { illegalArgument, onUnexpectedExternalError } from '../../../base/common/errors.js';\r\nimport { URI } from '../../../base/common/uri.js';\r\nimport { EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../browser/core/editorState.js';\r\nimport { isCodeEditor } from '../../browser/editorBrowser.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Range } from '../../common/core/range.js';\r\nimport { Selection } from '../../common/core/selection.js';\r\nimport { DocumentFormattingEditProviderRegistry, DocumentRangeFormattingEditProviderRegistry, OnTypeFormattingEditProviderRegistry } from '../../common/modes.js';\r\nimport { IEditorWorkerService } from '../../common/services/editorWorkerService.js';\r\nimport { IModelService } from '../../common/services/modelService.js';\r\nimport { FormattingEdit } from './formattingEdit.js';\r\nimport * as nls from '../../../nls.js';\r\nimport { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';\r\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\r\nimport { LinkedList } from '../../../base/common/linkedList.js';\r\nimport { CommandsRegistry } from '../../../platform/commands/common/commands.js';\r\nimport { assertType } from '../../../base/common/types.js';\r\nimport { Iterable } from '../../../base/common/iterator.js';\r\nexport function alertFormattingEdits(edits) {\r\n    edits = edits.filter(edit => edit.range);\r\n    if (!edits.length) {\r\n        return;\r\n    }\r\n    let { range } = edits[0];\r\n    for (let i = 1; i < edits.length; i++) {\r\n        range = Range.plusRange(range, edits[i].range);\r\n    }\r\n    const { startLineNumber, endLineNumber } = range;\r\n    if (startLineNumber === endLineNumber) {\r\n        if (edits.length === 1) {\r\n            alert(nls.localize('hint11', \"Made 1 formatting edit on line {0}\", startLineNumber));\r\n        }\r\n        else {\r\n            alert(nls.localize('hintn1', \"Made {0} formatting edits on line {1}\", edits.length, startLineNumber));\r\n        }\r\n    }\r\n    else {\r\n        if (edits.length === 1) {\r\n            alert(nls.localize('hint1n', \"Made 1 formatting edit between lines {0} and {1}\", startLineNumber, endLineNumber));\r\n        }\r\n        else {\r\n            alert(nls.localize('hintnn', \"Made {0} formatting edits between lines {1} and {2}\", edits.length, startLineNumber, endLineNumber));\r\n        }\r\n    }\r\n}\r\nexport function getRealAndSyntheticDocumentFormattersOrdered(model) {\r\n    const result = [];\r\n    const seen = new Set();\r\n    // (1) add all document formatter\r\n    const docFormatter = DocumentFormattingEditProviderRegistry.ordered(model);\r\n    for (const formatter of docFormatter) {\r\n        result.push(formatter);\r\n        if (formatter.extensionId) {\r\n            seen.add(ExtensionIdentifier.toKey(formatter.extensionId));\r\n        }\r\n    }\r\n    // (2) add all range formatter as document formatter (unless the same extension already did that)\r\n    const rangeFormatter = DocumentRangeFormattingEditProviderRegistry.ordered(model);\r\n    for (const formatter of rangeFormatter) {\r\n        if (formatter.extensionId) {\r\n            if (seen.has(ExtensionIdentifier.toKey(formatter.extensionId))) {\r\n                continue;\r\n            }\r\n            seen.add(ExtensionIdentifier.toKey(formatter.extensionId));\r\n        }\r\n        result.push({\r\n            displayName: formatter.displayName,\r\n            extensionId: formatter.extensionId,\r\n            provideDocumentFormattingEdits(model, options, token) {\r\n                return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\r\n            }\r\n        });\r\n    }\r\n    return result;\r\n}\r\nexport class FormattingConflicts {\r\n    static setFormatterSelector(selector) {\r\n        const remove = FormattingConflicts._selectors.unshift(selector);\r\n        return { dispose: remove };\r\n    }\r\n    static select(formatter, document, mode) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (formatter.length === 0) {\r\n                return undefined;\r\n            }\r\n            const selector = Iterable.first(FormattingConflicts._selectors);\r\n            if (selector) {\r\n                return yield selector(formatter, document, mode);\r\n            }\r\n            return undefined;\r\n        });\r\n    }\r\n}\r\nFormattingConflicts._selectors = new LinkedList();\r\nexport function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const instaService = accessor.get(IInstantiationService);\r\n        const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\r\n        const provider = DocumentRangeFormattingEditProviderRegistry.ordered(model);\r\n        const selected = yield FormattingConflicts.select(provider, model, mode);\r\n        if (selected) {\r\n            progress.report(selected);\r\n            yield instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token);\r\n        }\r\n    });\r\n}\r\nexport function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const workerService = accessor.get(IEditorWorkerService);\r\n        let model;\r\n        let cts;\r\n        if (isCodeEditor(editorOrModel)) {\r\n            model = editorOrModel.getModel();\r\n            cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* Value */ | 4 /* Position */, undefined, token);\r\n        }\r\n        else {\r\n            model = editorOrModel;\r\n            cts = new TextModelCancellationTokenSource(editorOrModel, token);\r\n        }\r\n        // make sure that ranges don't overlap nor touch each other\r\n        let ranges = [];\r\n        let len = 0;\r\n        for (let range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {\r\n            if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {\r\n                ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());\r\n            }\r\n            else {\r\n                len = ranges.push(range);\r\n            }\r\n        }\r\n        const allEdits = [];\r\n        for (let range of ranges) {\r\n            try {\r\n                const rawEdits = yield provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token);\r\n                const minEdits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\r\n                if (minEdits) {\r\n                    allEdits.push(...minEdits);\r\n                }\r\n                if (cts.token.isCancellationRequested) {\r\n                    return true;\r\n                }\r\n            }\r\n            finally {\r\n                cts.dispose();\r\n            }\r\n        }\r\n        if (allEdits.length === 0) {\r\n            return false;\r\n        }\r\n        if (isCodeEditor(editorOrModel)) {\r\n            // use editor to apply edits\r\n            FormattingEdit.execute(editorOrModel, allEdits, true);\r\n            alertFormattingEdits(allEdits);\r\n            editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* Immediate */);\r\n        }\r\n        else {\r\n            // use model to apply edits\r\n            const [{ range }] = allEdits;\r\n            const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\r\n            model.pushEditOperations([initialSelection], allEdits.map(edit => {\r\n                return {\r\n                    text: edit.text,\r\n                    range: Range.lift(edit.range),\r\n                    forceMoveMarkers: true\r\n                };\r\n            }), undoEdits => {\r\n                for (const { range } of undoEdits) {\r\n                    if (Range.areIntersectingOrTouching(range, initialSelection)) {\r\n                        return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\r\n                    }\r\n                }\r\n                return null;\r\n            });\r\n        }\r\n        return true;\r\n    });\r\n}\r\nexport function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const instaService = accessor.get(IInstantiationService);\r\n        const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\r\n        const provider = getRealAndSyntheticDocumentFormattersOrdered(model);\r\n        const selected = yield FormattingConflicts.select(provider, model, mode);\r\n        if (selected) {\r\n            progress.report(selected);\r\n            yield instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token);\r\n        }\r\n    });\r\n}\r\nexport function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const workerService = accessor.get(IEditorWorkerService);\r\n        let model;\r\n        let cts;\r\n        if (isCodeEditor(editorOrModel)) {\r\n            model = editorOrModel.getModel();\r\n            cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* Value */ | 4 /* Position */, undefined, token);\r\n        }\r\n        else {\r\n            model = editorOrModel;\r\n            cts = new TextModelCancellationTokenSource(editorOrModel, token);\r\n        }\r\n        let edits;\r\n        try {\r\n            const rawEdits = yield provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);\r\n            edits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\r\n            if (cts.token.isCancellationRequested) {\r\n                return true;\r\n            }\r\n        }\r\n        finally {\r\n            cts.dispose();\r\n        }\r\n        if (!edits || edits.length === 0) {\r\n            return false;\r\n        }\r\n        if (isCodeEditor(editorOrModel)) {\r\n            // use editor to apply edits\r\n            FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* Silent */);\r\n            if (mode !== 2 /* Silent */) {\r\n                alertFormattingEdits(edits);\r\n                editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* Immediate */);\r\n            }\r\n        }\r\n        else {\r\n            // use model to apply edits\r\n            const [{ range }] = edits;\r\n            const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\r\n            model.pushEditOperations([initialSelection], edits.map(edit => {\r\n                return {\r\n                    text: edit.text,\r\n                    range: Range.lift(edit.range),\r\n                    forceMoveMarkers: true\r\n                };\r\n            }), undoEdits => {\r\n                for (const { range } of undoEdits) {\r\n                    if (Range.areIntersectingOrTouching(range, initialSelection)) {\r\n                        return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\r\n                    }\r\n                }\r\n                return null;\r\n            });\r\n        }\r\n        return true;\r\n    });\r\n}\r\nexport function getDocumentRangeFormattingEditsUntilResult(workerService, model, range, options, token) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const providers = DocumentRangeFormattingEditProviderRegistry.ordered(model);\r\n        for (const provider of providers) {\r\n            let rawEdits = yield Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\r\n            if (isNonEmptyArray(rawEdits)) {\r\n                return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\r\n            }\r\n        }\r\n        return undefined;\r\n    });\r\n}\r\nexport function getDocumentFormattingEditsUntilResult(workerService, model, options, token) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const providers = getRealAndSyntheticDocumentFormattersOrdered(model);\r\n        for (const provider of providers) {\r\n            let rawEdits = yield Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\r\n            if (isNonEmptyArray(rawEdits)) {\r\n                return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\r\n            }\r\n        }\r\n        return undefined;\r\n    });\r\n}\r\nexport function getOnTypeFormattingEdits(workerService, model, position, ch, options) {\r\n    const providers = OnTypeFormattingEditProviderRegistry.ordered(model);\r\n    if (providers.length === 0) {\r\n        return Promise.resolve(undefined);\r\n    }\r\n    if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\r\n        return Promise.resolve(undefined);\r\n    }\r\n    return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, CancellationToken.None)).catch(onUnexpectedExternalError).then(edits => {\r\n        return workerService.computeMoreMinimalEdits(model.uri, edits);\r\n    });\r\n}\r\nCommandsRegistry.registerCommand('_executeFormatRangeProvider', function (accessor, ...args) {\r\n    const [resource, range, options] = args;\r\n    assertType(URI.isUri(resource));\r\n    assertType(Range.isIRange(range));\r\n    const model = accessor.get(IModelService).getModel(resource);\r\n    if (!model) {\r\n        throw illegalArgument('resource');\r\n    }\r\n    return getDocumentRangeFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, Range.lift(range), options, CancellationToken.None);\r\n});\r\nCommandsRegistry.registerCommand('_executeFormatDocumentProvider', function (accessor, ...args) {\r\n    const [resource, options] = args;\r\n    assertType(URI.isUri(resource));\r\n    const model = accessor.get(IModelService).getModel(resource);\r\n    if (!model) {\r\n        throw illegalArgument('resource');\r\n    }\r\n    return getDocumentFormattingEditsUntilResult(accessor.get(IEditorWorkerService), model, options, CancellationToken.None);\r\n});\r\nCommandsRegistry.registerCommand('_executeFormatOnTypeProvider', function (accessor, ...args) {\r\n    const [resource, position, ch, options] = args;\r\n    assertType(URI.isUri(resource));\r\n    assertType(Position.isIPosition(position));\r\n    assertType(typeof ch === 'string');\r\n    const model = accessor.get(IModelService).getModel(resource);\r\n    if (!model) {\r\n        throw illegalArgument('resource');\r\n    }\r\n    return getOnTypeFormattingEdits(accessor.get(IEditorWorkerService), model, Position.lift(position), ch, options);\r\n});\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}