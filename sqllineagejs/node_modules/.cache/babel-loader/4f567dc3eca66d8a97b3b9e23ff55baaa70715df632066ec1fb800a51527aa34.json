{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nexport class StringDiffSequence {\n  constructor(source) {\n    this.source = source;\n  }\n  getElements() {\n    const source = this.source;\n    const characters = new Int32Array(source.length);\n    for (let i = 0, len = source.length; i < len; i++) {\n      characters[i] = source.charCodeAt(i);\n    }\n    return characters;\n  }\n}\nexport function stringDiff(original, modified, pretty) {\n  return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\n//\n// The code below has been ported from a C# implementation in VS\n//\nexport class Debug {\n  static Assert(condition, message) {\n    if (!condition) {\n      throw new Error(message);\n    }\n  }\n}\nexport class MyArray {\n  /**\r\n   * Copies a range of elements from an Array starting at the specified source index and pastes\r\n   * them to another Array starting at the specified destination index. The length and the indexes\r\n   * are specified as 64-bit integers.\r\n   * sourceArray:\r\n   *\t\tThe Array that contains the data to copy.\r\n   * sourceIndex:\r\n   *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\r\n   * destinationArray:\r\n   *\t\tThe Array that receives the data.\r\n   * destinationIndex:\r\n   *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\r\n   * length:\r\n   *\t\tA 64-bit integer that represents the number of elements to copy.\r\n   */\n  static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n    for (let i = 0; i < length; i++) {\n      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n    }\n  }\n  static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n    for (let i = 0; i < length; i++) {\n      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n    }\n  }\n}\n/**\r\n * A utility class which helps to create the set of DiffChanges from\r\n * a difference operation. This class accepts original DiffElements and\r\n * modified DiffElements that are involved in a particular change. The\r\n * MarktNextChange() method can be called to mark the separation between\r\n * distinct changes. At the end, the Changes property can be called to retrieve\r\n * the constructed changes.\r\n */\nclass DiffChangeHelper {\n  /**\r\n   * Constructs a new DiffChangeHelper for the given DiffSequences.\r\n   */\n  constructor() {\n    this.m_changes = [];\n    this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n    this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n    this.m_originalCount = 0;\n    this.m_modifiedCount = 0;\n  }\n  /**\r\n   * Marks the beginning of the next change in the set of differences.\r\n   */\n  MarkNextChange() {\n    // Only add to the list if there is something to add\n    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n      // Add the new change to our list\n      this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n    }\n    // Reset for the next change\n    this.m_originalCount = 0;\n    this.m_modifiedCount = 0;\n    this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n    this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n  }\n  /**\r\n   * Adds the original element at the given position to the elements\r\n   * affected by the current change. The modified index gives context\r\n   * to the change position with respect to the original sequence.\r\n   * @param originalIndex The index of the original element to add.\r\n   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\r\n   */\n  AddOriginalElement(originalIndex, modifiedIndex) {\n    // The 'true' start index is the smallest of the ones we've seen\n    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n    this.m_originalCount++;\n  }\n  /**\r\n   * Adds the modified element at the given position to the elements\r\n   * affected by the current change. The original index gives context\r\n   * to the change position with respect to the modified sequence.\r\n   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\r\n   * @param modifiedIndex The index of the modified element to add.\r\n   */\n  AddModifiedElement(originalIndex, modifiedIndex) {\n    // The 'true' start index is the smallest of the ones we've seen\n    this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n    this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n    this.m_modifiedCount++;\n  }\n  /**\r\n   * Retrieves all of the changes marked by the class.\r\n   */\n  getChanges() {\n    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n      // Finish up on whatever is left\n      this.MarkNextChange();\n    }\n    return this.m_changes;\n  }\n  /**\r\n   * Retrieves all of the changes marked by the class in the reverse order\r\n   */\n  getReverseChanges() {\n    if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n      // Finish up on whatever is left\n      this.MarkNextChange();\n    }\n    this.m_changes.reverse();\n    return this.m_changes;\n  }\n}\n/**\r\n * An implementation of the difference algorithm described in\r\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\r\n */\nexport class LcsDiff {\n  /**\r\n   * Constructs the DiffFinder\r\n   */\n  constructor(originalSequence, modifiedSequence) {\n    let continueProcessingPredicate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    this.ContinueProcessingPredicate = continueProcessingPredicate;\n    const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n    const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n    this._hasStrings = originalHasStrings && modifiedHasStrings;\n    this._originalStringElements = originalStringElements;\n    this._originalElementsOrHash = originalElementsOrHash;\n    this._modifiedStringElements = modifiedStringElements;\n    this._modifiedElementsOrHash = modifiedElementsOrHash;\n    this.m_forwardHistory = [];\n    this.m_reverseHistory = [];\n  }\n  static _isStringArray(arr) {\n    return arr.length > 0 && typeof arr[0] === 'string';\n  }\n  static _getElements(sequence) {\n    const elements = sequence.getElements();\n    if (LcsDiff._isStringArray(elements)) {\n      const hashes = new Int32Array(elements.length);\n      for (let i = 0, len = elements.length; i < len; i++) {\n        hashes[i] = stringHash(elements[i], 0);\n      }\n      return [elements, hashes, true];\n    }\n    if (elements instanceof Int32Array) {\n      return [[], elements, false];\n    }\n    return [[], new Int32Array(elements), false];\n  }\n  ElementsAreEqual(originalIndex, newIndex) {\n    if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n      return false;\n    }\n    return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;\n  }\n  OriginalElementsAreEqual(index1, index2) {\n    if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n      return false;\n    }\n    return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;\n  }\n  ModifiedElementsAreEqual(index1, index2) {\n    if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n      return false;\n    }\n    return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;\n  }\n  ComputeDiff(pretty) {\n    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n  }\n  /**\r\n   * Computes the differences between the original and modified input\r\n   * sequences on the bounded range.\r\n   * @returns An array of the differences between the two input sequences.\r\n   */\n  _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n    const quitEarlyArr = [false];\n    let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n    if (pretty) {\n      // We have to clean up the computed diff to be more intuitive\n      // but it turns out this cannot be done correctly until the entire set\n      // of diffs have been computed\n      changes = this.PrettifyChanges(changes);\n    }\n    return {\n      quitEarly: quitEarlyArr[0],\n      changes: changes\n    };\n  }\n  /**\r\n   * Private helper method which computes the differences on the bounded range\r\n   * recursively.\r\n   * @returns An array of the differences between the two input sequences.\r\n   */\n  ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n    quitEarlyArr[0] = false;\n    // Find the start of the differences\n    while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n      originalStart++;\n      modifiedStart++;\n    }\n    // Find the end of the differences\n    while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n      originalEnd--;\n      modifiedEnd--;\n    }\n    // In the special case where we either have all insertions or all deletions or the sequences are identical\n    if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n      let changes;\n      if (modifiedStart <= modifiedEnd) {\n        Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n        // All insertions\n        changes = [new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)];\n      } else if (originalStart <= originalEnd) {\n        Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n        // All deletions\n        changes = [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)];\n      } else {\n        Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n        Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n        // Identical sequences - No differences\n        changes = [];\n      }\n      return changes;\n    }\n    // This problem can be solved using the Divide-And-Conquer technique.\n    const midOriginalArr = [0];\n    const midModifiedArr = [0];\n    const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n    const midOriginal = midOriginalArr[0];\n    const midModified = midModifiedArr[0];\n    if (result !== null) {\n      // Result is not-null when there was enough memory to compute the changes while\n      // searching for the recursion point\n      return result;\n    } else if (!quitEarlyArr[0]) {\n      // We can break the problem down recursively by finding the changes in the\n      // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n      // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n      // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n      const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n      let rightChanges = [];\n      if (!quitEarlyArr[0]) {\n        rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n      } else {\n        // We did't have time to finish the first half, so we don't have time to compute this half.\n        // Consider the entire rest of the sequence different.\n        rightChanges = [new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)];\n      }\n      return this.ConcatenateChanges(leftChanges, rightChanges);\n    }\n    // If we hit here, we quit early, and so can't return anything meaningful\n    return [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];\n  }\n  WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n    let forwardChanges = null;\n    let reverseChanges = null;\n    // First, walk backward through the forward diagonals history\n    let changeHelper = new DiffChangeHelper();\n    let diagonalMin = diagonalForwardStart;\n    let diagonalMax = diagonalForwardEnd;\n    let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;\n    let lastOriginalIndex = -1073741824 /* MIN_SAFE_SMALL_INTEGER */;\n    let historyIndex = this.m_forwardHistory.length - 1;\n    do {\n      // Get the diagonal index from the relative diagonal number\n      const diagonal = diagonalRelative + diagonalForwardBase;\n      // Figure out where we came from\n      if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {\n        // Vertical line (the element is an insert)\n        originalIndex = forwardPoints[diagonal + 1];\n        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n        if (originalIndex < lastOriginalIndex) {\n          changeHelper.MarkNextChange();\n        }\n        lastOriginalIndex = originalIndex;\n        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n        diagonalRelative = diagonal + 1 - diagonalForwardBase; //Setup for the next iteration\n      } else {\n        // Horizontal line (the element is a deletion)\n        originalIndex = forwardPoints[diagonal - 1] + 1;\n        modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n        if (originalIndex < lastOriginalIndex) {\n          changeHelper.MarkNextChange();\n        }\n        lastOriginalIndex = originalIndex - 1;\n        changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n        diagonalRelative = diagonal - 1 - diagonalForwardBase; //Setup for the next iteration\n      }\n\n      if (historyIndex >= 0) {\n        forwardPoints = this.m_forwardHistory[historyIndex];\n        diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n        diagonalMin = 1;\n        diagonalMax = forwardPoints.length - 1;\n      }\n    } while (--historyIndex >= -1);\n    // Ironically, we get the forward changes as the reverse of the\n    // order we added them since we technically added them backwards\n    forwardChanges = changeHelper.getReverseChanges();\n    if (quitEarlyArr[0]) {\n      // TODO: Calculate a partial from the reverse diagonals.\n      //       For now, just assume everything after the midOriginal/midModified point is a diff\n      let originalStartPoint = midOriginalArr[0] + 1;\n      let modifiedStartPoint = midModifiedArr[0] + 1;\n      if (forwardChanges !== null && forwardChanges.length > 0) {\n        const lastForwardChange = forwardChanges[forwardChanges.length - 1];\n        originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n        modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n      }\n      reverseChanges = [new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)];\n    } else {\n      // Now walk backward through the reverse diagonals history\n      changeHelper = new DiffChangeHelper();\n      diagonalMin = diagonalReverseStart;\n      diagonalMax = diagonalReverseEnd;\n      diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;\n      lastOriginalIndex = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n      historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n      do {\n        // Get the diagonal index from the relative diagonal number\n        const diagonal = diagonalRelative + diagonalReverseBase;\n        // Figure out where we came from\n        if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {\n          // Horizontal line (the element is a deletion))\n          originalIndex = reversePoints[diagonal + 1] - 1;\n          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n          if (originalIndex > lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n          lastOriginalIndex = originalIndex + 1;\n          changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n          diagonalRelative = diagonal + 1 - diagonalReverseBase; //Setup for the next iteration\n        } else {\n          // Vertical line (the element is an insertion)\n          originalIndex = reversePoints[diagonal - 1];\n          modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n          if (originalIndex > lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n          lastOriginalIndex = originalIndex;\n          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n          diagonalRelative = diagonal - 1 - diagonalReverseBase; //Setup for the next iteration\n        }\n\n        if (historyIndex >= 0) {\n          reversePoints = this.m_reverseHistory[historyIndex];\n          diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n          diagonalMin = 1;\n          diagonalMax = reversePoints.length - 1;\n        }\n      } while (--historyIndex >= -1);\n      // There are cases where the reverse history will find diffs that\n      // are correct, but not intuitive, so we need shift them.\n      reverseChanges = changeHelper.getChanges();\n    }\n    return this.ConcatenateChanges(forwardChanges, reverseChanges);\n  }\n  /**\r\n   * Given the range to compute the diff on, this method finds the point:\r\n   * (midOriginal, midModified)\r\n   * that exists in the middle of the LCS of the two sequences and\r\n   * is the point at which the LCS problem may be broken down recursively.\r\n   * This method will try to keep the LCS trace in memory. If the LCS recursion\r\n   * point is calculated and the full trace is available in memory, then this method\r\n   * will return the change list.\r\n   * @param originalStart The start bound of the original sequence range\r\n   * @param originalEnd The end bound of the original sequence range\r\n   * @param modifiedStart The start bound of the modified sequence range\r\n   * @param modifiedEnd The end bound of the modified sequence range\r\n   * @param midOriginal The middle point of the original sequence range\r\n   * @param midModified The middle point of the modified sequence range\r\n   * @returns The diff changes, if available, otherwise null\r\n   */\n  ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n    let originalIndex = 0,\n      modifiedIndex = 0;\n    let diagonalForwardStart = 0,\n      diagonalForwardEnd = 0;\n    let diagonalReverseStart = 0,\n      diagonalReverseEnd = 0;\n    // To traverse the edit graph and produce the proper LCS, our actual\n    // start position is just outside the given boundary\n    originalStart--;\n    modifiedStart--;\n    // We set these up to make the compiler happy, but they will\n    // be replaced before we return with the actual recursion point\n    midOriginalArr[0] = 0;\n    midModifiedArr[0] = 0;\n    // Clear out the history\n    this.m_forwardHistory = [];\n    this.m_reverseHistory = [];\n    // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n    // The integer value in the cell represents the originalIndex of the furthest\n    // reaching point found so far that ends in that diagonal.\n    // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n    const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);\n    const numDiagonals = maxDifferences + 1;\n    const forwardPoints = new Int32Array(numDiagonals);\n    const reversePoints = new Int32Array(numDiagonals);\n    // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n    // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n    const diagonalForwardBase = modifiedEnd - modifiedStart;\n    const diagonalReverseBase = originalEnd - originalStart;\n    // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n    //    diagonal number (relative to diagonalForwardBase)\n    // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n    //    diagonal number (relative to diagonalReverseBase)\n    const diagonalForwardOffset = originalStart - modifiedStart;\n    const diagonalReverseOffset = originalEnd - modifiedEnd;\n    // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n    //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n    // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n    const delta = diagonalReverseBase - diagonalForwardBase;\n    const deltaIsEven = delta % 2 === 0;\n    // Here we set up the start and end points as the furthest points found so far\n    // in both the forward and reverse directions, respectively\n    forwardPoints[diagonalForwardBase] = originalStart;\n    reversePoints[diagonalReverseBase] = originalEnd;\n    // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n    quitEarlyArr[0] = false;\n    // A couple of points:\n    // --With this method, we iterate on the number of differences between the two sequences.\n    //   The more differences there actually are, the longer this will take.\n    // --Also, as the number of differences increases, we have to search on diagonals further\n    //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n    // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n    //   is even and odd diagonals only when numDifferences is odd.\n    for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {\n      let furthestOriginalIndex = 0;\n      let furthestModifiedIndex = 0;\n      // Run the algorithm in the forward direction\n      diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n      diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n      for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n        // STEP 1: We extend the furthest reaching point in the present diagonal\n        // by looking at the diagonals above and below and picking the one whose point\n        // is further away from the start point (originalStart, modifiedStart)\n        if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {\n          originalIndex = forwardPoints[diagonal + 1];\n        } else {\n          originalIndex = forwardPoints[diagonal - 1] + 1;\n        }\n        modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n        // Save the current originalIndex so we can test for false overlap in step 3\n        const tempOriginalIndex = originalIndex;\n        // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n        // so long as the elements are equal.\n        while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n          originalIndex++;\n          modifiedIndex++;\n        }\n        forwardPoints[diagonal] = originalIndex;\n        if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n          furthestOriginalIndex = originalIndex;\n          furthestModifiedIndex = modifiedIndex;\n        }\n        // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n        // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n        // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n        // then check for overlap.\n        if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {\n          if (originalIndex >= reversePoints[diagonal]) {\n            midOriginalArr[0] = originalIndex;\n            midModifiedArr[0] = modifiedIndex;\n            if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= 1447 /* MaxDifferencesHistory */ + 1) {\n              // BINGO! We overlapped, and we have the full trace in memory!\n              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n            } else {\n              // Either false overlap, or we didn't have enough memory for the full trace\n              // Just return the recursion point\n              return null;\n            }\n          }\n        }\n      }\n      // Check to see if we should be quitting early, before moving on to the next iteration.\n      const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n        // We can't finish, so skip ahead to generating a result from what we have.\n        quitEarlyArr[0] = true;\n        // Use the furthest distance we got in the forward direction.\n        midOriginalArr[0] = furthestOriginalIndex;\n        midModifiedArr[0] = furthestModifiedIndex;\n        if (matchLengthOfLongest > 0 && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= 1447 /* MaxDifferencesHistory */ + 1) {\n          // Enough of the history is in memory to walk it backwards\n          return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n        } else {\n          // We didn't actually remember enough of the history.\n          //Since we are quiting the diff early, we need to shift back the originalStart and modified start\n          //back into the boundary limits since we decremented their value above beyond the boundary limit.\n          originalStart++;\n          modifiedStart++;\n          return [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];\n        }\n      }\n      // Run the algorithm in the reverse direction\n      diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n      diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n      for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n        // STEP 1: We extend the furthest reaching point in the present diagonal\n        // by looking at the diagonals above and below and picking the one whose point\n        // is further away from the start point (originalEnd, modifiedEnd)\n        if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {\n          originalIndex = reversePoints[diagonal + 1] - 1;\n        } else {\n          originalIndex = reversePoints[diagonal - 1];\n        }\n        modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n        // Save the current originalIndex so we can test for false overlap\n        const tempOriginalIndex = originalIndex;\n        // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n        // as long as the elements are equal.\n        while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n          originalIndex--;\n          modifiedIndex--;\n        }\n        reversePoints[diagonal] = originalIndex;\n        // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n        // and diagonal is in the range of forward diagonals computed for numDifferences\n        // then check for overlap.\n        if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n          if (originalIndex <= forwardPoints[diagonal]) {\n            midOriginalArr[0] = originalIndex;\n            midModifiedArr[0] = modifiedIndex;\n            if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= 1447 /* MaxDifferencesHistory */ + 1) {\n              // BINGO! We overlapped, and we have the full trace in memory!\n              return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n            } else {\n              // Either false overlap, or we didn't have enough memory for the full trace\n              // Just return the recursion point\n              return null;\n            }\n          }\n        }\n      }\n      // Save current vectors to history before the next iteration\n      if (numDifferences <= 1447 /* MaxDifferencesHistory */) {\n        // We are allocating space for one extra int, which we fill with\n        // the index of the diagonal base index\n        let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n        temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n        MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n        this.m_forwardHistory.push(temp);\n        temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n        temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n        MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n        this.m_reverseHistory.push(temp);\n      }\n    }\n    // If we got here, then we have the full trace in history. We just have to convert it to a change list\n    // NOTE: This part is a bit messy\n    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n  }\n  /**\r\n   * Shifts the given changes to provide a more intuitive diff.\r\n   * While the first element in a diff matches the first element after the diff,\r\n   * we shift the diff down.\r\n   *\r\n   * @param changes The list of changes to shift\r\n   * @returns The shifted changes\r\n   */\n  PrettifyChanges(changes) {\n    // Shift all the changes down first\n    for (let i = 0; i < changes.length; i++) {\n      const change = changes[i];\n      const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n      const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n      const checkOriginal = change.originalLength > 0;\n      const checkModified = change.modifiedLength > 0;\n      while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n        change.originalStart++;\n        change.modifiedStart++;\n      }\n      let mergedChangeArr = [null];\n      if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n        changes[i] = mergedChangeArr[0];\n        changes.splice(i + 1, 1);\n        i--;\n        continue;\n      }\n    }\n    // Shift changes back up until we hit empty or whitespace-only lines\n    for (let i = changes.length - 1; i >= 0; i--) {\n      const change = changes[i];\n      let originalStop = 0;\n      let modifiedStop = 0;\n      if (i > 0) {\n        const prevChange = changes[i - 1];\n        if (prevChange.originalLength > 0) {\n          originalStop = prevChange.originalStart + prevChange.originalLength;\n        }\n        if (prevChange.modifiedLength > 0) {\n          modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n        }\n      }\n      const checkOriginal = change.originalLength > 0;\n      const checkModified = change.modifiedLength > 0;\n      let bestDelta = 0;\n      let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n      for (let delta = 1;; delta++) {\n        const originalStart = change.originalStart - delta;\n        const modifiedStart = change.modifiedStart - delta;\n        if (originalStart < originalStop || modifiedStart < modifiedStop) {\n          break;\n        }\n        if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n          break;\n        }\n        if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n          break;\n        }\n        const score = this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);\n        if (score > bestScore) {\n          bestScore = score;\n          bestDelta = delta;\n        }\n      }\n      change.originalStart -= bestDelta;\n      change.modifiedStart -= bestDelta;\n    }\n    // There could be multiple longest common substrings.\n    // Give preference to the ones containing longer lines\n    if (this._hasStrings) {\n      for (let i = 1, len = changes.length; i < len; i++) {\n        const aChange = changes[i - 1];\n        const bChange = changes[i];\n        const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n        const aOriginalStart = aChange.originalStart;\n        const bOriginalEnd = bChange.originalStart + bChange.originalLength;\n        const abOriginalLength = bOriginalEnd - aOriginalStart;\n        const aModifiedStart = aChange.modifiedStart;\n        const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n        const abModifiedLength = bModifiedEnd - aModifiedStart;\n        // Avoid wasting a lot of time with these searches\n        if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n          const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n          if (t) {\n            const [originalMatchStart, modifiedMatchStart] = t;\n            if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n              // switch to another sequence that has a better score\n              aChange.originalLength = originalMatchStart - aChange.originalStart;\n              aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n              bChange.originalStart = originalMatchStart + matchedLength;\n              bChange.modifiedStart = modifiedMatchStart + matchedLength;\n              bChange.originalLength = bOriginalEnd - bChange.originalStart;\n              bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n            }\n          }\n        }\n      }\n    }\n    return changes;\n  }\n  _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n    if (originalLength < desiredLength || modifiedLength < desiredLength) {\n      return null;\n    }\n    const originalMax = originalStart + originalLength - desiredLength + 1;\n    const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n    let bestScore = 0;\n    let bestOriginalStart = 0;\n    let bestModifiedStart = 0;\n    for (let i = originalStart; i < originalMax; i++) {\n      for (let j = modifiedStart; j < modifiedMax; j++) {\n        const score = this._contiguousSequenceScore(i, j, desiredLength);\n        if (score > 0 && score > bestScore) {\n          bestScore = score;\n          bestOriginalStart = i;\n          bestModifiedStart = j;\n        }\n      }\n    }\n    if (bestScore > 0) {\n      return [bestOriginalStart, bestModifiedStart];\n    }\n    return null;\n  }\n  _contiguousSequenceScore(originalStart, modifiedStart, length) {\n    let score = 0;\n    for (let l = 0; l < length; l++) {\n      if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n        return 0;\n      }\n      score += this._originalStringElements[originalStart + l].length;\n    }\n    return score;\n  }\n  _OriginalIsBoundary(index) {\n    if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n      return true;\n    }\n    return this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]);\n  }\n  _OriginalRegionIsBoundary(originalStart, originalLength) {\n    if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n      return true;\n    }\n    if (originalLength > 0) {\n      const originalEnd = originalStart + originalLength;\n      if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _ModifiedIsBoundary(index) {\n    if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n      return true;\n    }\n    return this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]);\n  }\n  _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n    if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n      return true;\n    }\n    if (modifiedLength > 0) {\n      const modifiedEnd = modifiedStart + modifiedLength;\n      if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n    const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;\n    const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;\n    return originalScore + modifiedScore;\n  }\n  /**\r\n   * Concatenates the two input DiffChange lists and returns the resulting\r\n   * list.\r\n   * @param The left changes\r\n   * @param The right changes\r\n   * @returns The concatenated list\r\n   */\n  ConcatenateChanges(left, right) {\n    let mergedChangeArr = [];\n    if (left.length === 0 || right.length === 0) {\n      return right.length > 0 ? right : left;\n    } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n      // Since we break the problem down recursively, it is possible that we\n      // might recurse in the middle of a change thereby splitting it into\n      // two changes. Here in the combining stage, we detect and fuse those\n      // changes back together\n      const result = new Array(left.length + right.length - 1);\n      MyArray.Copy(left, 0, result, 0, left.length - 1);\n      result[left.length - 1] = mergedChangeArr[0];\n      MyArray.Copy(right, 1, result, left.length, right.length - 1);\n      return result;\n    } else {\n      const result = new Array(left.length + right.length);\n      MyArray.Copy(left, 0, result, 0, left.length);\n      MyArray.Copy(right, 0, result, left.length, right.length);\n      return result;\n    }\n  }\n  /**\r\n   * Returns true if the two changes overlap and can be merged into a single\r\n   * change\r\n   * @param left The left change\r\n   * @param right The right change\r\n   * @param mergedChange The merged change if the two overlap, null otherwise\r\n   * @returns True if the two changes overlap\r\n   */\n  ChangesOverlap(left, right, mergedChangeArr) {\n    Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n    Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n    if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n      const originalStart = left.originalStart;\n      let originalLength = left.originalLength;\n      const modifiedStart = left.modifiedStart;\n      let modifiedLength = left.modifiedLength;\n      if (left.originalStart + left.originalLength >= right.originalStart) {\n        originalLength = right.originalStart + right.originalLength - left.originalStart;\n      }\n      if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n        modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n      }\n      mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n      return true;\n    } else {\n      mergedChangeArr[0] = null;\n      return false;\n    }\n  }\n  /**\r\n   * Helper method used to clip a diagonal index to the range of valid\r\n   * diagonals. This also decides whether or not the diagonal index,\r\n   * if it exceeds the boundary, should be clipped to the boundary or clipped\r\n   * one inside the boundary depending on the Even/Odd status of the boundary\r\n   * and numDifferences.\r\n   * @param diagonal The index of the diagonal to clip.\r\n   * @param numDifferences The current number of differences being iterated upon.\r\n   * @param diagonalBaseIndex The base reference diagonal.\r\n   * @param numDiagonals The total number of diagonals.\r\n   * @returns The clipped diagonal index.\r\n   */\n  ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n    if (diagonal >= 0 && diagonal < numDiagonals) {\n      // Nothing to clip, its in range\n      return diagonal;\n    }\n    // diagonalsBelow: The number of diagonals below the reference diagonal\n    // diagonalsAbove: The number of diagonals above the reference diagonal\n    const diagonalsBelow = diagonalBaseIndex;\n    const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n    const diffEven = numDifferences % 2 === 0;\n    if (diagonal < 0) {\n      const lowerBoundEven = diagonalsBelow % 2 === 0;\n      return diffEven === lowerBoundEven ? 0 : 1;\n    } else {\n      const upperBoundEven = diagonalsAbove % 2 === 0;\n      return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;\n    }\n  }\n}","map":{"version":3,"names":["DiffChange","stringHash","StringDiffSequence","constructor","source","getElements","characters","Int32Array","length","i","len","charCodeAt","stringDiff","original","modified","pretty","LcsDiff","ComputeDiff","changes","Debug","Assert","condition","message","Error","MyArray","Copy","sourceArray","sourceIndex","destinationArray","destinationIndex","Copy2","DiffChangeHelper","m_changes","m_originalStart","m_modifiedStart","m_originalCount","m_modifiedCount","MarkNextChange","push","AddOriginalElement","originalIndex","modifiedIndex","Math","min","AddModifiedElement","getChanges","getReverseChanges","reverse","originalSequence","modifiedSequence","continueProcessingPredicate","arguments","undefined","ContinueProcessingPredicate","originalStringElements","originalElementsOrHash","originalHasStrings","_getElements","modifiedStringElements","modifiedElementsOrHash","modifiedHasStrings","_hasStrings","_originalStringElements","_originalElementsOrHash","_modifiedStringElements","_modifiedElementsOrHash","m_forwardHistory","m_reverseHistory","_isStringArray","arr","sequence","elements","hashes","ElementsAreEqual","newIndex","OriginalElementsAreEqual","index1","index2","ModifiedElementsAreEqual","_ComputeDiff","originalStart","originalEnd","modifiedStart","modifiedEnd","quitEarlyArr","ComputeDiffRecursive","PrettifyChanges","quitEarly","midOriginalArr","midModifiedArr","result","ComputeRecursionPoint","midOriginal","midModified","leftChanges","rightChanges","ConcatenateChanges","WALKTRACE","diagonalForwardBase","diagonalForwardStart","diagonalForwardEnd","diagonalForwardOffset","diagonalReverseBase","diagonalReverseStart","diagonalReverseEnd","diagonalReverseOffset","forwardPoints","reversePoints","deltaIsEven","forwardChanges","reverseChanges","changeHelper","diagonalMin","diagonalMax","diagonalRelative","lastOriginalIndex","historyIndex","diagonal","originalStartPoint","modifiedStartPoint","lastForwardChange","max","getOriginalEnd","getModifiedEnd","maxDifferences","numDiagonals","delta","numDifferences","furthestOriginalIndex","furthestModifiedIndex","ClipDiagonalBound","tempOriginalIndex","abs","matchLengthOfLongest","temp","change","originalStop","modifiedStop","checkOriginal","originalLength","checkModified","modifiedLength","mergedChangeArr","ChangesOverlap","splice","prevChange","bestDelta","bestScore","_boundaryScore","score","aChange","bChange","matchedLength","aOriginalStart","bOriginalEnd","abOriginalLength","aModifiedStart","bModifiedEnd","abModifiedLength","t","_findBetterContiguousSequence","originalMatchStart","modifiedMatchStart","desiredLength","originalMax","modifiedMax","bestOriginalStart","bestModifiedStart","j","_contiguousSequenceScore","l","_OriginalIsBoundary","index","test","_OriginalRegionIsBoundary","_ModifiedIsBoundary","_ModifiedRegionIsBoundary","originalScore","modifiedScore","left","right","Array","diagonalBaseIndex","diagonalsBelow","diagonalsAbove","diffEven","lowerBoundEven","upperBoundEven"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { DiffChange } from './diffChange.js';\r\nimport { stringHash } from '../hash.js';\r\nexport class StringDiffSequence {\r\n    constructor(source) {\r\n        this.source = source;\r\n    }\r\n    getElements() {\r\n        const source = this.source;\r\n        const characters = new Int32Array(source.length);\r\n        for (let i = 0, len = source.length; i < len; i++) {\r\n            characters[i] = source.charCodeAt(i);\r\n        }\r\n        return characters;\r\n    }\r\n}\r\nexport function stringDiff(original, modified, pretty) {\r\n    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\r\n}\r\n//\r\n// The code below has been ported from a C# implementation in VS\r\n//\r\nexport class Debug {\r\n    static Assert(condition, message) {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n}\r\nexport class MyArray {\r\n    /**\r\n     * Copies a range of elements from an Array starting at the specified source index and pastes\r\n     * them to another Array starting at the specified destination index. The length and the indexes\r\n     * are specified as 64-bit integers.\r\n     * sourceArray:\r\n     *\t\tThe Array that contains the data to copy.\r\n     * sourceIndex:\r\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\r\n     * destinationArray:\r\n     *\t\tThe Array that receives the data.\r\n     * destinationIndex:\r\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\r\n     * length:\r\n     *\t\tA 64-bit integer that represents the number of elements to copy.\r\n     */\r\n    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\r\n        for (let i = 0; i < length; i++) {\r\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\r\n        }\r\n    }\r\n    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\r\n        for (let i = 0; i < length; i++) {\r\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\r\n        }\r\n    }\r\n}\r\n/**\r\n * A utility class which helps to create the set of DiffChanges from\r\n * a difference operation. This class accepts original DiffElements and\r\n * modified DiffElements that are involved in a particular change. The\r\n * MarktNextChange() method can be called to mark the separation between\r\n * distinct changes. At the end, the Changes property can be called to retrieve\r\n * the constructed changes.\r\n */\r\nclass DiffChangeHelper {\r\n    /**\r\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\r\n     */\r\n    constructor() {\r\n        this.m_changes = [];\r\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        this.m_originalCount = 0;\r\n        this.m_modifiedCount = 0;\r\n    }\r\n    /**\r\n     * Marks the beginning of the next change in the set of differences.\r\n     */\r\n    MarkNextChange() {\r\n        // Only add to the list if there is something to add\r\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n            // Add the new change to our list\r\n            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\r\n        }\r\n        // Reset for the next change\r\n        this.m_originalCount = 0;\r\n        this.m_modifiedCount = 0;\r\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n    }\r\n    /**\r\n     * Adds the original element at the given position to the elements\r\n     * affected by the current change. The modified index gives context\r\n     * to the change position with respect to the original sequence.\r\n     * @param originalIndex The index of the original element to add.\r\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\r\n     */\r\n    AddOriginalElement(originalIndex, modifiedIndex) {\r\n        // The 'true' start index is the smallest of the ones we've seen\r\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\r\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\r\n        this.m_originalCount++;\r\n    }\r\n    /**\r\n     * Adds the modified element at the given position to the elements\r\n     * affected by the current change. The original index gives context\r\n     * to the change position with respect to the modified sequence.\r\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\r\n     * @param modifiedIndex The index of the modified element to add.\r\n     */\r\n    AddModifiedElement(originalIndex, modifiedIndex) {\r\n        // The 'true' start index is the smallest of the ones we've seen\r\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\r\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\r\n        this.m_modifiedCount++;\r\n    }\r\n    /**\r\n     * Retrieves all of the changes marked by the class.\r\n     */\r\n    getChanges() {\r\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n            // Finish up on whatever is left\r\n            this.MarkNextChange();\r\n        }\r\n        return this.m_changes;\r\n    }\r\n    /**\r\n     * Retrieves all of the changes marked by the class in the reverse order\r\n     */\r\n    getReverseChanges() {\r\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n            // Finish up on whatever is left\r\n            this.MarkNextChange();\r\n        }\r\n        this.m_changes.reverse();\r\n        return this.m_changes;\r\n    }\r\n}\r\n/**\r\n * An implementation of the difference algorithm described in\r\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\r\n */\r\nexport class LcsDiff {\r\n    /**\r\n     * Constructs the DiffFinder\r\n     */\r\n    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\r\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\r\n        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\r\n        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\r\n        this._hasStrings = (originalHasStrings && modifiedHasStrings);\r\n        this._originalStringElements = originalStringElements;\r\n        this._originalElementsOrHash = originalElementsOrHash;\r\n        this._modifiedStringElements = modifiedStringElements;\r\n        this._modifiedElementsOrHash = modifiedElementsOrHash;\r\n        this.m_forwardHistory = [];\r\n        this.m_reverseHistory = [];\r\n    }\r\n    static _isStringArray(arr) {\r\n        return (arr.length > 0 && typeof arr[0] === 'string');\r\n    }\r\n    static _getElements(sequence) {\r\n        const elements = sequence.getElements();\r\n        if (LcsDiff._isStringArray(elements)) {\r\n            const hashes = new Int32Array(elements.length);\r\n            for (let i = 0, len = elements.length; i < len; i++) {\r\n                hashes[i] = stringHash(elements[i], 0);\r\n            }\r\n            return [elements, hashes, true];\r\n        }\r\n        if (elements instanceof Int32Array) {\r\n            return [[], elements, false];\r\n        }\r\n        return [[], new Int32Array(elements), false];\r\n    }\r\n    ElementsAreEqual(originalIndex, newIndex) {\r\n        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\r\n            return false;\r\n        }\r\n        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\r\n    }\r\n    OriginalElementsAreEqual(index1, index2) {\r\n        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\r\n            return false;\r\n        }\r\n        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\r\n    }\r\n    ModifiedElementsAreEqual(index1, index2) {\r\n        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\r\n            return false;\r\n        }\r\n        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\r\n    }\r\n    ComputeDiff(pretty) {\r\n        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\r\n    }\r\n    /**\r\n     * Computes the differences between the original and modified input\r\n     * sequences on the bounded range.\r\n     * @returns An array of the differences between the two input sequences.\r\n     */\r\n    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\r\n        const quitEarlyArr = [false];\r\n        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\r\n        if (pretty) {\r\n            // We have to clean up the computed diff to be more intuitive\r\n            // but it turns out this cannot be done correctly until the entire set\r\n            // of diffs have been computed\r\n            changes = this.PrettifyChanges(changes);\r\n        }\r\n        return {\r\n            quitEarly: quitEarlyArr[0],\r\n            changes: changes\r\n        };\r\n    }\r\n    /**\r\n     * Private helper method which computes the differences on the bounded range\r\n     * recursively.\r\n     * @returns An array of the differences between the two input sequences.\r\n     */\r\n    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\r\n        quitEarlyArr[0] = false;\r\n        // Find the start of the differences\r\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\r\n            originalStart++;\r\n            modifiedStart++;\r\n        }\r\n        // Find the end of the differences\r\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\r\n            originalEnd--;\r\n            modifiedEnd--;\r\n        }\r\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\r\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\r\n            let changes;\r\n            if (modifiedStart <= modifiedEnd) {\r\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\r\n                // All insertions\r\n                changes = [\r\n                    new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n                ];\r\n            }\r\n            else if (originalStart <= originalEnd) {\r\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\r\n                // All deletions\r\n                changes = [\r\n                    new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\r\n                ];\r\n            }\r\n            else {\r\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\r\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\r\n                // Identical sequences - No differences\r\n                changes = [];\r\n            }\r\n            return changes;\r\n        }\r\n        // This problem can be solved using the Divide-And-Conquer technique.\r\n        const midOriginalArr = [0];\r\n        const midModifiedArr = [0];\r\n        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\r\n        const midOriginal = midOriginalArr[0];\r\n        const midModified = midModifiedArr[0];\r\n        if (result !== null) {\r\n            // Result is not-null when there was enough memory to compute the changes while\r\n            // searching for the recursion point\r\n            return result;\r\n        }\r\n        else if (!quitEarlyArr[0]) {\r\n            // We can break the problem down recursively by finding the changes in the\r\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\r\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\r\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\r\n            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\r\n            let rightChanges = [];\r\n            if (!quitEarlyArr[0]) {\r\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\r\n            }\r\n            else {\r\n                // We did't have time to finish the first half, so we don't have time to compute this half.\r\n                // Consider the entire rest of the sequence different.\r\n                rightChanges = [\r\n                    new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\r\n                ];\r\n            }\r\n            return this.ConcatenateChanges(leftChanges, rightChanges);\r\n        }\r\n        // If we hit here, we quit early, and so can't return anything meaningful\r\n        return [\r\n            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n        ];\r\n    }\r\n    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\r\n        let forwardChanges = null;\r\n        let reverseChanges = null;\r\n        // First, walk backward through the forward diagonals history\r\n        let changeHelper = new DiffChangeHelper();\r\n        let diagonalMin = diagonalForwardStart;\r\n        let diagonalMax = diagonalForwardEnd;\r\n        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\r\n        let lastOriginalIndex = -1073741824 /* MIN_SAFE_SMALL_INTEGER */;\r\n        let historyIndex = this.m_forwardHistory.length - 1;\r\n        do {\r\n            // Get the diagonal index from the relative diagonal number\r\n            const diagonal = diagonalRelative + diagonalForwardBase;\r\n            // Figure out where we came from\r\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\r\n                // Vertical line (the element is an insert)\r\n                originalIndex = forwardPoints[diagonal + 1];\r\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\r\n                if (originalIndex < lastOriginalIndex) {\r\n                    changeHelper.MarkNextChange();\r\n                }\r\n                lastOriginalIndex = originalIndex;\r\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\r\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\r\n            }\r\n            else {\r\n                // Horizontal line (the element is a deletion)\r\n                originalIndex = forwardPoints[diagonal - 1] + 1;\r\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\r\n                if (originalIndex < lastOriginalIndex) {\r\n                    changeHelper.MarkNextChange();\r\n                }\r\n                lastOriginalIndex = originalIndex - 1;\r\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\r\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\r\n            }\r\n            if (historyIndex >= 0) {\r\n                forwardPoints = this.m_forwardHistory[historyIndex];\r\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\r\n                diagonalMin = 1;\r\n                diagonalMax = forwardPoints.length - 1;\r\n            }\r\n        } while (--historyIndex >= -1);\r\n        // Ironically, we get the forward changes as the reverse of the\r\n        // order we added them since we technically added them backwards\r\n        forwardChanges = changeHelper.getReverseChanges();\r\n        if (quitEarlyArr[0]) {\r\n            // TODO: Calculate a partial from the reverse diagonals.\r\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\r\n            let originalStartPoint = midOriginalArr[0] + 1;\r\n            let modifiedStartPoint = midModifiedArr[0] + 1;\r\n            if (forwardChanges !== null && forwardChanges.length > 0) {\r\n                const lastForwardChange = forwardChanges[forwardChanges.length - 1];\r\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\r\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\r\n            }\r\n            reverseChanges = [\r\n                new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\r\n            ];\r\n        }\r\n        else {\r\n            // Now walk backward through the reverse diagonals history\r\n            changeHelper = new DiffChangeHelper();\r\n            diagonalMin = diagonalReverseStart;\r\n            diagonalMax = diagonalReverseEnd;\r\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\r\n            lastOriginalIndex = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\r\n            do {\r\n                // Get the diagonal index from the relative diagonal number\r\n                const diagonal = diagonalRelative + diagonalReverseBase;\r\n                // Figure out where we came from\r\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\r\n                    // Horizontal line (the element is a deletion))\r\n                    originalIndex = reversePoints[diagonal + 1] - 1;\r\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\r\n                    if (originalIndex > lastOriginalIndex) {\r\n                        changeHelper.MarkNextChange();\r\n                    }\r\n                    lastOriginalIndex = originalIndex + 1;\r\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\r\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\r\n                }\r\n                else {\r\n                    // Vertical line (the element is an insertion)\r\n                    originalIndex = reversePoints[diagonal - 1];\r\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\r\n                    if (originalIndex > lastOriginalIndex) {\r\n                        changeHelper.MarkNextChange();\r\n                    }\r\n                    lastOriginalIndex = originalIndex;\r\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\r\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\r\n                }\r\n                if (historyIndex >= 0) {\r\n                    reversePoints = this.m_reverseHistory[historyIndex];\r\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\r\n                    diagonalMin = 1;\r\n                    diagonalMax = reversePoints.length - 1;\r\n                }\r\n            } while (--historyIndex >= -1);\r\n            // There are cases where the reverse history will find diffs that\r\n            // are correct, but not intuitive, so we need shift them.\r\n            reverseChanges = changeHelper.getChanges();\r\n        }\r\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\r\n    }\r\n    /**\r\n     * Given the range to compute the diff on, this method finds the point:\r\n     * (midOriginal, midModified)\r\n     * that exists in the middle of the LCS of the two sequences and\r\n     * is the point at which the LCS problem may be broken down recursively.\r\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\r\n     * point is calculated and the full trace is available in memory, then this method\r\n     * will return the change list.\r\n     * @param originalStart The start bound of the original sequence range\r\n     * @param originalEnd The end bound of the original sequence range\r\n     * @param modifiedStart The start bound of the modified sequence range\r\n     * @param modifiedEnd The end bound of the modified sequence range\r\n     * @param midOriginal The middle point of the original sequence range\r\n     * @param midModified The middle point of the modified sequence range\r\n     * @returns The diff changes, if available, otherwise null\r\n     */\r\n    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\r\n        let originalIndex = 0, modifiedIndex = 0;\r\n        let diagonalForwardStart = 0, diagonalForwardEnd = 0;\r\n        let diagonalReverseStart = 0, diagonalReverseEnd = 0;\r\n        // To traverse the edit graph and produce the proper LCS, our actual\r\n        // start position is just outside the given boundary\r\n        originalStart--;\r\n        modifiedStart--;\r\n        // We set these up to make the compiler happy, but they will\r\n        // be replaced before we return with the actual recursion point\r\n        midOriginalArr[0] = 0;\r\n        midModifiedArr[0] = 0;\r\n        // Clear out the history\r\n        this.m_forwardHistory = [];\r\n        this.m_reverseHistory = [];\r\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\r\n        // The integer value in the cell represents the originalIndex of the furthest\r\n        // reaching point found so far that ends in that diagonal.\r\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\r\n        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\r\n        const numDiagonals = maxDifferences + 1;\r\n        const forwardPoints = new Int32Array(numDiagonals);\r\n        const reversePoints = new Int32Array(numDiagonals);\r\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\r\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\r\n        const diagonalForwardBase = (modifiedEnd - modifiedStart);\r\n        const diagonalReverseBase = (originalEnd - originalStart);\r\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\r\n        //    diagonal number (relative to diagonalForwardBase)\r\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\r\n        //    diagonal number (relative to diagonalReverseBase)\r\n        const diagonalForwardOffset = (originalStart - modifiedStart);\r\n        const diagonalReverseOffset = (originalEnd - modifiedEnd);\r\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\r\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\r\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\r\n        const delta = diagonalReverseBase - diagonalForwardBase;\r\n        const deltaIsEven = (delta % 2 === 0);\r\n        // Here we set up the start and end points as the furthest points found so far\r\n        // in both the forward and reverse directions, respectively\r\n        forwardPoints[diagonalForwardBase] = originalStart;\r\n        reversePoints[diagonalReverseBase] = originalEnd;\r\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\r\n        quitEarlyArr[0] = false;\r\n        // A couple of points:\r\n        // --With this method, we iterate on the number of differences between the two sequences.\r\n        //   The more differences there actually are, the longer this will take.\r\n        // --Also, as the number of differences increases, we have to search on diagonals further\r\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\r\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\r\n        //   is even and odd diagonals only when numDifferences is odd.\r\n        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\r\n            let furthestOriginalIndex = 0;\r\n            let furthestModifiedIndex = 0;\r\n            // Run the algorithm in the forward direction\r\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\r\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\r\n            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\r\n                // STEP 1: We extend the furthest reaching point in the present diagonal\r\n                // by looking at the diagonals above and below and picking the one whose point\r\n                // is further away from the start point (originalStart, modifiedStart)\r\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\r\n                    originalIndex = forwardPoints[diagonal + 1];\r\n                }\r\n                else {\r\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\r\n                }\r\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\r\n                // Save the current originalIndex so we can test for false overlap in step 3\r\n                const tempOriginalIndex = originalIndex;\r\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\r\n                // so long as the elements are equal.\r\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\r\n                    originalIndex++;\r\n                    modifiedIndex++;\r\n                }\r\n                forwardPoints[diagonal] = originalIndex;\r\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\r\n                    furthestOriginalIndex = originalIndex;\r\n                    furthestModifiedIndex = modifiedIndex;\r\n                }\r\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\r\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\r\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\r\n                // then check for overlap.\r\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\r\n                    if (originalIndex >= reversePoints[diagonal]) {\r\n                        midOriginalArr[0] = originalIndex;\r\n                        midModifiedArr[0] = modifiedIndex;\r\n                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\r\n                            // BINGO! We overlapped, and we have the full trace in memory!\r\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                        }\r\n                        else {\r\n                            // Either false overlap, or we didn't have enough memory for the full trace\r\n                            // Just return the recursion point\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Check to see if we should be quitting early, before moving on to the next iteration.\r\n            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\r\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\r\n                // We can't finish, so skip ahead to generating a result from what we have.\r\n                quitEarlyArr[0] = true;\r\n                // Use the furthest distance we got in the forward direction.\r\n                midOriginalArr[0] = furthestOriginalIndex;\r\n                midModifiedArr[0] = furthestModifiedIndex;\r\n                if (matchLengthOfLongest > 0 && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\r\n                    // Enough of the history is in memory to walk it backwards\r\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                }\r\n                else {\r\n                    // We didn't actually remember enough of the history.\r\n                    //Since we are quiting the diff early, we need to shift back the originalStart and modified start\r\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\r\n                    originalStart++;\r\n                    modifiedStart++;\r\n                    return [\r\n                        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n                    ];\r\n                }\r\n            }\r\n            // Run the algorithm in the reverse direction\r\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\r\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\r\n            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\r\n                // STEP 1: We extend the furthest reaching point in the present diagonal\r\n                // by looking at the diagonals above and below and picking the one whose point\r\n                // is further away from the start point (originalEnd, modifiedEnd)\r\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\r\n                    originalIndex = reversePoints[diagonal + 1] - 1;\r\n                }\r\n                else {\r\n                    originalIndex = reversePoints[diagonal - 1];\r\n                }\r\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\r\n                // Save the current originalIndex so we can test for false overlap\r\n                const tempOriginalIndex = originalIndex;\r\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\r\n                // as long as the elements are equal.\r\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\r\n                    originalIndex--;\r\n                    modifiedIndex--;\r\n                }\r\n                reversePoints[diagonal] = originalIndex;\r\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\r\n                // and diagonal is in the range of forward diagonals computed for numDifferences\r\n                // then check for overlap.\r\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\r\n                    if (originalIndex <= forwardPoints[diagonal]) {\r\n                        midOriginalArr[0] = originalIndex;\r\n                        midModifiedArr[0] = modifiedIndex;\r\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\r\n                            // BINGO! We overlapped, and we have the full trace in memory!\r\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                        }\r\n                        else {\r\n                            // Either false overlap, or we didn't have enough memory for the full trace\r\n                            // Just return the recursion point\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Save current vectors to history before the next iteration\r\n            if (numDifferences <= 1447 /* MaxDifferencesHistory */) {\r\n                // We are allocating space for one extra int, which we fill with\r\n                // the index of the diagonal base index\r\n                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\r\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\r\n                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\r\n                this.m_forwardHistory.push(temp);\r\n                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\r\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\r\n                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\r\n                this.m_reverseHistory.push(temp);\r\n            }\r\n        }\r\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\r\n        // NOTE: This part is a bit messy\r\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n    }\r\n    /**\r\n     * Shifts the given changes to provide a more intuitive diff.\r\n     * While the first element in a diff matches the first element after the diff,\r\n     * we shift the diff down.\r\n     *\r\n     * @param changes The list of changes to shift\r\n     * @returns The shifted changes\r\n     */\r\n    PrettifyChanges(changes) {\r\n        // Shift all the changes down first\r\n        for (let i = 0; i < changes.length; i++) {\r\n            const change = changes[i];\r\n            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\r\n            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\r\n            const checkOriginal = change.originalLength > 0;\r\n            const checkModified = change.modifiedLength > 0;\r\n            while (change.originalStart + change.originalLength < originalStop &&\r\n                change.modifiedStart + change.modifiedLength < modifiedStop &&\r\n                (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) &&\r\n                (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\r\n                change.originalStart++;\r\n                change.modifiedStart++;\r\n            }\r\n            let mergedChangeArr = [null];\r\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\r\n                changes[i] = mergedChangeArr[0];\r\n                changes.splice(i + 1, 1);\r\n                i--;\r\n                continue;\r\n            }\r\n        }\r\n        // Shift changes back up until we hit empty or whitespace-only lines\r\n        for (let i = changes.length - 1; i >= 0; i--) {\r\n            const change = changes[i];\r\n            let originalStop = 0;\r\n            let modifiedStop = 0;\r\n            if (i > 0) {\r\n                const prevChange = changes[i - 1];\r\n                if (prevChange.originalLength > 0) {\r\n                    originalStop = prevChange.originalStart + prevChange.originalLength;\r\n                }\r\n                if (prevChange.modifiedLength > 0) {\r\n                    modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\r\n                }\r\n            }\r\n            const checkOriginal = change.originalLength > 0;\r\n            const checkModified = change.modifiedLength > 0;\r\n            let bestDelta = 0;\r\n            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\r\n            for (let delta = 1;; delta++) {\r\n                const originalStart = change.originalStart - delta;\r\n                const modifiedStart = change.modifiedStart - delta;\r\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\r\n                    break;\r\n                }\r\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\r\n                    break;\r\n                }\r\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\r\n                    break;\r\n                }\r\n                const score = this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);\r\n                if (score > bestScore) {\r\n                    bestScore = score;\r\n                    bestDelta = delta;\r\n                }\r\n            }\r\n            change.originalStart -= bestDelta;\r\n            change.modifiedStart -= bestDelta;\r\n        }\r\n        // There could be multiple longest common substrings.\r\n        // Give preference to the ones containing longer lines\r\n        if (this._hasStrings) {\r\n            for (let i = 1, len = changes.length; i < len; i++) {\r\n                const aChange = changes[i - 1];\r\n                const bChange = changes[i];\r\n                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\r\n                const aOriginalStart = aChange.originalStart;\r\n                const bOriginalEnd = bChange.originalStart + bChange.originalLength;\r\n                const abOriginalLength = bOriginalEnd - aOriginalStart;\r\n                const aModifiedStart = aChange.modifiedStart;\r\n                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\r\n                const abModifiedLength = bModifiedEnd - aModifiedStart;\r\n                // Avoid wasting a lot of time with these searches\r\n                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\r\n                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\r\n                    if (t) {\r\n                        const [originalMatchStart, modifiedMatchStart] = t;\r\n                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\r\n                            // switch to another sequence that has a better score\r\n                            aChange.originalLength = originalMatchStart - aChange.originalStart;\r\n                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\r\n                            bChange.originalStart = originalMatchStart + matchedLength;\r\n                            bChange.modifiedStart = modifiedMatchStart + matchedLength;\r\n                            bChange.originalLength = bOriginalEnd - bChange.originalStart;\r\n                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return changes;\r\n    }\r\n    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\r\n        if (originalLength < desiredLength || modifiedLength < desiredLength) {\r\n            return null;\r\n        }\r\n        const originalMax = originalStart + originalLength - desiredLength + 1;\r\n        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\r\n        let bestScore = 0;\r\n        let bestOriginalStart = 0;\r\n        let bestModifiedStart = 0;\r\n        for (let i = originalStart; i < originalMax; i++) {\r\n            for (let j = modifiedStart; j < modifiedMax; j++) {\r\n                const score = this._contiguousSequenceScore(i, j, desiredLength);\r\n                if (score > 0 && score > bestScore) {\r\n                    bestScore = score;\r\n                    bestOriginalStart = i;\r\n                    bestModifiedStart = j;\r\n                }\r\n            }\r\n        }\r\n        if (bestScore > 0) {\r\n            return [bestOriginalStart, bestModifiedStart];\r\n        }\r\n        return null;\r\n    }\r\n    _contiguousSequenceScore(originalStart, modifiedStart, length) {\r\n        let score = 0;\r\n        for (let l = 0; l < length; l++) {\r\n            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\r\n                return 0;\r\n            }\r\n            score += this._originalStringElements[originalStart + l].length;\r\n        }\r\n        return score;\r\n    }\r\n    _OriginalIsBoundary(index) {\r\n        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\r\n            return true;\r\n        }\r\n        return (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\r\n    }\r\n    _OriginalRegionIsBoundary(originalStart, originalLength) {\r\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\r\n            return true;\r\n        }\r\n        if (originalLength > 0) {\r\n            const originalEnd = originalStart + originalLength;\r\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _ModifiedIsBoundary(index) {\r\n        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\r\n            return true;\r\n        }\r\n        return (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\r\n    }\r\n    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\r\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\r\n            return true;\r\n        }\r\n        if (modifiedLength > 0) {\r\n            const modifiedEnd = modifiedStart + modifiedLength;\r\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\r\n        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\r\n        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\r\n        return (originalScore + modifiedScore);\r\n    }\r\n    /**\r\n     * Concatenates the two input DiffChange lists and returns the resulting\r\n     * list.\r\n     * @param The left changes\r\n     * @param The right changes\r\n     * @returns The concatenated list\r\n     */\r\n    ConcatenateChanges(left, right) {\r\n        let mergedChangeArr = [];\r\n        if (left.length === 0 || right.length === 0) {\r\n            return (right.length > 0) ? right : left;\r\n        }\r\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\r\n            // Since we break the problem down recursively, it is possible that we\r\n            // might recurse in the middle of a change thereby splitting it into\r\n            // two changes. Here in the combining stage, we detect and fuse those\r\n            // changes back together\r\n            const result = new Array(left.length + right.length - 1);\r\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\r\n            result[left.length - 1] = mergedChangeArr[0];\r\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\r\n            return result;\r\n        }\r\n        else {\r\n            const result = new Array(left.length + right.length);\r\n            MyArray.Copy(left, 0, result, 0, left.length);\r\n            MyArray.Copy(right, 0, result, left.length, right.length);\r\n            return result;\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if the two changes overlap and can be merged into a single\r\n     * change\r\n     * @param left The left change\r\n     * @param right The right change\r\n     * @param mergedChange The merged change if the two overlap, null otherwise\r\n     * @returns True if the two changes overlap\r\n     */\r\n    ChangesOverlap(left, right, mergedChangeArr) {\r\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\r\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\r\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\r\n            const originalStart = left.originalStart;\r\n            let originalLength = left.originalLength;\r\n            const modifiedStart = left.modifiedStart;\r\n            let modifiedLength = left.modifiedLength;\r\n            if (left.originalStart + left.originalLength >= right.originalStart) {\r\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\r\n            }\r\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\r\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\r\n            }\r\n            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\r\n            return true;\r\n        }\r\n        else {\r\n            mergedChangeArr[0] = null;\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Helper method used to clip a diagonal index to the range of valid\r\n     * diagonals. This also decides whether or not the diagonal index,\r\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\r\n     * one inside the boundary depending on the Even/Odd status of the boundary\r\n     * and numDifferences.\r\n     * @param diagonal The index of the diagonal to clip.\r\n     * @param numDifferences The current number of differences being iterated upon.\r\n     * @param diagonalBaseIndex The base reference diagonal.\r\n     * @param numDiagonals The total number of diagonals.\r\n     * @returns The clipped diagonal index.\r\n     */\r\n    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\r\n        if (diagonal >= 0 && diagonal < numDiagonals) {\r\n            // Nothing to clip, its in range\r\n            return diagonal;\r\n        }\r\n        // diagonalsBelow: The number of diagonals below the reference diagonal\r\n        // diagonalsAbove: The number of diagonals above the reference diagonal\r\n        const diagonalsBelow = diagonalBaseIndex;\r\n        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\r\n        const diffEven = (numDifferences % 2 === 0);\r\n        if (diagonal < 0) {\r\n            const lowerBoundEven = (diagonalsBelow % 2 === 0);\r\n            return (diffEven === lowerBoundEven) ? 0 : 1;\r\n        }\r\n        else {\r\n            const upperBoundEven = (diagonalsAbove % 2 === 0);\r\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,UAAU,QAAQ,iBAAiB;AAC5C,SAASC,UAAU,QAAQ,YAAY;AACvC,OAAO,MAAMC,kBAAkB,CAAC;EAC5BC,WAAWA,CAACC,MAAM,EAAE;IAChB,IAAI,CAACA,MAAM,GAAGA,MAAM;EACxB;EACAC,WAAWA,CAAA,EAAG;IACV,MAAMD,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,MAAME,UAAU,GAAG,IAAIC,UAAU,CAACH,MAAM,CAACI,MAAM,CAAC;IAChD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGN,MAAM,CAACI,MAAM,EAAEC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC/CH,UAAU,CAACG,CAAC,CAAC,GAAGL,MAAM,CAACO,UAAU,CAACF,CAAC,CAAC;IACxC;IACA,OAAOH,UAAU;EACrB;AACJ;AACA,OAAO,SAASM,UAAUA,CAACC,QAAQ,EAAEC,QAAQ,EAAEC,MAAM,EAAE;EACnD,OAAO,IAAIC,OAAO,CAAC,IAAId,kBAAkB,CAACW,QAAQ,CAAC,EAAE,IAAIX,kBAAkB,CAACY,QAAQ,CAAC,CAAC,CAACG,WAAW,CAACF,MAAM,CAAC,CAACG,OAAO;AACtH;AACA;AACA;AACA;AACA,OAAO,MAAMC,KAAK,CAAC;EACf,OAAOC,MAAMA,CAACC,SAAS,EAAEC,OAAO,EAAE;IAC9B,IAAI,CAACD,SAAS,EAAE;MACZ,MAAM,IAAIE,KAAK,CAACD,OAAO,CAAC;IAC5B;EACJ;AACJ;AACA,OAAO,MAAME,OAAO,CAAC;EACjB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOC,IAAIA,CAACC,WAAW,EAAEC,WAAW,EAAEC,gBAAgB,EAAEC,gBAAgB,EAAErB,MAAM,EAAE;IAC9E,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC7BmB,gBAAgB,CAACC,gBAAgB,GAAGpB,CAAC,CAAC,GAAGiB,WAAW,CAACC,WAAW,GAAGlB,CAAC,CAAC;IACzE;EACJ;EACA,OAAOqB,KAAKA,CAACJ,WAAW,EAAEC,WAAW,EAAEC,gBAAgB,EAAEC,gBAAgB,EAAErB,MAAM,EAAE;IAC/E,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC7BmB,gBAAgB,CAACC,gBAAgB,GAAGpB,CAAC,CAAC,GAAGiB,WAAW,CAACC,WAAW,GAAGlB,CAAC,CAAC;IACzE;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMsB,gBAAgB,CAAC;EACnB;AACJ;AACA;EACI5B,WAAWA,CAAA,EAAG;IACV,IAAI,CAAC6B,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,eAAe,GAAG,UAAU,CAAC;IAClC,IAAI,CAACC,eAAe,GAAG,UAAU,CAAC;IAClC,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,eAAe,GAAG,CAAC;EAC5B;EACA;AACJ;AACA;EACIC,cAAcA,CAAA,EAAG;IACb;IACA,IAAI,IAAI,CAACF,eAAe,GAAG,CAAC,IAAI,IAAI,CAACC,eAAe,GAAG,CAAC,EAAE;MACtD;MACA,IAAI,CAACJ,SAAS,CAACM,IAAI,CAAC,IAAItC,UAAU,CAAC,IAAI,CAACiC,eAAe,EAAE,IAAI,CAACE,eAAe,EAAE,IAAI,CAACD,eAAe,EAAE,IAAI,CAACE,eAAe,CAAC,CAAC;IAC/H;IACA;IACA,IAAI,CAACD,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB,IAAI,CAACH,eAAe,GAAG,UAAU,CAAC;IAClC,IAAI,CAACC,eAAe,GAAG,UAAU,CAAC;EACtC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIK,kBAAkBA,CAACC,aAAa,EAAEC,aAAa,EAAE;IAC7C;IACA,IAAI,CAACR,eAAe,GAAGS,IAAI,CAACC,GAAG,CAAC,IAAI,CAACV,eAAe,EAAEO,aAAa,CAAC;IACpE,IAAI,CAACN,eAAe,GAAGQ,IAAI,CAACC,GAAG,CAAC,IAAI,CAACT,eAAe,EAAEO,aAAa,CAAC;IACpE,IAAI,CAACN,eAAe,EAAE;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIS,kBAAkBA,CAACJ,aAAa,EAAEC,aAAa,EAAE;IAC7C;IACA,IAAI,CAACR,eAAe,GAAGS,IAAI,CAACC,GAAG,CAAC,IAAI,CAACV,eAAe,EAAEO,aAAa,CAAC;IACpE,IAAI,CAACN,eAAe,GAAGQ,IAAI,CAACC,GAAG,CAAC,IAAI,CAACT,eAAe,EAAEO,aAAa,CAAC;IACpE,IAAI,CAACL,eAAe,EAAE;EAC1B;EACA;AACJ;AACA;EACIS,UAAUA,CAAA,EAAG;IACT,IAAI,IAAI,CAACV,eAAe,GAAG,CAAC,IAAI,IAAI,CAACC,eAAe,GAAG,CAAC,EAAE;MACtD;MACA,IAAI,CAACC,cAAc,CAAC,CAAC;IACzB;IACA,OAAO,IAAI,CAACL,SAAS;EACzB;EACA;AACJ;AACA;EACIc,iBAAiBA,CAAA,EAAG;IAChB,IAAI,IAAI,CAACX,eAAe,GAAG,CAAC,IAAI,IAAI,CAACC,eAAe,GAAG,CAAC,EAAE;MACtD;MACA,IAAI,CAACC,cAAc,CAAC,CAAC;IACzB;IACA,IAAI,CAACL,SAAS,CAACe,OAAO,CAAC,CAAC;IACxB,OAAO,IAAI,CAACf,SAAS;EACzB;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMhB,OAAO,CAAC;EACjB;AACJ;AACA;EACIb,WAAWA,CAAC6C,gBAAgB,EAAEC,gBAAgB,EAAsC;IAAA,IAApCC,2BAA2B,GAAAC,SAAA,CAAA3C,MAAA,QAAA2C,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,IAAI;IAC9E,IAAI,CAACE,2BAA2B,GAAGH,2BAA2B;IAC9D,MAAM,CAACI,sBAAsB,EAAEC,sBAAsB,EAAEC,kBAAkB,CAAC,GAAGxC,OAAO,CAACyC,YAAY,CAACT,gBAAgB,CAAC;IACnH,MAAM,CAACU,sBAAsB,EAAEC,sBAAsB,EAAEC,kBAAkB,CAAC,GAAG5C,OAAO,CAACyC,YAAY,CAACR,gBAAgB,CAAC;IACnH,IAAI,CAACY,WAAW,GAAIL,kBAAkB,IAAII,kBAAmB;IAC7D,IAAI,CAACE,uBAAuB,GAAGR,sBAAsB;IACrD,IAAI,CAACS,uBAAuB,GAAGR,sBAAsB;IACrD,IAAI,CAACS,uBAAuB,GAAGN,sBAAsB;IACrD,IAAI,CAACO,uBAAuB,GAAGN,sBAAsB;IACrD,IAAI,CAACO,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACC,gBAAgB,GAAG,EAAE;EAC9B;EACA,OAAOC,cAAcA,CAACC,GAAG,EAAE;IACvB,OAAQA,GAAG,CAAC7D,MAAM,GAAG,CAAC,IAAI,OAAO6D,GAAG,CAAC,CAAC,CAAC,KAAK,QAAQ;EACxD;EACA,OAAOZ,YAAYA,CAACa,QAAQ,EAAE;IAC1B,MAAMC,QAAQ,GAAGD,QAAQ,CAACjE,WAAW,CAAC,CAAC;IACvC,IAAIW,OAAO,CAACoD,cAAc,CAACG,QAAQ,CAAC,EAAE;MAClC,MAAMC,MAAM,GAAG,IAAIjE,UAAU,CAACgE,QAAQ,CAAC/D,MAAM,CAAC;MAC9C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG6D,QAAQ,CAAC/D,MAAM,EAAEC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QACjD+D,MAAM,CAAC/D,CAAC,CAAC,GAAGR,UAAU,CAACsE,QAAQ,CAAC9D,CAAC,CAAC,EAAE,CAAC,CAAC;MAC1C;MACA,OAAO,CAAC8D,QAAQ,EAAEC,MAAM,EAAE,IAAI,CAAC;IACnC;IACA,IAAID,QAAQ,YAAYhE,UAAU,EAAE;MAChC,OAAO,CAAC,EAAE,EAAEgE,QAAQ,EAAE,KAAK,CAAC;IAChC;IACA,OAAO,CAAC,EAAE,EAAE,IAAIhE,UAAU,CAACgE,QAAQ,CAAC,EAAE,KAAK,CAAC;EAChD;EACAE,gBAAgBA,CAACjC,aAAa,EAAEkC,QAAQ,EAAE;IACtC,IAAI,IAAI,CAACX,uBAAuB,CAACvB,aAAa,CAAC,KAAK,IAAI,CAACyB,uBAAuB,CAACS,QAAQ,CAAC,EAAE;MACxF,OAAO,KAAK;IAChB;IACA,OAAQ,IAAI,CAACb,WAAW,GAAG,IAAI,CAACC,uBAAuB,CAACtB,aAAa,CAAC,KAAK,IAAI,CAACwB,uBAAuB,CAACU,QAAQ,CAAC,GAAG,IAAI;EAC5H;EACAC,wBAAwBA,CAACC,MAAM,EAAEC,MAAM,EAAE;IACrC,IAAI,IAAI,CAACd,uBAAuB,CAACa,MAAM,CAAC,KAAK,IAAI,CAACb,uBAAuB,CAACc,MAAM,CAAC,EAAE;MAC/E,OAAO,KAAK;IAChB;IACA,OAAQ,IAAI,CAAChB,WAAW,GAAG,IAAI,CAACC,uBAAuB,CAACc,MAAM,CAAC,KAAK,IAAI,CAACd,uBAAuB,CAACe,MAAM,CAAC,GAAG,IAAI;EACnH;EACAC,wBAAwBA,CAACF,MAAM,EAAEC,MAAM,EAAE;IACrC,IAAI,IAAI,CAACZ,uBAAuB,CAACW,MAAM,CAAC,KAAK,IAAI,CAACX,uBAAuB,CAACY,MAAM,CAAC,EAAE;MAC/E,OAAO,KAAK;IAChB;IACA,OAAQ,IAAI,CAAChB,WAAW,GAAG,IAAI,CAACG,uBAAuB,CAACY,MAAM,CAAC,KAAK,IAAI,CAACZ,uBAAuB,CAACa,MAAM,CAAC,GAAG,IAAI;EACnH;EACA5D,WAAWA,CAACF,MAAM,EAAE;IAChB,OAAO,IAAI,CAACgE,YAAY,CAAC,CAAC,EAAE,IAAI,CAAChB,uBAAuB,CAACvD,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,IAAI,CAACyD,uBAAuB,CAACzD,MAAM,GAAG,CAAC,EAAEO,MAAM,CAAC;EAC5H;EACA;AACJ;AACA;AACA;AACA;EACIgE,YAAYA,CAACC,aAAa,EAAEC,WAAW,EAAEC,aAAa,EAAEC,WAAW,EAAEpE,MAAM,EAAE;IACzE,MAAMqE,YAAY,GAAG,CAAC,KAAK,CAAC;IAC5B,IAAIlE,OAAO,GAAG,IAAI,CAACmE,oBAAoB,CAACL,aAAa,EAAEC,WAAW,EAAEC,aAAa,EAAEC,WAAW,EAAEC,YAAY,CAAC;IAC7G,IAAIrE,MAAM,EAAE;MACR;MACA;MACA;MACAG,OAAO,GAAG,IAAI,CAACoE,eAAe,CAACpE,OAAO,CAAC;IAC3C;IACA,OAAO;MACHqE,SAAS,EAAEH,YAAY,CAAC,CAAC,CAAC;MAC1BlE,OAAO,EAAEA;IACb,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;EACImE,oBAAoBA,CAACL,aAAa,EAAEC,WAAW,EAAEC,aAAa,EAAEC,WAAW,EAAEC,YAAY,EAAE;IACvFA,YAAY,CAAC,CAAC,CAAC,GAAG,KAAK;IACvB;IACA,OAAOJ,aAAa,IAAIC,WAAW,IAAIC,aAAa,IAAIC,WAAW,IAAI,IAAI,CAACV,gBAAgB,CAACO,aAAa,EAAEE,aAAa,CAAC,EAAE;MACxHF,aAAa,EAAE;MACfE,aAAa,EAAE;IACnB;IACA;IACA,OAAOD,WAAW,IAAID,aAAa,IAAIG,WAAW,IAAID,aAAa,IAAI,IAAI,CAACT,gBAAgB,CAACQ,WAAW,EAAEE,WAAW,CAAC,EAAE;MACpHF,WAAW,EAAE;MACbE,WAAW,EAAE;IACjB;IACA;IACA,IAAIH,aAAa,GAAGC,WAAW,IAAIC,aAAa,GAAGC,WAAW,EAAE;MAC5D,IAAIjE,OAAO;MACX,IAAIgE,aAAa,IAAIC,WAAW,EAAE;QAC9BhE,KAAK,CAACC,MAAM,CAAC4D,aAAa,KAAKC,WAAW,GAAG,CAAC,EAAE,wDAAwD,CAAC;QACzG;QACA/D,OAAO,GAAG,CACN,IAAIlB,UAAU,CAACgF,aAAa,EAAE,CAAC,EAAEE,aAAa,EAAEC,WAAW,GAAGD,aAAa,GAAG,CAAC,CAAC,CACnF;MACL,CAAC,MACI,IAAIF,aAAa,IAAIC,WAAW,EAAE;QACnC9D,KAAK,CAACC,MAAM,CAAC8D,aAAa,KAAKC,WAAW,GAAG,CAAC,EAAE,wDAAwD,CAAC;QACzG;QACAjE,OAAO,GAAG,CACN,IAAIlB,UAAU,CAACgF,aAAa,EAAEC,WAAW,GAAGD,aAAa,GAAG,CAAC,EAAEE,aAAa,EAAE,CAAC,CAAC,CACnF;MACL,CAAC,MACI;QACD/D,KAAK,CAACC,MAAM,CAAC4D,aAAa,KAAKC,WAAW,GAAG,CAAC,EAAE,wDAAwD,CAAC;QACzG9D,KAAK,CAACC,MAAM,CAAC8D,aAAa,KAAKC,WAAW,GAAG,CAAC,EAAE,wDAAwD,CAAC;QACzG;QACAjE,OAAO,GAAG,EAAE;MAChB;MACA,OAAOA,OAAO;IAClB;IACA;IACA,MAAMsE,cAAc,GAAG,CAAC,CAAC,CAAC;IAC1B,MAAMC,cAAc,GAAG,CAAC,CAAC,CAAC;IAC1B,MAAMC,MAAM,GAAG,IAAI,CAACC,qBAAqB,CAACX,aAAa,EAAEC,WAAW,EAAEC,aAAa,EAAEC,WAAW,EAAEK,cAAc,EAAEC,cAAc,EAAEL,YAAY,CAAC;IAC/I,MAAMQ,WAAW,GAAGJ,cAAc,CAAC,CAAC,CAAC;IACrC,MAAMK,WAAW,GAAGJ,cAAc,CAAC,CAAC,CAAC;IACrC,IAAIC,MAAM,KAAK,IAAI,EAAE;MACjB;MACA;MACA,OAAOA,MAAM;IACjB,CAAC,MACI,IAAI,CAACN,YAAY,CAAC,CAAC,CAAC,EAAE;MACvB;MACA;MACA;MACA;MACA,MAAMU,WAAW,GAAG,IAAI,CAACT,oBAAoB,CAACL,aAAa,EAAEY,WAAW,EAAEV,aAAa,EAAEW,WAAW,EAAET,YAAY,CAAC;MACnH,IAAIW,YAAY,GAAG,EAAE;MACrB,IAAI,CAACX,YAAY,CAAC,CAAC,CAAC,EAAE;QAClBW,YAAY,GAAG,IAAI,CAACV,oBAAoB,CAACO,WAAW,GAAG,CAAC,EAAEX,WAAW,EAAEY,WAAW,GAAG,CAAC,EAAEV,WAAW,EAAEC,YAAY,CAAC;MACtH,CAAC,MACI;QACD;QACA;QACAW,YAAY,GAAG,CACX,IAAI/F,UAAU,CAAC4F,WAAW,GAAG,CAAC,EAAEX,WAAW,IAAIW,WAAW,GAAG,CAAC,CAAC,GAAG,CAAC,EAAEC,WAAW,GAAG,CAAC,EAAEV,WAAW,IAAIU,WAAW,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAC7H;MACL;MACA,OAAO,IAAI,CAACG,kBAAkB,CAACF,WAAW,EAAEC,YAAY,CAAC;IAC7D;IACA;IACA,OAAO,CACH,IAAI/F,UAAU,CAACgF,aAAa,EAAEC,WAAW,GAAGD,aAAa,GAAG,CAAC,EAAEE,aAAa,EAAEC,WAAW,GAAGD,aAAa,GAAG,CAAC,CAAC,CACjH;EACL;EACAe,SAASA,CAACC,mBAAmB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAEC,aAAa,EAAEC,aAAa,EAAEnE,aAAa,EAAEyC,WAAW,EAAEO,cAAc,EAAE/C,aAAa,EAAE0C,WAAW,EAAEM,cAAc,EAAEmB,WAAW,EAAExB,YAAY,EAAE;IACnU,IAAIyB,cAAc,GAAG,IAAI;IACzB,IAAIC,cAAc,GAAG,IAAI;IACzB;IACA,IAAIC,YAAY,GAAG,IAAIhF,gBAAgB,CAAC,CAAC;IACzC,IAAIiF,WAAW,GAAGb,oBAAoB;IACtC,IAAIc,WAAW,GAAGb,kBAAkB;IACpC,IAAIc,gBAAgB,GAAI1B,cAAc,CAAC,CAAC,CAAC,GAAGC,cAAc,CAAC,CAAC,CAAC,GAAIY,qBAAqB;IACtF,IAAIc,iBAAiB,GAAG,CAAC,UAAU,CAAC;IACpC,IAAIC,YAAY,GAAG,IAAI,CAAClD,gBAAgB,CAAC1D,MAAM,GAAG,CAAC;IACnD,GAAG;MACC;MACA,MAAM6G,QAAQ,GAAGH,gBAAgB,GAAGhB,mBAAmB;MACvD;MACA,IAAImB,QAAQ,KAAKL,WAAW,IAAKK,QAAQ,GAAGJ,WAAW,IAAIP,aAAa,CAACW,QAAQ,GAAG,CAAC,CAAC,GAAGX,aAAa,CAACW,QAAQ,GAAG,CAAC,CAAE,EAAE;QACnH;QACA7E,aAAa,GAAGkE,aAAa,CAACW,QAAQ,GAAG,CAAC,CAAC;QAC3C5E,aAAa,GAAGD,aAAa,GAAG0E,gBAAgB,GAAGb,qBAAqB;QACxE,IAAI7D,aAAa,GAAG2E,iBAAiB,EAAE;UACnCJ,YAAY,CAAC1E,cAAc,CAAC,CAAC;QACjC;QACA8E,iBAAiB,GAAG3E,aAAa;QACjCuE,YAAY,CAACnE,kBAAkB,CAACJ,aAAa,GAAG,CAAC,EAAEC,aAAa,CAAC;QACjEyE,gBAAgB,GAAIG,QAAQ,GAAG,CAAC,GAAInB,mBAAmB,CAAC,CAAC;MAC7D,CAAC,MACI;QACD;QACA1D,aAAa,GAAGkE,aAAa,CAACW,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC;QAC/C5E,aAAa,GAAGD,aAAa,GAAG0E,gBAAgB,GAAGb,qBAAqB;QACxE,IAAI7D,aAAa,GAAG2E,iBAAiB,EAAE;UACnCJ,YAAY,CAAC1E,cAAc,CAAC,CAAC;QACjC;QACA8E,iBAAiB,GAAG3E,aAAa,GAAG,CAAC;QACrCuE,YAAY,CAACxE,kBAAkB,CAACC,aAAa,EAAEC,aAAa,GAAG,CAAC,CAAC;QACjEyE,gBAAgB,GAAIG,QAAQ,GAAG,CAAC,GAAInB,mBAAmB,CAAC,CAAC;MAC7D;;MACA,IAAIkB,YAAY,IAAI,CAAC,EAAE;QACnBV,aAAa,GAAG,IAAI,CAACxC,gBAAgB,CAACkD,YAAY,CAAC;QACnDlB,mBAAmB,GAAGQ,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;QACxCM,WAAW,GAAG,CAAC;QACfC,WAAW,GAAGP,aAAa,CAAClG,MAAM,GAAG,CAAC;MAC1C;IACJ,CAAC,QAAQ,EAAE4G,YAAY,IAAI,CAAC,CAAC;IAC7B;IACA;IACAP,cAAc,GAAGE,YAAY,CAACjE,iBAAiB,CAAC,CAAC;IACjD,IAAIsC,YAAY,CAAC,CAAC,CAAC,EAAE;MACjB;MACA;MACA,IAAIkC,kBAAkB,GAAG9B,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC;MAC9C,IAAI+B,kBAAkB,GAAG9B,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC;MAC9C,IAAIoB,cAAc,KAAK,IAAI,IAAIA,cAAc,CAACrG,MAAM,GAAG,CAAC,EAAE;QACtD,MAAMgH,iBAAiB,GAAGX,cAAc,CAACA,cAAc,CAACrG,MAAM,GAAG,CAAC,CAAC;QACnE8G,kBAAkB,GAAG5E,IAAI,CAAC+E,GAAG,CAACH,kBAAkB,EAAEE,iBAAiB,CAACE,cAAc,CAAC,CAAC,CAAC;QACrFH,kBAAkB,GAAG7E,IAAI,CAAC+E,GAAG,CAACF,kBAAkB,EAAEC,iBAAiB,CAACG,cAAc,CAAC,CAAC,CAAC;MACzF;MACAb,cAAc,GAAG,CACb,IAAI9G,UAAU,CAACsH,kBAAkB,EAAErC,WAAW,GAAGqC,kBAAkB,GAAG,CAAC,EAAEC,kBAAkB,EAAEpC,WAAW,GAAGoC,kBAAkB,GAAG,CAAC,CAAC,CACrI;IACL,CAAC,MACI;MACD;MACAR,YAAY,GAAG,IAAIhF,gBAAgB,CAAC,CAAC;MACrCiF,WAAW,GAAGT,oBAAoB;MAClCU,WAAW,GAAGT,kBAAkB;MAChCU,gBAAgB,GAAI1B,cAAc,CAAC,CAAC,CAAC,GAAGC,cAAc,CAAC,CAAC,CAAC,GAAIgB,qBAAqB;MAClFU,iBAAiB,GAAG,UAAU,CAAC;MAC/BC,YAAY,GAAIR,WAAW,GAAI,IAAI,CAACzC,gBAAgB,CAAC3D,MAAM,GAAG,CAAC,GAAG,IAAI,CAAC2D,gBAAgB,CAAC3D,MAAM,GAAG,CAAC;MAClG,GAAG;QACC;QACA,MAAM6G,QAAQ,GAAGH,gBAAgB,GAAGZ,mBAAmB;QACvD;QACA,IAAIe,QAAQ,KAAKL,WAAW,IAAKK,QAAQ,GAAGJ,WAAW,IAAIN,aAAa,CAACU,QAAQ,GAAG,CAAC,CAAC,IAAIV,aAAa,CAACU,QAAQ,GAAG,CAAC,CAAE,EAAE;UACpH;UACA7E,aAAa,GAAGmE,aAAa,CAACU,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC;UAC/C5E,aAAa,GAAGD,aAAa,GAAG0E,gBAAgB,GAAGT,qBAAqB;UACxE,IAAIjE,aAAa,GAAG2E,iBAAiB,EAAE;YACnCJ,YAAY,CAAC1E,cAAc,CAAC,CAAC;UACjC;UACA8E,iBAAiB,GAAG3E,aAAa,GAAG,CAAC;UACrCuE,YAAY,CAACxE,kBAAkB,CAACC,aAAa,GAAG,CAAC,EAAEC,aAAa,GAAG,CAAC,CAAC;UACrEyE,gBAAgB,GAAIG,QAAQ,GAAG,CAAC,GAAIf,mBAAmB,CAAC,CAAC;QAC7D,CAAC,MACI;UACD;UACA9D,aAAa,GAAGmE,aAAa,CAACU,QAAQ,GAAG,CAAC,CAAC;UAC3C5E,aAAa,GAAGD,aAAa,GAAG0E,gBAAgB,GAAGT,qBAAqB;UACxE,IAAIjE,aAAa,GAAG2E,iBAAiB,EAAE;YACnCJ,YAAY,CAAC1E,cAAc,CAAC,CAAC;UACjC;UACA8E,iBAAiB,GAAG3E,aAAa;UACjCuE,YAAY,CAACnE,kBAAkB,CAACJ,aAAa,GAAG,CAAC,EAAEC,aAAa,GAAG,CAAC,CAAC;UACrEyE,gBAAgB,GAAIG,QAAQ,GAAG,CAAC,GAAIf,mBAAmB,CAAC,CAAC;QAC7D;;QACA,IAAIc,YAAY,IAAI,CAAC,EAAE;UACnBT,aAAa,GAAG,IAAI,CAACxC,gBAAgB,CAACiD,YAAY,CAAC;UACnDd,mBAAmB,GAAGK,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;UACxCK,WAAW,GAAG,CAAC;UACfC,WAAW,GAAGN,aAAa,CAACnG,MAAM,GAAG,CAAC;QAC1C;MACJ,CAAC,QAAQ,EAAE4G,YAAY,IAAI,CAAC,CAAC;MAC7B;MACA;MACAN,cAAc,GAAGC,YAAY,CAAClE,UAAU,CAAC,CAAC;IAC9C;IACA,OAAO,IAAI,CAACmD,kBAAkB,CAACa,cAAc,EAAEC,cAAc,CAAC;EAClE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACInB,qBAAqBA,CAACX,aAAa,EAAEC,WAAW,EAAEC,aAAa,EAAEC,WAAW,EAAEK,cAAc,EAAEC,cAAc,EAAEL,YAAY,EAAE;IACxH,IAAI5C,aAAa,GAAG,CAAC;MAAEC,aAAa,GAAG,CAAC;IACxC,IAAI0D,oBAAoB,GAAG,CAAC;MAAEC,kBAAkB,GAAG,CAAC;IACpD,IAAIG,oBAAoB,GAAG,CAAC;MAAEC,kBAAkB,GAAG,CAAC;IACpD;IACA;IACAxB,aAAa,EAAE;IACfE,aAAa,EAAE;IACf;IACA;IACAM,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC;IACrBC,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC;IACrB;IACA,IAAI,CAACvB,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACC,gBAAgB,GAAG,EAAE;IAC1B;IACA;IACA;IACA;IACA,MAAMyD,cAAc,GAAI3C,WAAW,GAAGD,aAAa,IAAKG,WAAW,GAAGD,aAAa,CAAC;IACpF,MAAM2C,YAAY,GAAGD,cAAc,GAAG,CAAC;IACvC,MAAMlB,aAAa,GAAG,IAAInG,UAAU,CAACsH,YAAY,CAAC;IAClD,MAAMlB,aAAa,GAAG,IAAIpG,UAAU,CAACsH,YAAY,CAAC;IAClD;IACA;IACA,MAAM3B,mBAAmB,GAAIf,WAAW,GAAGD,aAAc;IACzD,MAAMoB,mBAAmB,GAAIrB,WAAW,GAAGD,aAAc;IACzD;IACA;IACA;IACA;IACA,MAAMqB,qBAAqB,GAAIrB,aAAa,GAAGE,aAAc;IAC7D,MAAMuB,qBAAqB,GAAIxB,WAAW,GAAGE,WAAY;IACzD;IACA;IACA;IACA,MAAM2C,KAAK,GAAGxB,mBAAmB,GAAGJ,mBAAmB;IACvD,MAAMU,WAAW,GAAIkB,KAAK,GAAG,CAAC,KAAK,CAAE;IACrC;IACA;IACApB,aAAa,CAACR,mBAAmB,CAAC,GAAGlB,aAAa;IAClD2B,aAAa,CAACL,mBAAmB,CAAC,GAAGrB,WAAW;IAChD;IACAG,YAAY,CAAC,CAAC,CAAC,GAAG,KAAK;IACvB;IACA;IACA;IACA;IACA;IACA;IACA;IACA,KAAK,IAAI2C,cAAc,GAAG,CAAC,EAAEA,cAAc,IAAKH,cAAc,GAAG,CAAC,GAAI,CAAC,EAAEG,cAAc,EAAE,EAAE;MACvF,IAAIC,qBAAqB,GAAG,CAAC;MAC7B,IAAIC,qBAAqB,GAAG,CAAC;MAC7B;MACA9B,oBAAoB,GAAG,IAAI,CAAC+B,iBAAiB,CAAChC,mBAAmB,GAAG6B,cAAc,EAAEA,cAAc,EAAE7B,mBAAmB,EAAE2B,YAAY,CAAC;MACtIzB,kBAAkB,GAAG,IAAI,CAAC8B,iBAAiB,CAAChC,mBAAmB,GAAG6B,cAAc,EAAEA,cAAc,EAAE7B,mBAAmB,EAAE2B,YAAY,CAAC;MACpI,KAAK,IAAIR,QAAQ,GAAGlB,oBAAoB,EAAEkB,QAAQ,IAAIjB,kBAAkB,EAAEiB,QAAQ,IAAI,CAAC,EAAE;QACrF;QACA;QACA;QACA,IAAIA,QAAQ,KAAKlB,oBAAoB,IAAKkB,QAAQ,GAAGjB,kBAAkB,IAAIM,aAAa,CAACW,QAAQ,GAAG,CAAC,CAAC,GAAGX,aAAa,CAACW,QAAQ,GAAG,CAAC,CAAE,EAAE;UACnI7E,aAAa,GAAGkE,aAAa,CAACW,QAAQ,GAAG,CAAC,CAAC;QAC/C,CAAC,MACI;UACD7E,aAAa,GAAGkE,aAAa,CAACW,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC;QACnD;QACA5E,aAAa,GAAGD,aAAa,IAAI6E,QAAQ,GAAGnB,mBAAmB,CAAC,GAAGG,qBAAqB;QACxF;QACA,MAAM8B,iBAAiB,GAAG3F,aAAa;QACvC;QACA;QACA,OAAOA,aAAa,GAAGyC,WAAW,IAAIxC,aAAa,GAAG0C,WAAW,IAAI,IAAI,CAACV,gBAAgB,CAACjC,aAAa,GAAG,CAAC,EAAEC,aAAa,GAAG,CAAC,CAAC,EAAE;UAC9HD,aAAa,EAAE;UACfC,aAAa,EAAE;QACnB;QACAiE,aAAa,CAACW,QAAQ,CAAC,GAAG7E,aAAa;QACvC,IAAIA,aAAa,GAAGC,aAAa,GAAGuF,qBAAqB,GAAGC,qBAAqB,EAAE;UAC/ED,qBAAqB,GAAGxF,aAAa;UACrCyF,qBAAqB,GAAGxF,aAAa;QACzC;QACA;QACA;QACA;QACA;QACA,IAAI,CAACmE,WAAW,IAAIlE,IAAI,CAAC0F,GAAG,CAACf,QAAQ,GAAGf,mBAAmB,CAAC,IAAKyB,cAAc,GAAG,CAAE,EAAE;UAClF,IAAIvF,aAAa,IAAImE,aAAa,CAACU,QAAQ,CAAC,EAAE;YAC1C7B,cAAc,CAAC,CAAC,CAAC,GAAGhD,aAAa;YACjCiD,cAAc,CAAC,CAAC,CAAC,GAAGhD,aAAa;YACjC,IAAI0F,iBAAiB,IAAIxB,aAAa,CAACU,QAAQ,CAAC,IAAI,IAAI,CAAC,8BAA8B,CAAC,IAAIU,cAAc,IAAK,IAAI,CAAC,8BAA8B,CAAE,EAAE;cAClJ;cACA,OAAO,IAAI,CAAC9B,SAAS,CAACC,mBAAmB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAEC,aAAa,EAAEC,aAAa,EAAEnE,aAAa,EAAEyC,WAAW,EAAEO,cAAc,EAAE/C,aAAa,EAAE0C,WAAW,EAAEM,cAAc,EAAEmB,WAAW,EAAExB,YAAY,CAAC;YACtV,CAAC,MACI;cACD;cACA;cACA,OAAO,IAAI;YACf;UACJ;QACJ;MACJ;MACA;MACA,MAAMiD,oBAAoB,GAAG,CAAEL,qBAAqB,GAAGhD,aAAa,IAAKiD,qBAAqB,GAAG/C,aAAa,CAAC,GAAG6C,cAAc,IAAI,CAAC;MACrI,IAAI,IAAI,CAAC1E,2BAA2B,KAAK,IAAI,IAAI,CAAC,IAAI,CAACA,2BAA2B,CAAC2E,qBAAqB,EAAEK,oBAAoB,CAAC,EAAE;QAC7H;QACAjD,YAAY,CAAC,CAAC,CAAC,GAAG,IAAI;QACtB;QACAI,cAAc,CAAC,CAAC,CAAC,GAAGwC,qBAAqB;QACzCvC,cAAc,CAAC,CAAC,CAAC,GAAGwC,qBAAqB;QACzC,IAAII,oBAAoB,GAAG,CAAC,IAAI,IAAI,CAAC,8BAA8B,CAAC,IAAIN,cAAc,IAAK,IAAI,CAAC,8BAA8B,CAAE,EAAE;UAC9H;UACA,OAAO,IAAI,CAAC9B,SAAS,CAACC,mBAAmB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAEC,aAAa,EAAEC,aAAa,EAAEnE,aAAa,EAAEyC,WAAW,EAAEO,cAAc,EAAE/C,aAAa,EAAE0C,WAAW,EAAEM,cAAc,EAAEmB,WAAW,EAAExB,YAAY,CAAC;QACtV,CAAC,MACI;UACD;UACA;UACA;UACAJ,aAAa,EAAE;UACfE,aAAa,EAAE;UACf,OAAO,CACH,IAAIlF,UAAU,CAACgF,aAAa,EAAEC,WAAW,GAAGD,aAAa,GAAG,CAAC,EAAEE,aAAa,EAAEC,WAAW,GAAGD,aAAa,GAAG,CAAC,CAAC,CACjH;QACL;MACJ;MACA;MACAqB,oBAAoB,GAAG,IAAI,CAAC2B,iBAAiB,CAAC5B,mBAAmB,GAAGyB,cAAc,EAAEA,cAAc,EAAEzB,mBAAmB,EAAEuB,YAAY,CAAC;MACtIrB,kBAAkB,GAAG,IAAI,CAAC0B,iBAAiB,CAAC5B,mBAAmB,GAAGyB,cAAc,EAAEA,cAAc,EAAEzB,mBAAmB,EAAEuB,YAAY,CAAC;MACpI,KAAK,IAAIR,QAAQ,GAAGd,oBAAoB,EAAEc,QAAQ,IAAIb,kBAAkB,EAAEa,QAAQ,IAAI,CAAC,EAAE;QACrF;QACA;QACA;QACA,IAAIA,QAAQ,KAAKd,oBAAoB,IAAKc,QAAQ,GAAGb,kBAAkB,IAAIG,aAAa,CAACU,QAAQ,GAAG,CAAC,CAAC,IAAIV,aAAa,CAACU,QAAQ,GAAG,CAAC,CAAE,EAAE;UACpI7E,aAAa,GAAGmE,aAAa,CAACU,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC;QACnD,CAAC,MACI;UACD7E,aAAa,GAAGmE,aAAa,CAACU,QAAQ,GAAG,CAAC,CAAC;QAC/C;QACA5E,aAAa,GAAGD,aAAa,IAAI6E,QAAQ,GAAGf,mBAAmB,CAAC,GAAGG,qBAAqB;QACxF;QACA,MAAM0B,iBAAiB,GAAG3F,aAAa;QACvC;QACA;QACA,OAAOA,aAAa,GAAGwC,aAAa,IAAIvC,aAAa,GAAGyC,aAAa,IAAI,IAAI,CAACT,gBAAgB,CAACjC,aAAa,EAAEC,aAAa,CAAC,EAAE;UAC1HD,aAAa,EAAE;UACfC,aAAa,EAAE;QACnB;QACAkE,aAAa,CAACU,QAAQ,CAAC,GAAG7E,aAAa;QACvC;QACA;QACA;QACA,IAAIoE,WAAW,IAAIlE,IAAI,CAAC0F,GAAG,CAACf,QAAQ,GAAGnB,mBAAmB,CAAC,IAAI6B,cAAc,EAAE;UAC3E,IAAIvF,aAAa,IAAIkE,aAAa,CAACW,QAAQ,CAAC,EAAE;YAC1C7B,cAAc,CAAC,CAAC,CAAC,GAAGhD,aAAa;YACjCiD,cAAc,CAAC,CAAC,CAAC,GAAGhD,aAAa;YACjC,IAAI0F,iBAAiB,IAAIzB,aAAa,CAACW,QAAQ,CAAC,IAAI,IAAI,CAAC,8BAA8B,CAAC,IAAIU,cAAc,IAAK,IAAI,CAAC,8BAA8B,CAAE,EAAE;cAClJ;cACA,OAAO,IAAI,CAAC9B,SAAS,CAACC,mBAAmB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAEC,aAAa,EAAEC,aAAa,EAAEnE,aAAa,EAAEyC,WAAW,EAAEO,cAAc,EAAE/C,aAAa,EAAE0C,WAAW,EAAEM,cAAc,EAAEmB,WAAW,EAAExB,YAAY,CAAC;YACtV,CAAC,MACI;cACD;cACA;cACA,OAAO,IAAI;YACf;UACJ;QACJ;MACJ;MACA;MACA,IAAI2C,cAAc,IAAI,IAAI,CAAC,6BAA6B;QACpD;QACA;QACA,IAAIO,IAAI,GAAG,IAAI/H,UAAU,CAAC6F,kBAAkB,GAAGD,oBAAoB,GAAG,CAAC,CAAC;QACxEmC,IAAI,CAAC,CAAC,CAAC,GAAGpC,mBAAmB,GAAGC,oBAAoB,GAAG,CAAC;QACxD3E,OAAO,CAACM,KAAK,CAAC4E,aAAa,EAAEP,oBAAoB,EAAEmC,IAAI,EAAE,CAAC,EAAElC,kBAAkB,GAAGD,oBAAoB,GAAG,CAAC,CAAC;QAC1G,IAAI,CAACjC,gBAAgB,CAAC5B,IAAI,CAACgG,IAAI,CAAC;QAChCA,IAAI,GAAG,IAAI/H,UAAU,CAACiG,kBAAkB,GAAGD,oBAAoB,GAAG,CAAC,CAAC;QACpE+B,IAAI,CAAC,CAAC,CAAC,GAAGhC,mBAAmB,GAAGC,oBAAoB,GAAG,CAAC;QACxD/E,OAAO,CAACM,KAAK,CAAC6E,aAAa,EAAEJ,oBAAoB,EAAE+B,IAAI,EAAE,CAAC,EAAE9B,kBAAkB,GAAGD,oBAAoB,GAAG,CAAC,CAAC;QAC1G,IAAI,CAACpC,gBAAgB,CAAC7B,IAAI,CAACgG,IAAI,CAAC;MACpC;IACJ;IACA;IACA;IACA,OAAO,IAAI,CAACrC,SAAS,CAACC,mBAAmB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAEC,aAAa,EAAEC,aAAa,EAAEnE,aAAa,EAAEyC,WAAW,EAAEO,cAAc,EAAE/C,aAAa,EAAE0C,WAAW,EAAEM,cAAc,EAAEmB,WAAW,EAAExB,YAAY,CAAC;EACtV;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,eAAeA,CAACpE,OAAO,EAAE;IACrB;IACA,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,OAAO,CAACV,MAAM,EAAEC,CAAC,EAAE,EAAE;MACrC,MAAM8H,MAAM,GAAGrH,OAAO,CAACT,CAAC,CAAC;MACzB,MAAM+H,YAAY,GAAI/H,CAAC,GAAGS,OAAO,CAACV,MAAM,GAAG,CAAC,GAAIU,OAAO,CAACT,CAAC,GAAG,CAAC,CAAC,CAACuE,aAAa,GAAG,IAAI,CAACjB,uBAAuB,CAACvD,MAAM;MAClH,MAAMiI,YAAY,GAAIhI,CAAC,GAAGS,OAAO,CAACV,MAAM,GAAG,CAAC,GAAIU,OAAO,CAACT,CAAC,GAAG,CAAC,CAAC,CAACyE,aAAa,GAAG,IAAI,CAACjB,uBAAuB,CAACzD,MAAM;MAClH,MAAMkI,aAAa,GAAGH,MAAM,CAACI,cAAc,GAAG,CAAC;MAC/C,MAAMC,aAAa,GAAGL,MAAM,CAACM,cAAc,GAAG,CAAC;MAC/C,OAAON,MAAM,CAACvD,aAAa,GAAGuD,MAAM,CAACI,cAAc,GAAGH,YAAY,IAC9DD,MAAM,CAACrD,aAAa,GAAGqD,MAAM,CAACM,cAAc,GAAGJ,YAAY,KAC1D,CAACC,aAAa,IAAI,IAAI,CAAC/D,wBAAwB,CAAC4D,MAAM,CAACvD,aAAa,EAAEuD,MAAM,CAACvD,aAAa,GAAGuD,MAAM,CAACI,cAAc,CAAC,CAAC,KACpH,CAACC,aAAa,IAAI,IAAI,CAAC9D,wBAAwB,CAACyD,MAAM,CAACrD,aAAa,EAAEqD,MAAM,CAACrD,aAAa,GAAGqD,MAAM,CAACM,cAAc,CAAC,CAAC,EAAE;QACvHN,MAAM,CAACvD,aAAa,EAAE;QACtBuD,MAAM,CAACrD,aAAa,EAAE;MAC1B;MACA,IAAI4D,eAAe,GAAG,CAAC,IAAI,CAAC;MAC5B,IAAIrI,CAAC,GAAGS,OAAO,CAACV,MAAM,GAAG,CAAC,IAAI,IAAI,CAACuI,cAAc,CAAC7H,OAAO,CAACT,CAAC,CAAC,EAAES,OAAO,CAACT,CAAC,GAAG,CAAC,CAAC,EAAEqI,eAAe,CAAC,EAAE;QAC5F5H,OAAO,CAACT,CAAC,CAAC,GAAGqI,eAAe,CAAC,CAAC,CAAC;QAC/B5H,OAAO,CAAC8H,MAAM,CAACvI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACxBA,CAAC,EAAE;QACH;MACJ;IACJ;IACA;IACA,KAAK,IAAIA,CAAC,GAAGS,OAAO,CAACV,MAAM,GAAG,CAAC,EAAEC,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC1C,MAAM8H,MAAM,GAAGrH,OAAO,CAACT,CAAC,CAAC;MACzB,IAAI+H,YAAY,GAAG,CAAC;MACpB,IAAIC,YAAY,GAAG,CAAC;MACpB,IAAIhI,CAAC,GAAG,CAAC,EAAE;QACP,MAAMwI,UAAU,GAAG/H,OAAO,CAACT,CAAC,GAAG,CAAC,CAAC;QACjC,IAAIwI,UAAU,CAACN,cAAc,GAAG,CAAC,EAAE;UAC/BH,YAAY,GAAGS,UAAU,CAACjE,aAAa,GAAGiE,UAAU,CAACN,cAAc;QACvE;QACA,IAAIM,UAAU,CAACJ,cAAc,GAAG,CAAC,EAAE;UAC/BJ,YAAY,GAAGQ,UAAU,CAAC/D,aAAa,GAAG+D,UAAU,CAACJ,cAAc;QACvE;MACJ;MACA,MAAMH,aAAa,GAAGH,MAAM,CAACI,cAAc,GAAG,CAAC;MAC/C,MAAMC,aAAa,GAAGL,MAAM,CAACM,cAAc,GAAG,CAAC;MAC/C,IAAIK,SAAS,GAAG,CAAC;MACjB,IAAIC,SAAS,GAAG,IAAI,CAACC,cAAc,CAACb,MAAM,CAACvD,aAAa,EAAEuD,MAAM,CAACI,cAAc,EAAEJ,MAAM,CAACrD,aAAa,EAAEqD,MAAM,CAACM,cAAc,CAAC;MAC7H,KAAK,IAAIf,KAAK,GAAG,CAAC,GAAGA,KAAK,EAAE,EAAE;QAC1B,MAAM9C,aAAa,GAAGuD,MAAM,CAACvD,aAAa,GAAG8C,KAAK;QAClD,MAAM5C,aAAa,GAAGqD,MAAM,CAACrD,aAAa,GAAG4C,KAAK;QAClD,IAAI9C,aAAa,GAAGwD,YAAY,IAAItD,aAAa,GAAGuD,YAAY,EAAE;UAC9D;QACJ;QACA,IAAIC,aAAa,IAAI,CAAC,IAAI,CAAC/D,wBAAwB,CAACK,aAAa,EAAEA,aAAa,GAAGuD,MAAM,CAACI,cAAc,CAAC,EAAE;UACvG;QACJ;QACA,IAAIC,aAAa,IAAI,CAAC,IAAI,CAAC9D,wBAAwB,CAACI,aAAa,EAAEA,aAAa,GAAGqD,MAAM,CAACM,cAAc,CAAC,EAAE;UACvG;QACJ;QACA,MAAMQ,KAAK,GAAG,IAAI,CAACD,cAAc,CAACpE,aAAa,EAAEuD,MAAM,CAACI,cAAc,EAAEzD,aAAa,EAAEqD,MAAM,CAACM,cAAc,CAAC;QAC7G,IAAIQ,KAAK,GAAGF,SAAS,EAAE;UACnBA,SAAS,GAAGE,KAAK;UACjBH,SAAS,GAAGpB,KAAK;QACrB;MACJ;MACAS,MAAM,CAACvD,aAAa,IAAIkE,SAAS;MACjCX,MAAM,CAACrD,aAAa,IAAIgE,SAAS;IACrC;IACA;IACA;IACA,IAAI,IAAI,CAACrF,WAAW,EAAE;MAClB,KAAK,IAAIpD,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGQ,OAAO,CAACV,MAAM,EAAEC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QAChD,MAAM6I,OAAO,GAAGpI,OAAO,CAACT,CAAC,GAAG,CAAC,CAAC;QAC9B,MAAM8I,OAAO,GAAGrI,OAAO,CAACT,CAAC,CAAC;QAC1B,MAAM+I,aAAa,GAAGD,OAAO,CAACvE,aAAa,GAAGsE,OAAO,CAACtE,aAAa,GAAGsE,OAAO,CAACX,cAAc;QAC5F,MAAMc,cAAc,GAAGH,OAAO,CAACtE,aAAa;QAC5C,MAAM0E,YAAY,GAAGH,OAAO,CAACvE,aAAa,GAAGuE,OAAO,CAACZ,cAAc;QACnE,MAAMgB,gBAAgB,GAAGD,YAAY,GAAGD,cAAc;QACtD,MAAMG,cAAc,GAAGN,OAAO,CAACpE,aAAa;QAC5C,MAAM2E,YAAY,GAAGN,OAAO,CAACrE,aAAa,GAAGqE,OAAO,CAACV,cAAc;QACnE,MAAMiB,gBAAgB,GAAGD,YAAY,GAAGD,cAAc;QACtD;QACA,IAAIJ,aAAa,GAAG,CAAC,IAAIG,gBAAgB,GAAG,EAAE,IAAIG,gBAAgB,GAAG,EAAE,EAAE;UACrE,MAAMC,CAAC,GAAG,IAAI,CAACC,6BAA6B,CAACP,cAAc,EAAEE,gBAAgB,EAAEC,cAAc,EAAEE,gBAAgB,EAAEN,aAAa,CAAC;UAC/H,IAAIO,CAAC,EAAE;YACH,MAAM,CAACE,kBAAkB,EAAEC,kBAAkB,CAAC,GAAGH,CAAC;YAClD,IAAIE,kBAAkB,KAAKX,OAAO,CAACtE,aAAa,GAAGsE,OAAO,CAACX,cAAc,IAAIuB,kBAAkB,KAAKZ,OAAO,CAACpE,aAAa,GAAGoE,OAAO,CAACT,cAAc,EAAE;cAChJ;cACAS,OAAO,CAACX,cAAc,GAAGsB,kBAAkB,GAAGX,OAAO,CAACtE,aAAa;cACnEsE,OAAO,CAACT,cAAc,GAAGqB,kBAAkB,GAAGZ,OAAO,CAACpE,aAAa;cACnEqE,OAAO,CAACvE,aAAa,GAAGiF,kBAAkB,GAAGT,aAAa;cAC1DD,OAAO,CAACrE,aAAa,GAAGgF,kBAAkB,GAAGV,aAAa;cAC1DD,OAAO,CAACZ,cAAc,GAAGe,YAAY,GAAGH,OAAO,CAACvE,aAAa;cAC7DuE,OAAO,CAACV,cAAc,GAAGgB,YAAY,GAAGN,OAAO,CAACrE,aAAa;YACjE;UACJ;QACJ;MACJ;IACJ;IACA,OAAOhE,OAAO;EAClB;EACA8I,6BAA6BA,CAAChF,aAAa,EAAE2D,cAAc,EAAEzD,aAAa,EAAE2D,cAAc,EAAEsB,aAAa,EAAE;IACvG,IAAIxB,cAAc,GAAGwB,aAAa,IAAItB,cAAc,GAAGsB,aAAa,EAAE;MAClE,OAAO,IAAI;IACf;IACA,MAAMC,WAAW,GAAGpF,aAAa,GAAG2D,cAAc,GAAGwB,aAAa,GAAG,CAAC;IACtE,MAAME,WAAW,GAAGnF,aAAa,GAAG2D,cAAc,GAAGsB,aAAa,GAAG,CAAC;IACtE,IAAIhB,SAAS,GAAG,CAAC;IACjB,IAAImB,iBAAiB,GAAG,CAAC;IACzB,IAAIC,iBAAiB,GAAG,CAAC;IACzB,KAAK,IAAI9J,CAAC,GAAGuE,aAAa,EAAEvE,CAAC,GAAG2J,WAAW,EAAE3J,CAAC,EAAE,EAAE;MAC9C,KAAK,IAAI+J,CAAC,GAAGtF,aAAa,EAAEsF,CAAC,GAAGH,WAAW,EAAEG,CAAC,EAAE,EAAE;QAC9C,MAAMnB,KAAK,GAAG,IAAI,CAACoB,wBAAwB,CAAChK,CAAC,EAAE+J,CAAC,EAAEL,aAAa,CAAC;QAChE,IAAId,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAGF,SAAS,EAAE;UAChCA,SAAS,GAAGE,KAAK;UACjBiB,iBAAiB,GAAG7J,CAAC;UACrB8J,iBAAiB,GAAGC,CAAC;QACzB;MACJ;IACJ;IACA,IAAIrB,SAAS,GAAG,CAAC,EAAE;MACf,OAAO,CAACmB,iBAAiB,EAAEC,iBAAiB,CAAC;IACjD;IACA,OAAO,IAAI;EACf;EACAE,wBAAwBA,CAACzF,aAAa,EAAEE,aAAa,EAAE1E,MAAM,EAAE;IAC3D,IAAI6I,KAAK,GAAG,CAAC;IACb,KAAK,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlK,MAAM,EAAEkK,CAAC,EAAE,EAAE;MAC7B,IAAI,CAAC,IAAI,CAACjG,gBAAgB,CAACO,aAAa,GAAG0F,CAAC,EAAExF,aAAa,GAAGwF,CAAC,CAAC,EAAE;QAC9D,OAAO,CAAC;MACZ;MACArB,KAAK,IAAI,IAAI,CAACvF,uBAAuB,CAACkB,aAAa,GAAG0F,CAAC,CAAC,CAAClK,MAAM;IACnE;IACA,OAAO6I,KAAK;EAChB;EACAsB,mBAAmBA,CAACC,KAAK,EAAE;IACvB,IAAIA,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI,IAAI,CAAC7G,uBAAuB,CAACvD,MAAM,GAAG,CAAC,EAAE;MAChE,OAAO,IAAI;IACf;IACA,OAAQ,IAAI,CAACqD,WAAW,IAAI,OAAO,CAACgH,IAAI,CAAC,IAAI,CAAC/G,uBAAuB,CAAC8G,KAAK,CAAC,CAAC;EACjF;EACAE,yBAAyBA,CAAC9F,aAAa,EAAE2D,cAAc,EAAE;IACrD,IAAI,IAAI,CAACgC,mBAAmB,CAAC3F,aAAa,CAAC,IAAI,IAAI,CAAC2F,mBAAmB,CAAC3F,aAAa,GAAG,CAAC,CAAC,EAAE;MACxF,OAAO,IAAI;IACf;IACA,IAAI2D,cAAc,GAAG,CAAC,EAAE;MACpB,MAAM1D,WAAW,GAAGD,aAAa,GAAG2D,cAAc;MAClD,IAAI,IAAI,CAACgC,mBAAmB,CAAC1F,WAAW,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC0F,mBAAmB,CAAC1F,WAAW,CAAC,EAAE;QACpF,OAAO,IAAI;MACf;IACJ;IACA,OAAO,KAAK;EAChB;EACA8F,mBAAmBA,CAACH,KAAK,EAAE;IACvB,IAAIA,KAAK,IAAI,CAAC,IAAIA,KAAK,IAAI,IAAI,CAAC3G,uBAAuB,CAACzD,MAAM,GAAG,CAAC,EAAE;MAChE,OAAO,IAAI;IACf;IACA,OAAQ,IAAI,CAACqD,WAAW,IAAI,OAAO,CAACgH,IAAI,CAAC,IAAI,CAAC7G,uBAAuB,CAAC4G,KAAK,CAAC,CAAC;EACjF;EACAI,yBAAyBA,CAAC9F,aAAa,EAAE2D,cAAc,EAAE;IACrD,IAAI,IAAI,CAACkC,mBAAmB,CAAC7F,aAAa,CAAC,IAAI,IAAI,CAAC6F,mBAAmB,CAAC7F,aAAa,GAAG,CAAC,CAAC,EAAE;MACxF,OAAO,IAAI;IACf;IACA,IAAI2D,cAAc,GAAG,CAAC,EAAE;MACpB,MAAM1D,WAAW,GAAGD,aAAa,GAAG2D,cAAc;MAClD,IAAI,IAAI,CAACkC,mBAAmB,CAAC5F,WAAW,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC4F,mBAAmB,CAAC5F,WAAW,CAAC,EAAE;QACpF,OAAO,IAAI;MACf;IACJ;IACA,OAAO,KAAK;EAChB;EACAiE,cAAcA,CAACpE,aAAa,EAAE2D,cAAc,EAAEzD,aAAa,EAAE2D,cAAc,EAAE;IACzE,MAAMoC,aAAa,GAAI,IAAI,CAACH,yBAAyB,CAAC9F,aAAa,EAAE2D,cAAc,CAAC,GAAG,CAAC,GAAG,CAAE;IAC7F,MAAMuC,aAAa,GAAI,IAAI,CAACF,yBAAyB,CAAC9F,aAAa,EAAE2D,cAAc,CAAC,GAAG,CAAC,GAAG,CAAE;IAC7F,OAAQoC,aAAa,GAAGC,aAAa;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIlF,kBAAkBA,CAACmF,IAAI,EAAEC,KAAK,EAAE;IAC5B,IAAItC,eAAe,GAAG,EAAE;IACxB,IAAIqC,IAAI,CAAC3K,MAAM,KAAK,CAAC,IAAI4K,KAAK,CAAC5K,MAAM,KAAK,CAAC,EAAE;MACzC,OAAQ4K,KAAK,CAAC5K,MAAM,GAAG,CAAC,GAAI4K,KAAK,GAAGD,IAAI;IAC5C,CAAC,MACI,IAAI,IAAI,CAACpC,cAAc,CAACoC,IAAI,CAACA,IAAI,CAAC3K,MAAM,GAAG,CAAC,CAAC,EAAE4K,KAAK,CAAC,CAAC,CAAC,EAAEtC,eAAe,CAAC,EAAE;MAC5E;MACA;MACA;MACA;MACA,MAAMpD,MAAM,GAAG,IAAI2F,KAAK,CAACF,IAAI,CAAC3K,MAAM,GAAG4K,KAAK,CAAC5K,MAAM,GAAG,CAAC,CAAC;MACxDgB,OAAO,CAACC,IAAI,CAAC0J,IAAI,EAAE,CAAC,EAAEzF,MAAM,EAAE,CAAC,EAAEyF,IAAI,CAAC3K,MAAM,GAAG,CAAC,CAAC;MACjDkF,MAAM,CAACyF,IAAI,CAAC3K,MAAM,GAAG,CAAC,CAAC,GAAGsI,eAAe,CAAC,CAAC,CAAC;MAC5CtH,OAAO,CAACC,IAAI,CAAC2J,KAAK,EAAE,CAAC,EAAE1F,MAAM,EAAEyF,IAAI,CAAC3K,MAAM,EAAE4K,KAAK,CAAC5K,MAAM,GAAG,CAAC,CAAC;MAC7D,OAAOkF,MAAM;IACjB,CAAC,MACI;MACD,MAAMA,MAAM,GAAG,IAAI2F,KAAK,CAACF,IAAI,CAAC3K,MAAM,GAAG4K,KAAK,CAAC5K,MAAM,CAAC;MACpDgB,OAAO,CAACC,IAAI,CAAC0J,IAAI,EAAE,CAAC,EAAEzF,MAAM,EAAE,CAAC,EAAEyF,IAAI,CAAC3K,MAAM,CAAC;MAC7CgB,OAAO,CAACC,IAAI,CAAC2J,KAAK,EAAE,CAAC,EAAE1F,MAAM,EAAEyF,IAAI,CAAC3K,MAAM,EAAE4K,KAAK,CAAC5K,MAAM,CAAC;MACzD,OAAOkF,MAAM;IACjB;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIqD,cAAcA,CAACoC,IAAI,EAAEC,KAAK,EAAEtC,eAAe,EAAE;IACzC3H,KAAK,CAACC,MAAM,CAAC+J,IAAI,CAACnG,aAAa,IAAIoG,KAAK,CAACpG,aAAa,EAAE,uDAAuD,CAAC;IAChH7D,KAAK,CAACC,MAAM,CAAC+J,IAAI,CAACjG,aAAa,IAAIkG,KAAK,CAAClG,aAAa,EAAE,uDAAuD,CAAC;IAChH,IAAIiG,IAAI,CAACnG,aAAa,GAAGmG,IAAI,CAACxC,cAAc,IAAIyC,KAAK,CAACpG,aAAa,IAAImG,IAAI,CAACjG,aAAa,GAAGiG,IAAI,CAACtC,cAAc,IAAIuC,KAAK,CAAClG,aAAa,EAAE;MACpI,MAAMF,aAAa,GAAGmG,IAAI,CAACnG,aAAa;MACxC,IAAI2D,cAAc,GAAGwC,IAAI,CAACxC,cAAc;MACxC,MAAMzD,aAAa,GAAGiG,IAAI,CAACjG,aAAa;MACxC,IAAI2D,cAAc,GAAGsC,IAAI,CAACtC,cAAc;MACxC,IAAIsC,IAAI,CAACnG,aAAa,GAAGmG,IAAI,CAACxC,cAAc,IAAIyC,KAAK,CAACpG,aAAa,EAAE;QACjE2D,cAAc,GAAGyC,KAAK,CAACpG,aAAa,GAAGoG,KAAK,CAACzC,cAAc,GAAGwC,IAAI,CAACnG,aAAa;MACpF;MACA,IAAImG,IAAI,CAACjG,aAAa,GAAGiG,IAAI,CAACtC,cAAc,IAAIuC,KAAK,CAAClG,aAAa,EAAE;QACjE2D,cAAc,GAAGuC,KAAK,CAAClG,aAAa,GAAGkG,KAAK,CAACvC,cAAc,GAAGsC,IAAI,CAACjG,aAAa;MACpF;MACA4D,eAAe,CAAC,CAAC,CAAC,GAAG,IAAI9I,UAAU,CAACgF,aAAa,EAAE2D,cAAc,EAAEzD,aAAa,EAAE2D,cAAc,CAAC;MACjG,OAAO,IAAI;IACf,CAAC,MACI;MACDC,eAAe,CAAC,CAAC,CAAC,GAAG,IAAI;MACzB,OAAO,KAAK;IAChB;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIZ,iBAAiBA,CAACb,QAAQ,EAAEU,cAAc,EAAEuD,iBAAiB,EAAEzD,YAAY,EAAE;IACzE,IAAIR,QAAQ,IAAI,CAAC,IAAIA,QAAQ,GAAGQ,YAAY,EAAE;MAC1C;MACA,OAAOR,QAAQ;IACnB;IACA;IACA;IACA,MAAMkE,cAAc,GAAGD,iBAAiB;IACxC,MAAME,cAAc,GAAG3D,YAAY,GAAGyD,iBAAiB,GAAG,CAAC;IAC3D,MAAMG,QAAQ,GAAI1D,cAAc,GAAG,CAAC,KAAK,CAAE;IAC3C,IAAIV,QAAQ,GAAG,CAAC,EAAE;MACd,MAAMqE,cAAc,GAAIH,cAAc,GAAG,CAAC,KAAK,CAAE;MACjD,OAAQE,QAAQ,KAAKC,cAAc,GAAI,CAAC,GAAG,CAAC;IAChD,CAAC,MACI;MACD,MAAMC,cAAc,GAAIH,cAAc,GAAG,CAAC,KAAK,CAAE;MACjD,OAAQC,QAAQ,KAAKE,cAAc,GAAI9D,YAAY,GAAG,CAAC,GAAGA,YAAY,GAAG,CAAC;IAC9E;EACJ;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}