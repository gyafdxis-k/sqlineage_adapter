{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../config/editorOptions.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport * as model from '../model.js';\nimport { EditStack } from './editStack.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, getNodeIsInOverviewRuler, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { InternalModelContentChangeEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from './textModelEvents.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TextModelTokenization } from './textModelTokens.js';\nimport { getWordAtText } from './wordHelper.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nimport { NULL_LANGUAGE_IDENTIFIER } from '../modes/nullMode.js';\nimport { ignoreBracketsInToken } from '../modes/supports.js';\nimport { BracketsUtils } from '../modes/supports/richEditBrackets.js';\nimport { TokensStore, countEOL, TokensStore2 } from './tokensStore.js';\nimport { Color } from '../../../base/common/color.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nfunction createTextBufferBuilder() {\n  return new PieceTreeTextBufferBuilder();\n}\nexport function createTextBufferFactory(text) {\n  const builder = createTextBufferBuilder();\n  builder.acceptChunk(text);\n  return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n  const factory = typeof value === 'string' ? createTextBufferFactory(value) : value;\n  return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nexport const LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n  constructor(source) {\n    this._source = source;\n    this._eos = false;\n  }\n  read() {\n    if (this._eos) {\n      return null;\n    }\n    let result = [],\n      resultCnt = 0,\n      resultLength = 0;\n    do {\n      let tmp = this._source.read();\n      if (tmp === null) {\n        // end-of-stream\n        this._eos = true;\n        if (resultCnt === 0) {\n          return null;\n        } else {\n          return result.join('');\n        }\n      }\n      if (tmp.length > 0) {\n        result[resultCnt++] = tmp;\n        resultLength += tmp.length;\n      }\n      if (resultLength >= 64 * 1024) {\n        return result.join('');\n      }\n    } while (true);\n  }\n}\nconst invalidFunc = () => {\n  throw new Error(\"Invalid change accessor\");\n};\nclass BracketSearchCanceled {\n  constructor() {\n    this._searchCanceledBrand = undefined;\n  }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n  if (result instanceof BracketSearchCanceled) {\n    return null;\n  }\n  return result;\n}\nexport class TextModel extends Disposable {\n  //#endregion\n  constructor(source, creationOptions, languageIdentifier) {\n    let associatedResource = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let undoRedoService = arguments.length > 4 ? arguments[4] : undefined;\n    super();\n    //#region Events\n    this._onWillDispose = this._register(new Emitter());\n    this.onWillDispose = this._onWillDispose.event;\n    this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter());\n    this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n    this._onDidChangeLanguage = this._register(new Emitter());\n    this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n    this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n    this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n    this._onDidChangeTokens = this._register(new Emitter());\n    this.onDidChangeTokens = this._onDidChangeTokens.event;\n    this._onDidChangeOptions = this._register(new Emitter());\n    this.onDidChangeOptions = this._onDidChangeOptions.event;\n    this._onDidChangeAttached = this._register(new Emitter());\n    this.onDidChangeAttached = this._onDidChangeAttached.event;\n    this._eventEmitter = this._register(new DidChangeContentEmitter());\n    // Generate a new unique model id\n    MODEL_ID++;\n    this.id = '$model' + MODEL_ID;\n    this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n    if (typeof associatedResource === 'undefined' || associatedResource === null) {\n      this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n    } else {\n      this._associatedResource = associatedResource;\n    }\n    this._undoRedoService = undoRedoService;\n    this._attachedEditorCount = 0;\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(source, creationOptions.defaultEOL);\n    this._buffer = textBuffer;\n    this._bufferDisposable = disposable;\n    this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n    const bufferLineCount = this._buffer.getLineCount();\n    const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* TextDefined */);\n    // !!! Make a decision in the ctor and permanently respect this decision !!!\n    // If a model is too large at construction time, it will never get tokenized,\n    // under no circumstances.\n    if (creationOptions.largeFileOptimizations) {\n      this._isTooLargeForTokenization = bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD || bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD;\n    } else {\n      this._isTooLargeForTokenization = false;\n    }\n    this._isTooLargeForSyncing = bufferTextLength > TextModel.MODEL_SYNC_LIMIT;\n    this._versionId = 1;\n    this._alternativeVersionId = 1;\n    this._initialUndoRedoSnapshot = null;\n    this._isDisposed = false;\n    this._isDisposing = false;\n    this._languageIdentifier = languageIdentifier || NULL_LANGUAGE_IDENTIFIER;\n    this._languageRegistryListener = LanguageConfigurationRegistry.onDidChange(e => {\n      if (e.languageIdentifier.id === this._languageIdentifier.id) {\n        this._onDidChangeLanguageConfiguration.fire({});\n      }\n    });\n    this._instanceId = strings.singleLetterHash(MODEL_ID);\n    this._lastDecorationId = 0;\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees();\n    this._commandManager = new EditStack(this, undoRedoService);\n    this._isUndoing = false;\n    this._isRedoing = false;\n    this._trimAutoWhitespaceLines = null;\n    this._tokens = new TokensStore();\n    this._tokens2 = new TokensStore2();\n    this._tokenization = new TextModelTokenization(this);\n  }\n  static resolveOptions(textBuffer, options) {\n    if (options.detectIndentation) {\n      const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n      return new model.TextModelResolvedOptions({\n        tabSize: guessedIndentation.tabSize,\n        indentSize: guessedIndentation.tabSize,\n        insertSpaces: guessedIndentation.insertSpaces,\n        trimAutoWhitespace: options.trimAutoWhitespace,\n        defaultEOL: options.defaultEOL\n      });\n    }\n    return new model.TextModelResolvedOptions({\n      tabSize: options.tabSize,\n      indentSize: options.indentSize,\n      insertSpaces: options.insertSpaces,\n      trimAutoWhitespace: options.trimAutoWhitespace,\n      defaultEOL: options.defaultEOL\n    });\n  }\n  onDidChangeRawContentFast(listener) {\n    return this._eventEmitter.fastEvent(e => listener(e.rawContentChangedEvent));\n  }\n  onDidChangeContentFast(listener) {\n    return this._eventEmitter.fastEvent(e => listener(e.contentChangedEvent));\n  }\n  onDidChangeContent(listener) {\n    return this._eventEmitter.slowEvent(e => listener(e.contentChangedEvent));\n  }\n  dispose() {\n    this._isDisposing = true;\n    this._onWillDispose.fire();\n    this._languageRegistryListener.dispose();\n    this._tokenization.dispose();\n    this._isDisposed = true;\n    super.dispose();\n    this._bufferDisposable.dispose();\n    this._isDisposing = false;\n    // Manually release reference to previous text buffer to avoid large leaks\n    // in case someone leaks a TextModel reference\n    const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n    emptyDisposedTextBuffer.dispose();\n    this._buffer = emptyDisposedTextBuffer;\n  }\n  _assertNotDisposed() {\n    if (this._isDisposed) {\n      throw new Error('Model is disposed!');\n    }\n  }\n  _emitContentChangedEvent(rawChange, change) {\n    if (this._isDisposing) {\n      // Do not confuse listeners by emitting any event after disposing\n      return;\n    }\n    this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n  }\n  setValue(value) {\n    this._assertNotDisposed();\n    if (value === null) {\n      // There's nothing to do\n      return;\n    }\n    const {\n      textBuffer,\n      disposable\n    } = createTextBuffer(value, this._options.defaultEOL);\n    this._setValueFromTextBuffer(textBuffer, disposable);\n  }\n  _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n    return {\n      changes: [{\n        range: range,\n        rangeOffset: rangeOffset,\n        rangeLength: rangeLength,\n        text: text\n      }],\n      eol: this._buffer.getEOL(),\n      versionId: this.getVersionId(),\n      isUndoing: isUndoing,\n      isRedoing: isRedoing,\n      isFlush: isFlush\n    };\n  }\n  _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n    this._assertNotDisposed();\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    this._buffer = textBuffer;\n    this._bufferDisposable.dispose();\n    this._bufferDisposable = textBufferDisposable;\n    this._increaseVersionId();\n    // Flush all tokens\n    this._tokens.flush();\n    this._tokens2.flush();\n    // Destroy all my decorations\n    this._decorations = Object.create(null);\n    this._decorationsTree = new DecorationsTrees();\n    // Destroy my edit history and settings\n    this._commandManager.clear();\n    this._trimAutoWhitespaceLines = null;\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawFlush()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n  }\n  setEOL(eol) {\n    this._assertNotDisposed();\n    const newEOL = eol === 1 /* CRLF */ ? '\\r\\n' : '\\n';\n    if (this._buffer.getEOL() === newEOL) {\n      // Nothing to do\n      return;\n    }\n    const oldFullModelRange = this.getFullModelRange();\n    const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n    const endLineNumber = this.getLineCount();\n    const endColumn = this.getLineMaxColumn(endLineNumber);\n    this._onBeforeEOLChange();\n    this._buffer.setEOL(newEOL);\n    this._increaseVersionId();\n    this._onAfterEOLChange();\n    this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawEOLChanged()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n  }\n  _onBeforeEOLChange() {\n    // Ensure all decorations get their `range` set.\n    const versionId = this.getVersionId();\n    const allDecorations = this._decorationsTree.search(0, false, false, versionId);\n    this._ensureNodesHaveRanges(allDecorations);\n  }\n  _onAfterEOLChange() {\n    // Transform back `range` to offsets\n    const versionId = this.getVersionId();\n    const allDecorations = this._decorationsTree.collectNodesPostOrder();\n    for (let i = 0, len = allDecorations.length; i < len; i++) {\n      const node = allDecorations[i];\n      const delta = node.cachedAbsoluteStart - node.start;\n      const startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);\n      const endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);\n      node.cachedAbsoluteStart = startOffset;\n      node.cachedAbsoluteEnd = endOffset;\n      node.cachedVersionId = versionId;\n      node.start = startOffset - delta;\n      node.end = endOffset - delta;\n      recomputeMaxEnd(node);\n    }\n  }\n  onBeforeAttached() {\n    this._attachedEditorCount++;\n    if (this._attachedEditorCount === 1) {\n      this._onDidChangeAttached.fire(undefined);\n    }\n  }\n  onBeforeDetached() {\n    this._attachedEditorCount--;\n    if (this._attachedEditorCount === 0) {\n      this._onDidChangeAttached.fire(undefined);\n    }\n  }\n  isAttachedToEditor() {\n    return this._attachedEditorCount > 0;\n  }\n  getAttachedEditorCount() {\n    return this._attachedEditorCount;\n  }\n  isTooLargeForSyncing() {\n    return this._isTooLargeForSyncing;\n  }\n  isTooLargeForTokenization() {\n    return this._isTooLargeForTokenization;\n  }\n  isDisposed() {\n    return this._isDisposed;\n  }\n  isDominatedByLongLines() {\n    this._assertNotDisposed();\n    if (this.isTooLargeForTokenization()) {\n      // Cannot word wrap huge files anyways, so it doesn't really matter\n      return false;\n    }\n    let smallLineCharCount = 0;\n    let longLineCharCount = 0;\n    const lineCount = this._buffer.getLineCount();\n    for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n      const lineLength = this._buffer.getLineLength(lineNumber);\n      if (lineLength >= LONG_LINE_BOUNDARY) {\n        longLineCharCount += lineLength;\n      } else {\n        smallLineCharCount += lineLength;\n      }\n    }\n    return longLineCharCount > smallLineCharCount;\n  }\n  get uri() {\n    return this._associatedResource;\n  }\n  //#region Options\n  getOptions() {\n    this._assertNotDisposed();\n    return this._options;\n  }\n  getFormattingOptions() {\n    return {\n      tabSize: this._options.indentSize,\n      insertSpaces: this._options.insertSpaces\n    };\n  }\n  updateOptions(_newOpts) {\n    this._assertNotDisposed();\n    let tabSize = typeof _newOpts.tabSize !== 'undefined' ? _newOpts.tabSize : this._options.tabSize;\n    let indentSize = typeof _newOpts.indentSize !== 'undefined' ? _newOpts.indentSize : this._options.indentSize;\n    let insertSpaces = typeof _newOpts.insertSpaces !== 'undefined' ? _newOpts.insertSpaces : this._options.insertSpaces;\n    let trimAutoWhitespace = typeof _newOpts.trimAutoWhitespace !== 'undefined' ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n    let newOpts = new model.TextModelResolvedOptions({\n      tabSize: tabSize,\n      indentSize: indentSize,\n      insertSpaces: insertSpaces,\n      defaultEOL: this._options.defaultEOL,\n      trimAutoWhitespace: trimAutoWhitespace\n    });\n    if (this._options.equals(newOpts)) {\n      return;\n    }\n    let e = this._options.createChangeEvent(newOpts);\n    this._options = newOpts;\n    this._onDidChangeOptions.fire(e);\n  }\n  detectIndentation(defaultInsertSpaces, defaultTabSize) {\n    this._assertNotDisposed();\n    let guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n    this.updateOptions({\n      insertSpaces: guessedIndentation.insertSpaces,\n      tabSize: guessedIndentation.tabSize,\n      indentSize: guessedIndentation.tabSize // TODO@Alex: guess indentSize independent of tabSize\n    });\n  }\n\n  static _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n      if (str.charAt(i) === '\\t') {\n        spacesCnt += indentSize;\n      } else {\n        spacesCnt++;\n      }\n    }\n    let result = '';\n    if (!insertSpaces) {\n      let tabsCnt = Math.floor(spacesCnt / indentSize);\n      spacesCnt = spacesCnt % indentSize;\n      for (let i = 0; i < tabsCnt; i++) {\n        result += '\\t';\n      }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n      result += ' ';\n    }\n    return result;\n  }\n  static normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n      firstNonWhitespaceIndex = str.length;\n    }\n    return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n  }\n  normalizeIndentation(str) {\n    this._assertNotDisposed();\n    return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n  }\n  //#endregion\n  //#region Reading\n  getVersionId() {\n    this._assertNotDisposed();\n    return this._versionId;\n  }\n  mightContainRTL() {\n    return this._buffer.mightContainRTL();\n  }\n  mightContainUnusualLineTerminators() {\n    return this._buffer.mightContainUnusualLineTerminators();\n  }\n  removeUnusualLineTerminators() {\n    let selections = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\n    this._buffer.resetMightContainUnusualLineTerminators();\n    this.pushEditOperations(selections, matches.map(m => ({\n      range: m.range,\n      text: null\n    })), () => null);\n  }\n  mightContainNonBasicASCII() {\n    return this._buffer.mightContainNonBasicASCII();\n  }\n  getAlternativeVersionId() {\n    this._assertNotDisposed();\n    return this._alternativeVersionId;\n  }\n  getInitialUndoRedoSnapshot() {\n    this._assertNotDisposed();\n    return this._initialUndoRedoSnapshot;\n  }\n  getOffsetAt(rawPosition) {\n    this._assertNotDisposed();\n    let position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* Relaxed */);\n    return this._buffer.getOffsetAt(position.lineNumber, position.column);\n  }\n  getPositionAt(rawOffset) {\n    this._assertNotDisposed();\n    let offset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));\n    return this._buffer.getPositionAt(offset);\n  }\n  _increaseVersionId() {\n    this._versionId = this._versionId + 1;\n    this._alternativeVersionId = this._versionId;\n  }\n  _overwriteVersionId(versionId) {\n    this._versionId = versionId;\n  }\n  _overwriteAlternativeVersionId(newAlternativeVersionId) {\n    this._alternativeVersionId = newAlternativeVersionId;\n  }\n  _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n    this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n  }\n  getValue(eol) {\n    let preserveBOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this._assertNotDisposed();\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueInRange(fullModelRange, eol);\n    if (preserveBOM) {\n      return this._buffer.getBOM() + fullModelValue;\n    }\n    return fullModelValue;\n  }\n  createSnapshot() {\n    let preserveBOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n  }\n  getValueLength(eol) {\n    let preserveBOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this._assertNotDisposed();\n    const fullModelRange = this.getFullModelRange();\n    const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n    if (preserveBOM) {\n      return this._buffer.getBOM().length + fullModelValue;\n    }\n    return fullModelValue;\n  }\n  getValueInRange(rawRange) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertNotDisposed();\n    return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n  }\n  getValueLengthInRange(rawRange) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertNotDisposed();\n    return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n  }\n  getCharacterCountInRange(rawRange) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertNotDisposed();\n    return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n  }\n  getLineCount() {\n    this._assertNotDisposed();\n    return this._buffer.getLineCount();\n  }\n  getLineContent(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineContent(lineNumber);\n  }\n  getLineLength(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLength(lineNumber);\n  }\n  getLinesContent() {\n    this._assertNotDisposed();\n    return this._buffer.getLinesContent();\n  }\n  getEOL() {\n    this._assertNotDisposed();\n    return this._buffer.getEOL();\n  }\n  getEndOfLineSequence() {\n    this._assertNotDisposed();\n    return this._buffer.getEOL() === '\\n' ? 0 /* LF */ : 1 /* CRLF */;\n  }\n\n  getLineMinColumn(lineNumber) {\n    this._assertNotDisposed();\n    return 1;\n  }\n  getLineMaxColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLength(lineNumber) + 1;\n  }\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n  }\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    this._assertNotDisposed();\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n  }\n  /**\r\n   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\r\n   * Will try to not allocate if possible.\r\n   */\n  _validateRangeRelaxedNoAllocations(range) {\n    const linesCount = this._buffer.getLineCount();\n    const initialStartLineNumber = range.startLineNumber;\n    const initialStartColumn = range.startColumn;\n    let startLineNumber;\n    let startColumn;\n    if (initialStartLineNumber < 1) {\n      startLineNumber = 1;\n      startColumn = 1;\n    } else if (initialStartLineNumber > linesCount) {\n      startLineNumber = linesCount;\n      startColumn = this.getLineMaxColumn(startLineNumber);\n    } else {\n      startLineNumber = initialStartLineNumber | 0;\n      if (initialStartColumn <= 1) {\n        startColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(startLineNumber);\n        if (initialStartColumn >= maxColumn) {\n          startColumn = maxColumn;\n        } else {\n          startColumn = initialStartColumn | 0;\n        }\n      }\n    }\n    const initialEndLineNumber = range.endLineNumber;\n    const initialEndColumn = range.endColumn;\n    let endLineNumber;\n    let endColumn;\n    if (initialEndLineNumber < 1) {\n      endLineNumber = 1;\n      endColumn = 1;\n    } else if (initialEndLineNumber > linesCount) {\n      endLineNumber = linesCount;\n      endColumn = this.getLineMaxColumn(endLineNumber);\n    } else {\n      endLineNumber = initialEndLineNumber | 0;\n      if (initialEndColumn <= 1) {\n        endColumn = 1;\n      } else {\n        const maxColumn = this.getLineMaxColumn(endLineNumber);\n        if (initialEndColumn >= maxColumn) {\n          endColumn = maxColumn;\n        } else {\n          endColumn = initialEndColumn | 0;\n        }\n      }\n    }\n    if (initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && initialEndLineNumber === endLineNumber && initialEndColumn === endColumn && range instanceof Range && !(range instanceof Selection)) {\n      return range;\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  _isValidPosition(lineNumber, column, validationType) {\n    if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n      return false;\n    }\n    if (isNaN(lineNumber) || isNaN(column)) {\n      return false;\n    }\n    if (lineNumber < 1 || column < 1) {\n      return false;\n    }\n    if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n      return false;\n    }\n    const lineCount = this._buffer.getLineCount();\n    if (lineNumber > lineCount) {\n      return false;\n    }\n    if (column === 1) {\n      return true;\n    }\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n    if (column > maxColumn) {\n      return false;\n    }\n    if (validationType === 1 /* SurrogatePairs */) {\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _validatePosition(_lineNumber, _column, validationType) {\n    const lineNumber = Math.floor(typeof _lineNumber === 'number' && !isNaN(_lineNumber) ? _lineNumber : 1);\n    const column = Math.floor(typeof _column === 'number' && !isNaN(_column) ? _column : 1);\n    const lineCount = this._buffer.getLineCount();\n    if (lineNumber < 1) {\n      return new Position(1, 1);\n    }\n    if (lineNumber > lineCount) {\n      return new Position(lineCount, this.getLineMaxColumn(lineCount));\n    }\n    if (column <= 1) {\n      return new Position(lineNumber, 1);\n    }\n    const maxColumn = this.getLineMaxColumn(lineNumber);\n    if (column >= maxColumn) {\n      return new Position(lineNumber, maxColumn);\n    }\n    if (validationType === 1 /* SurrogatePairs */) {\n      // If the position would end up in the middle of a high-low surrogate pair,\n      // we move it to before the pair\n      // !!At this point, column > 1\n      const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n      if (strings.isHighSurrogate(charCodeBefore)) {\n        return new Position(lineNumber, column - 1);\n      }\n    }\n    return new Position(lineNumber, column);\n  }\n  validatePosition(position) {\n    const validationType = 1 /* SurrogatePairs */;\n    this._assertNotDisposed();\n    // Avoid object allocation and cover most likely case\n    if (position instanceof Position) {\n      if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n        return position;\n      }\n    }\n    return this._validatePosition(position.lineNumber, position.column, validationType);\n  }\n  _isValidRange(range, validationType) {\n    const startLineNumber = range.startLineNumber;\n    const startColumn = range.startColumn;\n    const endLineNumber = range.endLineNumber;\n    const endColumn = range.endColumn;\n    if (!this._isValidPosition(startLineNumber, startColumn, 0 /* Relaxed */)) {\n      return false;\n    }\n    if (!this._isValidPosition(endLineNumber, endColumn, 0 /* Relaxed */)) {\n      return false;\n    }\n    if (validationType === 1 /* SurrogatePairs */) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return true;\n      }\n      return false;\n    }\n    return true;\n  }\n  validateRange(_range) {\n    const validationType = 1 /* SurrogatePairs */;\n    this._assertNotDisposed();\n    // Avoid object allocation and cover most likely case\n    if (_range instanceof Range && !(_range instanceof Selection)) {\n      if (this._isValidRange(_range, validationType)) {\n        return _range;\n      }\n    }\n    const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* Relaxed */);\n    const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* Relaxed */);\n    const startLineNumber = start.lineNumber;\n    const startColumn = start.column;\n    const endLineNumber = end.lineNumber;\n    const endColumn = end.column;\n    if (validationType === 1 /* SurrogatePairs */) {\n      const charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n      const charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n      const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n      const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n      if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      }\n      if (startLineNumber === endLineNumber && startColumn === endColumn) {\n        // do not expand a collapsed range, simply move it to a valid location\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n      }\n      if (startInsideSurrogatePair && endInsideSurrogatePair) {\n        // expand range at both ends\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n      }\n      if (startInsideSurrogatePair) {\n        // only expand range at the start\n        return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n      }\n      // only expand range at the end\n      return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n    }\n    return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n  }\n  modifyPosition(rawPosition, offset) {\n    this._assertNotDisposed();\n    let candidate = this.getOffsetAt(rawPosition) + offset;\n    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n  }\n  getFullModelRange() {\n    this._assertNotDisposed();\n    const lineCount = this.getLineCount();\n    return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n  }\n  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n    return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  }\n  findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches) {\n    let limitResultCount = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : LIMIT_FIND_COUNT;\n    this._assertNotDisposed();\n    let searchRanges = null;\n    if (rawSearchScope !== null) {\n      if (!Array.isArray(rawSearchScope)) {\n        rawSearchScope = [rawSearchScope];\n      }\n      if (rawSearchScope.every(searchScope => Range.isIRange(searchScope))) {\n        searchRanges = rawSearchScope.map(searchScope => this.validateRange(searchScope));\n      }\n    }\n    if (searchRanges === null) {\n      searchRanges = [this.getFullModelRange()];\n    }\n    searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n    const uniqueSearchRanges = [];\n    uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n      if (Range.areIntersecting(prev, curr)) {\n        return prev.plusRange(curr);\n      }\n      uniqueSearchRanges.push(prev);\n      return curr;\n    }));\n    let matchMapper;\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      // not regex, not multi line\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return [];\n      }\n      matchMapper = searchRange => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    } else {\n      matchMapper = searchRange => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n    }\n    return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n  }\n  findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n    const searchStart = this.validatePosition(rawSearchStart);\n    if (!isRegex && searchString.indexOf('\\n') < 0) {\n      const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n      const searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return null;\n      }\n      const lineCount = this.getLineCount();\n      let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n      let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n      if (ret.length > 0) {\n        return ret[0];\n      }\n      searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n      ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n      if (ret.length > 0) {\n        return ret[0];\n      }\n      return null;\n    }\n    return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }\n  findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n    this._assertNotDisposed();\n    const searchStart = this.validatePosition(rawSearchStart);\n    return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n  }\n  //#endregion\n  //#region Editing\n  pushStackElement() {\n    this._commandManager.pushStackElement();\n  }\n  popStackElement() {\n    this._commandManager.popStackElement();\n  }\n  pushEOL(eol) {\n    const currentEOL = this.getEOL() === '\\n' ? 0 /* LF */ : 1 /* CRLF */;\n    if (currentEOL === eol) {\n      return;\n    }\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      if (this._initialUndoRedoSnapshot === null) {\n        this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n      }\n      this._commandManager.pushEOL(eol);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _validateEditOperation(rawOperation) {\n    if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n      return rawOperation;\n    }\n    return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n  }\n  _validateEditOperations(rawOperations) {\n    const result = [];\n    for (let i = 0, len = rawOperations.length; i < len; i++) {\n      result[i] = this._validateEditOperation(rawOperations[i]);\n    }\n    return result;\n  }\n  pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n      // Go through each saved line number and insert a trim whitespace edit\n      // if it is safe to do so (no conflicts with other edits).\n      let incomingEdits = editOperations.map(op => {\n        return {\n          range: this.validateRange(op.range),\n          text: op.text\n        };\n      });\n      // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n      // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n      let editsAreNearCursors = true;\n      if (beforeCursorState) {\n        for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n          let sel = beforeCursorState[i];\n          let foundEditNearSel = false;\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            let editRange = incomingEdits[j].range;\n            let selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n            let selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n            if (!selIsAbove && !selIsBelow) {\n              foundEditNearSel = true;\n              break;\n            }\n          }\n          if (!foundEditNearSel) {\n            editsAreNearCursors = false;\n            break;\n          }\n        }\n      }\n      if (editsAreNearCursors) {\n        for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n          let trimLineNumber = this._trimAutoWhitespaceLines[i];\n          let maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n          let allowTrimLine = true;\n          for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n            let editRange = incomingEdits[j].range;\n            let editText = incomingEdits[j].text;\n            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n              // `trimLine` is completely outside this edit\n              continue;\n            }\n            // At this point:\n            //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n              // This edit inserts a new line (and maybe other text) after `trimLine`\n              continue;\n            }\n            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1 && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n              // This edit inserts a new line (and maybe other text) before `trimLine`\n              continue;\n            }\n            // Looks like we can't trim this line as it would interfere with an incoming edit\n            allowTrimLine = false;\n            break;\n          }\n          if (allowTrimLine) {\n            const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n            editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n          }\n        }\n      }\n      this._trimAutoWhitespaceLines = null;\n    }\n    if (this._initialUndoRedoSnapshot === null) {\n      this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n    }\n    return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n  }\n  _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.newPosition);\n      const rangeEnd = this.getPositionAt(change.newEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.oldText\n      };\n    });\n    this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n  }\n  _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n    const edits = changes.map(change => {\n      const rangeStart = this.getPositionAt(change.oldPosition);\n      const rangeEnd = this.getPositionAt(change.oldEnd);\n      return {\n        range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n        text: change.newText\n      };\n    });\n    this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n  }\n  _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      this._isUndoing = isUndoing;\n      this._isRedoing = isRedoing;\n      this.applyEdits(edits, false);\n      this.setEOL(eol);\n      this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n    } finally {\n      this._isUndoing = false;\n      this._isRedoing = false;\n      this._eventEmitter.endDeferredEmit(resultingSelection);\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  applyEdits(rawOperations) {\n    let computeUndoEdits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      this._eventEmitter.beginDeferredEmit();\n      const operations = this._validateEditOperations(rawOperations);\n      return this._doApplyEdits(operations, computeUndoEdits);\n    } finally {\n      this._eventEmitter.endDeferredEmit();\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _doApplyEdits(rawOperations, computeUndoEdits) {\n    const oldLineCount = this._buffer.getLineCount();\n    const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n    const newLineCount = this._buffer.getLineCount();\n    const contentChanges = result.changes;\n    this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n    if (contentChanges.length !== 0) {\n      let rawContentChanges = [];\n      let lineCount = oldLineCount;\n      for (let i = 0, len = contentChanges.length; i < len; i++) {\n        const change = contentChanges[i];\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\n        this._tokens.acceptEdit(change.range, eolCount, firstLineLength);\n        this._tokens2.acceptEdit(change.range, eolCount, firstLineLength, lastLineLength, change.text.length > 0 ? change.text.charCodeAt(0) : 0 /* Null */);\n        this._onDidChangeDecorations.fire();\n        this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n        const startLineNumber = change.range.startLineNumber;\n        const endLineNumber = change.range.endLineNumber;\n        const deletingLinesCnt = endLineNumber - startLineNumber;\n        const insertingLinesCnt = eolCount;\n        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n        const changeLineCountDelta = insertingLinesCnt - deletingLinesCnt;\n        for (let j = editingLinesCnt; j >= 0; j--) {\n          const editLineNumber = startLineNumber + j;\n          const currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;\n          rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));\n        }\n        if (editingLinesCnt < deletingLinesCnt) {\n          // Must delete some lines\n          const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n          rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n        }\n        if (editingLinesCnt < insertingLinesCnt) {\n          // Must insert some lines\n          const spliceLineNumber = startLineNumber + editingLinesCnt;\n          const cnt = insertingLinesCnt - editingLinesCnt;\n          const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n          let newLines = [];\n          for (let i = 0; i < cnt; i++) {\n            let lineNumber = fromLineNumber + i;\n            newLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);\n          }\n          rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));\n        }\n        lineCount += changeLineCountDelta;\n      }\n      this._increaseVersionId();\n      this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n        changes: contentChanges,\n        eol: this._buffer.getEOL(),\n        versionId: this.getVersionId(),\n        isUndoing: this._isUndoing,\n        isRedoing: this._isRedoing,\n        isFlush: false\n      });\n    }\n    return result.reverseEdits === null ? undefined : result.reverseEdits;\n  }\n  undo() {\n    return this._undoRedoService.undo(this.uri);\n  }\n  canUndo() {\n    return this._undoRedoService.canUndo(this.uri);\n  }\n  redo() {\n    return this._undoRedoService.redo(this.uri);\n  }\n  canRedo() {\n    return this._undoRedoService.canRedo(this.uri);\n  }\n  //#endregion\n  //#region Decorations\n  changeDecorations(callback) {\n    let ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._assertNotDisposed();\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      return this._changeDecorations(ownerId, callback);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _changeDecorations(ownerId, callback) {\n    let changeAccessor = {\n      addDecoration: (range, options) => {\n        return this._deltaDecorationsImpl(ownerId, [], [{\n          range: range,\n          options: options\n        }])[0];\n      },\n      changeDecoration: (id, newRange) => {\n        this._changeDecorationImpl(id, newRange);\n      },\n      changeDecorationOptions: (id, options) => {\n        this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n      },\n      removeDecoration: id => {\n        this._deltaDecorationsImpl(ownerId, [id], []);\n      },\n      deltaDecorations: (oldDecorations, newDecorations) => {\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n          // nothing to do\n          return [];\n        }\n        return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n      }\n    };\n    let result = null;\n    try {\n      result = callback(changeAccessor);\n    } catch (e) {\n      onUnexpectedError(e);\n    }\n    // Invalidate change accessor\n    changeAccessor.addDecoration = invalidFunc;\n    changeAccessor.changeDecoration = invalidFunc;\n    changeAccessor.changeDecorationOptions = invalidFunc;\n    changeAccessor.removeDecoration = invalidFunc;\n    changeAccessor.deltaDecorations = invalidFunc;\n    return result;\n  }\n  deltaDecorations(oldDecorations, newDecorations) {\n    let ownerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._assertNotDisposed();\n    if (!oldDecorations) {\n      oldDecorations = [];\n    }\n    if (oldDecorations.length === 0 && newDecorations.length === 0) {\n      // nothing to do\n      return [];\n    }\n    try {\n      this._onDidChangeDecorations.beginDeferredEmit();\n      return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n    } finally {\n      this._onDidChangeDecorations.endDeferredEmit();\n    }\n  }\n  _getTrackedRange(id) {\n    return this.getDecorationRange(id);\n  }\n  _setTrackedRange(id, newRange, newStickiness) {\n    const node = id ? this._decorations[id] : null;\n    if (!node) {\n      if (!newRange) {\n        // node doesn't exist, the request is to delete => nothing to do\n        return null;\n      }\n      // node doesn't exist, the request is to set => add the tracked range\n      return this._deltaDecorationsImpl(0, [], [{\n        range: newRange,\n        options: TRACKED_RANGE_OPTIONS[newStickiness]\n      }])[0];\n    }\n    if (!newRange) {\n      // node exists, the request is to delete => delete node\n      this._decorationsTree.delete(node);\n      delete this._decorations[node.id];\n      return null;\n    }\n    // node exists, the request is to set => change the tracked range and its options\n    const range = this._validateRangeRelaxedNoAllocations(newRange);\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n    this._decorationsTree.delete(node);\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n    this._decorationsTree.insert(node);\n    return node.id;\n  }\n  removeAllDecorationsWithOwnerId(ownerId) {\n    if (this._isDisposed) {\n      return;\n    }\n    const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n    for (let i = 0, len = nodes.length; i < len; i++) {\n      const node = nodes[i];\n      this._decorationsTree.delete(node);\n      delete this._decorations[node.id];\n    }\n  }\n  getDecorationOptions(decorationId) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return null;\n    }\n    return node.options;\n  }\n  getDecorationRange(decorationId) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return null;\n    }\n    const versionId = this.getVersionId();\n    if (node.cachedVersionId !== versionId) {\n      this._decorationsTree.resolveNode(node, versionId);\n    }\n    if (node.range === null) {\n      node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n    }\n    return node.range;\n  }\n  getLineDecorations(lineNumber) {\n    let ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let filterOutValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      return [];\n    }\n    return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n  }\n  getLinesDecorations(_startLineNumber, _endLineNumber) {\n    let ownerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let filterOutValidation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let lineCount = this.getLineCount();\n    let startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n    let endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n    let endColumn = this.getLineMaxColumn(endLineNumber);\n    return this._getDecorationsInRange(new Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);\n  }\n  getDecorationsInRange(range) {\n    let ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let filterOutValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let validatedRange = this.validateRange(range);\n    return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n  }\n  getOverviewRulerDecorations() {\n    let ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let filterOutValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const versionId = this.getVersionId();\n    const result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);\n    return this._ensureNodesHaveRanges(result);\n  }\n  getAllDecorations() {\n    let ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let filterOutValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const versionId = this.getVersionId();\n    const result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);\n    return this._ensureNodesHaveRanges(result);\n  }\n  _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n    const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n    const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n    const versionId = this.getVersionId();\n    const result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);\n    return this._ensureNodesHaveRanges(result);\n  }\n  _ensureNodesHaveRanges(nodes) {\n    for (let i = 0, len = nodes.length; i < len; i++) {\n      const node = nodes[i];\n      if (node.range === null) {\n        node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n      }\n    }\n    return nodes;\n  }\n  _getRangeAt(start, end) {\n    return this._buffer.getRangeAt(start, end - start);\n  }\n  _changeDecorationImpl(decorationId, _range) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return;\n    }\n    const range = this._validateRangeRelaxedNoAllocations(_range);\n    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n    this._decorationsTree.delete(node);\n    node.reset(this.getVersionId(), startOffset, endOffset, range);\n    this._decorationsTree.insert(node);\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n  }\n  _changeDecorationOptionsImpl(decorationId, options) {\n    const node = this._decorations[decorationId];\n    if (!node) {\n      return;\n    }\n    const nodeWasInOverviewRuler = node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n    const nodeIsInOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n    this._onDidChangeDecorations.checkAffectedAndFire(options);\n    if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n      // Delete + Insert due to an overview ruler status change\n      this._decorationsTree.delete(node);\n      node.setOptions(options);\n      this._decorationsTree.insert(node);\n    } else {\n      node.setOptions(options);\n    }\n  }\n  _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n    const versionId = this.getVersionId();\n    const oldDecorationsLen = oldDecorationsIds.length;\n    let oldDecorationIndex = 0;\n    const newDecorationsLen = newDecorations.length;\n    let newDecorationIndex = 0;\n    let result = new Array(newDecorationsLen);\n    while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n      let node = null;\n      if (oldDecorationIndex < oldDecorationsLen) {\n        // (1) get ourselves an old node\n        do {\n          node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n        } while (!node && oldDecorationIndex < oldDecorationsLen);\n        // (2) remove the node from the tree (if it exists)\n        if (node) {\n          this._decorationsTree.delete(node);\n          this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        }\n      }\n      if (newDecorationIndex < newDecorationsLen) {\n        // (3) create a new node if necessary\n        if (!node) {\n          const internalDecorationId = ++this._lastDecorationId;\n          const decorationId = \"\".concat(this._instanceId, \";\").concat(internalDecorationId);\n          node = new IntervalNode(decorationId, 0, 0);\n          this._decorations[decorationId] = node;\n        }\n        // (4) initialize node\n        const newDecoration = newDecorations[newDecorationIndex];\n        const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n        const options = _normalizeOptions(newDecoration.options);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        node.ownerId = ownerId;\n        node.reset(versionId, startOffset, endOffset, range);\n        node.setOptions(options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        this._decorationsTree.insert(node);\n        result[newDecorationIndex] = node.id;\n        newDecorationIndex++;\n      } else {\n        if (node) {\n          delete this._decorations[node.id];\n        }\n      }\n    }\n    return result;\n  }\n  setTokens(tokens) {\n    if (tokens.length === 0) {\n      return;\n    }\n    let ranges = [];\n    for (let i = 0, len = tokens.length; i < len; i++) {\n      const element = tokens[i];\n      let minChangedLineNumber = 0;\n      let maxChangedLineNumber = 0;\n      let hasChange = false;\n      for (let j = 0, lenJ = element.tokens.length; j < lenJ; j++) {\n        const lineNumber = element.startLineNumber + j;\n        if (hasChange) {\n          this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], false);\n          maxChangedLineNumber = lineNumber;\n        } else {\n          const lineHasChange = this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], true);\n          if (lineHasChange) {\n            hasChange = true;\n            minChangedLineNumber = lineNumber;\n            maxChangedLineNumber = lineNumber;\n          }\n        }\n      }\n      if (hasChange) {\n        ranges.push({\n          fromLineNumber: minChangedLineNumber,\n          toLineNumber: maxChangedLineNumber\n        });\n      }\n    }\n    if (ranges.length > 0) {\n      this._emitModelTokensChangedEvent({\n        tokenizationSupportChanged: false,\n        semanticTokensApplied: false,\n        ranges: ranges\n      });\n    }\n  }\n  setSemanticTokens(tokens, isComplete) {\n    this._tokens2.set(tokens, isComplete);\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: false,\n      semanticTokensApplied: tokens !== null,\n      ranges: [{\n        fromLineNumber: 1,\n        toLineNumber: this.getLineCount()\n      }]\n    });\n  }\n  hasCompleteSemanticTokens() {\n    return this._tokens2.isComplete();\n  }\n  hasSomeSemanticTokens() {\n    return !this._tokens2.isEmpty();\n  }\n  setPartialSemanticTokens(range, tokens) {\n    if (this.hasCompleteSemanticTokens()) {\n      return;\n    }\n    const changedRange = this._tokens2.setPartial(range, tokens);\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: false,\n      semanticTokensApplied: true,\n      ranges: [{\n        fromLineNumber: changedRange.startLineNumber,\n        toLineNumber: changedRange.endLineNumber\n      }]\n    });\n  }\n  tokenizeViewport(startLineNumber, endLineNumber) {\n    startLineNumber = Math.max(1, startLineNumber);\n    endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);\n    this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\n  }\n  clearTokens() {\n    this._tokens.flush();\n    this._emitModelTokensChangedEvent({\n      tokenizationSupportChanged: true,\n      semanticTokensApplied: false,\n      ranges: [{\n        fromLineNumber: 1,\n        toLineNumber: this._buffer.getLineCount()\n      }]\n    });\n  }\n  _emitModelTokensChangedEvent(e) {\n    if (!this._isDisposing) {\n      this._onDidChangeTokens.fire(e);\n    }\n  }\n  resetTokenization() {\n    this._tokenization.reset();\n  }\n  forceTokenization(lineNumber) {\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    this._tokenization.forceTokenization(lineNumber);\n  }\n  isCheapToTokenize(lineNumber) {\n    return this._tokenization.isCheapToTokenize(lineNumber);\n  }\n  tokenizeIfCheap(lineNumber) {\n    if (this.isCheapToTokenize(lineNumber)) {\n      this.forceTokenization(lineNumber);\n    }\n  }\n  getLineTokens(lineNumber) {\n    if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    return this._getLineTokens(lineNumber);\n  }\n  _getLineTokens(lineNumber) {\n    const lineText = this.getLineContent(lineNumber);\n    const syntacticTokens = this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);\n    return this._tokens2.addSemanticTokens(lineNumber, syntacticTokens);\n  }\n  getLanguageIdentifier() {\n    return this._languageIdentifier;\n  }\n  getModeId() {\n    return this._languageIdentifier.language;\n  }\n  setMode(languageIdentifier) {\n    if (this._languageIdentifier.id === languageIdentifier.id) {\n      // There's nothing to do\n      return;\n    }\n    let e = {\n      oldLanguage: this._languageIdentifier.language,\n      newLanguage: languageIdentifier.language\n    };\n    this._languageIdentifier = languageIdentifier;\n    this._onDidChangeLanguage.fire(e);\n    this._onDidChangeLanguageConfiguration.fire({});\n  }\n  getLanguageIdAtPosition(lineNumber, column) {\n    const position = this.validatePosition(new Position(lineNumber, column));\n    const lineTokens = this.getLineTokens(position.lineNumber);\n    return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n  }\n  // Having tokens allows implementing additional helper methods\n  getWordAtPosition(_position) {\n    this._assertNotDisposed();\n    const position = this.validatePosition(_position);\n    const lineContent = this.getLineContent(position.lineNumber);\n    const lineTokens = this._getLineTokens(position.lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    // (1). First try checking right biased word\n    const [rbStartOffset, rbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex);\n    const rightBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n    // Make sure the result touches the original passed in position\n    if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n      return rightBiasedWord;\n    }\n    // (2). Else, if we were at a language boundary, check the left biased word\n    if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n      // edge case, where `position` sits between two tokens belonging to two different languages\n      const [lbStartOffset, lbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n      const leftBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n      // Make sure the result touches the original passed in position\n      if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n        return leftBiasedWord;\n      }\n    }\n    return null;\n  }\n  static _findLanguageBoundaries(lineTokens, tokenIndex) {\n    const languageId = lineTokens.getLanguageId(tokenIndex);\n    // go left until a different language is hit\n    let startOffset = 0;\n    for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n      startOffset = lineTokens.getStartOffset(i);\n    }\n    // go right until a different language is hit\n    let endOffset = lineTokens.getLineContent().length;\n    for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n      endOffset = lineTokens.getEndOffset(i);\n    }\n    return [startOffset, endOffset];\n  }\n  getWordUntilPosition(position) {\n    const wordAtPosition = this.getWordAtPosition(position);\n    if (!wordAtPosition) {\n      return {\n        word: '',\n        startColumn: position.column,\n        endColumn: position.column\n      };\n    }\n    return {\n      word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n      startColumn: wordAtPosition.startColumn,\n      endColumn: position.column\n    };\n  }\n  findMatchingBracketUp(_bracket, _position) {\n    let bracket = _bracket.toLowerCase();\n    let position = this.validatePosition(_position);\n    let lineTokens = this._getLineTokens(position.lineNumber);\n    let languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    let bracketsSupport = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n    if (!bracketsSupport) {\n      return null;\n    }\n    let data = bracketsSupport.textIsBracket[bracket];\n    if (!data) {\n      return null;\n    }\n    return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, null));\n  }\n  matchBracket(position) {\n    return this._matchBracket(this.validatePosition(position));\n  }\n  _matchBracket(position) {\n    const lineNumber = position.lineNumber;\n    const lineTokens = this._getLineTokens(lineNumber);\n    const tokenCount = lineTokens.getCount();\n    const lineText = this._buffer.getLineContent(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    if (tokenIndex < 0) {\n      return null;\n    }\n    const currentModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));\n    // check that the token is not to be ignored\n    if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n      // limit search to not go before `maxBracketLength`\n      let searchStartOffset = Math.max(0, position.column - 1 - currentModeBrackets.maxBracketLength);\n      for (let i = tokenIndex - 1; i >= 0; i--) {\n        const tokenEndOffset = lineTokens.getEndOffset(i);\n        if (tokenEndOffset <= searchStartOffset) {\n          break;\n        }\n        if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i))) {\n          searchStartOffset = tokenEndOffset;\n        }\n      }\n      // limit search to not go after `maxBracketLength`\n      const searchEndOffset = Math.min(lineText.length, position.column - 1 + currentModeBrackets.maxBracketLength);\n      // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n      // `bestResult` will contain the most right-side result\n      let bestResult = null;\n      while (true) {\n        const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (!foundBracket) {\n          // there are no more brackets in this text\n          break;\n        }\n        // check that we didn't hit a bracket too far away from position\n        if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n          const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], null);\n          if (r) {\n            if (r instanceof BracketSearchCanceled) {\n              return null;\n            }\n            bestResult = r;\n          }\n        }\n        searchStartOffset = foundBracket.endColumn - 1;\n      }\n      if (bestResult) {\n        return bestResult;\n      }\n    }\n    // If position is in between two tokens, try also looking in the previous token\n    if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n      const prevTokenIndex = tokenIndex - 1;\n      const prevModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(prevTokenIndex));\n      // check that previous token is not to be ignored\n      if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n        // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`\n        const searchStartOffset = Math.max(0, position.column - 1 - prevModeBrackets.maxBracketLength);\n        let searchEndOffset = Math.min(lineText.length, position.column - 1 + prevModeBrackets.maxBracketLength);\n        for (let i = prevTokenIndex + 1; i < tokenCount; i++) {\n          const tokenStartOffset = lineTokens.getStartOffset(i);\n          if (tokenStartOffset >= searchEndOffset) {\n            break;\n          }\n          if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i))) {\n            searchEndOffset = tokenStartOffset;\n          }\n        }\n        const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        // check that we didn't hit a bracket too far away from position\n        if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n          const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n          const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], null);\n          if (r) {\n            if (r instanceof BracketSearchCanceled) {\n              return null;\n            }\n            return r;\n          }\n        }\n      }\n    }\n    return null;\n  }\n  _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n    if (!data) {\n      return null;\n    }\n    const matched = isOpen ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate) : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate);\n    if (!matched) {\n      return null;\n    }\n    if (matched instanceof BracketSearchCanceled) {\n      return matched;\n    }\n    return [foundBracket, matched];\n  }\n  _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n    // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n    const languageId = bracket.languageIdentifier.id;\n    const reversedBracketRegex = bracket.reversedRegex;\n    let count = -1;\n    let totalCallCount = 0;\n    const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (!r) {\n          break;\n        }\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        if (bracket.isOpen(hitText)) {\n          count++;\n        } else if (bracket.isClose(hitText)) {\n          count--;\n        }\n        if (count === 0) {\n          return r;\n        }\n        searchEndOffset = r.startColumn - 1;\n      }\n      return null;\n    };\n    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n      const lineTokens = this._getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this._buffer.getLineContent(lineNumber);\n      let tokenIndex = tokenCount - 1;\n      let searchStartOffset = lineText.length;\n      let searchEndOffset = lineText.length;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex >= 0; tokenIndex--) {\n        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchStartOffset\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return r;\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    return null;\n  }\n  _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n    // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n    const languageId = bracket.languageIdentifier.id;\n    const bracketRegex = bracket.forwardRegex;\n    let count = 1;\n    let totalCallCount = 0;\n    const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n        const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (!r) {\n          break;\n        }\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        if (bracket.isOpen(hitText)) {\n          count++;\n        } else if (bracket.isClose(hitText)) {\n          count--;\n        }\n        if (count === 0) {\n          return r;\n        }\n        searchStartOffset = r.endColumn - 1;\n      }\n      return null;\n    };\n    const lineCount = this.getLineCount();\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this._getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this._buffer.getLineContent(lineNumber);\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return r;\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return r;\n        }\n      }\n    }\n    return null;\n  }\n  findPrevBracket(_position) {\n    const position = this.validatePosition(_position);\n    let languageId = -1;\n    let modeBrackets = null;\n    for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n      const lineTokens = this._getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this._buffer.getLineContent(lineNumber);\n      let tokenIndex = tokenCount - 1;\n      let searchStartOffset = lineText.length;\n      let searchEndOffset = lineText.length;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n        }\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex >= 0; tokenIndex--) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return this._toFoundBracket(modeBrackets, r);\n            }\n            prevSearchInToken = false;\n          }\n          languageId = tokenLanguageId;\n          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n        }\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchStartOffset\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return this._toFoundBracket(modeBrackets, r);\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return this._toFoundBracket(modeBrackets, r);\n        }\n      }\n    }\n    return null;\n  }\n  findNextBracket(_position) {\n    const position = this.validatePosition(_position);\n    const lineCount = this.getLineCount();\n    let languageId = -1;\n    let modeBrackets = null;\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this._getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this._buffer.getLineContent(lineNumber);\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n        }\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return this._toFoundBracket(modeBrackets, r);\n            }\n            prevSearchInToken = false;\n          }\n          languageId = tokenLanguageId;\n          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n        }\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return this._toFoundBracket(modeBrackets, r);\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return this._toFoundBracket(modeBrackets, r);\n        }\n      }\n    }\n    return null;\n  }\n  findEnclosingBrackets(_position, maxDuration) {\n    let continueSearchPredicate;\n    if (typeof maxDuration === 'undefined') {\n      continueSearchPredicate = null;\n    } else {\n      const startTime = Date.now();\n      continueSearchPredicate = () => {\n        return Date.now() - startTime <= maxDuration;\n      };\n    }\n    const position = this.validatePosition(_position);\n    const lineCount = this.getLineCount();\n    const savedCounts = new Map();\n    let counts = [];\n    const resetCounts = (languageId, modeBrackets) => {\n      if (!savedCounts.has(languageId)) {\n        let tmp = [];\n        for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n          tmp[i] = 0;\n        }\n        savedCounts.set(languageId, tmp);\n      }\n      counts = savedCounts.get(languageId);\n    };\n    let totalCallCount = 0;\n    const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n      while (true) {\n        if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n          return BracketSearchCanceled.INSTANCE;\n        }\n        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (!r) {\n          break;\n        }\n        const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const bracket = modeBrackets.textIsBracket[hitText];\n        if (bracket) {\n          if (bracket.isOpen(hitText)) {\n            counts[bracket.index]++;\n          } else if (bracket.isClose(hitText)) {\n            counts[bracket.index]--;\n          }\n          if (counts[bracket.index] === -1) {\n            return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n          }\n        }\n        searchStartOffset = r.endColumn - 1;\n      }\n      return null;\n    };\n    let languageId = -1;\n    let modeBrackets = null;\n    for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n      const lineTokens = this._getLineTokens(lineNumber);\n      const tokenCount = lineTokens.getCount();\n      const lineText = this._buffer.getLineContent(lineNumber);\n      let tokenIndex = 0;\n      let searchStartOffset = 0;\n      let searchEndOffset = 0;\n      if (lineNumber === position.lineNumber) {\n        tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        searchStartOffset = position.column - 1;\n        searchEndOffset = position.column - 1;\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          languageId = tokenLanguageId;\n          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n          resetCounts(languageId, modeBrackets);\n        }\n      }\n      let prevSearchInToken = true;\n      for (; tokenIndex < tokenCount; tokenIndex++) {\n        const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n        if (languageId !== tokenLanguageId) {\n          // language id change!\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return stripBracketSearchCanceled(r);\n            }\n            prevSearchInToken = false;\n          }\n          languageId = tokenLanguageId;\n          modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n          resetCounts(languageId, modeBrackets);\n        }\n        const searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n        if (searchInToken) {\n          // this token should be searched\n          if (prevSearchInToken) {\n            // the previous token should be searched, simply extend searchEndOffset\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          } else {\n            // the previous token should not be searched\n            searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n          }\n        } else {\n          // this token should not be searched\n          if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n            const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n            if (r) {\n              return stripBracketSearchCanceled(r);\n            }\n          }\n        }\n        prevSearchInToken = searchInToken;\n      }\n      if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n        if (r) {\n          return stripBracketSearchCanceled(r);\n        }\n      }\n    }\n    return null;\n  }\n  _toFoundBracket(modeBrackets, r) {\n    if (!r) {\n      return null;\n    }\n    let text = this.getValueInRange(r);\n    text = text.toLowerCase();\n    let data = modeBrackets.textIsBracket[text];\n    if (!data) {\n      return null;\n    }\n    return {\n      range: r,\n      open: data.open,\n      close: data.close,\n      isOpen: modeBrackets.textIsOpenBracket[text]\n    };\n  }\n  /**\r\n   * Returns:\r\n   *  - -1 => the line consists of whitespace\r\n   *  - otherwise => the indent level is returned value\r\n   */\n  static computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    let len = line.length;\n    while (i < len) {\n      let chCode = line.charCodeAt(i);\n      if (chCode === 32 /* Space */) {\n        indent++;\n      } else if (chCode === 9 /* Tab */) {\n        indent = indent - indent % tabSize + tabSize;\n      } else {\n        break;\n      }\n      i++;\n    }\n    if (i === len) {\n      return -1; // line only consists of whitespace\n    }\n\n    return indent;\n  }\n  _computeIndentLevel(lineIndex) {\n    return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);\n  }\n  getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n    this._assertNotDisposed();\n    const lineCount = this.getLineCount();\n    if (lineNumber < 1 || lineNumber > lineCount) {\n      throw new Error('Illegal value for lineNumber');\n    }\n    const foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n    const offSide = Boolean(foldingRules && foldingRules.offSide);\n    let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n    let up_aboveContentLineIndent = -1;\n    let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n    let up_belowContentLineIndent = -1;\n    const up_resolveIndents = lineNumber => {\n      if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\n        up_aboveContentLineIndex = -1;\n        up_aboveContentLineIndent = -1;\n        // must find previous line with content\n        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          let indent = this._computeIndentLevel(lineIndex);\n          if (indent >= 0) {\n            up_aboveContentLineIndex = lineIndex;\n            up_aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n      if (up_belowContentLineIndex === -2) {\n        up_belowContentLineIndex = -1;\n        up_belowContentLineIndent = -1;\n        // must find next line with content\n        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          let indent = this._computeIndentLevel(lineIndex);\n          if (indent >= 0) {\n            up_belowContentLineIndex = lineIndex;\n            up_belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n    };\n    let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n    let down_aboveContentLineIndent = -1;\n    let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n    let down_belowContentLineIndent = -1;\n    const down_resolveIndents = lineNumber => {\n      if (down_aboveContentLineIndex === -2) {\n        down_aboveContentLineIndex = -1;\n        down_aboveContentLineIndent = -1;\n        // must find previous line with content\n        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          let indent = this._computeIndentLevel(lineIndex);\n          if (indent >= 0) {\n            down_aboveContentLineIndex = lineIndex;\n            down_aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n      if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\n        down_belowContentLineIndex = -1;\n        down_belowContentLineIndent = -1;\n        // must find next line with content\n        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          let indent = this._computeIndentLevel(lineIndex);\n          if (indent >= 0) {\n            down_belowContentLineIndex = lineIndex;\n            down_belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n    };\n    let startLineNumber = 0;\n    let goUp = true;\n    let endLineNumber = 0;\n    let goDown = true;\n    let indent = 0;\n    let initialIndent = 0;\n    for (let distance = 0; goUp || goDown; distance++) {\n      const upLineNumber = lineNumber - distance;\n      const downLineNumber = lineNumber + distance;\n      if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n        goUp = false;\n      }\n      if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n        goDown = false;\n      }\n      if (distance > 50000) {\n        // stop processing\n        goUp = false;\n        goDown = false;\n      }\n      let upLineIndentLevel = -1;\n      if (goUp) {\n        // compute indent level going up\n        const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n        if (currentIndent >= 0) {\n          // This line has content (besides whitespace)\n          // Use the line's indent\n          up_belowContentLineIndex = upLineNumber - 1;\n          up_belowContentLineIndent = currentIndent;\n          upLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n        } else {\n          up_resolveIndents(upLineNumber);\n          upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n        }\n      }\n      let downLineIndentLevel = -1;\n      if (goDown) {\n        // compute indent level going down\n        const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n        if (currentIndent >= 0) {\n          // This line has content (besides whitespace)\n          // Use the line's indent\n          down_aboveContentLineIndex = downLineNumber - 1;\n          down_aboveContentLineIndent = currentIndent;\n          downLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n        } else {\n          down_resolveIndents(downLineNumber);\n          downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n        }\n      }\n      if (distance === 0) {\n        initialIndent = upLineIndentLevel;\n        continue;\n      }\n      if (distance === 1) {\n        if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {\n          // This is the beginning of a scope, we have special handling here, since we want the\n          // child scope indent to be active, not the parent scope\n          goUp = false;\n          startLineNumber = downLineNumber;\n          endLineNumber = downLineNumber;\n          indent = downLineIndentLevel;\n          continue;\n        }\n        if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {\n          // This is the end of a scope, just like above\n          goDown = false;\n          startLineNumber = upLineNumber;\n          endLineNumber = upLineNumber;\n          indent = upLineIndentLevel;\n          continue;\n        }\n        startLineNumber = lineNumber;\n        endLineNumber = lineNumber;\n        indent = initialIndent;\n        if (indent === 0) {\n          // No need to continue\n          return {\n            startLineNumber,\n            endLineNumber,\n            indent\n          };\n        }\n      }\n      if (goUp) {\n        if (upLineIndentLevel >= indent) {\n          startLineNumber = upLineNumber;\n        } else {\n          goUp = false;\n        }\n      }\n      if (goDown) {\n        if (downLineIndentLevel >= indent) {\n          endLineNumber = downLineNumber;\n        } else {\n          goDown = false;\n        }\n      }\n    }\n    return {\n      startLineNumber,\n      endLineNumber,\n      indent\n    };\n  }\n  getLinesIndentGuides(startLineNumber, endLineNumber) {\n    this._assertNotDisposed();\n    const lineCount = this.getLineCount();\n    if (startLineNumber < 1 || startLineNumber > lineCount) {\n      throw new Error('Illegal value for startLineNumber');\n    }\n    if (endLineNumber < 1 || endLineNumber > lineCount) {\n      throw new Error('Illegal value for endLineNumber');\n    }\n    const foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n    const offSide = Boolean(foldingRules && foldingRules.offSide);\n    let result = new Array(endLineNumber - startLineNumber + 1);\n    let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n    let aboveContentLineIndent = -1;\n    let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n    let belowContentLineIndent = -1;\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      let resultIndex = lineNumber - startLineNumber;\n      const currentIndent = this._computeIndentLevel(lineNumber - 1);\n      if (currentIndent >= 0) {\n        // This line has content (besides whitespace)\n        // Use the line's indent\n        aboveContentLineIndex = lineNumber - 1;\n        aboveContentLineIndent = currentIndent;\n        result[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);\n        continue;\n      }\n      if (aboveContentLineIndex === -2) {\n        aboveContentLineIndex = -1;\n        aboveContentLineIndent = -1;\n        // must find previous line with content\n        for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n          let indent = this._computeIndentLevel(lineIndex);\n          if (indent >= 0) {\n            aboveContentLineIndex = lineIndex;\n            aboveContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n      if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n        belowContentLineIndex = -1;\n        belowContentLineIndent = -1;\n        // must find next line with content\n        for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n          let indent = this._computeIndentLevel(lineIndex);\n          if (indent >= 0) {\n            belowContentLineIndex = lineIndex;\n            belowContentLineIndent = indent;\n            break;\n          }\n        }\n      }\n      result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n    }\n    return result;\n  }\n  _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n    if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n      // At the top or bottom of the file\n      return 0;\n    } else if (aboveContentLineIndent < belowContentLineIndent) {\n      // we are inside the region above\n      return 1 + Math.floor(aboveContentLineIndent / this._options.indentSize);\n    } else if (aboveContentLineIndent === belowContentLineIndent) {\n      // we are in between two regions\n      return Math.ceil(belowContentLineIndent / this._options.indentSize);\n    } else {\n      if (offSide) {\n        // same level as region below\n        return Math.ceil(belowContentLineIndent / this._options.indentSize);\n      } else {\n        // we are inside the region that ends below\n        return 1 + Math.floor(belowContentLineIndent / this._options.indentSize);\n      }\n    }\n  }\n}\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.DEFAULT_CREATION_OPTIONS = {\n  isForSimpleWidget: false,\n  tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n  indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n  insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n  detectIndentation: false,\n  defaultEOL: 1 /* LF */,\n  trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n  largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations\n};\n//#region Decorations\nclass DecorationsTrees {\n  constructor() {\n    this._decorationsTree0 = new IntervalTree();\n    this._decorationsTree1 = new IntervalTree();\n  }\n  intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n    const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    return r0.concat(r1);\n  }\n  search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n    if (overviewRulerOnly) {\n      return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n    } else {\n      const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n      const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n      return r0.concat(r1);\n    }\n  }\n  collectNodesFromOwner(ownerId) {\n    const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n    const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n    return r0.concat(r1);\n  }\n  collectNodesPostOrder() {\n    const r0 = this._decorationsTree0.collectNodesPostOrder();\n    const r1 = this._decorationsTree1.collectNodesPostOrder();\n    return r0.concat(r1);\n  }\n  insert(node) {\n    if (getNodeIsInOverviewRuler(node)) {\n      this._decorationsTree1.insert(node);\n    } else {\n      this._decorationsTree0.insert(node);\n    }\n  }\n  delete(node) {\n    if (getNodeIsInOverviewRuler(node)) {\n      this._decorationsTree1.delete(node);\n    } else {\n      this._decorationsTree0.delete(node);\n    }\n  }\n  resolveNode(node, cachedVersionId) {\n    if (getNodeIsInOverviewRuler(node)) {\n      this._decorationsTree1.resolveNode(node, cachedVersionId);\n    } else {\n      this._decorationsTree0.resolveNode(node, cachedVersionId);\n    }\n  }\n  acceptReplace(offset, length, textLength, forceMoveMarkers) {\n    this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n  }\n}\nfunction cleanClassName(className) {\n  return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n  constructor(options) {\n    this.color = options.color || '';\n    this.darkColor = options.darkColor || '';\n  }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this._resolvedColor = null;\n    this.position = typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center;\n  }\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n    return this._resolvedColor;\n  }\n  invalidateCachedColor() {\n    this._resolvedColor = null;\n  }\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return color;\n    }\n    let c = color ? theme.getColor(color.id) : null;\n    if (!c) {\n      return '';\n    }\n    return c.toString();\n  }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n  constructor(options) {\n    super(options);\n    this.position = options.position;\n  }\n  getColor(theme) {\n    if (!this._resolvedColor) {\n      if (theme.type !== 'light' && this.darkColor) {\n        this._resolvedColor = this._resolveColor(this.darkColor, theme);\n      } else {\n        this._resolvedColor = this._resolveColor(this.color, theme);\n      }\n    }\n    return this._resolvedColor;\n  }\n  invalidateCachedColor() {\n    this._resolvedColor = undefined;\n  }\n  _resolveColor(color, theme) {\n    if (typeof color === 'string') {\n      return Color.fromHex(color);\n    }\n    return theme.getColor(color.id);\n  }\n}\nexport class ModelDecorationOptions {\n  constructor(options) {\n    this.stickiness = options.stickiness || 0 /* AlwaysGrowsWhenTypingAtEdges */;\n    this.zIndex = options.zIndex || 0;\n    this.className = options.className ? cleanClassName(options.className) : null;\n    this.hoverMessage = options.hoverMessage || null;\n    this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n    this.isWholeLine = options.isWholeLine || false;\n    this.showIfCollapsed = options.showIfCollapsed || false;\n    this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n    this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n    this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n    this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n    this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n    this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n    this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n    this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n    this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n  }\n  static register(options) {\n    return new ModelDecorationOptions(options);\n  }\n  static createDynamic(options) {\n    return new ModelDecorationOptions(options);\n  }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});\n/**\r\n * The order carefully matches the values of the enum.\r\n */\nconst TRACKED_RANGE_OPTIONS = [ModelDecorationOptions.register({\n  stickiness: 0 /* AlwaysGrowsWhenTypingAtEdges */\n}), ModelDecorationOptions.register({\n  stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n}), ModelDecorationOptions.register({\n  stickiness: 2 /* GrowsOnlyWhenTypingBefore */\n}), ModelDecorationOptions.register({\n  stickiness: 3 /* GrowsOnlyWhenTypingAfter */\n})];\n\nfunction _normalizeOptions(options) {\n  if (options instanceof ModelDecorationOptions) {\n    return options;\n  }\n  return ModelDecorationOptions.createDynamic(options);\n}\nexport class DidChangeDecorationsEmitter extends Disposable {\n  constructor() {\n    super();\n    this._actual = this._register(new Emitter());\n    this.event = this._actual.event;\n    this._deferredCnt = 0;\n    this._shouldFire = false;\n    this._affectsMinimap = false;\n    this._affectsOverviewRuler = false;\n  }\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n  endDeferredEmit() {\n    this._deferredCnt--;\n    if (this._deferredCnt === 0) {\n      if (this._shouldFire) {\n        const event = {\n          affectsMinimap: this._affectsMinimap,\n          affectsOverviewRuler: this._affectsOverviewRuler\n        };\n        this._shouldFire = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._actual.fire(event);\n      }\n    }\n  }\n  checkAffectedAndFire(options) {\n    if (!this._affectsMinimap) {\n      this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n    }\n    if (!this._affectsOverviewRuler) {\n      this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n    }\n    this._shouldFire = true;\n  }\n  fire() {\n    this._affectsMinimap = true;\n    this._affectsOverviewRuler = true;\n    this._shouldFire = true;\n  }\n}\n//#endregion\nexport class DidChangeContentEmitter extends Disposable {\n  constructor() {\n    super();\n    /**\r\n     * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\r\n     */\n    this._fastEmitter = this._register(new Emitter());\n    this.fastEvent = this._fastEmitter.event;\n    this._slowEmitter = this._register(new Emitter());\n    this.slowEvent = this._slowEmitter.event;\n    this._deferredCnt = 0;\n    this._deferredEvent = null;\n  }\n  beginDeferredEmit() {\n    this._deferredCnt++;\n  }\n  endDeferredEmit() {\n    let resultingSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this._deferredCnt--;\n    if (this._deferredCnt === 0) {\n      if (this._deferredEvent !== null) {\n        this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n        const e = this._deferredEvent;\n        this._deferredEvent = null;\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n      }\n    }\n  }\n  fire(e) {\n    if (this._deferredCnt > 0) {\n      if (this._deferredEvent) {\n        this._deferredEvent = this._deferredEvent.merge(e);\n      } else {\n        this._deferredEvent = e;\n      }\n      return;\n    }\n    this._fastEmitter.fire(e);\n    this._slowEmitter.fire(e);\n  }\n}","map":{"version":3,"names":["onUnexpectedError","Emitter","Disposable","strings","URI","EDITOR_MODEL_DEFAULTS","Position","Range","Selection","model","EditStack","guessIndentation","IntervalNode","IntervalTree","getNodeIsInOverviewRuler","recomputeMaxEnd","PieceTreeTextBufferBuilder","InternalModelContentChangeEvent","ModelRawContentChangedEvent","ModelRawEOLChanged","ModelRawFlush","ModelRawLineChanged","ModelRawLinesDeleted","ModelRawLinesInserted","SearchParams","TextModelSearch","TextModelTokenization","getWordAtText","LanguageConfigurationRegistry","NULL_LANGUAGE_IDENTIFIER","ignoreBracketsInToken","BracketsUtils","TokensStore","countEOL","TokensStore2","Color","PieceTreeTextBuffer","createTextBufferBuilder","createTextBufferFactory","text","builder","acceptChunk","finish","createTextBuffer","value","defaultEOL","factory","create","MODEL_ID","LIMIT_FIND_COUNT","LONG_LINE_BOUNDARY","TextModelSnapshot","constructor","source","_source","_eos","read","result","resultCnt","resultLength","tmp","join","length","invalidFunc","Error","BracketSearchCanceled","_searchCanceledBrand","undefined","INSTANCE","stripBracketSearchCanceled","TextModel","creationOptions","languageIdentifier","associatedResource","arguments","undoRedoService","_onWillDispose","_register","onWillDispose","event","_onDidChangeDecorations","DidChangeDecorationsEmitter","onDidChangeDecorations","_onDidChangeLanguage","onDidChangeLanguage","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","_eventEmitter","DidChangeContentEmitter","id","isForSimpleWidget","_associatedResource","parse","_undoRedoService","_attachedEditorCount","textBuffer","disposable","_buffer","_bufferDisposable","_options","resolveOptions","bufferLineCount","getLineCount","bufferTextLength","getValueLengthInRange","getLineLength","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForSyncing","MODEL_SYNC_LIMIT","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_isDisposed","_isDisposing","_languageIdentifier","_languageRegistryListener","onDidChange","e","fire","_instanceId","singleLetterHash","_lastDecorationId","_decorations","Object","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","_tokens","_tokens2","_tokenization","options","detectIndentation","guessedIndentation","tabSize","insertSpaces","TextModelResolvedOptions","indentSize","trimAutoWhitespace","onDidChangeRawContentFast","listener","fastEvent","rawContentChangedEvent","onDidChangeContentFast","contentChangedEvent","onDidChangeContent","slowEvent","dispose","emptyDisposedTextBuffer","_assertNotDisposed","_emitContentChangedEvent","rawChange","change","setValue","_setValueFromTextBuffer","_createContentChanged2","range","rangeOffset","rangeLength","isUndoing","isRedoing","isFlush","changes","eol","getEOL","versionId","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","endLineNumber","endColumn","getLineMaxColumn","_increaseVersionId","flush","clear","getValue","setEOL","newEOL","_onBeforeEOLChange","_onAfterEOLChange","allDecorations","search","_ensureNodesHaveRanges","collectNodesPostOrder","i","len","node","delta","cachedAbsoluteStart","start","startOffset","getOffsetAt","startLineNumber","startColumn","endOffset","cachedAbsoluteEnd","cachedVersionId","end","onBeforeAttached","onBeforeDetached","isAttachedToEditor","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForTokenization","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineCount","lineNumber","lineLength","uri","getOptions","getFormattingOptions","updateOptions","_newOpts","newOpts","equals","createChangeEvent","defaultInsertSpaces","defaultTabSize","_normalizeIndentationFromWhitespace","str","spacesCnt","charAt","tabsCnt","Math","floor","normalizeIndentation","firstNonWhitespaceIndex","substring","mightContainRTL","mightContainUnusualLineTerminators","removeUnusualLineTerminators","selections","matches","findMatches","UNUSUAL_LINE_TERMINATORS","resetMightContainUnusualLineTerminators","pushEditOperations","map","m","mightContainNonBasicASCII","getAlternativeVersionId","getInitialUndoRedoSnapshot","rawPosition","position","_validatePosition","column","getPositionAt","rawOffset","offset","min","getLength","max","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","preserveBOM","fullModelRange","fullModelValue","getValueInRange","getBOM","createSnapshot","getValueLength","rawRange","validateRange","getCharacterCountInRange","getLineContent","getLinesContent","getEndOfLineSequence","getLineMinColumn","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","_validateRangeRelaxedNoAllocations","linesCount","initialStartLineNumber","initialStartColumn","maxColumn","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","isNaN","charCodeBefore","getLineCharCode","isHighSurrogate","_lineNumber","_column","validatePosition","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","modifyPosition","candidate","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","searchString","rawSearchScope","isRegex","matchCase","wordSeparators","searchRanges","Array","isArray","every","searchScope","isIRange","sort","d1","d2","uniqueSearchRanges","push","reduce","prev","curr","areIntersecting","plusRange","matchMapper","indexOf","searchParams","parseSearchRequest","arr","concat","findNextMatch","rawSearchStart","searchStart","ret","findPreviousMatch","pushStackElement","popStackElement","pushEOL","currentEOL","beginDeferredEmit","endDeferredEmit","_validateEditOperation","rawOperation","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","_validateEditOperations","rawOperations","beforeCursorState","editOperations","cursorStateComputer","_pushEditOperations","incomingEdits","op","editsAreNearCursors","sel","foundEditNearSel","j","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","isEmpty","trimRange","pushEditOperation","_applyUndo","resultingAlternativeVersionId","resultingSelection","edits","rangeStart","newPosition","rangeEnd","newEnd","oldText","_applyUndoRedoEdits","_applyRedo","oldPosition","oldEnd","newText","applyEdits","computeUndoEdits","operations","_doApplyEdits","oldLineCount","newLineCount","contentChanges","trimAutoWhitespaceLineNumbers","rawContentChanges","eolCount","firstLineLength","lastLineLength","acceptEdit","charCodeAt","acceptReplace","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","editLineNumber","currentEditLineNumber","spliceStartLineNumber","spliceLineNumber","cnt","fromLineNumber","newLines","reverseEdits","undo","canUndo","redo","canRedo","changeDecorations","callback","ownerId","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","newRange","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","delete","reset","setOptions","insert","removeAllDecorationsWithOwnerId","nodes","collectNodesFromOwner","getDecorationOptions","decorationId","resolveNode","_getRangeAt","getLineDecorations","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","_getDecorationsInRange","getDecorationsInRange","validatedRange","getOverviewRulerDecorations","getAllDecorations","filterRange","filterOwnerId","intervalSearch","getRangeAt","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","color","nodeIsInOverviewRuler","oldDecorationsIds","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","setTokens","tokens","ranges","element","minChangedLineNumber","maxChangedLineNumber","hasChange","lineHasChange","toLineNumber","_emitModelTokensChangedEvent","tokenizationSupportChanged","semanticTokensApplied","setSemanticTokens","isComplete","set","hasCompleteSemanticTokens","hasSomeSemanticTokens","setPartialSemanticTokens","changedRange","setPartial","tokenizeViewport","clearTokens","resetTokenization","forceTokenization","isCheapToTokenize","tokenizeIfCheap","getLineTokens","_getLineTokens","lineText","syntacticTokens","getTokens","addSemanticTokens","getLanguageIdentifier","getModeId","language","setMode","oldLanguage","newLanguage","getLanguageIdAtPosition","lineTokens","getLanguageId","findTokenIndexAtOffset","getWordAtPosition","_position","lineContent","tokenIndex","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","getWordDefinition","lbStartOffset","lbEndOffset","leftBiasedWord","languageId","getStartOffset","tokenCount","getCount","getEndOffset","getWordUntilPosition","wordAtPosition","word","substr","findMatchingBracketUp","_bracket","bracket","toLowerCase","bracketsSupport","getBracketsSupport","data","textIsBracket","_findMatchingBracketUp","matchBracket","_matchBracket","currentModeBrackets","getStandardTokenType","searchStartOffset","maxBracketLength","tokenEndOffset","searchEndOffset","bestResult","foundBracket","findNextBracketInRange","forwardRegex","foundBracketText","r","_matchFoundBracket","textIsOpenBracket","prevTokenIndex","prevModeBrackets","tokenStartOffset","findPrevBracketInRange","reversedRegex","isOpen","continueSearchPredicate","matched","_findMatchingBracketDown","getEndPosition","getStartPosition","reversedBracketRegex","count","totalCallCount","searchPrevMatchingBracketInRange","hitText","isClose","prevSearchInToken","searchInToken","bracketRegex","searchNextMatchingBracketInRange","findPrevBracket","modeBrackets","tokenLanguageId","_toFoundBracket","findNextBracket","findEnclosingBrackets","maxDuration","startTime","Date","now","savedCounts","Map","counts","resetCounts","has","brackets","get","searchInRange","index","open","close","computeIndentLevel","line","indent","chCode","_computeIndentLevel","lineIndex","getActiveIndentGuide","minLineNumber","maxLineNumber","foldingRules","getFoldingRules","offSide","Boolean","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesIndentGuides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","DEFAULT_CREATION_OPTIONS","_decorationsTree0","_decorationsTree1","r0","r1","overviewRulerOnly","textLength","cleanClassName","className","replace","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","OverviewRulerLane","Center","getColor","theme","type","_resolveColor","invalidateCachedColor","c","toString","ModelDecorationMinimapOptions","fromHex","ModelDecorationOptions","stickiness","zIndex","hoverMessage","glyphMarginHoverMessage","isWholeLine","showIfCollapsed","collapseOnReplaceEdit","minimap","glyphMarginClassName","linesDecorationsClassName","firstLineDecorationClassName","marginClassName","inlineClassName","inlineClassNameAffectsLetterSpacing","beforeContentClassName","afterContentClassName","register","createDynamic","EMPTY","_actual","_deferredCnt","_shouldFire","_affectsMinimap","_affectsOverviewRuler","affectsMinimap","affectsOverviewRuler","_fastEmitter","_slowEmitter","_deferredEvent","merge"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { onUnexpectedError } from '../../../base/common/errors.js';\r\nimport { Emitter } from '../../../base/common/event.js';\r\nimport { Disposable } from '../../../base/common/lifecycle.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { URI } from '../../../base/common/uri.js';\r\nimport { EDITOR_MODEL_DEFAULTS } from '../config/editorOptions.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { Selection } from '../core/selection.js';\r\nimport * as model from '../model.js';\r\nimport { EditStack } from './editStack.js';\r\nimport { guessIndentation } from './indentationGuesser.js';\r\nimport { IntervalNode, IntervalTree, getNodeIsInOverviewRuler, recomputeMaxEnd } from './intervalTree.js';\r\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\r\nimport { InternalModelContentChangeEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from './textModelEvents.js';\r\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\r\nimport { TextModelTokenization } from './textModelTokens.js';\r\nimport { getWordAtText } from './wordHelper.js';\r\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\r\nimport { NULL_LANGUAGE_IDENTIFIER } from '../modes/nullMode.js';\r\nimport { ignoreBracketsInToken } from '../modes/supports.js';\r\nimport { BracketsUtils } from '../modes/supports/richEditBrackets.js';\r\nimport { TokensStore, countEOL, TokensStore2 } from './tokensStore.js';\r\nimport { Color } from '../../../base/common/color.js';\r\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\r\nfunction createTextBufferBuilder() {\r\n    return new PieceTreeTextBufferBuilder();\r\n}\r\nexport function createTextBufferFactory(text) {\r\n    const builder = createTextBufferBuilder();\r\n    builder.acceptChunk(text);\r\n    return builder.finish();\r\n}\r\nexport function createTextBuffer(value, defaultEOL) {\r\n    const factory = (typeof value === 'string' ? createTextBufferFactory(value) : value);\r\n    return factory.create(defaultEOL);\r\n}\r\nlet MODEL_ID = 0;\r\nconst LIMIT_FIND_COUNT = 999;\r\nexport const LONG_LINE_BOUNDARY = 10000;\r\nclass TextModelSnapshot {\r\n    constructor(source) {\r\n        this._source = source;\r\n        this._eos = false;\r\n    }\r\n    read() {\r\n        if (this._eos) {\r\n            return null;\r\n        }\r\n        let result = [], resultCnt = 0, resultLength = 0;\r\n        do {\r\n            let tmp = this._source.read();\r\n            if (tmp === null) {\r\n                // end-of-stream\r\n                this._eos = true;\r\n                if (resultCnt === 0) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    return result.join('');\r\n                }\r\n            }\r\n            if (tmp.length > 0) {\r\n                result[resultCnt++] = tmp;\r\n                resultLength += tmp.length;\r\n            }\r\n            if (resultLength >= 64 * 1024) {\r\n                return result.join('');\r\n            }\r\n        } while (true);\r\n    }\r\n}\r\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\r\nclass BracketSearchCanceled {\r\n    constructor() {\r\n        this._searchCanceledBrand = undefined;\r\n    }\r\n}\r\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\r\nfunction stripBracketSearchCanceled(result) {\r\n    if (result instanceof BracketSearchCanceled) {\r\n        return null;\r\n    }\r\n    return result;\r\n}\r\nexport class TextModel extends Disposable {\r\n    //#endregion\r\n    constructor(source, creationOptions, languageIdentifier, associatedResource = null, undoRedoService) {\r\n        super();\r\n        //#region Events\r\n        this._onWillDispose = this._register(new Emitter());\r\n        this.onWillDispose = this._onWillDispose.event;\r\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter());\r\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\r\n        this._onDidChangeLanguage = this._register(new Emitter());\r\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\r\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\r\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\r\n        this._onDidChangeTokens = this._register(new Emitter());\r\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\r\n        this._onDidChangeOptions = this._register(new Emitter());\r\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\r\n        this._onDidChangeAttached = this._register(new Emitter());\r\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\r\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\r\n        // Generate a new unique model id\r\n        MODEL_ID++;\r\n        this.id = '$model' + MODEL_ID;\r\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\r\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\r\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\r\n        }\r\n        else {\r\n            this._associatedResource = associatedResource;\r\n        }\r\n        this._undoRedoService = undoRedoService;\r\n        this._attachedEditorCount = 0;\r\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\r\n        this._buffer = textBuffer;\r\n        this._bufferDisposable = disposable;\r\n        this._options = TextModel.resolveOptions(this._buffer, creationOptions);\r\n        const bufferLineCount = this._buffer.getLineCount();\r\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* TextDefined */);\r\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\r\n        // If a model is too large at construction time, it will never get tokenized,\r\n        // under no circumstances.\r\n        if (creationOptions.largeFileOptimizations) {\r\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\r\n                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\r\n        }\r\n        else {\r\n            this._isTooLargeForTokenization = false;\r\n        }\r\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\r\n        this._versionId = 1;\r\n        this._alternativeVersionId = 1;\r\n        this._initialUndoRedoSnapshot = null;\r\n        this._isDisposed = false;\r\n        this._isDisposing = false;\r\n        this._languageIdentifier = languageIdentifier || NULL_LANGUAGE_IDENTIFIER;\r\n        this._languageRegistryListener = LanguageConfigurationRegistry.onDidChange((e) => {\r\n            if (e.languageIdentifier.id === this._languageIdentifier.id) {\r\n                this._onDidChangeLanguageConfiguration.fire({});\r\n            }\r\n        });\r\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\r\n        this._lastDecorationId = 0;\r\n        this._decorations = Object.create(null);\r\n        this._decorationsTree = new DecorationsTrees();\r\n        this._commandManager = new EditStack(this, undoRedoService);\r\n        this._isUndoing = false;\r\n        this._isRedoing = false;\r\n        this._trimAutoWhitespaceLines = null;\r\n        this._tokens = new TokensStore();\r\n        this._tokens2 = new TokensStore2();\r\n        this._tokenization = new TextModelTokenization(this);\r\n    }\r\n    static resolveOptions(textBuffer, options) {\r\n        if (options.detectIndentation) {\r\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\r\n            return new model.TextModelResolvedOptions({\r\n                tabSize: guessedIndentation.tabSize,\r\n                indentSize: guessedIndentation.tabSize,\r\n                insertSpaces: guessedIndentation.insertSpaces,\r\n                trimAutoWhitespace: options.trimAutoWhitespace,\r\n                defaultEOL: options.defaultEOL\r\n            });\r\n        }\r\n        return new model.TextModelResolvedOptions({\r\n            tabSize: options.tabSize,\r\n            indentSize: options.indentSize,\r\n            insertSpaces: options.insertSpaces,\r\n            trimAutoWhitespace: options.trimAutoWhitespace,\r\n            defaultEOL: options.defaultEOL\r\n        });\r\n    }\r\n    onDidChangeRawContentFast(listener) {\r\n        return this._eventEmitter.fastEvent((e) => listener(e.rawContentChangedEvent));\r\n    }\r\n    onDidChangeContentFast(listener) {\r\n        return this._eventEmitter.fastEvent((e) => listener(e.contentChangedEvent));\r\n    }\r\n    onDidChangeContent(listener) {\r\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\r\n    }\r\n    dispose() {\r\n        this._isDisposing = true;\r\n        this._onWillDispose.fire();\r\n        this._languageRegistryListener.dispose();\r\n        this._tokenization.dispose();\r\n        this._isDisposed = true;\r\n        super.dispose();\r\n        this._bufferDisposable.dispose();\r\n        this._isDisposing = false;\r\n        // Manually release reference to previous text buffer to avoid large leaks\r\n        // in case someone leaks a TextModel reference\r\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\r\n        emptyDisposedTextBuffer.dispose();\r\n        this._buffer = emptyDisposedTextBuffer;\r\n    }\r\n    _assertNotDisposed() {\r\n        if (this._isDisposed) {\r\n            throw new Error('Model is disposed!');\r\n        }\r\n    }\r\n    _emitContentChangedEvent(rawChange, change) {\r\n        if (this._isDisposing) {\r\n            // Do not confuse listeners by emitting any event after disposing\r\n            return;\r\n        }\r\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\r\n    }\r\n    setValue(value) {\r\n        this._assertNotDisposed();\r\n        if (value === null) {\r\n            // There's nothing to do\r\n            return;\r\n        }\r\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\r\n        this._setValueFromTextBuffer(textBuffer, disposable);\r\n    }\r\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\r\n        return {\r\n            changes: [{\r\n                    range: range,\r\n                    rangeOffset: rangeOffset,\r\n                    rangeLength: rangeLength,\r\n                    text: text,\r\n                }],\r\n            eol: this._buffer.getEOL(),\r\n            versionId: this.getVersionId(),\r\n            isUndoing: isUndoing,\r\n            isRedoing: isRedoing,\r\n            isFlush: isFlush\r\n        };\r\n    }\r\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\r\n        this._assertNotDisposed();\r\n        const oldFullModelRange = this.getFullModelRange();\r\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\r\n        const endLineNumber = this.getLineCount();\r\n        const endColumn = this.getLineMaxColumn(endLineNumber);\r\n        this._buffer = textBuffer;\r\n        this._bufferDisposable.dispose();\r\n        this._bufferDisposable = textBufferDisposable;\r\n        this._increaseVersionId();\r\n        // Flush all tokens\r\n        this._tokens.flush();\r\n        this._tokens2.flush();\r\n        // Destroy all my decorations\r\n        this._decorations = Object.create(null);\r\n        this._decorationsTree = new DecorationsTrees();\r\n        // Destroy my edit history and settings\r\n        this._commandManager.clear();\r\n        this._trimAutoWhitespaceLines = null;\r\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\r\n            new ModelRawFlush()\r\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\r\n    }\r\n    setEOL(eol) {\r\n        this._assertNotDisposed();\r\n        const newEOL = (eol === 1 /* CRLF */ ? '\\r\\n' : '\\n');\r\n        if (this._buffer.getEOL() === newEOL) {\r\n            // Nothing to do\r\n            return;\r\n        }\r\n        const oldFullModelRange = this.getFullModelRange();\r\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\r\n        const endLineNumber = this.getLineCount();\r\n        const endColumn = this.getLineMaxColumn(endLineNumber);\r\n        this._onBeforeEOLChange();\r\n        this._buffer.setEOL(newEOL);\r\n        this._increaseVersionId();\r\n        this._onAfterEOLChange();\r\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\r\n            new ModelRawEOLChanged()\r\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\r\n    }\r\n    _onBeforeEOLChange() {\r\n        // Ensure all decorations get their `range` set.\r\n        const versionId = this.getVersionId();\r\n        const allDecorations = this._decorationsTree.search(0, false, false, versionId);\r\n        this._ensureNodesHaveRanges(allDecorations);\r\n    }\r\n    _onAfterEOLChange() {\r\n        // Transform back `range` to offsets\r\n        const versionId = this.getVersionId();\r\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\r\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\r\n            const node = allDecorations[i];\r\n            const delta = node.cachedAbsoluteStart - node.start;\r\n            const startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);\r\n            const endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);\r\n            node.cachedAbsoluteStart = startOffset;\r\n            node.cachedAbsoluteEnd = endOffset;\r\n            node.cachedVersionId = versionId;\r\n            node.start = startOffset - delta;\r\n            node.end = endOffset - delta;\r\n            recomputeMaxEnd(node);\r\n        }\r\n    }\r\n    onBeforeAttached() {\r\n        this._attachedEditorCount++;\r\n        if (this._attachedEditorCount === 1) {\r\n            this._onDidChangeAttached.fire(undefined);\r\n        }\r\n    }\r\n    onBeforeDetached() {\r\n        this._attachedEditorCount--;\r\n        if (this._attachedEditorCount === 0) {\r\n            this._onDidChangeAttached.fire(undefined);\r\n        }\r\n    }\r\n    isAttachedToEditor() {\r\n        return this._attachedEditorCount > 0;\r\n    }\r\n    getAttachedEditorCount() {\r\n        return this._attachedEditorCount;\r\n    }\r\n    isTooLargeForSyncing() {\r\n        return this._isTooLargeForSyncing;\r\n    }\r\n    isTooLargeForTokenization() {\r\n        return this._isTooLargeForTokenization;\r\n    }\r\n    isDisposed() {\r\n        return this._isDisposed;\r\n    }\r\n    isDominatedByLongLines() {\r\n        this._assertNotDisposed();\r\n        if (this.isTooLargeForTokenization()) {\r\n            // Cannot word wrap huge files anyways, so it doesn't really matter\r\n            return false;\r\n        }\r\n        let smallLineCharCount = 0;\r\n        let longLineCharCount = 0;\r\n        const lineCount = this._buffer.getLineCount();\r\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\r\n            const lineLength = this._buffer.getLineLength(lineNumber);\r\n            if (lineLength >= LONG_LINE_BOUNDARY) {\r\n                longLineCharCount += lineLength;\r\n            }\r\n            else {\r\n                smallLineCharCount += lineLength;\r\n            }\r\n        }\r\n        return (longLineCharCount > smallLineCharCount);\r\n    }\r\n    get uri() {\r\n        return this._associatedResource;\r\n    }\r\n    //#region Options\r\n    getOptions() {\r\n        this._assertNotDisposed();\r\n        return this._options;\r\n    }\r\n    getFormattingOptions() {\r\n        return {\r\n            tabSize: this._options.indentSize,\r\n            insertSpaces: this._options.insertSpaces\r\n        };\r\n    }\r\n    updateOptions(_newOpts) {\r\n        this._assertNotDisposed();\r\n        let tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\r\n        let indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\r\n        let insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\r\n        let trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\r\n        let newOpts = new model.TextModelResolvedOptions({\r\n            tabSize: tabSize,\r\n            indentSize: indentSize,\r\n            insertSpaces: insertSpaces,\r\n            defaultEOL: this._options.defaultEOL,\r\n            trimAutoWhitespace: trimAutoWhitespace\r\n        });\r\n        if (this._options.equals(newOpts)) {\r\n            return;\r\n        }\r\n        let e = this._options.createChangeEvent(newOpts);\r\n        this._options = newOpts;\r\n        this._onDidChangeOptions.fire(e);\r\n    }\r\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\r\n        this._assertNotDisposed();\r\n        let guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\r\n        this.updateOptions({\r\n            insertSpaces: guessedIndentation.insertSpaces,\r\n            tabSize: guessedIndentation.tabSize,\r\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\r\n        });\r\n    }\r\n    static _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\r\n        let spacesCnt = 0;\r\n        for (let i = 0; i < str.length; i++) {\r\n            if (str.charAt(i) === '\\t') {\r\n                spacesCnt += indentSize;\r\n            }\r\n            else {\r\n                spacesCnt++;\r\n            }\r\n        }\r\n        let result = '';\r\n        if (!insertSpaces) {\r\n            let tabsCnt = Math.floor(spacesCnt / indentSize);\r\n            spacesCnt = spacesCnt % indentSize;\r\n            for (let i = 0; i < tabsCnt; i++) {\r\n                result += '\\t';\r\n            }\r\n        }\r\n        for (let i = 0; i < spacesCnt; i++) {\r\n            result += ' ';\r\n        }\r\n        return result;\r\n    }\r\n    static normalizeIndentation(str, indentSize, insertSpaces) {\r\n        let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\r\n        if (firstNonWhitespaceIndex === -1) {\r\n            firstNonWhitespaceIndex = str.length;\r\n        }\r\n        return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\r\n    }\r\n    normalizeIndentation(str) {\r\n        this._assertNotDisposed();\r\n        return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\r\n    }\r\n    //#endregion\r\n    //#region Reading\r\n    getVersionId() {\r\n        this._assertNotDisposed();\r\n        return this._versionId;\r\n    }\r\n    mightContainRTL() {\r\n        return this._buffer.mightContainRTL();\r\n    }\r\n    mightContainUnusualLineTerminators() {\r\n        return this._buffer.mightContainUnusualLineTerminators();\r\n    }\r\n    removeUnusualLineTerminators(selections = null) {\r\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\r\n        this._buffer.resetMightContainUnusualLineTerminators();\r\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\r\n    }\r\n    mightContainNonBasicASCII() {\r\n        return this._buffer.mightContainNonBasicASCII();\r\n    }\r\n    getAlternativeVersionId() {\r\n        this._assertNotDisposed();\r\n        return this._alternativeVersionId;\r\n    }\r\n    getInitialUndoRedoSnapshot() {\r\n        this._assertNotDisposed();\r\n        return this._initialUndoRedoSnapshot;\r\n    }\r\n    getOffsetAt(rawPosition) {\r\n        this._assertNotDisposed();\r\n        let position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* Relaxed */);\r\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\r\n    }\r\n    getPositionAt(rawOffset) {\r\n        this._assertNotDisposed();\r\n        let offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\r\n        return this._buffer.getPositionAt(offset);\r\n    }\r\n    _increaseVersionId() {\r\n        this._versionId = this._versionId + 1;\r\n        this._alternativeVersionId = this._versionId;\r\n    }\r\n    _overwriteVersionId(versionId) {\r\n        this._versionId = versionId;\r\n    }\r\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\r\n        this._alternativeVersionId = newAlternativeVersionId;\r\n    }\r\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\r\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\r\n    }\r\n    getValue(eol, preserveBOM = false) {\r\n        this._assertNotDisposed();\r\n        const fullModelRange = this.getFullModelRange();\r\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\r\n        if (preserveBOM) {\r\n            return this._buffer.getBOM() + fullModelValue;\r\n        }\r\n        return fullModelValue;\r\n    }\r\n    createSnapshot(preserveBOM = false) {\r\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\r\n    }\r\n    getValueLength(eol, preserveBOM = false) {\r\n        this._assertNotDisposed();\r\n        const fullModelRange = this.getFullModelRange();\r\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\r\n        if (preserveBOM) {\r\n            return this._buffer.getBOM().length + fullModelValue;\r\n        }\r\n        return fullModelValue;\r\n    }\r\n    getValueInRange(rawRange, eol = 0 /* TextDefined */) {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\r\n    }\r\n    getValueLengthInRange(rawRange, eol = 0 /* TextDefined */) {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\r\n    }\r\n    getCharacterCountInRange(rawRange, eol = 0 /* TextDefined */) {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\r\n    }\r\n    getLineCount() {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getLineCount();\r\n    }\r\n    getLineContent(lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineContent(lineNumber);\r\n    }\r\n    getLineLength(lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineLength(lineNumber);\r\n    }\r\n    getLinesContent() {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getLinesContent();\r\n    }\r\n    getEOL() {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getEOL();\r\n    }\r\n    getEndOfLineSequence() {\r\n        this._assertNotDisposed();\r\n        return (this._buffer.getEOL() === '\\n'\r\n            ? 0 /* LF */\r\n            : 1 /* CRLF */);\r\n    }\r\n    getLineMinColumn(lineNumber) {\r\n        this._assertNotDisposed();\r\n        return 1;\r\n    }\r\n    getLineMaxColumn(lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineLength(lineNumber) + 1;\r\n    }\r\n    getLineFirstNonWhitespaceColumn(lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\r\n    }\r\n    getLineLastNonWhitespaceColumn(lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\r\n    }\r\n    /**\r\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\r\n     * Will try to not allocate if possible.\r\n     */\r\n    _validateRangeRelaxedNoAllocations(range) {\r\n        const linesCount = this._buffer.getLineCount();\r\n        const initialStartLineNumber = range.startLineNumber;\r\n        const initialStartColumn = range.startColumn;\r\n        let startLineNumber;\r\n        let startColumn;\r\n        if (initialStartLineNumber < 1) {\r\n            startLineNumber = 1;\r\n            startColumn = 1;\r\n        }\r\n        else if (initialStartLineNumber > linesCount) {\r\n            startLineNumber = linesCount;\r\n            startColumn = this.getLineMaxColumn(startLineNumber);\r\n        }\r\n        else {\r\n            startLineNumber = initialStartLineNumber | 0;\r\n            if (initialStartColumn <= 1) {\r\n                startColumn = 1;\r\n            }\r\n            else {\r\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\r\n                if (initialStartColumn >= maxColumn) {\r\n                    startColumn = maxColumn;\r\n                }\r\n                else {\r\n                    startColumn = initialStartColumn | 0;\r\n                }\r\n            }\r\n        }\r\n        const initialEndLineNumber = range.endLineNumber;\r\n        const initialEndColumn = range.endColumn;\r\n        let endLineNumber;\r\n        let endColumn;\r\n        if (initialEndLineNumber < 1) {\r\n            endLineNumber = 1;\r\n            endColumn = 1;\r\n        }\r\n        else if (initialEndLineNumber > linesCount) {\r\n            endLineNumber = linesCount;\r\n            endColumn = this.getLineMaxColumn(endLineNumber);\r\n        }\r\n        else {\r\n            endLineNumber = initialEndLineNumber | 0;\r\n            if (initialEndColumn <= 1) {\r\n                endColumn = 1;\r\n            }\r\n            else {\r\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\r\n                if (initialEndColumn >= maxColumn) {\r\n                    endColumn = maxColumn;\r\n                }\r\n                else {\r\n                    endColumn = initialEndColumn | 0;\r\n                }\r\n            }\r\n        }\r\n        if (initialStartLineNumber === startLineNumber\r\n            && initialStartColumn === startColumn\r\n            && initialEndLineNumber === endLineNumber\r\n            && initialEndColumn === endColumn\r\n            && range instanceof Range\r\n            && !(range instanceof Selection)) {\r\n            return range;\r\n        }\r\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n    }\r\n    _isValidPosition(lineNumber, column, validationType) {\r\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\r\n            return false;\r\n        }\r\n        if (isNaN(lineNumber) || isNaN(column)) {\r\n            return false;\r\n        }\r\n        if (lineNumber < 1 || column < 1) {\r\n            return false;\r\n        }\r\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\r\n            return false;\r\n        }\r\n        const lineCount = this._buffer.getLineCount();\r\n        if (lineNumber > lineCount) {\r\n            return false;\r\n        }\r\n        if (column === 1) {\r\n            return true;\r\n        }\r\n        const maxColumn = this.getLineMaxColumn(lineNumber);\r\n        if (column > maxColumn) {\r\n            return false;\r\n        }\r\n        if (validationType === 1 /* SurrogatePairs */) {\r\n            // !!At this point, column > 1\r\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\r\n            if (strings.isHighSurrogate(charCodeBefore)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    _validatePosition(_lineNumber, _column, validationType) {\r\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\r\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\r\n        const lineCount = this._buffer.getLineCount();\r\n        if (lineNumber < 1) {\r\n            return new Position(1, 1);\r\n        }\r\n        if (lineNumber > lineCount) {\r\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\r\n        }\r\n        if (column <= 1) {\r\n            return new Position(lineNumber, 1);\r\n        }\r\n        const maxColumn = this.getLineMaxColumn(lineNumber);\r\n        if (column >= maxColumn) {\r\n            return new Position(lineNumber, maxColumn);\r\n        }\r\n        if (validationType === 1 /* SurrogatePairs */) {\r\n            // If the position would end up in the middle of a high-low surrogate pair,\r\n            // we move it to before the pair\r\n            // !!At this point, column > 1\r\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\r\n            if (strings.isHighSurrogate(charCodeBefore)) {\r\n                return new Position(lineNumber, column - 1);\r\n            }\r\n        }\r\n        return new Position(lineNumber, column);\r\n    }\r\n    validatePosition(position) {\r\n        const validationType = 1 /* SurrogatePairs */;\r\n        this._assertNotDisposed();\r\n        // Avoid object allocation and cover most likely case\r\n        if (position instanceof Position) {\r\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\r\n                return position;\r\n            }\r\n        }\r\n        return this._validatePosition(position.lineNumber, position.column, validationType);\r\n    }\r\n    _isValidRange(range, validationType) {\r\n        const startLineNumber = range.startLineNumber;\r\n        const startColumn = range.startColumn;\r\n        const endLineNumber = range.endLineNumber;\r\n        const endColumn = range.endColumn;\r\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* Relaxed */)) {\r\n            return false;\r\n        }\r\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* Relaxed */)) {\r\n            return false;\r\n        }\r\n        if (validationType === 1 /* SurrogatePairs */) {\r\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\r\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\r\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\r\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\r\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    validateRange(_range) {\r\n        const validationType = 1 /* SurrogatePairs */;\r\n        this._assertNotDisposed();\r\n        // Avoid object allocation and cover most likely case\r\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\r\n            if (this._isValidRange(_range, validationType)) {\r\n                return _range;\r\n            }\r\n        }\r\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* Relaxed */);\r\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* Relaxed */);\r\n        const startLineNumber = start.lineNumber;\r\n        const startColumn = start.column;\r\n        const endLineNumber = end.lineNumber;\r\n        const endColumn = end.column;\r\n        if (validationType === 1 /* SurrogatePairs */) {\r\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\r\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\r\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\r\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\r\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\r\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n            }\r\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\r\n                // do not expand a collapsed range, simply move it to a valid location\r\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\r\n            }\r\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\r\n                // expand range at both ends\r\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\r\n            }\r\n            if (startInsideSurrogatePair) {\r\n                // only expand range at the start\r\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\r\n            }\r\n            // only expand range at the end\r\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\r\n        }\r\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n    }\r\n    modifyPosition(rawPosition, offset) {\r\n        this._assertNotDisposed();\r\n        let candidate = this.getOffsetAt(rawPosition) + offset;\r\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\r\n    }\r\n    getFullModelRange() {\r\n        this._assertNotDisposed();\r\n        const lineCount = this.getLineCount();\r\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\r\n    }\r\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\r\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\r\n    }\r\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\r\n        this._assertNotDisposed();\r\n        let searchRanges = null;\r\n        if (rawSearchScope !== null) {\r\n            if (!Array.isArray(rawSearchScope)) {\r\n                rawSearchScope = [rawSearchScope];\r\n            }\r\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\r\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\r\n            }\r\n        }\r\n        if (searchRanges === null) {\r\n            searchRanges = [this.getFullModelRange()];\r\n        }\r\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\r\n        const uniqueSearchRanges = [];\r\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\r\n            if (Range.areIntersecting(prev, curr)) {\r\n                return prev.plusRange(curr);\r\n            }\r\n            uniqueSearchRanges.push(prev);\r\n            return curr;\r\n        }));\r\n        let matchMapper;\r\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\r\n            // not regex, not multi line\r\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\r\n            const searchData = searchParams.parseSearchRequest();\r\n            if (!searchData) {\r\n                return [];\r\n            }\r\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\r\n        }\r\n        else {\r\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\r\n        }\r\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\r\n    }\r\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\r\n        this._assertNotDisposed();\r\n        const searchStart = this.validatePosition(rawSearchStart);\r\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\r\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\r\n            const searchData = searchParams.parseSearchRequest();\r\n            if (!searchData) {\r\n                return null;\r\n            }\r\n            const lineCount = this.getLineCount();\r\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\r\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\r\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\r\n            if (ret.length > 0) {\r\n                return ret[0];\r\n            }\r\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\r\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\r\n            if (ret.length > 0) {\r\n                return ret[0];\r\n            }\r\n            return null;\r\n        }\r\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\r\n    }\r\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\r\n        this._assertNotDisposed();\r\n        const searchStart = this.validatePosition(rawSearchStart);\r\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\r\n    }\r\n    //#endregion\r\n    //#region Editing\r\n    pushStackElement() {\r\n        this._commandManager.pushStackElement();\r\n    }\r\n    popStackElement() {\r\n        this._commandManager.popStackElement();\r\n    }\r\n    pushEOL(eol) {\r\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* LF */ : 1 /* CRLF */);\r\n        if (currentEOL === eol) {\r\n            return;\r\n        }\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            if (this._initialUndoRedoSnapshot === null) {\r\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\r\n            }\r\n            this._commandManager.pushEOL(eol);\r\n        }\r\n        finally {\r\n            this._eventEmitter.endDeferredEmit();\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    }\r\n    _validateEditOperation(rawOperation) {\r\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\r\n            return rawOperation;\r\n        }\r\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\r\n    }\r\n    _validateEditOperations(rawOperations) {\r\n        const result = [];\r\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\r\n            result[i] = this._validateEditOperation(rawOperations[i]);\r\n        }\r\n        return result;\r\n    }\r\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\r\n        }\r\n        finally {\r\n            this._eventEmitter.endDeferredEmit();\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    }\r\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\r\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\r\n            // Go through each saved line number and insert a trim whitespace edit\r\n            // if it is safe to do so (no conflicts with other edits).\r\n            let incomingEdits = editOperations.map((op) => {\r\n                return {\r\n                    range: this.validateRange(op.range),\r\n                    text: op.text\r\n                };\r\n            });\r\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\r\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\r\n            let editsAreNearCursors = true;\r\n            if (beforeCursorState) {\r\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\r\n                    let sel = beforeCursorState[i];\r\n                    let foundEditNearSel = false;\r\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\r\n                        let editRange = incomingEdits[j].range;\r\n                        let selIsAbove = editRange.startLineNumber > sel.endLineNumber;\r\n                        let selIsBelow = sel.startLineNumber > editRange.endLineNumber;\r\n                        if (!selIsAbove && !selIsBelow) {\r\n                            foundEditNearSel = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!foundEditNearSel) {\r\n                        editsAreNearCursors = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (editsAreNearCursors) {\r\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\r\n                    let trimLineNumber = this._trimAutoWhitespaceLines[i];\r\n                    let maxLineColumn = this.getLineMaxColumn(trimLineNumber);\r\n                    let allowTrimLine = true;\r\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\r\n                        let editRange = incomingEdits[j].range;\r\n                        let editText = incomingEdits[j].text;\r\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\r\n                            // `trimLine` is completely outside this edit\r\n                            continue;\r\n                        }\r\n                        // At this point:\r\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\r\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\r\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\r\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\r\n                            continue;\r\n                        }\r\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\r\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\r\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\r\n                            continue;\r\n                        }\r\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\r\n                        allowTrimLine = false;\r\n                        break;\r\n                    }\r\n                    if (allowTrimLine) {\r\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\r\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\r\n                    }\r\n                }\r\n            }\r\n            this._trimAutoWhitespaceLines = null;\r\n        }\r\n        if (this._initialUndoRedoSnapshot === null) {\r\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\r\n        }\r\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\r\n    }\r\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\r\n        const edits = changes.map((change) => {\r\n            const rangeStart = this.getPositionAt(change.newPosition);\r\n            const rangeEnd = this.getPositionAt(change.newEnd);\r\n            return {\r\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\r\n                text: change.oldText\r\n            };\r\n        });\r\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\r\n    }\r\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\r\n        const edits = changes.map((change) => {\r\n            const rangeStart = this.getPositionAt(change.oldPosition);\r\n            const rangeEnd = this.getPositionAt(change.oldEnd);\r\n            return {\r\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\r\n                text: change.newText\r\n            };\r\n        });\r\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\r\n    }\r\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            this._isUndoing = isUndoing;\r\n            this._isRedoing = isRedoing;\r\n            this.applyEdits(edits, false);\r\n            this.setEOL(eol);\r\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\r\n        }\r\n        finally {\r\n            this._isUndoing = false;\r\n            this._isRedoing = false;\r\n            this._eventEmitter.endDeferredEmit(resultingSelection);\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    }\r\n    applyEdits(rawOperations, computeUndoEdits = false) {\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            const operations = this._validateEditOperations(rawOperations);\r\n            return this._doApplyEdits(operations, computeUndoEdits);\r\n        }\r\n        finally {\r\n            this._eventEmitter.endDeferredEmit();\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    }\r\n    _doApplyEdits(rawOperations, computeUndoEdits) {\r\n        const oldLineCount = this._buffer.getLineCount();\r\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\r\n        const newLineCount = this._buffer.getLineCount();\r\n        const contentChanges = result.changes;\r\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\r\n        if (contentChanges.length !== 0) {\r\n            let rawContentChanges = [];\r\n            let lineCount = oldLineCount;\r\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\r\n                const change = contentChanges[i];\r\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\r\n                this._tokens.acceptEdit(change.range, eolCount, firstLineLength);\r\n                this._tokens2.acceptEdit(change.range, eolCount, firstLineLength, lastLineLength, change.text.length > 0 ? change.text.charCodeAt(0) : 0 /* Null */);\r\n                this._onDidChangeDecorations.fire();\r\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\r\n                const startLineNumber = change.range.startLineNumber;\r\n                const endLineNumber = change.range.endLineNumber;\r\n                const deletingLinesCnt = endLineNumber - startLineNumber;\r\n                const insertingLinesCnt = eolCount;\r\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\r\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\r\n                for (let j = editingLinesCnt; j >= 0; j--) {\r\n                    const editLineNumber = startLineNumber + j;\r\n                    const currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;\r\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));\r\n                }\r\n                if (editingLinesCnt < deletingLinesCnt) {\r\n                    // Must delete some lines\r\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\r\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\r\n                }\r\n                if (editingLinesCnt < insertingLinesCnt) {\r\n                    // Must insert some lines\r\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\r\n                    const cnt = insertingLinesCnt - editingLinesCnt;\r\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\r\n                    let newLines = [];\r\n                    for (let i = 0; i < cnt; i++) {\r\n                        let lineNumber = fromLineNumber + i;\r\n                        newLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);\r\n                    }\r\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));\r\n                }\r\n                lineCount += changeLineCountDelta;\r\n            }\r\n            this._increaseVersionId();\r\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\r\n                changes: contentChanges,\r\n                eol: this._buffer.getEOL(),\r\n                versionId: this.getVersionId(),\r\n                isUndoing: this._isUndoing,\r\n                isRedoing: this._isRedoing,\r\n                isFlush: false\r\n            });\r\n        }\r\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\r\n    }\r\n    undo() {\r\n        return this._undoRedoService.undo(this.uri);\r\n    }\r\n    canUndo() {\r\n        return this._undoRedoService.canUndo(this.uri);\r\n    }\r\n    redo() {\r\n        return this._undoRedoService.redo(this.uri);\r\n    }\r\n    canRedo() {\r\n        return this._undoRedoService.canRedo(this.uri);\r\n    }\r\n    //#endregion\r\n    //#region Decorations\r\n    changeDecorations(callback, ownerId = 0) {\r\n        this._assertNotDisposed();\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            return this._changeDecorations(ownerId, callback);\r\n        }\r\n        finally {\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    }\r\n    _changeDecorations(ownerId, callback) {\r\n        let changeAccessor = {\r\n            addDecoration: (range, options) => {\r\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\r\n            },\r\n            changeDecoration: (id, newRange) => {\r\n                this._changeDecorationImpl(id, newRange);\r\n            },\r\n            changeDecorationOptions: (id, options) => {\r\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\r\n            },\r\n            removeDecoration: (id) => {\r\n                this._deltaDecorationsImpl(ownerId, [id], []);\r\n            },\r\n            deltaDecorations: (oldDecorations, newDecorations) => {\r\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\r\n                    // nothing to do\r\n                    return [];\r\n                }\r\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\r\n            }\r\n        };\r\n        let result = null;\r\n        try {\r\n            result = callback(changeAccessor);\r\n        }\r\n        catch (e) {\r\n            onUnexpectedError(e);\r\n        }\r\n        // Invalidate change accessor\r\n        changeAccessor.addDecoration = invalidFunc;\r\n        changeAccessor.changeDecoration = invalidFunc;\r\n        changeAccessor.changeDecorationOptions = invalidFunc;\r\n        changeAccessor.removeDecoration = invalidFunc;\r\n        changeAccessor.deltaDecorations = invalidFunc;\r\n        return result;\r\n    }\r\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\r\n        this._assertNotDisposed();\r\n        if (!oldDecorations) {\r\n            oldDecorations = [];\r\n        }\r\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\r\n            // nothing to do\r\n            return [];\r\n        }\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\r\n        }\r\n        finally {\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    }\r\n    _getTrackedRange(id) {\r\n        return this.getDecorationRange(id);\r\n    }\r\n    _setTrackedRange(id, newRange, newStickiness) {\r\n        const node = (id ? this._decorations[id] : null);\r\n        if (!node) {\r\n            if (!newRange) {\r\n                // node doesn't exist, the request is to delete => nothing to do\r\n                return null;\r\n            }\r\n            // node doesn't exist, the request is to set => add the tracked range\r\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\r\n        }\r\n        if (!newRange) {\r\n            // node exists, the request is to delete => delete node\r\n            this._decorationsTree.delete(node);\r\n            delete this._decorations[node.id];\r\n            return null;\r\n        }\r\n        // node exists, the request is to set => change the tracked range and its options\r\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\r\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\r\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\r\n        this._decorationsTree.delete(node);\r\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\r\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\r\n        this._decorationsTree.insert(node);\r\n        return node.id;\r\n    }\r\n    removeAllDecorationsWithOwnerId(ownerId) {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\r\n        for (let i = 0, len = nodes.length; i < len; i++) {\r\n            const node = nodes[i];\r\n            this._decorationsTree.delete(node);\r\n            delete this._decorations[node.id];\r\n        }\r\n    }\r\n    getDecorationOptions(decorationId) {\r\n        const node = this._decorations[decorationId];\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        return node.options;\r\n    }\r\n    getDecorationRange(decorationId) {\r\n        const node = this._decorations[decorationId];\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        const versionId = this.getVersionId();\r\n        if (node.cachedVersionId !== versionId) {\r\n            this._decorationsTree.resolveNode(node, versionId);\r\n        }\r\n        if (node.range === null) {\r\n            node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\r\n        }\r\n        return node.range;\r\n    }\r\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            return [];\r\n        }\r\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\r\n    }\r\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {\r\n        let lineCount = this.getLineCount();\r\n        let startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\r\n        let endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\r\n        let endColumn = this.getLineMaxColumn(endLineNumber);\r\n        return this._getDecorationsInRange(new Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);\r\n    }\r\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false) {\r\n        let validatedRange = this.validateRange(range);\r\n        return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\r\n    }\r\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\r\n        const versionId = this.getVersionId();\r\n        const result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);\r\n        return this._ensureNodesHaveRanges(result);\r\n    }\r\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\r\n        const versionId = this.getVersionId();\r\n        const result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);\r\n        return this._ensureNodesHaveRanges(result);\r\n    }\r\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\r\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\r\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\r\n        const versionId = this.getVersionId();\r\n        const result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);\r\n        return this._ensureNodesHaveRanges(result);\r\n    }\r\n    _ensureNodesHaveRanges(nodes) {\r\n        for (let i = 0, len = nodes.length; i < len; i++) {\r\n            const node = nodes[i];\r\n            if (node.range === null) {\r\n                node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\r\n            }\r\n        }\r\n        return nodes;\r\n    }\r\n    _getRangeAt(start, end) {\r\n        return this._buffer.getRangeAt(start, end - start);\r\n    }\r\n    _changeDecorationImpl(decorationId, _range) {\r\n        const node = this._decorations[decorationId];\r\n        if (!node) {\r\n            return;\r\n        }\r\n        const range = this._validateRangeRelaxedNoAllocations(_range);\r\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\r\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\r\n        this._decorationsTree.delete(node);\r\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\r\n        this._decorationsTree.insert(node);\r\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\r\n    }\r\n    _changeDecorationOptionsImpl(decorationId, options) {\r\n        const node = this._decorations[decorationId];\r\n        if (!node) {\r\n            return;\r\n        }\r\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\r\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\r\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\r\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\r\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\r\n            // Delete + Insert due to an overview ruler status change\r\n            this._decorationsTree.delete(node);\r\n            node.setOptions(options);\r\n            this._decorationsTree.insert(node);\r\n        }\r\n        else {\r\n            node.setOptions(options);\r\n        }\r\n    }\r\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\r\n        const versionId = this.getVersionId();\r\n        const oldDecorationsLen = oldDecorationsIds.length;\r\n        let oldDecorationIndex = 0;\r\n        const newDecorationsLen = newDecorations.length;\r\n        let newDecorationIndex = 0;\r\n        let result = new Array(newDecorationsLen);\r\n        while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\r\n            let node = null;\r\n            if (oldDecorationIndex < oldDecorationsLen) {\r\n                // (1) get ourselves an old node\r\n                do {\r\n                    node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\r\n                } while (!node && oldDecorationIndex < oldDecorationsLen);\r\n                // (2) remove the node from the tree (if it exists)\r\n                if (node) {\r\n                    this._decorationsTree.delete(node);\r\n                    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\r\n                }\r\n            }\r\n            if (newDecorationIndex < newDecorationsLen) {\r\n                // (3) create a new node if necessary\r\n                if (!node) {\r\n                    const internalDecorationId = (++this._lastDecorationId);\r\n                    const decorationId = `${this._instanceId};${internalDecorationId}`;\r\n                    node = new IntervalNode(decorationId, 0, 0);\r\n                    this._decorations[decorationId] = node;\r\n                }\r\n                // (4) initialize node\r\n                const newDecoration = newDecorations[newDecorationIndex];\r\n                const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\r\n                const options = _normalizeOptions(newDecoration.options);\r\n                const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\r\n                const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\r\n                node.ownerId = ownerId;\r\n                node.reset(versionId, startOffset, endOffset, range);\r\n                node.setOptions(options);\r\n                this._onDidChangeDecorations.checkAffectedAndFire(options);\r\n                this._decorationsTree.insert(node);\r\n                result[newDecorationIndex] = node.id;\r\n                newDecorationIndex++;\r\n            }\r\n            else {\r\n                if (node) {\r\n                    delete this._decorations[node.id];\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    setTokens(tokens) {\r\n        if (tokens.length === 0) {\r\n            return;\r\n        }\r\n        let ranges = [];\r\n        for (let i = 0, len = tokens.length; i < len; i++) {\r\n            const element = tokens[i];\r\n            let minChangedLineNumber = 0;\r\n            let maxChangedLineNumber = 0;\r\n            let hasChange = false;\r\n            for (let j = 0, lenJ = element.tokens.length; j < lenJ; j++) {\r\n                const lineNumber = element.startLineNumber + j;\r\n                if (hasChange) {\r\n                    this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], false);\r\n                    maxChangedLineNumber = lineNumber;\r\n                }\r\n                else {\r\n                    const lineHasChange = this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], true);\r\n                    if (lineHasChange) {\r\n                        hasChange = true;\r\n                        minChangedLineNumber = lineNumber;\r\n                        maxChangedLineNumber = lineNumber;\r\n                    }\r\n                }\r\n            }\r\n            if (hasChange) {\r\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber });\r\n            }\r\n        }\r\n        if (ranges.length > 0) {\r\n            this._emitModelTokensChangedEvent({\r\n                tokenizationSupportChanged: false,\r\n                semanticTokensApplied: false,\r\n                ranges: ranges\r\n            });\r\n        }\r\n    }\r\n    setSemanticTokens(tokens, isComplete) {\r\n        this._tokens2.set(tokens, isComplete);\r\n        this._emitModelTokensChangedEvent({\r\n            tokenizationSupportChanged: false,\r\n            semanticTokensApplied: tokens !== null,\r\n            ranges: [{ fromLineNumber: 1, toLineNumber: this.getLineCount() }]\r\n        });\r\n    }\r\n    hasCompleteSemanticTokens() {\r\n        return this._tokens2.isComplete();\r\n    }\r\n    hasSomeSemanticTokens() {\r\n        return !this._tokens2.isEmpty();\r\n    }\r\n    setPartialSemanticTokens(range, tokens) {\r\n        if (this.hasCompleteSemanticTokens()) {\r\n            return;\r\n        }\r\n        const changedRange = this._tokens2.setPartial(range, tokens);\r\n        this._emitModelTokensChangedEvent({\r\n            tokenizationSupportChanged: false,\r\n            semanticTokensApplied: true,\r\n            ranges: [{ fromLineNumber: changedRange.startLineNumber, toLineNumber: changedRange.endLineNumber }]\r\n        });\r\n    }\r\n    tokenizeViewport(startLineNumber, endLineNumber) {\r\n        startLineNumber = Math.max(1, startLineNumber);\r\n        endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);\r\n        this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\r\n    }\r\n    clearTokens() {\r\n        this._tokens.flush();\r\n        this._emitModelTokensChangedEvent({\r\n            tokenizationSupportChanged: true,\r\n            semanticTokensApplied: false,\r\n            ranges: [{\r\n                    fromLineNumber: 1,\r\n                    toLineNumber: this._buffer.getLineCount()\r\n                }]\r\n        });\r\n    }\r\n    _emitModelTokensChangedEvent(e) {\r\n        if (!this._isDisposing) {\r\n            this._onDidChangeTokens.fire(e);\r\n        }\r\n    }\r\n    resetTokenization() {\r\n        this._tokenization.reset();\r\n    }\r\n    forceTokenization(lineNumber) {\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        this._tokenization.forceTokenization(lineNumber);\r\n    }\r\n    isCheapToTokenize(lineNumber) {\r\n        return this._tokenization.isCheapToTokenize(lineNumber);\r\n    }\r\n    tokenizeIfCheap(lineNumber) {\r\n        if (this.isCheapToTokenize(lineNumber)) {\r\n            this.forceTokenization(lineNumber);\r\n        }\r\n    }\r\n    getLineTokens(lineNumber) {\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._getLineTokens(lineNumber);\r\n    }\r\n    _getLineTokens(lineNumber) {\r\n        const lineText = this.getLineContent(lineNumber);\r\n        const syntacticTokens = this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);\r\n        return this._tokens2.addSemanticTokens(lineNumber, syntacticTokens);\r\n    }\r\n    getLanguageIdentifier() {\r\n        return this._languageIdentifier;\r\n    }\r\n    getModeId() {\r\n        return this._languageIdentifier.language;\r\n    }\r\n    setMode(languageIdentifier) {\r\n        if (this._languageIdentifier.id === languageIdentifier.id) {\r\n            // There's nothing to do\r\n            return;\r\n        }\r\n        let e = {\r\n            oldLanguage: this._languageIdentifier.language,\r\n            newLanguage: languageIdentifier.language\r\n        };\r\n        this._languageIdentifier = languageIdentifier;\r\n        this._onDidChangeLanguage.fire(e);\r\n        this._onDidChangeLanguageConfiguration.fire({});\r\n    }\r\n    getLanguageIdAtPosition(lineNumber, column) {\r\n        const position = this.validatePosition(new Position(lineNumber, column));\r\n        const lineTokens = this.getLineTokens(position.lineNumber);\r\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\r\n    }\r\n    // Having tokens allows implementing additional helper methods\r\n    getWordAtPosition(_position) {\r\n        this._assertNotDisposed();\r\n        const position = this.validatePosition(_position);\r\n        const lineContent = this.getLineContent(position.lineNumber);\r\n        const lineTokens = this._getLineTokens(position.lineNumber);\r\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n        // (1). First try checking right biased word\r\n        const [rbStartOffset, rbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex);\r\n        const rightBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\r\n        // Make sure the result touches the original passed in position\r\n        if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\r\n            return rightBiasedWord;\r\n        }\r\n        // (2). Else, if we were at a language boundary, check the left biased word\r\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\r\n            // edge case, where `position` sits between two tokens belonging to two different languages\r\n            const [lbStartOffset, lbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1);\r\n            const leftBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\r\n            // Make sure the result touches the original passed in position\r\n            if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\r\n                return leftBiasedWord;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\r\n        const languageId = lineTokens.getLanguageId(tokenIndex);\r\n        // go left until a different language is hit\r\n        let startOffset = 0;\r\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\r\n            startOffset = lineTokens.getStartOffset(i);\r\n        }\r\n        // go right until a different language is hit\r\n        let endOffset = lineTokens.getLineContent().length;\r\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\r\n            endOffset = lineTokens.getEndOffset(i);\r\n        }\r\n        return [startOffset, endOffset];\r\n    }\r\n    getWordUntilPosition(position) {\r\n        const wordAtPosition = this.getWordAtPosition(position);\r\n        if (!wordAtPosition) {\r\n            return {\r\n                word: '',\r\n                startColumn: position.column,\r\n                endColumn: position.column\r\n            };\r\n        }\r\n        return {\r\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\r\n            startColumn: wordAtPosition.startColumn,\r\n            endColumn: position.column\r\n        };\r\n    }\r\n    findMatchingBracketUp(_bracket, _position) {\r\n        let bracket = _bracket.toLowerCase();\r\n        let position = this.validatePosition(_position);\r\n        let lineTokens = this._getLineTokens(position.lineNumber);\r\n        let languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\r\n        let bracketsSupport = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n        if (!bracketsSupport) {\r\n            return null;\r\n        }\r\n        let data = bracketsSupport.textIsBracket[bracket];\r\n        if (!data) {\r\n            return null;\r\n        }\r\n        return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, null));\r\n    }\r\n    matchBracket(position) {\r\n        return this._matchBracket(this.validatePosition(position));\r\n    }\r\n    _matchBracket(position) {\r\n        const lineNumber = position.lineNumber;\r\n        const lineTokens = this._getLineTokens(lineNumber);\r\n        const tokenCount = lineTokens.getCount();\r\n        const lineText = this._buffer.getLineContent(lineNumber);\r\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n        if (tokenIndex < 0) {\r\n            return null;\r\n        }\r\n        const currentModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));\r\n        // check that the token is not to be ignored\r\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\r\n            // limit search to not go before `maxBracketLength`\r\n            let searchStartOffset = Math.max(0, position.column - 1 - currentModeBrackets.maxBracketLength);\r\n            for (let i = tokenIndex - 1; i >= 0; i--) {\r\n                const tokenEndOffset = lineTokens.getEndOffset(i);\r\n                if (tokenEndOffset <= searchStartOffset) {\r\n                    break;\r\n                }\r\n                if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i))) {\r\n                    searchStartOffset = tokenEndOffset;\r\n                }\r\n            }\r\n            // limit search to not go after `maxBracketLength`\r\n            const searchEndOffset = Math.min(lineText.length, position.column - 1 + currentModeBrackets.maxBracketLength);\r\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\r\n            // `bestResult` will contain the most right-side result\r\n            let bestResult = null;\r\n            while (true) {\r\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (!foundBracket) {\r\n                    // there are no more brackets in this text\r\n                    break;\r\n                }\r\n                // check that we didn't hit a bracket too far away from position\r\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\r\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\r\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], null);\r\n                    if (r) {\r\n                        if (r instanceof BracketSearchCanceled) {\r\n                            return null;\r\n                        }\r\n                        bestResult = r;\r\n                    }\r\n                }\r\n                searchStartOffset = foundBracket.endColumn - 1;\r\n            }\r\n            if (bestResult) {\r\n                return bestResult;\r\n            }\r\n        }\r\n        // If position is in between two tokens, try also looking in the previous token\r\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\r\n            const prevTokenIndex = tokenIndex - 1;\r\n            const prevModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(prevTokenIndex));\r\n            // check that previous token is not to be ignored\r\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\r\n                // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`\r\n                const searchStartOffset = Math.max(0, position.column - 1 - prevModeBrackets.maxBracketLength);\r\n                let searchEndOffset = Math.min(lineText.length, position.column - 1 + prevModeBrackets.maxBracketLength);\r\n                for (let i = prevTokenIndex + 1; i < tokenCount; i++) {\r\n                    const tokenStartOffset = lineTokens.getStartOffset(i);\r\n                    if (tokenStartOffset >= searchEndOffset) {\r\n                        break;\r\n                    }\r\n                    if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i))) {\r\n                        searchEndOffset = tokenStartOffset;\r\n                    }\r\n                }\r\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                // check that we didn't hit a bracket too far away from position\r\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\r\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\r\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], null);\r\n                    if (r) {\r\n                        if (r instanceof BracketSearchCanceled) {\r\n                            return null;\r\n                        }\r\n                        return r;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\r\n        if (!data) {\r\n            return null;\r\n        }\r\n        const matched = (isOpen\r\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\r\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\r\n        if (!matched) {\r\n            return null;\r\n        }\r\n        if (matched instanceof BracketSearchCanceled) {\r\n            return matched;\r\n        }\r\n        return [foundBracket, matched];\r\n    }\r\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\r\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\r\n        const languageId = bracket.languageIdentifier.id;\r\n        const reversedBracketRegex = bracket.reversedRegex;\r\n        let count = -1;\r\n        let totalCallCount = 0;\r\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\r\n            while (true) {\r\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\r\n                    return BracketSearchCanceled.INSTANCE;\r\n                }\r\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (!r) {\r\n                    break;\r\n                }\r\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\r\n                if (bracket.isOpen(hitText)) {\r\n                    count++;\r\n                }\r\n                else if (bracket.isClose(hitText)) {\r\n                    count--;\r\n                }\r\n                if (count === 0) {\r\n                    return r;\r\n                }\r\n                searchEndOffset = r.startColumn - 1;\r\n            }\r\n            return null;\r\n        };\r\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\r\n            const lineTokens = this._getLineTokens(lineNumber);\r\n            const tokenCount = lineTokens.getCount();\r\n            const lineText = this._buffer.getLineContent(lineNumber);\r\n            let tokenIndex = tokenCount - 1;\r\n            let searchStartOffset = lineText.length;\r\n            let searchEndOffset = lineText.length;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n            }\r\n            let prevSearchInToken = true;\r\n            for (; tokenIndex >= 0; tokenIndex--) {\r\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchStartOffset\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return r;\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return r;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\r\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\r\n        const languageId = bracket.languageIdentifier.id;\r\n        const bracketRegex = bracket.forwardRegex;\r\n        let count = 1;\r\n        let totalCallCount = 0;\r\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\r\n            while (true) {\r\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\r\n                    return BracketSearchCanceled.INSTANCE;\r\n                }\r\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (!r) {\r\n                    break;\r\n                }\r\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\r\n                if (bracket.isOpen(hitText)) {\r\n                    count++;\r\n                }\r\n                else if (bracket.isClose(hitText)) {\r\n                    count--;\r\n                }\r\n                if (count === 0) {\r\n                    return r;\r\n                }\r\n                searchStartOffset = r.endColumn - 1;\r\n            }\r\n            return null;\r\n        };\r\n        const lineCount = this.getLineCount();\r\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\r\n            const lineTokens = this._getLineTokens(lineNumber);\r\n            const tokenCount = lineTokens.getCount();\r\n            const lineText = this._buffer.getLineContent(lineNumber);\r\n            let tokenIndex = 0;\r\n            let searchStartOffset = 0;\r\n            let searchEndOffset = 0;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n            }\r\n            let prevSearchInToken = true;\r\n            for (; tokenIndex < tokenCount; tokenIndex++) {\r\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchEndOffset\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return r;\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return r;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    findPrevBracket(_position) {\r\n        const position = this.validatePosition(_position);\r\n        let languageId = -1;\r\n        let modeBrackets = null;\r\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\r\n            const lineTokens = this._getLineTokens(lineNumber);\r\n            const tokenCount = lineTokens.getCount();\r\n            const lineText = this._buffer.getLineContent(lineNumber);\r\n            let tokenIndex = tokenCount - 1;\r\n            let searchStartOffset = lineText.length;\r\n            let searchEndOffset = lineText.length;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                }\r\n            }\r\n            let prevSearchInToken = true;\r\n            for (; tokenIndex >= 0; tokenIndex--) {\r\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    // language id change!\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return this._toFoundBracket(modeBrackets, r);\r\n                        }\r\n                        prevSearchInToken = false;\r\n                    }\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                }\r\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchStartOffset\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return this._toFoundBracket(modeBrackets, r);\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return this._toFoundBracket(modeBrackets, r);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    findNextBracket(_position) {\r\n        const position = this.validatePosition(_position);\r\n        const lineCount = this.getLineCount();\r\n        let languageId = -1;\r\n        let modeBrackets = null;\r\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\r\n            const lineTokens = this._getLineTokens(lineNumber);\r\n            const tokenCount = lineTokens.getCount();\r\n            const lineText = this._buffer.getLineContent(lineNumber);\r\n            let tokenIndex = 0;\r\n            let searchStartOffset = 0;\r\n            let searchEndOffset = 0;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                }\r\n            }\r\n            let prevSearchInToken = true;\r\n            for (; tokenIndex < tokenCount; tokenIndex++) {\r\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    // language id change!\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return this._toFoundBracket(modeBrackets, r);\r\n                        }\r\n                        prevSearchInToken = false;\r\n                    }\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                }\r\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchEndOffset\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return this._toFoundBracket(modeBrackets, r);\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return this._toFoundBracket(modeBrackets, r);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    findEnclosingBrackets(_position, maxDuration) {\r\n        let continueSearchPredicate;\r\n        if (typeof maxDuration === 'undefined') {\r\n            continueSearchPredicate = null;\r\n        }\r\n        else {\r\n            const startTime = Date.now();\r\n            continueSearchPredicate = () => {\r\n                return (Date.now() - startTime <= maxDuration);\r\n            };\r\n        }\r\n        const position = this.validatePosition(_position);\r\n        const lineCount = this.getLineCount();\r\n        const savedCounts = new Map();\r\n        let counts = [];\r\n        const resetCounts = (languageId, modeBrackets) => {\r\n            if (!savedCounts.has(languageId)) {\r\n                let tmp = [];\r\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\r\n                    tmp[i] = 0;\r\n                }\r\n                savedCounts.set(languageId, tmp);\r\n            }\r\n            counts = savedCounts.get(languageId);\r\n        };\r\n        let totalCallCount = 0;\r\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\r\n            while (true) {\r\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\r\n                    return BracketSearchCanceled.INSTANCE;\r\n                }\r\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (!r) {\r\n                    break;\r\n                }\r\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\r\n                const bracket = modeBrackets.textIsBracket[hitText];\r\n                if (bracket) {\r\n                    if (bracket.isOpen(hitText)) {\r\n                        counts[bracket.index]++;\r\n                    }\r\n                    else if (bracket.isClose(hitText)) {\r\n                        counts[bracket.index]--;\r\n                    }\r\n                    if (counts[bracket.index] === -1) {\r\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\r\n                    }\r\n                }\r\n                searchStartOffset = r.endColumn - 1;\r\n            }\r\n            return null;\r\n        };\r\n        let languageId = -1;\r\n        let modeBrackets = null;\r\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\r\n            const lineTokens = this._getLineTokens(lineNumber);\r\n            const tokenCount = lineTokens.getCount();\r\n            const lineText = this._buffer.getLineContent(lineNumber);\r\n            let tokenIndex = 0;\r\n            let searchStartOffset = 0;\r\n            let searchEndOffset = 0;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                    resetCounts(languageId, modeBrackets);\r\n                }\r\n            }\r\n            let prevSearchInToken = true;\r\n            for (; tokenIndex < tokenCount; tokenIndex++) {\r\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    // language id change!\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return stripBracketSearchCanceled(r);\r\n                        }\r\n                        prevSearchInToken = false;\r\n                    }\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                    resetCounts(languageId, modeBrackets);\r\n                }\r\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchEndOffset\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return stripBracketSearchCanceled(r);\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return stripBracketSearchCanceled(r);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    _toFoundBracket(modeBrackets, r) {\r\n        if (!r) {\r\n            return null;\r\n        }\r\n        let text = this.getValueInRange(r);\r\n        text = text.toLowerCase();\r\n        let data = modeBrackets.textIsBracket[text];\r\n        if (!data) {\r\n            return null;\r\n        }\r\n        return {\r\n            range: r,\r\n            open: data.open,\r\n            close: data.close,\r\n            isOpen: modeBrackets.textIsOpenBracket[text]\r\n        };\r\n    }\r\n    /**\r\n     * Returns:\r\n     *  - -1 => the line consists of whitespace\r\n     *  - otherwise => the indent level is returned value\r\n     */\r\n    static computeIndentLevel(line, tabSize) {\r\n        let indent = 0;\r\n        let i = 0;\r\n        let len = line.length;\r\n        while (i < len) {\r\n            let chCode = line.charCodeAt(i);\r\n            if (chCode === 32 /* Space */) {\r\n                indent++;\r\n            }\r\n            else if (chCode === 9 /* Tab */) {\r\n                indent = indent - indent % tabSize + tabSize;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        if (i === len) {\r\n            return -1; // line only consists of whitespace\r\n        }\r\n        return indent;\r\n    }\r\n    _computeIndentLevel(lineIndex) {\r\n        return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);\r\n    }\r\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\r\n        this._assertNotDisposed();\r\n        const lineCount = this.getLineCount();\r\n        if (lineNumber < 1 || lineNumber > lineCount) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        const foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\r\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\r\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        let up_aboveContentLineIndent = -1;\r\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        let up_belowContentLineIndent = -1;\r\n        const up_resolveIndents = (lineNumber) => {\r\n            if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\r\n                up_aboveContentLineIndex = -1;\r\n                up_aboveContentLineIndent = -1;\r\n                // must find previous line with content\r\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\r\n                    let indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        up_aboveContentLineIndex = lineIndex;\r\n                        up_aboveContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (up_belowContentLineIndex === -2) {\r\n                up_belowContentLineIndex = -1;\r\n                up_belowContentLineIndent = -1;\r\n                // must find next line with content\r\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\r\n                    let indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        up_belowContentLineIndex = lineIndex;\r\n                        up_belowContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        let down_aboveContentLineIndent = -1;\r\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        let down_belowContentLineIndent = -1;\r\n        const down_resolveIndents = (lineNumber) => {\r\n            if (down_aboveContentLineIndex === -2) {\r\n                down_aboveContentLineIndex = -1;\r\n                down_aboveContentLineIndent = -1;\r\n                // must find previous line with content\r\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\r\n                    let indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        down_aboveContentLineIndex = lineIndex;\r\n                        down_aboveContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\r\n                down_belowContentLineIndex = -1;\r\n                down_belowContentLineIndent = -1;\r\n                // must find next line with content\r\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\r\n                    let indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        down_belowContentLineIndex = lineIndex;\r\n                        down_belowContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        let startLineNumber = 0;\r\n        let goUp = true;\r\n        let endLineNumber = 0;\r\n        let goDown = true;\r\n        let indent = 0;\r\n        let initialIndent = 0;\r\n        for (let distance = 0; goUp || goDown; distance++) {\r\n            const upLineNumber = lineNumber - distance;\r\n            const downLineNumber = lineNumber + distance;\r\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\r\n                goUp = false;\r\n            }\r\n            if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\r\n                goDown = false;\r\n            }\r\n            if (distance > 50000) {\r\n                // stop processing\r\n                goUp = false;\r\n                goDown = false;\r\n            }\r\n            let upLineIndentLevel = -1;\r\n            if (goUp) {\r\n                // compute indent level going up\r\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\r\n                if (currentIndent >= 0) {\r\n                    // This line has content (besides whitespace)\r\n                    // Use the line's indent\r\n                    up_belowContentLineIndex = upLineNumber - 1;\r\n                    up_belowContentLineIndent = currentIndent;\r\n                    upLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\r\n                }\r\n                else {\r\n                    up_resolveIndents(upLineNumber);\r\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\r\n                }\r\n            }\r\n            let downLineIndentLevel = -1;\r\n            if (goDown) {\r\n                // compute indent level going down\r\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\r\n                if (currentIndent >= 0) {\r\n                    // This line has content (besides whitespace)\r\n                    // Use the line's indent\r\n                    down_aboveContentLineIndex = downLineNumber - 1;\r\n                    down_aboveContentLineIndent = currentIndent;\r\n                    downLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\r\n                }\r\n                else {\r\n                    down_resolveIndents(downLineNumber);\r\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\r\n                }\r\n            }\r\n            if (distance === 0) {\r\n                initialIndent = upLineIndentLevel;\r\n                continue;\r\n            }\r\n            if (distance === 1) {\r\n                if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {\r\n                    // This is the beginning of a scope, we have special handling here, since we want the\r\n                    // child scope indent to be active, not the parent scope\r\n                    goUp = false;\r\n                    startLineNumber = downLineNumber;\r\n                    endLineNumber = downLineNumber;\r\n                    indent = downLineIndentLevel;\r\n                    continue;\r\n                }\r\n                if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {\r\n                    // This is the end of a scope, just like above\r\n                    goDown = false;\r\n                    startLineNumber = upLineNumber;\r\n                    endLineNumber = upLineNumber;\r\n                    indent = upLineIndentLevel;\r\n                    continue;\r\n                }\r\n                startLineNumber = lineNumber;\r\n                endLineNumber = lineNumber;\r\n                indent = initialIndent;\r\n                if (indent === 0) {\r\n                    // No need to continue\r\n                    return { startLineNumber, endLineNumber, indent };\r\n                }\r\n            }\r\n            if (goUp) {\r\n                if (upLineIndentLevel >= indent) {\r\n                    startLineNumber = upLineNumber;\r\n                }\r\n                else {\r\n                    goUp = false;\r\n                }\r\n            }\r\n            if (goDown) {\r\n                if (downLineIndentLevel >= indent) {\r\n                    endLineNumber = downLineNumber;\r\n                }\r\n                else {\r\n                    goDown = false;\r\n                }\r\n            }\r\n        }\r\n        return { startLineNumber, endLineNumber, indent };\r\n    }\r\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\r\n        this._assertNotDisposed();\r\n        const lineCount = this.getLineCount();\r\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\r\n            throw new Error('Illegal value for startLineNumber');\r\n        }\r\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\r\n            throw new Error('Illegal value for endLineNumber');\r\n        }\r\n        const foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\r\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\r\n        let result = new Array(endLineNumber - startLineNumber + 1);\r\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        let aboveContentLineIndent = -1;\r\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        let belowContentLineIndent = -1;\r\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            let resultIndex = lineNumber - startLineNumber;\r\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\r\n            if (currentIndent >= 0) {\r\n                // This line has content (besides whitespace)\r\n                // Use the line's indent\r\n                aboveContentLineIndex = lineNumber - 1;\r\n                aboveContentLineIndent = currentIndent;\r\n                result[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);\r\n                continue;\r\n            }\r\n            if (aboveContentLineIndex === -2) {\r\n                aboveContentLineIndex = -1;\r\n                aboveContentLineIndent = -1;\r\n                // must find previous line with content\r\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\r\n                    let indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        aboveContentLineIndex = lineIndex;\r\n                        aboveContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\r\n                belowContentLineIndex = -1;\r\n                belowContentLineIndent = -1;\r\n                // must find next line with content\r\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\r\n                    let indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        belowContentLineIndex = lineIndex;\r\n                        belowContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\r\n        }\r\n        return result;\r\n    }\r\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\r\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\r\n            // At the top or bottom of the file\r\n            return 0;\r\n        }\r\n        else if (aboveContentLineIndent < belowContentLineIndent) {\r\n            // we are inside the region above\r\n            return (1 + Math.floor(aboveContentLineIndent / this._options.indentSize));\r\n        }\r\n        else if (aboveContentLineIndent === belowContentLineIndent) {\r\n            // we are in between two regions\r\n            return Math.ceil(belowContentLineIndent / this._options.indentSize);\r\n        }\r\n        else {\r\n            if (offSide) {\r\n                // same level as region below\r\n                return Math.ceil(belowContentLineIndent / this._options.indentSize);\r\n            }\r\n            else {\r\n                // we are inside the region that ends below\r\n                return (1 + Math.floor(belowContentLineIndent / this._options.indentSize));\r\n            }\r\n        }\r\n    }\r\n}\r\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\r\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\r\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\r\nTextModel.DEFAULT_CREATION_OPTIONS = {\r\n    isForSimpleWidget: false,\r\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\r\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\r\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\r\n    detectIndentation: false,\r\n    defaultEOL: 1 /* LF */,\r\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\r\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\r\n};\r\n//#region Decorations\r\nclass DecorationsTrees {\r\n    constructor() {\r\n        this._decorationsTree0 = new IntervalTree();\r\n        this._decorationsTree1 = new IntervalTree();\r\n    }\r\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\r\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\r\n        return r0.concat(r1);\r\n    }\r\n    search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\r\n        if (overviewRulerOnly) {\r\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\r\n        }\r\n        else {\r\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\r\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\r\n            return r0.concat(r1);\r\n        }\r\n    }\r\n    collectNodesFromOwner(ownerId) {\r\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\r\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\r\n        return r0.concat(r1);\r\n    }\r\n    collectNodesPostOrder() {\r\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\r\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\r\n        return r0.concat(r1);\r\n    }\r\n    insert(node) {\r\n        if (getNodeIsInOverviewRuler(node)) {\r\n            this._decorationsTree1.insert(node);\r\n        }\r\n        else {\r\n            this._decorationsTree0.insert(node);\r\n        }\r\n    }\r\n    delete(node) {\r\n        if (getNodeIsInOverviewRuler(node)) {\r\n            this._decorationsTree1.delete(node);\r\n        }\r\n        else {\r\n            this._decorationsTree0.delete(node);\r\n        }\r\n    }\r\n    resolveNode(node, cachedVersionId) {\r\n        if (getNodeIsInOverviewRuler(node)) {\r\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\r\n        }\r\n        else {\r\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\r\n        }\r\n    }\r\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\r\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\r\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\r\n    }\r\n}\r\nfunction cleanClassName(className) {\r\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\r\n}\r\nclass DecorationOptions {\r\n    constructor(options) {\r\n        this.color = options.color || '';\r\n        this.darkColor = options.darkColor || '';\r\n    }\r\n}\r\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\r\n    constructor(options) {\r\n        super(options);\r\n        this._resolvedColor = null;\r\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\r\n    }\r\n    getColor(theme) {\r\n        if (!this._resolvedColor) {\r\n            if (theme.type !== 'light' && this.darkColor) {\r\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\r\n            }\r\n            else {\r\n                this._resolvedColor = this._resolveColor(this.color, theme);\r\n            }\r\n        }\r\n        return this._resolvedColor;\r\n    }\r\n    invalidateCachedColor() {\r\n        this._resolvedColor = null;\r\n    }\r\n    _resolveColor(color, theme) {\r\n        if (typeof color === 'string') {\r\n            return color;\r\n        }\r\n        let c = color ? theme.getColor(color.id) : null;\r\n        if (!c) {\r\n            return '';\r\n        }\r\n        return c.toString();\r\n    }\r\n}\r\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\r\n    constructor(options) {\r\n        super(options);\r\n        this.position = options.position;\r\n    }\r\n    getColor(theme) {\r\n        if (!this._resolvedColor) {\r\n            if (theme.type !== 'light' && this.darkColor) {\r\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\r\n            }\r\n            else {\r\n                this._resolvedColor = this._resolveColor(this.color, theme);\r\n            }\r\n        }\r\n        return this._resolvedColor;\r\n    }\r\n    invalidateCachedColor() {\r\n        this._resolvedColor = undefined;\r\n    }\r\n    _resolveColor(color, theme) {\r\n        if (typeof color === 'string') {\r\n            return Color.fromHex(color);\r\n        }\r\n        return theme.getColor(color.id);\r\n    }\r\n}\r\nexport class ModelDecorationOptions {\r\n    constructor(options) {\r\n        this.stickiness = options.stickiness || 0 /* AlwaysGrowsWhenTypingAtEdges */;\r\n        this.zIndex = options.zIndex || 0;\r\n        this.className = options.className ? cleanClassName(options.className) : null;\r\n        this.hoverMessage = options.hoverMessage || null;\r\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\r\n        this.isWholeLine = options.isWholeLine || false;\r\n        this.showIfCollapsed = options.showIfCollapsed || false;\r\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\r\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\r\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\r\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\r\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\r\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\r\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\r\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\r\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\r\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\r\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\r\n    }\r\n    static register(options) {\r\n        return new ModelDecorationOptions(options);\r\n    }\r\n    static createDynamic(options) {\r\n        return new ModelDecorationOptions(options);\r\n    }\r\n}\r\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});\r\n/**\r\n * The order carefully matches the values of the enum.\r\n */\r\nconst TRACKED_RANGE_OPTIONS = [\r\n    ModelDecorationOptions.register({ stickiness: 0 /* AlwaysGrowsWhenTypingAtEdges */ }),\r\n    ModelDecorationOptions.register({ stickiness: 1 /* NeverGrowsWhenTypingAtEdges */ }),\r\n    ModelDecorationOptions.register({ stickiness: 2 /* GrowsOnlyWhenTypingBefore */ }),\r\n    ModelDecorationOptions.register({ stickiness: 3 /* GrowsOnlyWhenTypingAfter */ }),\r\n];\r\nfunction _normalizeOptions(options) {\r\n    if (options instanceof ModelDecorationOptions) {\r\n        return options;\r\n    }\r\n    return ModelDecorationOptions.createDynamic(options);\r\n}\r\nexport class DidChangeDecorationsEmitter extends Disposable {\r\n    constructor() {\r\n        super();\r\n        this._actual = this._register(new Emitter());\r\n        this.event = this._actual.event;\r\n        this._deferredCnt = 0;\r\n        this._shouldFire = false;\r\n        this._affectsMinimap = false;\r\n        this._affectsOverviewRuler = false;\r\n    }\r\n    beginDeferredEmit() {\r\n        this._deferredCnt++;\r\n    }\r\n    endDeferredEmit() {\r\n        this._deferredCnt--;\r\n        if (this._deferredCnt === 0) {\r\n            if (this._shouldFire) {\r\n                const event = {\r\n                    affectsMinimap: this._affectsMinimap,\r\n                    affectsOverviewRuler: this._affectsOverviewRuler,\r\n                };\r\n                this._shouldFire = false;\r\n                this._affectsMinimap = false;\r\n                this._affectsOverviewRuler = false;\r\n                this._actual.fire(event);\r\n            }\r\n        }\r\n    }\r\n    checkAffectedAndFire(options) {\r\n        if (!this._affectsMinimap) {\r\n            this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\r\n        }\r\n        if (!this._affectsOverviewRuler) {\r\n            this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\r\n        }\r\n        this._shouldFire = true;\r\n    }\r\n    fire() {\r\n        this._affectsMinimap = true;\r\n        this._affectsOverviewRuler = true;\r\n        this._shouldFire = true;\r\n    }\r\n}\r\n//#endregion\r\nexport class DidChangeContentEmitter extends Disposable {\r\n    constructor() {\r\n        super();\r\n        /**\r\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\r\n         */\r\n        this._fastEmitter = this._register(new Emitter());\r\n        this.fastEvent = this._fastEmitter.event;\r\n        this._slowEmitter = this._register(new Emitter());\r\n        this.slowEvent = this._slowEmitter.event;\r\n        this._deferredCnt = 0;\r\n        this._deferredEvent = null;\r\n    }\r\n    beginDeferredEmit() {\r\n        this._deferredCnt++;\r\n    }\r\n    endDeferredEmit(resultingSelection = null) {\r\n        this._deferredCnt--;\r\n        if (this._deferredCnt === 0) {\r\n            if (this._deferredEvent !== null) {\r\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\r\n                const e = this._deferredEvent;\r\n                this._deferredEvent = null;\r\n                this._fastEmitter.fire(e);\r\n                this._slowEmitter.fire(e);\r\n            }\r\n        }\r\n    }\r\n    fire(e) {\r\n        if (this._deferredCnt > 0) {\r\n            if (this._deferredEvent) {\r\n                this._deferredEvent = this._deferredEvent.merge(e);\r\n            }\r\n            else {\r\n                this._deferredEvent = e;\r\n            }\r\n            return;\r\n        }\r\n        this._fastEmitter.fire(e);\r\n        this._slowEmitter.fire(e);\r\n    }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,iBAAiB,QAAQ,gCAAgC;AAClE,SAASC,OAAO,QAAQ,+BAA+B;AACvD,SAASC,UAAU,QAAQ,mCAAmC;AAC9D,OAAO,KAAKC,OAAO,MAAM,iCAAiC;AAC1D,SAASC,GAAG,QAAQ,6BAA6B;AACjD,SAASC,qBAAqB,QAAQ,4BAA4B;AAClE,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,SAAS,QAAQ,sBAAsB;AAChD,OAAO,KAAKC,KAAK,MAAM,aAAa;AACpC,SAASC,SAAS,QAAQ,gBAAgB;AAC1C,SAASC,gBAAgB,QAAQ,yBAAyB;AAC1D,SAASC,YAAY,EAAEC,YAAY,EAAEC,wBAAwB,EAAEC,eAAe,QAAQ,mBAAmB;AACzG,SAASC,0BAA0B,QAAQ,qDAAqD;AAChG,SAASC,+BAA+B,EAAEC,2BAA2B,EAAEC,kBAAkB,EAAEC,aAAa,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,qBAAqB,QAAQ,sBAAsB;AACxM,SAASC,YAAY,EAAEC,eAAe,QAAQ,sBAAsB;AACpE,SAASC,qBAAqB,QAAQ,sBAAsB;AAC5D,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,6BAA6B,QAAQ,2CAA2C;AACzF,SAASC,wBAAwB,QAAQ,sBAAsB;AAC/D,SAASC,qBAAqB,QAAQ,sBAAsB;AAC5D,SAASC,aAAa,QAAQ,uCAAuC;AACrE,SAASC,WAAW,EAAEC,QAAQ,EAAEC,YAAY,QAAQ,kBAAkB;AACtE,SAASC,KAAK,QAAQ,+BAA+B;AACrD,SAASC,mBAAmB,QAAQ,8CAA8C;AAClF,SAASC,uBAAuBA,CAAA,EAAG;EAC/B,OAAO,IAAIrB,0BAA0B,CAAC,CAAC;AAC3C;AACA,OAAO,SAASsB,uBAAuBA,CAACC,IAAI,EAAE;EAC1C,MAAMC,OAAO,GAAGH,uBAAuB,CAAC,CAAC;EACzCG,OAAO,CAACC,WAAW,CAACF,IAAI,CAAC;EACzB,OAAOC,OAAO,CAACE,MAAM,CAAC,CAAC;AAC3B;AACA,OAAO,SAASC,gBAAgBA,CAACC,KAAK,EAAEC,UAAU,EAAE;EAChD,MAAMC,OAAO,GAAI,OAAOF,KAAK,KAAK,QAAQ,GAAGN,uBAAuB,CAACM,KAAK,CAAC,GAAGA,KAAM;EACpF,OAAOE,OAAO,CAACC,MAAM,CAACF,UAAU,CAAC;AACrC;AACA,IAAIG,QAAQ,GAAG,CAAC;AAChB,MAAMC,gBAAgB,GAAG,GAAG;AAC5B,OAAO,MAAMC,kBAAkB,GAAG,KAAK;AACvC,MAAMC,iBAAiB,CAAC;EACpBC,WAAWA,CAACC,MAAM,EAAE;IAChB,IAAI,CAACC,OAAO,GAAGD,MAAM;IACrB,IAAI,CAACE,IAAI,GAAG,KAAK;EACrB;EACAC,IAAIA,CAAA,EAAG;IACH,IAAI,IAAI,CAACD,IAAI,EAAE;MACX,OAAO,IAAI;IACf;IACA,IAAIE,MAAM,GAAG,EAAE;MAAEC,SAAS,GAAG,CAAC;MAAEC,YAAY,GAAG,CAAC;IAChD,GAAG;MACC,IAAIC,GAAG,GAAG,IAAI,CAACN,OAAO,CAACE,IAAI,CAAC,CAAC;MAC7B,IAAII,GAAG,KAAK,IAAI,EAAE;QACd;QACA,IAAI,CAACL,IAAI,GAAG,IAAI;QAChB,IAAIG,SAAS,KAAK,CAAC,EAAE;UACjB,OAAO,IAAI;QACf,CAAC,MACI;UACD,OAAOD,MAAM,CAACI,IAAI,CAAC,EAAE,CAAC;QAC1B;MACJ;MACA,IAAID,GAAG,CAACE,MAAM,GAAG,CAAC,EAAE;QAChBL,MAAM,CAACC,SAAS,EAAE,CAAC,GAAGE,GAAG;QACzBD,YAAY,IAAIC,GAAG,CAACE,MAAM;MAC9B;MACA,IAAIH,YAAY,IAAI,EAAE,GAAG,IAAI,EAAE;QAC3B,OAAOF,MAAM,CAACI,IAAI,CAAC,EAAE,CAAC;MAC1B;IACJ,CAAC,QAAQ,IAAI;EACjB;AACJ;AACA,MAAME,WAAW,GAAGA,CAAA,KAAM;EAAE,MAAM,IAAIC,KAAK,0BAA0B,CAAC;AAAE,CAAC;AACzE,MAAMC,qBAAqB,CAAC;EACxBb,WAAWA,CAAA,EAAG;IACV,IAAI,CAACc,oBAAoB,GAAGC,SAAS;EACzC;AACJ;AACAF,qBAAqB,CAACG,QAAQ,GAAG,IAAIH,qBAAqB,CAAC,CAAC;AAC5D,SAASI,0BAA0BA,CAACZ,MAAM,EAAE;EACxC,IAAIA,MAAM,YAAYQ,qBAAqB,EAAE;IACzC,OAAO,IAAI;EACf;EACA,OAAOR,MAAM;AACjB;AACA,OAAO,MAAMa,SAAS,SAASpE,UAAU,CAAC;EACtC;EACAkD,WAAWA,CAACC,MAAM,EAAEkB,eAAe,EAAEC,kBAAkB,EAA8C;IAAA,IAA5CC,kBAAkB,GAAAC,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,IAAI;IAAA,IAAEC,eAAe,GAAAD,SAAA,CAAAZ,MAAA,OAAAY,SAAA,MAAAP,SAAA;IAC/F,KAAK,CAAC,CAAC;IACP;IACA,IAAI,CAACS,cAAc,GAAG,IAAI,CAACC,SAAS,CAAC,IAAI5E,OAAO,CAAC,CAAC,CAAC;IACnD,IAAI,CAAC6E,aAAa,GAAG,IAAI,CAACF,cAAc,CAACG,KAAK;IAC9C,IAAI,CAACC,uBAAuB,GAAG,IAAI,CAACH,SAAS,CAAC,IAAII,2BAA2B,CAAC,CAAC,CAAC;IAChF,IAAI,CAACC,sBAAsB,GAAG,IAAI,CAACF,uBAAuB,CAACD,KAAK;IAChE,IAAI,CAACI,oBAAoB,GAAG,IAAI,CAACN,SAAS,CAAC,IAAI5E,OAAO,CAAC,CAAC,CAAC;IACzD,IAAI,CAACmF,mBAAmB,GAAG,IAAI,CAACD,oBAAoB,CAACJ,KAAK;IAC1D,IAAI,CAACM,iCAAiC,GAAG,IAAI,CAACR,SAAS,CAAC,IAAI5E,OAAO,CAAC,CAAC,CAAC;IACtE,IAAI,CAACqF,gCAAgC,GAAG,IAAI,CAACD,iCAAiC,CAACN,KAAK;IACpF,IAAI,CAACQ,kBAAkB,GAAG,IAAI,CAACV,SAAS,CAAC,IAAI5E,OAAO,CAAC,CAAC,CAAC;IACvD,IAAI,CAACuF,iBAAiB,GAAG,IAAI,CAACD,kBAAkB,CAACR,KAAK;IACtD,IAAI,CAACU,mBAAmB,GAAG,IAAI,CAACZ,SAAS,CAAC,IAAI5E,OAAO,CAAC,CAAC,CAAC;IACxD,IAAI,CAACyF,kBAAkB,GAAG,IAAI,CAACD,mBAAmB,CAACV,KAAK;IACxD,IAAI,CAACY,oBAAoB,GAAG,IAAI,CAACd,SAAS,CAAC,IAAI5E,OAAO,CAAC,CAAC,CAAC;IACzD,IAAI,CAAC2F,mBAAmB,GAAG,IAAI,CAACD,oBAAoB,CAACZ,KAAK;IAC1D,IAAI,CAACc,aAAa,GAAG,IAAI,CAAChB,SAAS,CAAC,IAAIiB,uBAAuB,CAAC,CAAC,CAAC;IAClE;IACA9C,QAAQ,EAAE;IACV,IAAI,CAAC+C,EAAE,GAAG,QAAQ,GAAG/C,QAAQ;IAC7B,IAAI,CAACgD,iBAAiB,GAAGzB,eAAe,CAACyB,iBAAiB;IAC1D,IAAI,OAAOvB,kBAAkB,KAAK,WAAW,IAAIA,kBAAkB,KAAK,IAAI,EAAE;MAC1E,IAAI,CAACwB,mBAAmB,GAAG7F,GAAG,CAAC8F,KAAK,CAAC,mBAAmB,GAAGlD,QAAQ,CAAC;IACxE,CAAC,MACI;MACD,IAAI,CAACiD,mBAAmB,GAAGxB,kBAAkB;IACjD;IACA,IAAI,CAAC0B,gBAAgB,GAAGxB,eAAe;IACvC,IAAI,CAACyB,oBAAoB,GAAG,CAAC;IAC7B,MAAM;MAAEC,UAAU;MAAEC;IAAW,CAAC,GAAG3D,gBAAgB,CAACU,MAAM,EAAEkB,eAAe,CAAC1B,UAAU,CAAC;IACvF,IAAI,CAAC0D,OAAO,GAAGF,UAAU;IACzB,IAAI,CAACG,iBAAiB,GAAGF,UAAU;IACnC,IAAI,CAACG,QAAQ,GAAGnC,SAAS,CAACoC,cAAc,CAAC,IAAI,CAACH,OAAO,EAAEhC,eAAe,CAAC;IACvE,MAAMoC,eAAe,GAAG,IAAI,CAACJ,OAAO,CAACK,YAAY,CAAC,CAAC;IACnD,MAAMC,gBAAgB,GAAG,IAAI,CAACN,OAAO,CAACO,qBAAqB,CAAC,IAAIvG,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEoG,eAAe,EAAE,IAAI,CAACJ,OAAO,CAACQ,aAAa,CAACJ,eAAe,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,iBAAiB,CAAC;IACnK;IACA;IACA;IACA,IAAIpC,eAAe,CAACyC,sBAAsB,EAAE;MACxC,IAAI,CAACC,0BAA0B,GAAKJ,gBAAgB,GAAGvC,SAAS,CAAC4C,yBAAyB,IAClFP,eAAe,GAAGrC,SAAS,CAAC6C,+BAAiC;IACzE,CAAC,MACI;MACD,IAAI,CAACF,0BAA0B,GAAG,KAAK;IAC3C;IACA,IAAI,CAACG,qBAAqB,GAAIP,gBAAgB,GAAGvC,SAAS,CAAC+C,gBAAiB;IAC5E,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,qBAAqB,GAAG,CAAC;IAC9B,IAAI,CAACC,wBAAwB,GAAG,IAAI;IACpC,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,YAAY,GAAG,KAAK;IACzB,IAAI,CAACC,mBAAmB,GAAGnD,kBAAkB,IAAI3C,wBAAwB;IACzE,IAAI,CAAC+F,yBAAyB,GAAGhG,6BAA6B,CAACiG,WAAW,CAAEC,CAAC,IAAK;MAC9E,IAAIA,CAAC,CAACtD,kBAAkB,CAACuB,EAAE,KAAK,IAAI,CAAC4B,mBAAmB,CAAC5B,EAAE,EAAE;QACzD,IAAI,CAACV,iCAAiC,CAAC0C,IAAI,CAAC,CAAC,CAAC,CAAC;MACnD;IACJ,CAAC,CAAC;IACF,IAAI,CAACC,WAAW,GAAG7H,OAAO,CAAC8H,gBAAgB,CAACjF,QAAQ,CAAC;IACrD,IAAI,CAACkF,iBAAiB,GAAG,CAAC;IAC1B,IAAI,CAACC,YAAY,GAAGC,MAAM,CAACrF,MAAM,CAAC,IAAI,CAAC;IACvC,IAAI,CAACsF,gBAAgB,GAAG,IAAIC,gBAAgB,CAAC,CAAC;IAC9C,IAAI,CAACC,eAAe,GAAG,IAAI7H,SAAS,CAAC,IAAI,EAAEiE,eAAe,CAAC;IAC3D,IAAI,CAAC6D,UAAU,GAAG,KAAK;IACvB,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB,IAAI,CAACC,wBAAwB,GAAG,IAAI;IACpC,IAAI,CAACC,OAAO,GAAG,IAAI3G,WAAW,CAAC,CAAC;IAChC,IAAI,CAAC4G,QAAQ,GAAG,IAAI1G,YAAY,CAAC,CAAC;IAClC,IAAI,CAAC2G,aAAa,GAAG,IAAInH,qBAAqB,CAAC,IAAI,CAAC;EACxD;EACA,OAAOgF,cAAcA,CAACL,UAAU,EAAEyC,OAAO,EAAE;IACvC,IAAIA,OAAO,CAACC,iBAAiB,EAAE;MAC3B,MAAMC,kBAAkB,GAAGrI,gBAAgB,CAAC0F,UAAU,EAAEyC,OAAO,CAACG,OAAO,EAAEH,OAAO,CAACI,YAAY,CAAC;MAC9F,OAAO,IAAIzI,KAAK,CAAC0I,wBAAwB,CAAC;QACtCF,OAAO,EAAED,kBAAkB,CAACC,OAAO;QACnCG,UAAU,EAAEJ,kBAAkB,CAACC,OAAO;QACtCC,YAAY,EAAEF,kBAAkB,CAACE,YAAY;QAC7CG,kBAAkB,EAAEP,OAAO,CAACO,kBAAkB;QAC9CxG,UAAU,EAAEiG,OAAO,CAACjG;MACxB,CAAC,CAAC;IACN;IACA,OAAO,IAAIpC,KAAK,CAAC0I,wBAAwB,CAAC;MACtCF,OAAO,EAAEH,OAAO,CAACG,OAAO;MACxBG,UAAU,EAAEN,OAAO,CAACM,UAAU;MAC9BF,YAAY,EAAEJ,OAAO,CAACI,YAAY;MAClCG,kBAAkB,EAAEP,OAAO,CAACO,kBAAkB;MAC9CxG,UAAU,EAAEiG,OAAO,CAACjG;IACxB,CAAC,CAAC;EACN;EACAyG,yBAAyBA,CAACC,QAAQ,EAAE;IAChC,OAAO,IAAI,CAAC1D,aAAa,CAAC2D,SAAS,CAAE1B,CAAC,IAAKyB,QAAQ,CAACzB,CAAC,CAAC2B,sBAAsB,CAAC,CAAC;EAClF;EACAC,sBAAsBA,CAACH,QAAQ,EAAE;IAC7B,OAAO,IAAI,CAAC1D,aAAa,CAAC2D,SAAS,CAAE1B,CAAC,IAAKyB,QAAQ,CAACzB,CAAC,CAAC6B,mBAAmB,CAAC,CAAC;EAC/E;EACAC,kBAAkBA,CAACL,QAAQ,EAAE;IACzB,OAAO,IAAI,CAAC1D,aAAa,CAACgE,SAAS,CAAE/B,CAAC,IAAKyB,QAAQ,CAACzB,CAAC,CAAC6B,mBAAmB,CAAC,CAAC;EAC/E;EACAG,OAAOA,CAAA,EAAG;IACN,IAAI,CAACpC,YAAY,GAAG,IAAI;IACxB,IAAI,CAAC9C,cAAc,CAACmD,IAAI,CAAC,CAAC;IAC1B,IAAI,CAACH,yBAAyB,CAACkC,OAAO,CAAC,CAAC;IACxC,IAAI,CAACjB,aAAa,CAACiB,OAAO,CAAC,CAAC;IAC5B,IAAI,CAACrC,WAAW,GAAG,IAAI;IACvB,KAAK,CAACqC,OAAO,CAAC,CAAC;IACf,IAAI,CAACtD,iBAAiB,CAACsD,OAAO,CAAC,CAAC;IAChC,IAAI,CAACpC,YAAY,GAAG,KAAK;IACzB;IACA;IACA,MAAMqC,uBAAuB,GAAG,IAAI3H,mBAAmB,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC;IAC/F2H,uBAAuB,CAACD,OAAO,CAAC,CAAC;IACjC,IAAI,CAACvD,OAAO,GAAGwD,uBAAuB;EAC1C;EACAC,kBAAkBA,CAAA,EAAG;IACjB,IAAI,IAAI,CAACvC,WAAW,EAAE;MAClB,MAAM,IAAIzD,KAAK,CAAC,oBAAoB,CAAC;IACzC;EACJ;EACAiG,wBAAwBA,CAACC,SAAS,EAAEC,MAAM,EAAE;IACxC,IAAI,IAAI,CAACzC,YAAY,EAAE;MACnB;MACA;IACJ;IACA,IAAI,CAAC7B,aAAa,CAACkC,IAAI,CAAC,IAAI9G,+BAA+B,CAACiJ,SAAS,EAAEC,MAAM,CAAC,CAAC;EACnF;EACAC,QAAQA,CAACxH,KAAK,EAAE;IACZ,IAAI,CAACoH,kBAAkB,CAAC,CAAC;IACzB,IAAIpH,KAAK,KAAK,IAAI,EAAE;MAChB;MACA;IACJ;IACA,MAAM;MAAEyD,UAAU;MAAEC;IAAW,CAAC,GAAG3D,gBAAgB,CAACC,KAAK,EAAE,IAAI,CAAC6D,QAAQ,CAAC5D,UAAU,CAAC;IACpF,IAAI,CAACwH,uBAAuB,CAAChE,UAAU,EAAEC,UAAU,CAAC;EACxD;EACAgE,sBAAsBA,CAACC,KAAK,EAAEC,WAAW,EAAEC,WAAW,EAAElI,IAAI,EAAEmI,SAAS,EAAEC,SAAS,EAAEC,OAAO,EAAE;IACzF,OAAO;MACHC,OAAO,EAAE,CAAC;QACFN,KAAK,EAAEA,KAAK;QACZC,WAAW,EAAEA,WAAW;QACxBC,WAAW,EAAEA,WAAW;QACxBlI,IAAI,EAAEA;MACV,CAAC,CAAC;MACNuI,GAAG,EAAE,IAAI,CAACvE,OAAO,CAACwE,MAAM,CAAC,CAAC;MAC1BC,SAAS,EAAE,IAAI,CAACC,YAAY,CAAC,CAAC;MAC9BP,SAAS,EAAEA,SAAS;MACpBC,SAAS,EAAEA,SAAS;MACpBC,OAAO,EAAEA;IACb,CAAC;EACL;EACAP,uBAAuBA,CAAChE,UAAU,EAAE6E,oBAAoB,EAAE;IACtD,IAAI,CAAClB,kBAAkB,CAAC,CAAC;IACzB,MAAMmB,iBAAiB,GAAG,IAAI,CAACC,iBAAiB,CAAC,CAAC;IAClD,MAAMC,mBAAmB,GAAG,IAAI,CAACvE,qBAAqB,CAACqE,iBAAiB,CAAC;IACzE,MAAMG,aAAa,GAAG,IAAI,CAAC1E,YAAY,CAAC,CAAC;IACzC,MAAM2E,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAACF,aAAa,CAAC;IACtD,IAAI,CAAC/E,OAAO,GAAGF,UAAU;IACzB,IAAI,CAACG,iBAAiB,CAACsD,OAAO,CAAC,CAAC;IAChC,IAAI,CAACtD,iBAAiB,GAAG0E,oBAAoB;IAC7C,IAAI,CAACO,kBAAkB,CAAC,CAAC;IACzB;IACA,IAAI,CAAC9C,OAAO,CAAC+C,KAAK,CAAC,CAAC;IACpB,IAAI,CAAC9C,QAAQ,CAAC8C,KAAK,CAAC,CAAC;IACrB;IACA,IAAI,CAACvD,YAAY,GAAGC,MAAM,CAACrF,MAAM,CAAC,IAAI,CAAC;IACvC,IAAI,CAACsF,gBAAgB,GAAG,IAAIC,gBAAgB,CAAC,CAAC;IAC9C;IACA,IAAI,CAACC,eAAe,CAACoD,KAAK,CAAC,CAAC;IAC5B,IAAI,CAACjD,wBAAwB,GAAG,IAAI;IACpC,IAAI,CAACuB,wBAAwB,CAAC,IAAI/I,2BAA2B,CAAC,CAC1D,IAAIE,aAAa,CAAC,CAAC,CACtB,EAAE,IAAI,CAACkG,UAAU,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,CAACgD,sBAAsB,CAAC,IAAI/J,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE+K,aAAa,EAAEC,SAAS,CAAC,EAAE,CAAC,EAAEF,mBAAmB,EAAE,IAAI,CAACO,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;EAC3K;EACAC,MAAMA,CAACf,GAAG,EAAE;IACR,IAAI,CAACd,kBAAkB,CAAC,CAAC;IACzB,MAAM8B,MAAM,GAAIhB,GAAG,KAAK,CAAC,CAAC,aAAa,MAAM,GAAG,IAAK;IACrD,IAAI,IAAI,CAACvE,OAAO,CAACwE,MAAM,CAAC,CAAC,KAAKe,MAAM,EAAE;MAClC;MACA;IACJ;IACA,MAAMX,iBAAiB,GAAG,IAAI,CAACC,iBAAiB,CAAC,CAAC;IAClD,MAAMC,mBAAmB,GAAG,IAAI,CAACvE,qBAAqB,CAACqE,iBAAiB,CAAC;IACzE,MAAMG,aAAa,GAAG,IAAI,CAAC1E,YAAY,CAAC,CAAC;IACzC,MAAM2E,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAACF,aAAa,CAAC;IACtD,IAAI,CAACS,kBAAkB,CAAC,CAAC;IACzB,IAAI,CAACxF,OAAO,CAACsF,MAAM,CAACC,MAAM,CAAC;IAC3B,IAAI,CAACL,kBAAkB,CAAC,CAAC;IACzB,IAAI,CAACO,iBAAiB,CAAC,CAAC;IACxB,IAAI,CAAC/B,wBAAwB,CAAC,IAAI/I,2BAA2B,CAAC,CAC1D,IAAIC,kBAAkB,CAAC,CAAC,CAC3B,EAAE,IAAI,CAACmG,UAAU,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,CAACgD,sBAAsB,CAAC,IAAI/J,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE+K,aAAa,EAAEC,SAAS,CAAC,EAAE,CAAC,EAAEF,mBAAmB,EAAE,IAAI,CAACO,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;EAC5K;EACAG,kBAAkBA,CAAA,EAAG;IACjB;IACA,MAAMf,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IACrC,MAAMgB,cAAc,GAAG,IAAI,CAAC5D,gBAAgB,CAAC6D,MAAM,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAElB,SAAS,CAAC;IAC/E,IAAI,CAACmB,sBAAsB,CAACF,cAAc,CAAC;EAC/C;EACAD,iBAAiBA,CAAA,EAAG;IAChB;IACA,MAAMhB,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IACrC,MAAMgB,cAAc,GAAG,IAAI,CAAC5D,gBAAgB,CAAC+D,qBAAqB,CAAC,CAAC;IACpE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGL,cAAc,CAACnI,MAAM,EAAEuI,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACvD,MAAME,IAAI,GAAGN,cAAc,CAACI,CAAC,CAAC;MAC9B,MAAMG,KAAK,GAAGD,IAAI,CAACE,mBAAmB,GAAGF,IAAI,CAACG,KAAK;MACnD,MAAMC,WAAW,GAAG,IAAI,CAACpG,OAAO,CAACqG,WAAW,CAACL,IAAI,CAAChC,KAAK,CAACsC,eAAe,EAAEN,IAAI,CAAChC,KAAK,CAACuC,WAAW,CAAC;MAChG,MAAMC,SAAS,GAAG,IAAI,CAACxG,OAAO,CAACqG,WAAW,CAACL,IAAI,CAAChC,KAAK,CAACe,aAAa,EAAEiB,IAAI,CAAChC,KAAK,CAACgB,SAAS,CAAC;MAC1FgB,IAAI,CAACE,mBAAmB,GAAGE,WAAW;MACtCJ,IAAI,CAACS,iBAAiB,GAAGD,SAAS;MAClCR,IAAI,CAACU,eAAe,GAAGjC,SAAS;MAChCuB,IAAI,CAACG,KAAK,GAAGC,WAAW,GAAGH,KAAK;MAChCD,IAAI,CAACW,GAAG,GAAGH,SAAS,GAAGP,KAAK;MAC5BzL,eAAe,CAACwL,IAAI,CAAC;IACzB;EACJ;EACAY,gBAAgBA,CAAA,EAAG;IACf,IAAI,CAAC/G,oBAAoB,EAAE;IAC3B,IAAI,IAAI,CAACA,oBAAoB,KAAK,CAAC,EAAE;MACjC,IAAI,CAACT,oBAAoB,CAACoC,IAAI,CAAC5D,SAAS,CAAC;IAC7C;EACJ;EACAiJ,gBAAgBA,CAAA,EAAG;IACf,IAAI,CAAChH,oBAAoB,EAAE;IAC3B,IAAI,IAAI,CAACA,oBAAoB,KAAK,CAAC,EAAE;MACjC,IAAI,CAACT,oBAAoB,CAACoC,IAAI,CAAC5D,SAAS,CAAC;IAC7C;EACJ;EACAkJ,kBAAkBA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACjH,oBAAoB,GAAG,CAAC;EACxC;EACAkH,sBAAsBA,CAAA,EAAG;IACrB,OAAO,IAAI,CAAClH,oBAAoB;EACpC;EACAmH,oBAAoBA,CAAA,EAAG;IACnB,OAAO,IAAI,CAACnG,qBAAqB;EACrC;EACAoG,yBAAyBA,CAAA,EAAG;IACxB,OAAO,IAAI,CAACvG,0BAA0B;EAC1C;EACAwG,UAAUA,CAAA,EAAG;IACT,OAAO,IAAI,CAAChG,WAAW;EAC3B;EACAiG,sBAAsBA,CAAA,EAAG;IACrB,IAAI,CAAC1D,kBAAkB,CAAC,CAAC;IACzB,IAAI,IAAI,CAACwD,yBAAyB,CAAC,CAAC,EAAE;MAClC;MACA,OAAO,KAAK;IAChB;IACA,IAAIG,kBAAkB,GAAG,CAAC;IAC1B,IAAIC,iBAAiB,GAAG,CAAC;IACzB,MAAMC,SAAS,GAAG,IAAI,CAACtH,OAAO,CAACK,YAAY,CAAC,CAAC;IAC7C,KAAK,IAAIkH,UAAU,GAAG,CAAC,EAAEA,UAAU,IAAID,SAAS,EAAEC,UAAU,EAAE,EAAE;MAC5D,MAAMC,UAAU,GAAG,IAAI,CAACxH,OAAO,CAACQ,aAAa,CAAC+G,UAAU,CAAC;MACzD,IAAIC,UAAU,IAAI7K,kBAAkB,EAAE;QAClC0K,iBAAiB,IAAIG,UAAU;MACnC,CAAC,MACI;QACDJ,kBAAkB,IAAII,UAAU;MACpC;IACJ;IACA,OAAQH,iBAAiB,GAAGD,kBAAkB;EAClD;EACA,IAAIK,GAAGA,CAAA,EAAG;IACN,OAAO,IAAI,CAAC/H,mBAAmB;EACnC;EACA;EACAgI,UAAUA,CAAA,EAAG;IACT,IAAI,CAACjE,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAACvD,QAAQ;EACxB;EACAyH,oBAAoBA,CAAA,EAAG;IACnB,OAAO;MACHjF,OAAO,EAAE,IAAI,CAACxC,QAAQ,CAAC2C,UAAU;MACjCF,YAAY,EAAE,IAAI,CAACzC,QAAQ,CAACyC;IAChC,CAAC;EACL;EACAiF,aAAaA,CAACC,QAAQ,EAAE;IACpB,IAAI,CAACpE,kBAAkB,CAAC,CAAC;IACzB,IAAIf,OAAO,GAAI,OAAOmF,QAAQ,CAACnF,OAAO,KAAK,WAAW,GAAImF,QAAQ,CAACnF,OAAO,GAAG,IAAI,CAACxC,QAAQ,CAACwC,OAAO;IAClG,IAAIG,UAAU,GAAI,OAAOgF,QAAQ,CAAChF,UAAU,KAAK,WAAW,GAAIgF,QAAQ,CAAChF,UAAU,GAAG,IAAI,CAAC3C,QAAQ,CAAC2C,UAAU;IAC9G,IAAIF,YAAY,GAAI,OAAOkF,QAAQ,CAAClF,YAAY,KAAK,WAAW,GAAIkF,QAAQ,CAAClF,YAAY,GAAG,IAAI,CAACzC,QAAQ,CAACyC,YAAY;IACtH,IAAIG,kBAAkB,GAAI,OAAO+E,QAAQ,CAAC/E,kBAAkB,KAAK,WAAW,GAAI+E,QAAQ,CAAC/E,kBAAkB,GAAG,IAAI,CAAC5C,QAAQ,CAAC4C,kBAAkB;IAC9I,IAAIgF,OAAO,GAAG,IAAI5N,KAAK,CAAC0I,wBAAwB,CAAC;MAC7CF,OAAO,EAAEA,OAAO;MAChBG,UAAU,EAAEA,UAAU;MACtBF,YAAY,EAAEA,YAAY;MAC1BrG,UAAU,EAAE,IAAI,CAAC4D,QAAQ,CAAC5D,UAAU;MACpCwG,kBAAkB,EAAEA;IACxB,CAAC,CAAC;IACF,IAAI,IAAI,CAAC5C,QAAQ,CAAC6H,MAAM,CAACD,OAAO,CAAC,EAAE;MAC/B;IACJ;IACA,IAAIvG,CAAC,GAAG,IAAI,CAACrB,QAAQ,CAAC8H,iBAAiB,CAACF,OAAO,CAAC;IAChD,IAAI,CAAC5H,QAAQ,GAAG4H,OAAO;IACvB,IAAI,CAAC5I,mBAAmB,CAACsC,IAAI,CAACD,CAAC,CAAC;EACpC;EACAiB,iBAAiBA,CAACyF,mBAAmB,EAAEC,cAAc,EAAE;IACnD,IAAI,CAACzE,kBAAkB,CAAC,CAAC;IACzB,IAAIhB,kBAAkB,GAAGrI,gBAAgB,CAAC,IAAI,CAAC4F,OAAO,EAAEkI,cAAc,EAAED,mBAAmB,CAAC;IAC5F,IAAI,CAACL,aAAa,CAAC;MACfjF,YAAY,EAAEF,kBAAkB,CAACE,YAAY;MAC7CD,OAAO,EAAED,kBAAkB,CAACC,OAAO;MACnCG,UAAU,EAAEJ,kBAAkB,CAACC,OAAO,CAAE;IAC5C,CAAC,CAAC;EACN;;EACA,OAAOyF,mCAAmCA,CAACC,GAAG,EAAEvF,UAAU,EAAEF,YAAY,EAAE;IACtE,IAAI0F,SAAS,GAAG,CAAC;IACjB,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsC,GAAG,CAAC7K,MAAM,EAAEuI,CAAC,EAAE,EAAE;MACjC,IAAIsC,GAAG,CAACE,MAAM,CAACxC,CAAC,CAAC,KAAK,IAAI,EAAE;QACxBuC,SAAS,IAAIxF,UAAU;MAC3B,CAAC,MACI;QACDwF,SAAS,EAAE;MACf;IACJ;IACA,IAAInL,MAAM,GAAG,EAAE;IACf,IAAI,CAACyF,YAAY,EAAE;MACf,IAAI4F,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACJ,SAAS,GAAGxF,UAAU,CAAC;MAChDwF,SAAS,GAAGA,SAAS,GAAGxF,UAAU;MAClC,KAAK,IAAIiD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyC,OAAO,EAAEzC,CAAC,EAAE,EAAE;QAC9B5I,MAAM,IAAI,IAAI;MAClB;IACJ;IACA,KAAK,IAAI4I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuC,SAAS,EAAEvC,CAAC,EAAE,EAAE;MAChC5I,MAAM,IAAI,GAAG;IACjB;IACA,OAAOA,MAAM;EACjB;EACA,OAAOwL,oBAAoBA,CAACN,GAAG,EAAEvF,UAAU,EAAEF,YAAY,EAAE;IACvD,IAAIgG,uBAAuB,GAAG/O,OAAO,CAAC+O,uBAAuB,CAACP,GAAG,CAAC;IAClE,IAAIO,uBAAuB,KAAK,CAAC,CAAC,EAAE;MAChCA,uBAAuB,GAAGP,GAAG,CAAC7K,MAAM;IACxC;IACA,OAAOQ,SAAS,CAACoK,mCAAmC,CAACC,GAAG,CAACQ,SAAS,CAAC,CAAC,EAAED,uBAAuB,CAAC,EAAE9F,UAAU,EAAEF,YAAY,CAAC,GAAGyF,GAAG,CAACQ,SAAS,CAACD,uBAAuB,CAAC;EACtK;EACAD,oBAAoBA,CAACN,GAAG,EAAE;IACtB,IAAI,CAAC3E,kBAAkB,CAAC,CAAC;IACzB,OAAO1F,SAAS,CAAC2K,oBAAoB,CAACN,GAAG,EAAE,IAAI,CAAClI,QAAQ,CAAC2C,UAAU,EAAE,IAAI,CAAC3C,QAAQ,CAACyC,YAAY,CAAC;EACpG;EACA;EACA;EACA+B,YAAYA,CAAA,EAAG;IACX,IAAI,CAACjB,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAAC1C,UAAU;EAC1B;EACA8H,eAAeA,CAAA,EAAG;IACd,OAAO,IAAI,CAAC7I,OAAO,CAAC6I,eAAe,CAAC,CAAC;EACzC;EACAC,kCAAkCA,CAAA,EAAG;IACjC,OAAO,IAAI,CAAC9I,OAAO,CAAC8I,kCAAkC,CAAC,CAAC;EAC5D;EACAC,4BAA4BA,CAAA,EAAoB;IAAA,IAAnBC,UAAU,GAAA7K,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,IAAI;IAC1C,MAAM8K,OAAO,GAAG,IAAI,CAACC,WAAW,CAACtP,OAAO,CAACuP,wBAAwB,CAACrM,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC,4BAA4B,CAAC;IACnJ,IAAI,CAACkD,OAAO,CAACoJ,uCAAuC,CAAC,CAAC;IACtD,IAAI,CAACC,kBAAkB,CAACL,UAAU,EAAEC,OAAO,CAACK,GAAG,CAACC,CAAC,KAAK;MAAEvF,KAAK,EAAEuF,CAAC,CAACvF,KAAK;MAAEhI,IAAI,EAAE;IAAK,CAAC,CAAC,CAAC,EAAE,MAAM,IAAI,CAAC;EACvG;EACAwN,yBAAyBA,CAAA,EAAG;IACxB,OAAO,IAAI,CAACxJ,OAAO,CAACwJ,yBAAyB,CAAC,CAAC;EACnD;EACAC,uBAAuBA,CAAA,EAAG;IACtB,IAAI,CAAChG,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAACzC,qBAAqB;EACrC;EACA0I,0BAA0BA,CAAA,EAAG;IACzB,IAAI,CAACjG,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAACxC,wBAAwB;EACxC;EACAoF,WAAWA,CAACsD,WAAW,EAAE;IACrB,IAAI,CAAClG,kBAAkB,CAAC,CAAC;IACzB,IAAImG,QAAQ,GAAG,IAAI,CAACC,iBAAiB,CAACF,WAAW,CAACpC,UAAU,EAAEoC,WAAW,CAACG,MAAM,EAAE,CAAC,CAAC,aAAa,CAAC;IAClG,OAAO,IAAI,CAAC9J,OAAO,CAACqG,WAAW,CAACuD,QAAQ,CAACrC,UAAU,EAAEqC,QAAQ,CAACE,MAAM,CAAC;EACzE;EACAC,aAAaA,CAACC,SAAS,EAAE;IACrB,IAAI,CAACvG,kBAAkB,CAAC,CAAC;IACzB,IAAIwG,MAAM,GAAIzB,IAAI,CAAC0B,GAAG,CAAC,IAAI,CAAClK,OAAO,CAACmK,SAAS,CAAC,CAAC,EAAE3B,IAAI,CAAC4B,GAAG,CAAC,CAAC,EAAEJ,SAAS,CAAC,CAAE;IACzE,OAAO,IAAI,CAAChK,OAAO,CAAC+J,aAAa,CAACE,MAAM,CAAC;EAC7C;EACA/E,kBAAkBA,CAAA,EAAG;IACjB,IAAI,CAACnE,UAAU,GAAG,IAAI,CAACA,UAAU,GAAG,CAAC;IACrC,IAAI,CAACC,qBAAqB,GAAG,IAAI,CAACD,UAAU;EAChD;EACAsJ,mBAAmBA,CAAC5F,SAAS,EAAE;IAC3B,IAAI,CAAC1D,UAAU,GAAG0D,SAAS;EAC/B;EACA6F,8BAA8BA,CAACC,uBAAuB,EAAE;IACpD,IAAI,CAACvJ,qBAAqB,GAAGuJ,uBAAuB;EACxD;EACAC,iCAAiCA,CAACC,0BAA0B,EAAE;IAC1D,IAAI,CAACxJ,wBAAwB,GAAGwJ,0BAA0B;EAC9D;EACApF,QAAQA,CAACd,GAAG,EAAuB;IAAA,IAArBmG,WAAW,GAAAvM,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,KAAK;IAC7B,IAAI,CAACsF,kBAAkB,CAAC,CAAC;IACzB,MAAMkH,cAAc,GAAG,IAAI,CAAC9F,iBAAiB,CAAC,CAAC;IAC/C,MAAM+F,cAAc,GAAG,IAAI,CAACC,eAAe,CAACF,cAAc,EAAEpG,GAAG,CAAC;IAChE,IAAImG,WAAW,EAAE;MACb,OAAO,IAAI,CAAC1K,OAAO,CAAC8K,MAAM,CAAC,CAAC,GAAGF,cAAc;IACjD;IACA,OAAOA,cAAc;EACzB;EACAG,cAAcA,CAAA,EAAsB;IAAA,IAArBL,WAAW,GAAAvM,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,KAAK;IAC9B,OAAO,IAAIvB,iBAAiB,CAAC,IAAI,CAACoD,OAAO,CAAC+K,cAAc,CAACL,WAAW,CAAC,CAAC;EAC1E;EACAM,cAAcA,CAACzG,GAAG,EAAuB;IAAA,IAArBmG,WAAW,GAAAvM,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,KAAK;IACnC,IAAI,CAACsF,kBAAkB,CAAC,CAAC;IACzB,MAAMkH,cAAc,GAAG,IAAI,CAAC9F,iBAAiB,CAAC,CAAC;IAC/C,MAAM+F,cAAc,GAAG,IAAI,CAACrK,qBAAqB,CAACoK,cAAc,EAAEpG,GAAG,CAAC;IACtE,IAAImG,WAAW,EAAE;MACb,OAAO,IAAI,CAAC1K,OAAO,CAAC8K,MAAM,CAAC,CAAC,CAACvN,MAAM,GAAGqN,cAAc;IACxD;IACA,OAAOA,cAAc;EACzB;EACAC,eAAeA,CAACI,QAAQ,EAA6B;IAAA,IAA3B1G,GAAG,GAAApG,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,CAAC;IAC7B,IAAI,CAACsF,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAACzD,OAAO,CAAC6K,eAAe,CAAC,IAAI,CAACK,aAAa,CAACD,QAAQ,CAAC,EAAE1G,GAAG,CAAC;EAC1E;EACAhE,qBAAqBA,CAAC0K,QAAQ,EAA6B;IAAA,IAA3B1G,GAAG,GAAApG,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,CAAC;IACnC,IAAI,CAACsF,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAACzD,OAAO,CAACO,qBAAqB,CAAC,IAAI,CAAC2K,aAAa,CAACD,QAAQ,CAAC,EAAE1G,GAAG,CAAC;EAChF;EACA4G,wBAAwBA,CAACF,QAAQ,EAA6B;IAAA,IAA3B1G,GAAG,GAAApG,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,CAAC;IACtC,IAAI,CAACsF,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAACzD,OAAO,CAACmL,wBAAwB,CAAC,IAAI,CAACD,aAAa,CAACD,QAAQ,CAAC,EAAE1G,GAAG,CAAC;EACnF;EACAlE,YAAYA,CAAA,EAAG;IACX,IAAI,CAACoD,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAACzD,OAAO,CAACK,YAAY,CAAC,CAAC;EACtC;EACA+K,cAAcA,CAAC7D,UAAU,EAAE;IACvB,IAAI,CAAC9D,kBAAkB,CAAC,CAAC;IACzB,IAAI8D,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAAClH,YAAY,CAAC,CAAC,EAAE;MACpD,MAAM,IAAI5C,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,OAAO,IAAI,CAACuC,OAAO,CAACoL,cAAc,CAAC7D,UAAU,CAAC;EAClD;EACA/G,aAAaA,CAAC+G,UAAU,EAAE;IACtB,IAAI,CAAC9D,kBAAkB,CAAC,CAAC;IACzB,IAAI8D,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAAClH,YAAY,CAAC,CAAC,EAAE;MACpD,MAAM,IAAI5C,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,OAAO,IAAI,CAACuC,OAAO,CAACQ,aAAa,CAAC+G,UAAU,CAAC;EACjD;EACA8D,eAAeA,CAAA,EAAG;IACd,IAAI,CAAC5H,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAACzD,OAAO,CAACqL,eAAe,CAAC,CAAC;EACzC;EACA7G,MAAMA,CAAA,EAAG;IACL,IAAI,CAACf,kBAAkB,CAAC,CAAC;IACzB,OAAO,IAAI,CAACzD,OAAO,CAACwE,MAAM,CAAC,CAAC;EAChC;EACA8G,oBAAoBA,CAAA,EAAG;IACnB,IAAI,CAAC7H,kBAAkB,CAAC,CAAC;IACzB,OAAQ,IAAI,CAACzD,OAAO,CAACwE,MAAM,CAAC,CAAC,KAAK,IAAI,GAChC,CAAC,CAAC,WACF,CAAC,CAAC;EACZ;;EACA+G,gBAAgBA,CAAChE,UAAU,EAAE;IACzB,IAAI,CAAC9D,kBAAkB,CAAC,CAAC;IACzB,OAAO,CAAC;EACZ;EACAwB,gBAAgBA,CAACsC,UAAU,EAAE;IACzB,IAAI,CAAC9D,kBAAkB,CAAC,CAAC;IACzB,IAAI8D,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAAClH,YAAY,CAAC,CAAC,EAAE;MACpD,MAAM,IAAI5C,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,OAAO,IAAI,CAACuC,OAAO,CAACQ,aAAa,CAAC+G,UAAU,CAAC,GAAG,CAAC;EACrD;EACAiE,+BAA+BA,CAACjE,UAAU,EAAE;IACxC,IAAI,CAAC9D,kBAAkB,CAAC,CAAC;IACzB,IAAI8D,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAAClH,YAAY,CAAC,CAAC,EAAE;MACpD,MAAM,IAAI5C,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,OAAO,IAAI,CAACuC,OAAO,CAACwL,+BAA+B,CAACjE,UAAU,CAAC;EACnE;EACAkE,8BAA8BA,CAAClE,UAAU,EAAE;IACvC,IAAI,CAAC9D,kBAAkB,CAAC,CAAC;IACzB,IAAI8D,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAAClH,YAAY,CAAC,CAAC,EAAE;MACpD,MAAM,IAAI5C,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,OAAO,IAAI,CAACuC,OAAO,CAACyL,8BAA8B,CAAClE,UAAU,CAAC;EAClE;EACA;AACJ;AACA;AACA;EACImE,kCAAkCA,CAAC1H,KAAK,EAAE;IACtC,MAAM2H,UAAU,GAAG,IAAI,CAAC3L,OAAO,CAACK,YAAY,CAAC,CAAC;IAC9C,MAAMuL,sBAAsB,GAAG5H,KAAK,CAACsC,eAAe;IACpD,MAAMuF,kBAAkB,GAAG7H,KAAK,CAACuC,WAAW;IAC5C,IAAID,eAAe;IACnB,IAAIC,WAAW;IACf,IAAIqF,sBAAsB,GAAG,CAAC,EAAE;MAC5BtF,eAAe,GAAG,CAAC;MACnBC,WAAW,GAAG,CAAC;IACnB,CAAC,MACI,IAAIqF,sBAAsB,GAAGD,UAAU,EAAE;MAC1CrF,eAAe,GAAGqF,UAAU;MAC5BpF,WAAW,GAAG,IAAI,CAACtB,gBAAgB,CAACqB,eAAe,CAAC;IACxD,CAAC,MACI;MACDA,eAAe,GAAGsF,sBAAsB,GAAG,CAAC;MAC5C,IAAIC,kBAAkB,IAAI,CAAC,EAAE;QACzBtF,WAAW,GAAG,CAAC;MACnB,CAAC,MACI;QACD,MAAMuF,SAAS,GAAG,IAAI,CAAC7G,gBAAgB,CAACqB,eAAe,CAAC;QACxD,IAAIuF,kBAAkB,IAAIC,SAAS,EAAE;UACjCvF,WAAW,GAAGuF,SAAS;QAC3B,CAAC,MACI;UACDvF,WAAW,GAAGsF,kBAAkB,GAAG,CAAC;QACxC;MACJ;IACJ;IACA,MAAME,oBAAoB,GAAG/H,KAAK,CAACe,aAAa;IAChD,MAAMiH,gBAAgB,GAAGhI,KAAK,CAACgB,SAAS;IACxC,IAAID,aAAa;IACjB,IAAIC,SAAS;IACb,IAAI+G,oBAAoB,GAAG,CAAC,EAAE;MAC1BhH,aAAa,GAAG,CAAC;MACjBC,SAAS,GAAG,CAAC;IACjB,CAAC,MACI,IAAI+G,oBAAoB,GAAGJ,UAAU,EAAE;MACxC5G,aAAa,GAAG4G,UAAU;MAC1B3G,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAACF,aAAa,CAAC;IACpD,CAAC,MACI;MACDA,aAAa,GAAGgH,oBAAoB,GAAG,CAAC;MACxC,IAAIC,gBAAgB,IAAI,CAAC,EAAE;QACvBhH,SAAS,GAAG,CAAC;MACjB,CAAC,MACI;QACD,MAAM8G,SAAS,GAAG,IAAI,CAAC7G,gBAAgB,CAACF,aAAa,CAAC;QACtD,IAAIiH,gBAAgB,IAAIF,SAAS,EAAE;UAC/B9G,SAAS,GAAG8G,SAAS;QACzB,CAAC,MACI;UACD9G,SAAS,GAAGgH,gBAAgB,GAAG,CAAC;QACpC;MACJ;IACJ;IACA,IAAIJ,sBAAsB,KAAKtF,eAAe,IACvCuF,kBAAkB,KAAKtF,WAAW,IAClCwF,oBAAoB,KAAKhH,aAAa,IACtCiH,gBAAgB,KAAKhH,SAAS,IAC9BhB,KAAK,YAAYhK,KAAK,IACtB,EAAEgK,KAAK,YAAY/J,SAAS,CAAC,EAAE;MAClC,OAAO+J,KAAK;IAChB;IACA,OAAO,IAAIhK,KAAK,CAACsM,eAAe,EAAEC,WAAW,EAAExB,aAAa,EAAEC,SAAS,CAAC;EAC5E;EACAiH,gBAAgBA,CAAC1E,UAAU,EAAEuC,MAAM,EAAEoC,cAAc,EAAE;IACjD,IAAI,OAAO3E,UAAU,KAAK,QAAQ,IAAI,OAAOuC,MAAM,KAAK,QAAQ,EAAE;MAC9D,OAAO,KAAK;IAChB;IACA,IAAIqC,KAAK,CAAC5E,UAAU,CAAC,IAAI4E,KAAK,CAACrC,MAAM,CAAC,EAAE;MACpC,OAAO,KAAK;IAChB;IACA,IAAIvC,UAAU,GAAG,CAAC,IAAIuC,MAAM,GAAG,CAAC,EAAE;MAC9B,OAAO,KAAK;IAChB;IACA,IAAI,CAACvC,UAAU,GAAG,CAAC,MAAMA,UAAU,IAAI,CAACuC,MAAM,GAAG,CAAC,MAAMA,MAAM,EAAE;MAC5D,OAAO,KAAK;IAChB;IACA,MAAMxC,SAAS,GAAG,IAAI,CAACtH,OAAO,CAACK,YAAY,CAAC,CAAC;IAC7C,IAAIkH,UAAU,GAAGD,SAAS,EAAE;MACxB,OAAO,KAAK;IAChB;IACA,IAAIwC,MAAM,KAAK,CAAC,EAAE;MACd,OAAO,IAAI;IACf;IACA,MAAMgC,SAAS,GAAG,IAAI,CAAC7G,gBAAgB,CAACsC,UAAU,CAAC;IACnD,IAAIuC,MAAM,GAAGgC,SAAS,EAAE;MACpB,OAAO,KAAK;IAChB;IACA,IAAII,cAAc,KAAK,CAAC,CAAC,sBAAsB;MAC3C;MACA,MAAME,cAAc,GAAG,IAAI,CAACpM,OAAO,CAACqM,eAAe,CAAC9E,UAAU,EAAEuC,MAAM,GAAG,CAAC,CAAC;MAC3E,IAAIlQ,OAAO,CAAC0S,eAAe,CAACF,cAAc,CAAC,EAAE;QACzC,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACAvC,iBAAiBA,CAAC0C,WAAW,EAAEC,OAAO,EAAEN,cAAc,EAAE;IACpD,MAAM3E,UAAU,GAAGiB,IAAI,CAACC,KAAK,CAAE,OAAO8D,WAAW,KAAK,QAAQ,IAAI,CAACJ,KAAK,CAACI,WAAW,CAAC,GAAIA,WAAW,GAAG,CAAC,CAAC;IACzG,MAAMzC,MAAM,GAAGtB,IAAI,CAACC,KAAK,CAAE,OAAO+D,OAAO,KAAK,QAAQ,IAAI,CAACL,KAAK,CAACK,OAAO,CAAC,GAAIA,OAAO,GAAG,CAAC,CAAC;IACzF,MAAMlF,SAAS,GAAG,IAAI,CAACtH,OAAO,CAACK,YAAY,CAAC,CAAC;IAC7C,IAAIkH,UAAU,GAAG,CAAC,EAAE;MAChB,OAAO,IAAIxN,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC;IAC7B;IACA,IAAIwN,UAAU,GAAGD,SAAS,EAAE;MACxB,OAAO,IAAIvN,QAAQ,CAACuN,SAAS,EAAE,IAAI,CAACrC,gBAAgB,CAACqC,SAAS,CAAC,CAAC;IACpE;IACA,IAAIwC,MAAM,IAAI,CAAC,EAAE;MACb,OAAO,IAAI/P,QAAQ,CAACwN,UAAU,EAAE,CAAC,CAAC;IACtC;IACA,MAAMuE,SAAS,GAAG,IAAI,CAAC7G,gBAAgB,CAACsC,UAAU,CAAC;IACnD,IAAIuC,MAAM,IAAIgC,SAAS,EAAE;MACrB,OAAO,IAAI/R,QAAQ,CAACwN,UAAU,EAAEuE,SAAS,CAAC;IAC9C;IACA,IAAII,cAAc,KAAK,CAAC,CAAC,sBAAsB;MAC3C;MACA;MACA;MACA,MAAME,cAAc,GAAG,IAAI,CAACpM,OAAO,CAACqM,eAAe,CAAC9E,UAAU,EAAEuC,MAAM,GAAG,CAAC,CAAC;MAC3E,IAAIlQ,OAAO,CAAC0S,eAAe,CAACF,cAAc,CAAC,EAAE;QACzC,OAAO,IAAIrS,QAAQ,CAACwN,UAAU,EAAEuC,MAAM,GAAG,CAAC,CAAC;MAC/C;IACJ;IACA,OAAO,IAAI/P,QAAQ,CAACwN,UAAU,EAAEuC,MAAM,CAAC;EAC3C;EACA2C,gBAAgBA,CAAC7C,QAAQ,EAAE;IACvB,MAAMsC,cAAc,GAAG,CAAC,CAAC;IACzB,IAAI,CAACzI,kBAAkB,CAAC,CAAC;IACzB;IACA,IAAImG,QAAQ,YAAY7P,QAAQ,EAAE;MAC9B,IAAI,IAAI,CAACkS,gBAAgB,CAACrC,QAAQ,CAACrC,UAAU,EAAEqC,QAAQ,CAACE,MAAM,EAAEoC,cAAc,CAAC,EAAE;QAC7E,OAAOtC,QAAQ;MACnB;IACJ;IACA,OAAO,IAAI,CAACC,iBAAiB,CAACD,QAAQ,CAACrC,UAAU,EAAEqC,QAAQ,CAACE,MAAM,EAAEoC,cAAc,CAAC;EACvF;EACAQ,aAAaA,CAAC1I,KAAK,EAAEkI,cAAc,EAAE;IACjC,MAAM5F,eAAe,GAAGtC,KAAK,CAACsC,eAAe;IAC7C,MAAMC,WAAW,GAAGvC,KAAK,CAACuC,WAAW;IACrC,MAAMxB,aAAa,GAAGf,KAAK,CAACe,aAAa;IACzC,MAAMC,SAAS,GAAGhB,KAAK,CAACgB,SAAS;IACjC,IAAI,CAAC,IAAI,CAACiH,gBAAgB,CAAC3F,eAAe,EAAEC,WAAW,EAAE,CAAC,CAAC,aAAa,CAAC,EAAE;MACvE,OAAO,KAAK;IAChB;IACA,IAAI,CAAC,IAAI,CAAC0F,gBAAgB,CAAClH,aAAa,EAAEC,SAAS,EAAE,CAAC,CAAC,aAAa,CAAC,EAAE;MACnE,OAAO,KAAK;IAChB;IACA,IAAIkH,cAAc,KAAK,CAAC,CAAC,sBAAsB;MAC3C,MAAMS,mBAAmB,GAAIpG,WAAW,GAAG,CAAC,GAAG,IAAI,CAACvG,OAAO,CAACqM,eAAe,CAAC/F,eAAe,EAAEC,WAAW,GAAG,CAAC,CAAC,GAAG,CAAE;MAClH,MAAMqG,iBAAiB,GAAI5H,SAAS,GAAG,CAAC,IAAIA,SAAS,IAAI,IAAI,CAAChF,OAAO,CAACQ,aAAa,CAACuE,aAAa,CAAC,GAAG,IAAI,CAAC/E,OAAO,CAACqM,eAAe,CAACtH,aAAa,EAAEC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAE;MACpK,MAAM6H,wBAAwB,GAAGjT,OAAO,CAAC0S,eAAe,CAACK,mBAAmB,CAAC;MAC7E,MAAMG,sBAAsB,GAAGlT,OAAO,CAAC0S,eAAe,CAACM,iBAAiB,CAAC;MACzE,IAAI,CAACC,wBAAwB,IAAI,CAACC,sBAAsB,EAAE;QACtD,OAAO,IAAI;MACf;MACA,OAAO,KAAK;IAChB;IACA,OAAO,IAAI;EACf;EACA5B,aAAaA,CAAC6B,MAAM,EAAE;IAClB,MAAMb,cAAc,GAAG,CAAC,CAAC;IACzB,IAAI,CAACzI,kBAAkB,CAAC,CAAC;IACzB;IACA,IAAKsJ,MAAM,YAAY/S,KAAK,IAAK,EAAE+S,MAAM,YAAY9S,SAAS,CAAC,EAAE;MAC7D,IAAI,IAAI,CAACyS,aAAa,CAACK,MAAM,EAAEb,cAAc,CAAC,EAAE;QAC5C,OAAOa,MAAM;MACjB;IACJ;IACA,MAAM5G,KAAK,GAAG,IAAI,CAAC0D,iBAAiB,CAACkD,MAAM,CAACzG,eAAe,EAAEyG,MAAM,CAACxG,WAAW,EAAE,CAAC,CAAC,aAAa,CAAC;IACjG,MAAMI,GAAG,GAAG,IAAI,CAACkD,iBAAiB,CAACkD,MAAM,CAAChI,aAAa,EAAEgI,MAAM,CAAC/H,SAAS,EAAE,CAAC,CAAC,aAAa,CAAC;IAC3F,MAAMsB,eAAe,GAAGH,KAAK,CAACoB,UAAU;IACxC,MAAMhB,WAAW,GAAGJ,KAAK,CAAC2D,MAAM;IAChC,MAAM/E,aAAa,GAAG4B,GAAG,CAACY,UAAU;IACpC,MAAMvC,SAAS,GAAG2B,GAAG,CAACmD,MAAM;IAC5B,IAAIoC,cAAc,KAAK,CAAC,CAAC,sBAAsB;MAC3C,MAAMS,mBAAmB,GAAIpG,WAAW,GAAG,CAAC,GAAG,IAAI,CAACvG,OAAO,CAACqM,eAAe,CAAC/F,eAAe,EAAEC,WAAW,GAAG,CAAC,CAAC,GAAG,CAAE;MAClH,MAAMqG,iBAAiB,GAAI5H,SAAS,GAAG,CAAC,IAAIA,SAAS,IAAI,IAAI,CAAChF,OAAO,CAACQ,aAAa,CAACuE,aAAa,CAAC,GAAG,IAAI,CAAC/E,OAAO,CAACqM,eAAe,CAACtH,aAAa,EAAEC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAE;MACpK,MAAM6H,wBAAwB,GAAGjT,OAAO,CAAC0S,eAAe,CAACK,mBAAmB,CAAC;MAC7E,MAAMG,sBAAsB,GAAGlT,OAAO,CAAC0S,eAAe,CAACM,iBAAiB,CAAC;MACzE,IAAI,CAACC,wBAAwB,IAAI,CAACC,sBAAsB,EAAE;QACtD,OAAO,IAAI9S,KAAK,CAACsM,eAAe,EAAEC,WAAW,EAAExB,aAAa,EAAEC,SAAS,CAAC;MAC5E;MACA,IAAIsB,eAAe,KAAKvB,aAAa,IAAIwB,WAAW,KAAKvB,SAAS,EAAE;QAChE;QACA,OAAO,IAAIhL,KAAK,CAACsM,eAAe,EAAEC,WAAW,GAAG,CAAC,EAAExB,aAAa,EAAEC,SAAS,GAAG,CAAC,CAAC;MACpF;MACA,IAAI6H,wBAAwB,IAAIC,sBAAsB,EAAE;QACpD;QACA,OAAO,IAAI9S,KAAK,CAACsM,eAAe,EAAEC,WAAW,GAAG,CAAC,EAAExB,aAAa,EAAEC,SAAS,GAAG,CAAC,CAAC;MACpF;MACA,IAAI6H,wBAAwB,EAAE;QAC1B;QACA,OAAO,IAAI7S,KAAK,CAACsM,eAAe,EAAEC,WAAW,GAAG,CAAC,EAAExB,aAAa,EAAEC,SAAS,CAAC;MAChF;MACA;MACA,OAAO,IAAIhL,KAAK,CAACsM,eAAe,EAAEC,WAAW,EAAExB,aAAa,EAAEC,SAAS,GAAG,CAAC,CAAC;IAChF;IACA,OAAO,IAAIhL,KAAK,CAACsM,eAAe,EAAEC,WAAW,EAAExB,aAAa,EAAEC,SAAS,CAAC;EAC5E;EACAgI,cAAcA,CAACrD,WAAW,EAAEM,MAAM,EAAE;IAChC,IAAI,CAACxG,kBAAkB,CAAC,CAAC;IACzB,IAAIwJ,SAAS,GAAG,IAAI,CAAC5G,WAAW,CAACsD,WAAW,CAAC,GAAGM,MAAM;IACtD,OAAO,IAAI,CAACF,aAAa,CAACvB,IAAI,CAAC0B,GAAG,CAAC,IAAI,CAAClK,OAAO,CAACmK,SAAS,CAAC,CAAC,EAAE3B,IAAI,CAAC4B,GAAG,CAAC,CAAC,EAAE6C,SAAS,CAAC,CAAC,CAAC;EACzF;EACApI,iBAAiBA,CAAA,EAAG;IAChB,IAAI,CAACpB,kBAAkB,CAAC,CAAC;IACzB,MAAM6D,SAAS,GAAG,IAAI,CAACjH,YAAY,CAAC,CAAC;IACrC,OAAO,IAAIrG,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEsN,SAAS,EAAE,IAAI,CAACrC,gBAAgB,CAACqC,SAAS,CAAC,CAAC;EACvE;EACA4F,qBAAqBA,CAACC,WAAW,EAAEC,UAAU,EAAEC,cAAc,EAAEC,gBAAgB,EAAE;IAC7E,OAAO,IAAI,CAACtN,OAAO,CAACkN,qBAAqB,CAACC,WAAW,EAAEC,UAAU,EAAEC,cAAc,EAAEC,gBAAgB,CAAC;EACxG;EACApE,WAAWA,CAACqE,YAAY,EAAEC,cAAc,EAAEC,OAAO,EAAEC,SAAS,EAAEC,cAAc,EAAEN,cAAc,EAAuC;IAAA,IAArCC,gBAAgB,GAAAnP,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAGzB,gBAAgB;IAC7H,IAAI,CAAC+G,kBAAkB,CAAC,CAAC;IACzB,IAAImK,YAAY,GAAG,IAAI;IACvB,IAAIJ,cAAc,KAAK,IAAI,EAAE;MACzB,IAAI,CAACK,KAAK,CAACC,OAAO,CAACN,cAAc,CAAC,EAAE;QAChCA,cAAc,GAAG,CAACA,cAAc,CAAC;MACrC;MACA,IAAIA,cAAc,CAACO,KAAK,CAAEC,WAAW,IAAKhU,KAAK,CAACiU,QAAQ,CAACD,WAAW,CAAC,CAAC,EAAE;QACpEJ,YAAY,GAAGJ,cAAc,CAAClE,GAAG,CAAE0E,WAAW,IAAK,IAAI,CAAC9C,aAAa,CAAC8C,WAAW,CAAC,CAAC;MACvF;IACJ;IACA,IAAIJ,YAAY,KAAK,IAAI,EAAE;MACvBA,YAAY,GAAG,CAAC,IAAI,CAAC/I,iBAAiB,CAAC,CAAC,CAAC;IAC7C;IACA+I,YAAY,GAAGA,YAAY,CAACM,IAAI,CAAC,CAACC,EAAE,EAAEC,EAAE,KAAKD,EAAE,CAAC7H,eAAe,GAAG8H,EAAE,CAAC9H,eAAe,IAAI6H,EAAE,CAAC5H,WAAW,GAAG6H,EAAE,CAAC7H,WAAW,CAAC;IACxH,MAAM8H,kBAAkB,GAAG,EAAE;IAC7BA,kBAAkB,CAACC,IAAI,CAACV,YAAY,CAACW,MAAM,CAAC,CAACC,IAAI,EAAEC,IAAI,KAAK;MACxD,IAAIzU,KAAK,CAAC0U,eAAe,CAACF,IAAI,EAAEC,IAAI,CAAC,EAAE;QACnC,OAAOD,IAAI,CAACG,SAAS,CAACF,IAAI,CAAC;MAC/B;MACAJ,kBAAkB,CAACC,IAAI,CAACE,IAAI,CAAC;MAC7B,OAAOC,IAAI;IACf,CAAC,CAAC,CAAC;IACH,IAAIG,WAAW;IACf,IAAI,CAACnB,OAAO,IAAIF,YAAY,CAACsB,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;MAC5C;MACA,MAAMC,YAAY,GAAG,IAAI7T,YAAY,CAACsS,YAAY,EAAEE,OAAO,EAAEC,SAAS,EAAEC,cAAc,CAAC;MACvF,MAAMP,UAAU,GAAG0B,YAAY,CAACC,kBAAkB,CAAC,CAAC;MACpD,IAAI,CAAC3B,UAAU,EAAE;QACb,OAAO,EAAE;MACb;MACAwB,WAAW,GAAIzB,WAAW,IAAK,IAAI,CAACD,qBAAqB,CAACC,WAAW,EAAEC,UAAU,EAAEC,cAAc,EAAEC,gBAAgB,CAAC;IACxH,CAAC,MACI;MACDsB,WAAW,GAAIzB,WAAW,IAAKjS,eAAe,CAACgO,WAAW,CAAC,IAAI,EAAE,IAAIjO,YAAY,CAACsS,YAAY,EAAEE,OAAO,EAAEC,SAAS,EAAEC,cAAc,CAAC,EAAER,WAAW,EAAEE,cAAc,EAAEC,gBAAgB,CAAC;IACvL;IACA,OAAOe,kBAAkB,CAAC/E,GAAG,CAACsF,WAAW,CAAC,CAACL,MAAM,CAAC,CAACS,GAAG,EAAE/F,OAAO,KAAK+F,GAAG,CAACC,MAAM,CAAChG,OAAO,CAAC,EAAE,EAAE,CAAC;EAChG;EACAiG,aAAaA,CAAC3B,YAAY,EAAE4B,cAAc,EAAE1B,OAAO,EAAEC,SAAS,EAAEC,cAAc,EAAEN,cAAc,EAAE;IAC5F,IAAI,CAAC5J,kBAAkB,CAAC,CAAC;IACzB,MAAM2L,WAAW,GAAG,IAAI,CAAC3C,gBAAgB,CAAC0C,cAAc,CAAC;IACzD,IAAI,CAAC1B,OAAO,IAAIF,YAAY,CAACsB,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;MAC5C,MAAMC,YAAY,GAAG,IAAI7T,YAAY,CAACsS,YAAY,EAAEE,OAAO,EAAEC,SAAS,EAAEC,cAAc,CAAC;MACvF,MAAMP,UAAU,GAAG0B,YAAY,CAACC,kBAAkB,CAAC,CAAC;MACpD,IAAI,CAAC3B,UAAU,EAAE;QACb,OAAO,IAAI;MACf;MACA,MAAM9F,SAAS,GAAG,IAAI,CAACjH,YAAY,CAAC,CAAC;MACrC,IAAI8M,WAAW,GAAG,IAAInT,KAAK,CAACoV,WAAW,CAAC7H,UAAU,EAAE6H,WAAW,CAACtF,MAAM,EAAExC,SAAS,EAAE,IAAI,CAACrC,gBAAgB,CAACqC,SAAS,CAAC,CAAC;MACpH,IAAI+H,GAAG,GAAG,IAAI,CAACnC,qBAAqB,CAACC,WAAW,EAAEC,UAAU,EAAEC,cAAc,EAAE,CAAC,CAAC;MAChFnS,eAAe,CAACgU,aAAa,CAAC,IAAI,EAAE,IAAIjU,YAAY,CAACsS,YAAY,EAAEE,OAAO,EAAEC,SAAS,EAAEC,cAAc,CAAC,EAAEyB,WAAW,EAAE/B,cAAc,CAAC;MACpI,IAAIgC,GAAG,CAAC9R,MAAM,GAAG,CAAC,EAAE;QAChB,OAAO8R,GAAG,CAAC,CAAC,CAAC;MACjB;MACAlC,WAAW,GAAG,IAAInT,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEoV,WAAW,CAAC7H,UAAU,EAAE,IAAI,CAACtC,gBAAgB,CAACmK,WAAW,CAAC7H,UAAU,CAAC,CAAC;MACpG8H,GAAG,GAAG,IAAI,CAACnC,qBAAqB,CAACC,WAAW,EAAEC,UAAU,EAAEC,cAAc,EAAE,CAAC,CAAC;MAC5E,IAAIgC,GAAG,CAAC9R,MAAM,GAAG,CAAC,EAAE;QAChB,OAAO8R,GAAG,CAAC,CAAC,CAAC;MACjB;MACA,OAAO,IAAI;IACf;IACA,OAAOnU,eAAe,CAACgU,aAAa,CAAC,IAAI,EAAE,IAAIjU,YAAY,CAACsS,YAAY,EAAEE,OAAO,EAAEC,SAAS,EAAEC,cAAc,CAAC,EAAEyB,WAAW,EAAE/B,cAAc,CAAC;EAC/I;EACAiC,iBAAiBA,CAAC/B,YAAY,EAAE4B,cAAc,EAAE1B,OAAO,EAAEC,SAAS,EAAEC,cAAc,EAAEN,cAAc,EAAE;IAChG,IAAI,CAAC5J,kBAAkB,CAAC,CAAC;IACzB,MAAM2L,WAAW,GAAG,IAAI,CAAC3C,gBAAgB,CAAC0C,cAAc,CAAC;IACzD,OAAOjU,eAAe,CAACoU,iBAAiB,CAAC,IAAI,EAAE,IAAIrU,YAAY,CAACsS,YAAY,EAAEE,OAAO,EAAEC,SAAS,EAAEC,cAAc,CAAC,EAAEyB,WAAW,EAAE/B,cAAc,CAAC;EACnJ;EACA;EACA;EACAkC,gBAAgBA,CAAA,EAAG;IACf,IAAI,CAACvN,eAAe,CAACuN,gBAAgB,CAAC,CAAC;EAC3C;EACAC,eAAeA,CAAA,EAAG;IACd,IAAI,CAACxN,eAAe,CAACwN,eAAe,CAAC,CAAC;EAC1C;EACAC,OAAOA,CAAClL,GAAG,EAAE;IACT,MAAMmL,UAAU,GAAI,IAAI,CAAClL,MAAM,CAAC,CAAC,KAAK,IAAI,GAAG,CAAC,CAAC,WAAW,CAAC,CAAC,UAAW;IACvE,IAAIkL,UAAU,KAAKnL,GAAG,EAAE;MACpB;IACJ;IACA,IAAI;MACA,IAAI,CAAC9F,uBAAuB,CAACkR,iBAAiB,CAAC,CAAC;MAChD,IAAI,CAACrQ,aAAa,CAACqQ,iBAAiB,CAAC,CAAC;MACtC,IAAI,IAAI,CAAC1O,wBAAwB,KAAK,IAAI,EAAE;QACxC,IAAI,CAACA,wBAAwB,GAAG,IAAI,CAACrB,gBAAgB,CAACmL,cAAc,CAAC,IAAI,CAACtD,GAAG,CAAC;MAClF;MACA,IAAI,CAACzF,eAAe,CAACyN,OAAO,CAAClL,GAAG,CAAC;IACrC,CAAC,SACO;MACJ,IAAI,CAACjF,aAAa,CAACsQ,eAAe,CAAC,CAAC;MACpC,IAAI,CAACnR,uBAAuB,CAACmR,eAAe,CAAC,CAAC;IAClD;EACJ;EACAC,sBAAsBA,CAACC,YAAY,EAAE;IACjC,IAAIA,YAAY,YAAY5V,KAAK,CAAC6V,2BAA2B,EAAE;MAC3D,OAAOD,YAAY;IACvB;IACA,OAAO,IAAI5V,KAAK,CAAC6V,2BAA2B,CAACD,YAAY,CAACE,UAAU,IAAI,IAAI,EAAE,IAAI,CAAC9E,aAAa,CAAC4E,YAAY,CAAC9L,KAAK,CAAC,EAAE8L,YAAY,CAAC9T,IAAI,EAAE8T,YAAY,CAACG,gBAAgB,IAAI,KAAK,EAAEH,YAAY,CAACI,oBAAoB,IAAI,KAAK,EAAEJ,YAAY,CAACK,UAAU,IAAI,KAAK,CAAC;EAClQ;EACAC,uBAAuBA,CAACC,aAAa,EAAE;IACnC,MAAMnT,MAAM,GAAG,EAAE;IACjB,KAAK,IAAI4I,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGsK,aAAa,CAAC9S,MAAM,EAAEuI,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACtD5I,MAAM,CAAC4I,CAAC,CAAC,GAAG,IAAI,CAAC+J,sBAAsB,CAACQ,aAAa,CAACvK,CAAC,CAAC,CAAC;IAC7D;IACA,OAAO5I,MAAM;EACjB;EACAmM,kBAAkBA,CAACiH,iBAAiB,EAAEC,cAAc,EAAEC,mBAAmB,EAAE;IACvE,IAAI;MACA,IAAI,CAAC/R,uBAAuB,CAACkR,iBAAiB,CAAC,CAAC;MAChD,IAAI,CAACrQ,aAAa,CAACqQ,iBAAiB,CAAC,CAAC;MACtC,OAAO,IAAI,CAACc,mBAAmB,CAACH,iBAAiB,EAAE,IAAI,CAACF,uBAAuB,CAACG,cAAc,CAAC,EAAEC,mBAAmB,CAAC;IACzH,CAAC,SACO;MACJ,IAAI,CAAClR,aAAa,CAACsQ,eAAe,CAAC,CAAC;MACpC,IAAI,CAACnR,uBAAuB,CAACmR,eAAe,CAAC,CAAC;IAClD;EACJ;EACAa,mBAAmBA,CAACH,iBAAiB,EAAEC,cAAc,EAAEC,mBAAmB,EAAE;IACxE,IAAI,IAAI,CAACtQ,QAAQ,CAAC4C,kBAAkB,IAAI,IAAI,CAACX,wBAAwB,EAAE;MACnE;MACA;MACA,IAAIuO,aAAa,GAAGH,cAAc,CAACjH,GAAG,CAAEqH,EAAE,IAAK;QAC3C,OAAO;UACH3M,KAAK,EAAE,IAAI,CAACkH,aAAa,CAACyF,EAAE,CAAC3M,KAAK,CAAC;UACnChI,IAAI,EAAE2U,EAAE,CAAC3U;QACb,CAAC;MACL,CAAC,CAAC;MACF;MACA;MACA,IAAI4U,mBAAmB,GAAG,IAAI;MAC9B,IAAIN,iBAAiB,EAAE;QACnB,KAAK,IAAIxK,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGuK,iBAAiB,CAAC/S,MAAM,EAAEuI,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;UAC1D,IAAI+K,GAAG,GAAGP,iBAAiB,CAACxK,CAAC,CAAC;UAC9B,IAAIgL,gBAAgB,GAAG,KAAK;UAC5B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGN,aAAa,CAACnT,MAAM,EAAEwT,CAAC,GAAGC,IAAI,EAAED,CAAC,EAAE,EAAE;YACxD,IAAIE,SAAS,GAAGP,aAAa,CAACK,CAAC,CAAC,CAAC/M,KAAK;YACtC,IAAIkN,UAAU,GAAGD,SAAS,CAAC3K,eAAe,GAAGuK,GAAG,CAAC9L,aAAa;YAC9D,IAAIoM,UAAU,GAAGN,GAAG,CAACvK,eAAe,GAAG2K,SAAS,CAAClM,aAAa;YAC9D,IAAI,CAACmM,UAAU,IAAI,CAACC,UAAU,EAAE;cAC5BL,gBAAgB,GAAG,IAAI;cACvB;YACJ;UACJ;UACA,IAAI,CAACA,gBAAgB,EAAE;YACnBF,mBAAmB,GAAG,KAAK;YAC3B;UACJ;QACJ;MACJ;MACA,IAAIA,mBAAmB,EAAE;QACrB,KAAK,IAAI9K,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAAC5D,wBAAwB,CAAC5E,MAAM,EAAEuI,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;UACtE,IAAIsL,cAAc,GAAG,IAAI,CAACjP,wBAAwB,CAAC2D,CAAC,CAAC;UACrD,IAAIuL,aAAa,GAAG,IAAI,CAACpM,gBAAgB,CAACmM,cAAc,CAAC;UACzD,IAAIE,aAAa,GAAG,IAAI;UACxB,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGN,aAAa,CAACnT,MAAM,EAAEwT,CAAC,GAAGC,IAAI,EAAED,CAAC,EAAE,EAAE;YACxD,IAAIE,SAAS,GAAGP,aAAa,CAACK,CAAC,CAAC,CAAC/M,KAAK;YACtC,IAAIuN,QAAQ,GAAGb,aAAa,CAACK,CAAC,CAAC,CAAC/U,IAAI;YACpC,IAAIoV,cAAc,GAAGH,SAAS,CAAC3K,eAAe,IAAI8K,cAAc,GAAGH,SAAS,CAAClM,aAAa,EAAE;cACxF;cACA;YACJ;YACA;YACA;YACA,IAAIqM,cAAc,KAAKH,SAAS,CAAC3K,eAAe,IAAI2K,SAAS,CAAC1K,WAAW,KAAK8K,aAAa,IACpFJ,SAAS,CAACO,OAAO,CAAC,CAAC,IAAID,QAAQ,IAAIA,QAAQ,CAAChU,MAAM,GAAG,CAAC,IAAIgU,QAAQ,CAACjJ,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;cAC1F;cACA;YACJ;YACA,IAAI8I,cAAc,KAAKH,SAAS,CAAC3K,eAAe,IAAI2K,SAAS,CAAC1K,WAAW,KAAK,CAAC,IACxE0K,SAAS,CAACO,OAAO,CAAC,CAAC,IAAID,QAAQ,IAAIA,QAAQ,CAAChU,MAAM,GAAG,CAAC,IAAIgU,QAAQ,CAACjJ,MAAM,CAACiJ,QAAQ,CAAChU,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;cAC5G;cACA;YACJ;YACA;YACA+T,aAAa,GAAG,KAAK;YACrB;UACJ;UACA,IAAIA,aAAa,EAAE;YACf,MAAMG,SAAS,GAAG,IAAIzX,KAAK,CAACoX,cAAc,EAAE,CAAC,EAAEA,cAAc,EAAEC,aAAa,CAAC;YAC7Ed,cAAc,CAACjC,IAAI,CAAC,IAAIpU,KAAK,CAAC6V,2BAA2B,CAAC,IAAI,EAAE0B,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;UAC1G;QACJ;MACJ;MACA,IAAI,CAACtP,wBAAwB,GAAG,IAAI;IACxC;IACA,IAAI,IAAI,CAAClB,wBAAwB,KAAK,IAAI,EAAE;MACxC,IAAI,CAACA,wBAAwB,GAAG,IAAI,CAACrB,gBAAgB,CAACmL,cAAc,CAAC,IAAI,CAACtD,GAAG,CAAC;IAClF;IACA,OAAO,IAAI,CAACzF,eAAe,CAAC0P,iBAAiB,CAACpB,iBAAiB,EAAEC,cAAc,EAAEC,mBAAmB,CAAC;EACzG;EACAmB,UAAUA,CAACrN,OAAO,EAAEC,GAAG,EAAEqN,6BAA6B,EAAEC,kBAAkB,EAAE;IACxE,MAAMC,KAAK,GAAGxN,OAAO,CAACgF,GAAG,CAAE1F,MAAM,IAAK;MAClC,MAAMmO,UAAU,GAAG,IAAI,CAAChI,aAAa,CAACnG,MAAM,CAACoO,WAAW,CAAC;MACzD,MAAMC,QAAQ,GAAG,IAAI,CAAClI,aAAa,CAACnG,MAAM,CAACsO,MAAM,CAAC;MAClD,OAAO;QACHlO,KAAK,EAAE,IAAIhK,KAAK,CAAC+X,UAAU,CAACxK,UAAU,EAAEwK,UAAU,CAACjI,MAAM,EAAEmI,QAAQ,CAAC1K,UAAU,EAAE0K,QAAQ,CAACnI,MAAM,CAAC;QAChG9N,IAAI,EAAE4H,MAAM,CAACuO;MACjB,CAAC;IACL,CAAC,CAAC;IACF,IAAI,CAACC,mBAAmB,CAACN,KAAK,EAAEvN,GAAG,EAAE,IAAI,EAAE,KAAK,EAAEqN,6BAA6B,EAAEC,kBAAkB,CAAC;EACxG;EACAQ,UAAUA,CAAC/N,OAAO,EAAEC,GAAG,EAAEqN,6BAA6B,EAAEC,kBAAkB,EAAE;IACxE,MAAMC,KAAK,GAAGxN,OAAO,CAACgF,GAAG,CAAE1F,MAAM,IAAK;MAClC,MAAMmO,UAAU,GAAG,IAAI,CAAChI,aAAa,CAACnG,MAAM,CAAC0O,WAAW,CAAC;MACzD,MAAML,QAAQ,GAAG,IAAI,CAAClI,aAAa,CAACnG,MAAM,CAAC2O,MAAM,CAAC;MAClD,OAAO;QACHvO,KAAK,EAAE,IAAIhK,KAAK,CAAC+X,UAAU,CAACxK,UAAU,EAAEwK,UAAU,CAACjI,MAAM,EAAEmI,QAAQ,CAAC1K,UAAU,EAAE0K,QAAQ,CAACnI,MAAM,CAAC;QAChG9N,IAAI,EAAE4H,MAAM,CAAC4O;MACjB,CAAC;IACL,CAAC,CAAC;IACF,IAAI,CAACJ,mBAAmB,CAACN,KAAK,EAAEvN,GAAG,EAAE,KAAK,EAAE,IAAI,EAAEqN,6BAA6B,EAAEC,kBAAkB,CAAC;EACxG;EACAO,mBAAmBA,CAACN,KAAK,EAAEvN,GAAG,EAAEJ,SAAS,EAAEC,SAAS,EAAEwN,6BAA6B,EAAEC,kBAAkB,EAAE;IACrG,IAAI;MACA,IAAI,CAACpT,uBAAuB,CAACkR,iBAAiB,CAAC,CAAC;MAChD,IAAI,CAACrQ,aAAa,CAACqQ,iBAAiB,CAAC,CAAC;MACtC,IAAI,CAAC1N,UAAU,GAAGkC,SAAS;MAC3B,IAAI,CAACjC,UAAU,GAAGkC,SAAS;MAC3B,IAAI,CAACqO,UAAU,CAACX,KAAK,EAAE,KAAK,CAAC;MAC7B,IAAI,CAACxM,MAAM,CAACf,GAAG,CAAC;MAChB,IAAI,CAAC+F,8BAA8B,CAACsH,6BAA6B,CAAC;IACtE,CAAC,SACO;MACJ,IAAI,CAAC3P,UAAU,GAAG,KAAK;MACvB,IAAI,CAACC,UAAU,GAAG,KAAK;MACvB,IAAI,CAAC5C,aAAa,CAACsQ,eAAe,CAACiC,kBAAkB,CAAC;MACtD,IAAI,CAACpT,uBAAuB,CAACmR,eAAe,CAAC,CAAC;IAClD;EACJ;EACA6C,UAAUA,CAACpC,aAAa,EAA4B;IAAA,IAA1BqC,gBAAgB,GAAAvU,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,KAAK;IAC9C,IAAI;MACA,IAAI,CAACM,uBAAuB,CAACkR,iBAAiB,CAAC,CAAC;MAChD,IAAI,CAACrQ,aAAa,CAACqQ,iBAAiB,CAAC,CAAC;MACtC,MAAMgD,UAAU,GAAG,IAAI,CAACvC,uBAAuB,CAACC,aAAa,CAAC;MAC9D,OAAO,IAAI,CAACuC,aAAa,CAACD,UAAU,EAAED,gBAAgB,CAAC;IAC3D,CAAC,SACO;MACJ,IAAI,CAACpT,aAAa,CAACsQ,eAAe,CAAC,CAAC;MACpC,IAAI,CAACnR,uBAAuB,CAACmR,eAAe,CAAC,CAAC;IAClD;EACJ;EACAgD,aAAaA,CAACvC,aAAa,EAAEqC,gBAAgB,EAAE;IAC3C,MAAMG,YAAY,GAAG,IAAI,CAAC7S,OAAO,CAACK,YAAY,CAAC,CAAC;IAChD,MAAMnD,MAAM,GAAG,IAAI,CAAC8C,OAAO,CAACyS,UAAU,CAACpC,aAAa,EAAE,IAAI,CAACnQ,QAAQ,CAAC4C,kBAAkB,EAAE4P,gBAAgB,CAAC;IACzG,MAAMI,YAAY,GAAG,IAAI,CAAC9S,OAAO,CAACK,YAAY,CAAC,CAAC;IAChD,MAAM0S,cAAc,GAAG7V,MAAM,CAACoH,OAAO;IACrC,IAAI,CAACnC,wBAAwB,GAAGjF,MAAM,CAAC8V,6BAA6B;IACpE,IAAID,cAAc,CAACxV,MAAM,KAAK,CAAC,EAAE;MAC7B,IAAI0V,iBAAiB,GAAG,EAAE;MAC1B,IAAI3L,SAAS,GAAGuL,YAAY;MAC5B,KAAK,IAAI/M,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGgN,cAAc,CAACxV,MAAM,EAAEuI,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QACvD,MAAMlC,MAAM,GAAGmP,cAAc,CAACjN,CAAC,CAAC;QAChC,MAAM,CAACoN,QAAQ,EAAEC,eAAe,EAAEC,cAAc,CAAC,GAAG1X,QAAQ,CAACkI,MAAM,CAAC5H,IAAI,CAAC;QACzE,IAAI,CAACoG,OAAO,CAACiR,UAAU,CAACzP,MAAM,CAACI,KAAK,EAAEkP,QAAQ,EAAEC,eAAe,CAAC;QAChE,IAAI,CAAC9Q,QAAQ,CAACgR,UAAU,CAACzP,MAAM,CAACI,KAAK,EAAEkP,QAAQ,EAAEC,eAAe,EAAEC,cAAc,EAAExP,MAAM,CAAC5H,IAAI,CAACuB,MAAM,GAAG,CAAC,GAAGqG,MAAM,CAAC5H,IAAI,CAACsX,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC;QACpJ,IAAI,CAAC7U,uBAAuB,CAAC+C,IAAI,CAAC,CAAC;QACnC,IAAI,CAACM,gBAAgB,CAACyR,aAAa,CAAC3P,MAAM,CAACK,WAAW,EAAEL,MAAM,CAACM,WAAW,EAAEN,MAAM,CAAC5H,IAAI,CAACuB,MAAM,EAAEqG,MAAM,CAACqM,gBAAgB,CAAC;QACxH,MAAM3J,eAAe,GAAG1C,MAAM,CAACI,KAAK,CAACsC,eAAe;QACpD,MAAMvB,aAAa,GAAGnB,MAAM,CAACI,KAAK,CAACe,aAAa;QAChD,MAAMyO,gBAAgB,GAAGzO,aAAa,GAAGuB,eAAe;QACxD,MAAMmN,iBAAiB,GAAGP,QAAQ;QAClC,MAAMQ,eAAe,GAAGlL,IAAI,CAAC0B,GAAG,CAACsJ,gBAAgB,EAAEC,iBAAiB,CAAC;QACrE,MAAME,oBAAoB,GAAIF,iBAAiB,GAAGD,gBAAiB;QACnE,KAAK,IAAIzC,CAAC,GAAG2C,eAAe,EAAE3C,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UACvC,MAAM6C,cAAc,GAAGtN,eAAe,GAAGyK,CAAC;UAC1C,MAAM8C,qBAAqB,GAAGf,YAAY,GAAGxL,SAAS,GAAGqM,oBAAoB,GAAGC,cAAc;UAC9FX,iBAAiB,CAAC3E,IAAI,CAAC,IAAIxT,mBAAmB,CAAC8Y,cAAc,EAAE,IAAI,CAACxI,cAAc,CAACyI,qBAAqB,CAAC,CAAC,CAAC;QAC/G;QACA,IAAIH,eAAe,GAAGF,gBAAgB,EAAE;UACpC;UACA,MAAMM,qBAAqB,GAAGxN,eAAe,GAAGoN,eAAe;UAC/DT,iBAAiB,CAAC3E,IAAI,CAAC,IAAIvT,oBAAoB,CAAC+Y,qBAAqB,GAAG,CAAC,EAAE/O,aAAa,CAAC,CAAC;QAC9F;QACA,IAAI2O,eAAe,GAAGD,iBAAiB,EAAE;UACrC;UACA,MAAMM,gBAAgB,GAAGzN,eAAe,GAAGoN,eAAe;UAC1D,MAAMM,GAAG,GAAGP,iBAAiB,GAAGC,eAAe;UAC/C,MAAMO,cAAc,GAAGnB,YAAY,GAAGxL,SAAS,GAAG0M,GAAG,GAAGD,gBAAgB,GAAG,CAAC;UAC5E,IAAIG,QAAQ,GAAG,EAAE;UACjB,KAAK,IAAIpO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkO,GAAG,EAAElO,CAAC,EAAE,EAAE;YAC1B,IAAIyB,UAAU,GAAG0M,cAAc,GAAGnO,CAAC;YACnCoO,QAAQ,CAAC3M,UAAU,GAAG0M,cAAc,CAAC,GAAG,IAAI,CAAC7I,cAAc,CAAC7D,UAAU,CAAC;UAC3E;UACA0L,iBAAiB,CAAC3E,IAAI,CAAC,IAAItT,qBAAqB,CAAC+Y,gBAAgB,GAAG,CAAC,EAAEzN,eAAe,GAAGmN,iBAAiB,EAAES,QAAQ,CAAC,CAAC;QAC1H;QACA5M,SAAS,IAAIqM,oBAAoB;MACrC;MACA,IAAI,CAACzO,kBAAkB,CAAC,CAAC;MACzB,IAAI,CAACxB,wBAAwB,CAAC,IAAI/I,2BAA2B,CAACsY,iBAAiB,EAAE,IAAI,CAACvO,YAAY,CAAC,CAAC,EAAE,IAAI,CAACzC,UAAU,EAAE,IAAI,CAACC,UAAU,CAAC,EAAE;QACrIoC,OAAO,EAAEyO,cAAc;QACvBxO,GAAG,EAAE,IAAI,CAACvE,OAAO,CAACwE,MAAM,CAAC,CAAC;QAC1BC,SAAS,EAAE,IAAI,CAACC,YAAY,CAAC,CAAC;QAC9BP,SAAS,EAAE,IAAI,CAAClC,UAAU;QAC1BmC,SAAS,EAAE,IAAI,CAAClC,UAAU;QAC1BmC,OAAO,EAAE;MACb,CAAC,CAAC;IACN;IACA,OAAQnH,MAAM,CAACiX,YAAY,KAAK,IAAI,GAAGvW,SAAS,GAAGV,MAAM,CAACiX,YAAY;EAC1E;EACAC,IAAIA,CAAA,EAAG;IACH,OAAO,IAAI,CAACxU,gBAAgB,CAACwU,IAAI,CAAC,IAAI,CAAC3M,GAAG,CAAC;EAC/C;EACA4M,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAACzU,gBAAgB,CAACyU,OAAO,CAAC,IAAI,CAAC5M,GAAG,CAAC;EAClD;EACA6M,IAAIA,CAAA,EAAG;IACH,OAAO,IAAI,CAAC1U,gBAAgB,CAAC0U,IAAI,CAAC,IAAI,CAAC7M,GAAG,CAAC;EAC/C;EACA8M,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAAC3U,gBAAgB,CAAC2U,OAAO,CAAC,IAAI,CAAC9M,GAAG,CAAC;EAClD;EACA;EACA;EACA+M,iBAAiBA,CAACC,QAAQ,EAAe;IAAA,IAAbC,OAAO,GAAAvW,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,CAAC;IACnC,IAAI,CAACsF,kBAAkB,CAAC,CAAC;IACzB,IAAI;MACA,IAAI,CAAChF,uBAAuB,CAACkR,iBAAiB,CAAC,CAAC;MAChD,OAAO,IAAI,CAACgF,kBAAkB,CAACD,OAAO,EAAED,QAAQ,CAAC;IACrD,CAAC,SACO;MACJ,IAAI,CAAChW,uBAAuB,CAACmR,eAAe,CAAC,CAAC;IAClD;EACJ;EACA+E,kBAAkBA,CAACD,OAAO,EAAED,QAAQ,EAAE;IAClC,IAAIG,cAAc,GAAG;MACjBC,aAAa,EAAEA,CAAC7Q,KAAK,EAAEzB,OAAO,KAAK;QAC/B,OAAO,IAAI,CAACuS,qBAAqB,CAACJ,OAAO,EAAE,EAAE,EAAE,CAAC;UAAE1Q,KAAK,EAAEA,KAAK;UAAEzB,OAAO,EAAEA;QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAC3F,CAAC;MACDwS,gBAAgB,EAAEA,CAACvV,EAAE,EAAEwV,QAAQ,KAAK;QAChC,IAAI,CAACC,qBAAqB,CAACzV,EAAE,EAAEwV,QAAQ,CAAC;MAC5C,CAAC;MACDE,uBAAuB,EAAEA,CAAC1V,EAAE,EAAE+C,OAAO,KAAK;QACtC,IAAI,CAAC4S,4BAA4B,CAAC3V,EAAE,EAAE4V,iBAAiB,CAAC7S,OAAO,CAAC,CAAC;MACrE,CAAC;MACD8S,gBAAgB,EAAG7V,EAAE,IAAK;QACtB,IAAI,CAACsV,qBAAqB,CAACJ,OAAO,EAAE,CAAClV,EAAE,CAAC,EAAE,EAAE,CAAC;MACjD,CAAC;MACD8V,gBAAgB,EAAEA,CAACC,cAAc,EAAEC,cAAc,KAAK;QAClD,IAAID,cAAc,CAAChY,MAAM,KAAK,CAAC,IAAIiY,cAAc,CAACjY,MAAM,KAAK,CAAC,EAAE;UAC5D;UACA,OAAO,EAAE;QACb;QACA,OAAO,IAAI,CAACuX,qBAAqB,CAACJ,OAAO,EAAEa,cAAc,EAAEC,cAAc,CAAC;MAC9E;IACJ,CAAC;IACD,IAAItY,MAAM,GAAG,IAAI;IACjB,IAAI;MACAA,MAAM,GAAGuX,QAAQ,CAACG,cAAc,CAAC;IACrC,CAAC,CACD,OAAOrT,CAAC,EAAE;MACN9H,iBAAiB,CAAC8H,CAAC,CAAC;IACxB;IACA;IACAqT,cAAc,CAACC,aAAa,GAAGrX,WAAW;IAC1CoX,cAAc,CAACG,gBAAgB,GAAGvX,WAAW;IAC7CoX,cAAc,CAACM,uBAAuB,GAAG1X,WAAW;IACpDoX,cAAc,CAACS,gBAAgB,GAAG7X,WAAW;IAC7CoX,cAAc,CAACU,gBAAgB,GAAG9X,WAAW;IAC7C,OAAON,MAAM;EACjB;EACAoY,gBAAgBA,CAACC,cAAc,EAAEC,cAAc,EAAe;IAAA,IAAbd,OAAO,GAAAvW,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,CAAC;IACxD,IAAI,CAACsF,kBAAkB,CAAC,CAAC;IACzB,IAAI,CAAC8R,cAAc,EAAE;MACjBA,cAAc,GAAG,EAAE;IACvB;IACA,IAAIA,cAAc,CAAChY,MAAM,KAAK,CAAC,IAAIiY,cAAc,CAACjY,MAAM,KAAK,CAAC,EAAE;MAC5D;MACA,OAAO,EAAE;IACb;IACA,IAAI;MACA,IAAI,CAACkB,uBAAuB,CAACkR,iBAAiB,CAAC,CAAC;MAChD,OAAO,IAAI,CAACmF,qBAAqB,CAACJ,OAAO,EAAEa,cAAc,EAAEC,cAAc,CAAC;IAC9E,CAAC,SACO;MACJ,IAAI,CAAC/W,uBAAuB,CAACmR,eAAe,CAAC,CAAC;IAClD;EACJ;EACA6F,gBAAgBA,CAACjW,EAAE,EAAE;IACjB,OAAO,IAAI,CAACkW,kBAAkB,CAAClW,EAAE,CAAC;EACtC;EACAmW,gBAAgBA,CAACnW,EAAE,EAAEwV,QAAQ,EAAEY,aAAa,EAAE;IAC1C,MAAM5P,IAAI,GAAIxG,EAAE,GAAG,IAAI,CAACoC,YAAY,CAACpC,EAAE,CAAC,GAAG,IAAK;IAChD,IAAI,CAACwG,IAAI,EAAE;MACP,IAAI,CAACgP,QAAQ,EAAE;QACX;QACA,OAAO,IAAI;MACf;MACA;MACA,OAAO,IAAI,CAACF,qBAAqB,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC;QAAE9Q,KAAK,EAAEgR,QAAQ;QAAEzS,OAAO,EAAEsT,qBAAqB,CAACD,aAAa;MAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACrH;IACA,IAAI,CAACZ,QAAQ,EAAE;MACX;MACA,IAAI,CAAClT,gBAAgB,CAACgU,MAAM,CAAC9P,IAAI,CAAC;MAClC,OAAO,IAAI,CAACpE,YAAY,CAACoE,IAAI,CAACxG,EAAE,CAAC;MACjC,OAAO,IAAI;IACf;IACA;IACA,MAAMwE,KAAK,GAAG,IAAI,CAAC0H,kCAAkC,CAACsJ,QAAQ,CAAC;IAC/D,MAAM5O,WAAW,GAAG,IAAI,CAACpG,OAAO,CAACqG,WAAW,CAACrC,KAAK,CAACsC,eAAe,EAAEtC,KAAK,CAACuC,WAAW,CAAC;IACtF,MAAMC,SAAS,GAAG,IAAI,CAACxG,OAAO,CAACqG,WAAW,CAACrC,KAAK,CAACe,aAAa,EAAEf,KAAK,CAACgB,SAAS,CAAC;IAChF,IAAI,CAAClD,gBAAgB,CAACgU,MAAM,CAAC9P,IAAI,CAAC;IAClCA,IAAI,CAAC+P,KAAK,CAAC,IAAI,CAACrR,YAAY,CAAC,CAAC,EAAE0B,WAAW,EAAEI,SAAS,EAAExC,KAAK,CAAC;IAC9DgC,IAAI,CAACgQ,UAAU,CAACH,qBAAqB,CAACD,aAAa,CAAC,CAAC;IACrD,IAAI,CAAC9T,gBAAgB,CAACmU,MAAM,CAACjQ,IAAI,CAAC;IAClC,OAAOA,IAAI,CAACxG,EAAE;EAClB;EACA0W,+BAA+BA,CAACxB,OAAO,EAAE;IACrC,IAAI,IAAI,CAACxT,WAAW,EAAE;MAClB;IACJ;IACA,MAAMiV,KAAK,GAAG,IAAI,CAACrU,gBAAgB,CAACsU,qBAAqB,CAAC1B,OAAO,CAAC;IAClE,KAAK,IAAI5O,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGoQ,KAAK,CAAC5Y,MAAM,EAAEuI,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC9C,MAAME,IAAI,GAAGmQ,KAAK,CAACrQ,CAAC,CAAC;MACrB,IAAI,CAAChE,gBAAgB,CAACgU,MAAM,CAAC9P,IAAI,CAAC;MAClC,OAAO,IAAI,CAACpE,YAAY,CAACoE,IAAI,CAACxG,EAAE,CAAC;IACrC;EACJ;EACA6W,oBAAoBA,CAACC,YAAY,EAAE;IAC/B,MAAMtQ,IAAI,GAAG,IAAI,CAACpE,YAAY,CAAC0U,YAAY,CAAC;IAC5C,IAAI,CAACtQ,IAAI,EAAE;MACP,OAAO,IAAI;IACf;IACA,OAAOA,IAAI,CAACzD,OAAO;EACvB;EACAmT,kBAAkBA,CAACY,YAAY,EAAE;IAC7B,MAAMtQ,IAAI,GAAG,IAAI,CAACpE,YAAY,CAAC0U,YAAY,CAAC;IAC5C,IAAI,CAACtQ,IAAI,EAAE;MACP,OAAO,IAAI;IACf;IACA,MAAMvB,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IACrC,IAAIsB,IAAI,CAACU,eAAe,KAAKjC,SAAS,EAAE;MACpC,IAAI,CAAC3C,gBAAgB,CAACyU,WAAW,CAACvQ,IAAI,EAAEvB,SAAS,CAAC;IACtD;IACA,IAAIuB,IAAI,CAAChC,KAAK,KAAK,IAAI,EAAE;MACrBgC,IAAI,CAAChC,KAAK,GAAG,IAAI,CAACwS,WAAW,CAACxQ,IAAI,CAACE,mBAAmB,EAAEF,IAAI,CAACS,iBAAiB,CAAC;IACnF;IACA,OAAOT,IAAI,CAAChC,KAAK;EACrB;EACAyS,kBAAkBA,CAAClP,UAAU,EAA4C;IAAA,IAA1CmN,OAAO,GAAAvW,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,CAAC;IAAA,IAAEuY,mBAAmB,GAAAvY,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,KAAK;IACnE,IAAIoJ,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAAClH,YAAY,CAAC,CAAC,EAAE;MACpD,OAAO,EAAE;IACb;IACA,OAAO,IAAI,CAACsW,mBAAmB,CAACpP,UAAU,EAAEA,UAAU,EAAEmN,OAAO,EAAEgC,mBAAmB,CAAC;EACzF;EACAC,mBAAmBA,CAACC,gBAAgB,EAAEC,cAAc,EAA4C;IAAA,IAA1CnC,OAAO,GAAAvW,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,CAAC;IAAA,IAAEuY,mBAAmB,GAAAvY,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,KAAK;IAC1F,IAAImJ,SAAS,GAAG,IAAI,CAACjH,YAAY,CAAC,CAAC;IACnC,IAAIiG,eAAe,GAAGkC,IAAI,CAAC0B,GAAG,CAAC5C,SAAS,EAAEkB,IAAI,CAAC4B,GAAG,CAAC,CAAC,EAAEwM,gBAAgB,CAAC,CAAC;IACxE,IAAI7R,aAAa,GAAGyD,IAAI,CAAC0B,GAAG,CAAC5C,SAAS,EAAEkB,IAAI,CAAC4B,GAAG,CAAC,CAAC,EAAEyM,cAAc,CAAC,CAAC;IACpE,IAAI7R,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAACF,aAAa,CAAC;IACpD,OAAO,IAAI,CAAC+R,sBAAsB,CAAC,IAAI9c,KAAK,CAACsM,eAAe,EAAE,CAAC,EAAEvB,aAAa,EAAEC,SAAS,CAAC,EAAE0P,OAAO,EAAEgC,mBAAmB,CAAC;EAC7H;EACAK,qBAAqBA,CAAC/S,KAAK,EAA4C;IAAA,IAA1C0Q,OAAO,GAAAvW,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,CAAC;IAAA,IAAEuY,mBAAmB,GAAAvY,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,KAAK;IACjE,IAAI6Y,cAAc,GAAG,IAAI,CAAC9L,aAAa,CAAClH,KAAK,CAAC;IAC9C,OAAO,IAAI,CAAC8S,sBAAsB,CAACE,cAAc,EAAEtC,OAAO,EAAEgC,mBAAmB,CAAC;EACpF;EACAO,2BAA2BA,CAAA,EAA2C;IAAA,IAA1CvC,OAAO,GAAAvW,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,CAAC;IAAA,IAAEuY,mBAAmB,GAAAvY,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,KAAK;IAChE,MAAMsG,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IACrC,MAAMxH,MAAM,GAAG,IAAI,CAAC4E,gBAAgB,CAAC6D,MAAM,CAAC+O,OAAO,EAAEgC,mBAAmB,EAAE,IAAI,EAAEjS,SAAS,CAAC;IAC1F,OAAO,IAAI,CAACmB,sBAAsB,CAAC1I,MAAM,CAAC;EAC9C;EACAga,iBAAiBA,CAAA,EAA2C;IAAA,IAA1CxC,OAAO,GAAAvW,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,CAAC;IAAA,IAAEuY,mBAAmB,GAAAvY,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,KAAK;IACtD,MAAMsG,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IACrC,MAAMxH,MAAM,GAAG,IAAI,CAAC4E,gBAAgB,CAAC6D,MAAM,CAAC+O,OAAO,EAAEgC,mBAAmB,EAAE,KAAK,EAAEjS,SAAS,CAAC;IAC3F,OAAO,IAAI,CAACmB,sBAAsB,CAAC1I,MAAM,CAAC;EAC9C;EACA4Z,sBAAsBA,CAACK,WAAW,EAAEC,aAAa,EAAEV,mBAAmB,EAAE;IACpE,MAAMtQ,WAAW,GAAG,IAAI,CAACpG,OAAO,CAACqG,WAAW,CAAC8Q,WAAW,CAAC7Q,eAAe,EAAE6Q,WAAW,CAAC5Q,WAAW,CAAC;IAClG,MAAMC,SAAS,GAAG,IAAI,CAACxG,OAAO,CAACqG,WAAW,CAAC8Q,WAAW,CAACpS,aAAa,EAAEoS,WAAW,CAACnS,SAAS,CAAC;IAC5F,MAAMP,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IACrC,MAAMxH,MAAM,GAAG,IAAI,CAAC4E,gBAAgB,CAACuV,cAAc,CAACjR,WAAW,EAAEI,SAAS,EAAE4Q,aAAa,EAAEV,mBAAmB,EAAEjS,SAAS,CAAC;IAC1H,OAAO,IAAI,CAACmB,sBAAsB,CAAC1I,MAAM,CAAC;EAC9C;EACA0I,sBAAsBA,CAACuQ,KAAK,EAAE;IAC1B,KAAK,IAAIrQ,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGoQ,KAAK,CAAC5Y,MAAM,EAAEuI,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC9C,MAAME,IAAI,GAAGmQ,KAAK,CAACrQ,CAAC,CAAC;MACrB,IAAIE,IAAI,CAAChC,KAAK,KAAK,IAAI,EAAE;QACrBgC,IAAI,CAAChC,KAAK,GAAG,IAAI,CAACwS,WAAW,CAACxQ,IAAI,CAACE,mBAAmB,EAAEF,IAAI,CAACS,iBAAiB,CAAC;MACnF;IACJ;IACA,OAAO0P,KAAK;EAChB;EACAK,WAAWA,CAACrQ,KAAK,EAAEQ,GAAG,EAAE;IACpB,OAAO,IAAI,CAAC3G,OAAO,CAACsX,UAAU,CAACnR,KAAK,EAAEQ,GAAG,GAAGR,KAAK,CAAC;EACtD;EACA8O,qBAAqBA,CAACqB,YAAY,EAAEvJ,MAAM,EAAE;IACxC,MAAM/G,IAAI,GAAG,IAAI,CAACpE,YAAY,CAAC0U,YAAY,CAAC;IAC5C,IAAI,CAACtQ,IAAI,EAAE;MACP;IACJ;IACA,MAAMhC,KAAK,GAAG,IAAI,CAAC0H,kCAAkC,CAACqB,MAAM,CAAC;IAC7D,MAAM3G,WAAW,GAAG,IAAI,CAACpG,OAAO,CAACqG,WAAW,CAACrC,KAAK,CAACsC,eAAe,EAAEtC,KAAK,CAACuC,WAAW,CAAC;IACtF,MAAMC,SAAS,GAAG,IAAI,CAACxG,OAAO,CAACqG,WAAW,CAACrC,KAAK,CAACe,aAAa,EAAEf,KAAK,CAACgB,SAAS,CAAC;IAChF,IAAI,CAAClD,gBAAgB,CAACgU,MAAM,CAAC9P,IAAI,CAAC;IAClCA,IAAI,CAAC+P,KAAK,CAAC,IAAI,CAACrR,YAAY,CAAC,CAAC,EAAE0B,WAAW,EAAEI,SAAS,EAAExC,KAAK,CAAC;IAC9D,IAAI,CAAClC,gBAAgB,CAACmU,MAAM,CAACjQ,IAAI,CAAC;IAClC,IAAI,CAACvH,uBAAuB,CAAC8Y,oBAAoB,CAACvR,IAAI,CAACzD,OAAO,CAAC;EACnE;EACA4S,4BAA4BA,CAACmB,YAAY,EAAE/T,OAAO,EAAE;IAChD,MAAMyD,IAAI,GAAG,IAAI,CAACpE,YAAY,CAAC0U,YAAY,CAAC;IAC5C,IAAI,CAACtQ,IAAI,EAAE;MACP;IACJ;IACA,MAAMwR,sBAAsB,GAAIxR,IAAI,CAACzD,OAAO,CAACkV,aAAa,IAAIzR,IAAI,CAACzD,OAAO,CAACkV,aAAa,CAACC,KAAK,GAAG,IAAI,GAAG,KAAM;IAC9G,MAAMC,qBAAqB,GAAIpV,OAAO,CAACkV,aAAa,IAAIlV,OAAO,CAACkV,aAAa,CAACC,KAAK,GAAG,IAAI,GAAG,KAAM;IACnG,IAAI,CAACjZ,uBAAuB,CAAC8Y,oBAAoB,CAACvR,IAAI,CAACzD,OAAO,CAAC;IAC/D,IAAI,CAAC9D,uBAAuB,CAAC8Y,oBAAoB,CAAChV,OAAO,CAAC;IAC1D,IAAIiV,sBAAsB,KAAKG,qBAAqB,EAAE;MAClD;MACA,IAAI,CAAC7V,gBAAgB,CAACgU,MAAM,CAAC9P,IAAI,CAAC;MAClCA,IAAI,CAACgQ,UAAU,CAACzT,OAAO,CAAC;MACxB,IAAI,CAACT,gBAAgB,CAACmU,MAAM,CAACjQ,IAAI,CAAC;IACtC,CAAC,MACI;MACDA,IAAI,CAACgQ,UAAU,CAACzT,OAAO,CAAC;IAC5B;EACJ;EACAuS,qBAAqBA,CAACJ,OAAO,EAAEkD,iBAAiB,EAAEpC,cAAc,EAAE;IAC9D,MAAM/Q,SAAS,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IACrC,MAAMmT,iBAAiB,GAAGD,iBAAiB,CAACra,MAAM;IAClD,IAAIua,kBAAkB,GAAG,CAAC;IAC1B,MAAMC,iBAAiB,GAAGvC,cAAc,CAACjY,MAAM;IAC/C,IAAIya,kBAAkB,GAAG,CAAC;IAC1B,IAAI9a,MAAM,GAAG,IAAI2Q,KAAK,CAACkK,iBAAiB,CAAC;IACzC,OAAOD,kBAAkB,GAAGD,iBAAiB,IAAIG,kBAAkB,GAAGD,iBAAiB,EAAE;MACrF,IAAI/R,IAAI,GAAG,IAAI;MACf,IAAI8R,kBAAkB,GAAGD,iBAAiB,EAAE;QACxC;QACA,GAAG;UACC7R,IAAI,GAAG,IAAI,CAACpE,YAAY,CAACgW,iBAAiB,CAACE,kBAAkB,EAAE,CAAC,CAAC;QACrE,CAAC,QAAQ,CAAC9R,IAAI,IAAI8R,kBAAkB,GAAGD,iBAAiB;QACxD;QACA,IAAI7R,IAAI,EAAE;UACN,IAAI,CAAClE,gBAAgB,CAACgU,MAAM,CAAC9P,IAAI,CAAC;UAClC,IAAI,CAACvH,uBAAuB,CAAC8Y,oBAAoB,CAACvR,IAAI,CAACzD,OAAO,CAAC;QACnE;MACJ;MACA,IAAIyV,kBAAkB,GAAGD,iBAAiB,EAAE;QACxC;QACA,IAAI,CAAC/R,IAAI,EAAE;UACP,MAAMiS,oBAAoB,GAAI,EAAE,IAAI,CAACtW,iBAAkB;UACvD,MAAM2U,YAAY,MAAArH,MAAA,CAAM,IAAI,CAACxN,WAAW,OAAAwN,MAAA,CAAIgJ,oBAAoB,CAAE;UAClEjS,IAAI,GAAG,IAAI3L,YAAY,CAACic,YAAY,EAAE,CAAC,EAAE,CAAC,CAAC;UAC3C,IAAI,CAAC1U,YAAY,CAAC0U,YAAY,CAAC,GAAGtQ,IAAI;QAC1C;QACA;QACA,MAAMkS,aAAa,GAAG1C,cAAc,CAACwC,kBAAkB,CAAC;QACxD,MAAMhU,KAAK,GAAG,IAAI,CAAC0H,kCAAkC,CAACwM,aAAa,CAAClU,KAAK,CAAC;QAC1E,MAAMzB,OAAO,GAAG6S,iBAAiB,CAAC8C,aAAa,CAAC3V,OAAO,CAAC;QACxD,MAAM6D,WAAW,GAAG,IAAI,CAACpG,OAAO,CAACqG,WAAW,CAACrC,KAAK,CAACsC,eAAe,EAAEtC,KAAK,CAACuC,WAAW,CAAC;QACtF,MAAMC,SAAS,GAAG,IAAI,CAACxG,OAAO,CAACqG,WAAW,CAACrC,KAAK,CAACe,aAAa,EAAEf,KAAK,CAACgB,SAAS,CAAC;QAChFgB,IAAI,CAAC0O,OAAO,GAAGA,OAAO;QACtB1O,IAAI,CAAC+P,KAAK,CAACtR,SAAS,EAAE2B,WAAW,EAAEI,SAAS,EAAExC,KAAK,CAAC;QACpDgC,IAAI,CAACgQ,UAAU,CAACzT,OAAO,CAAC;QACxB,IAAI,CAAC9D,uBAAuB,CAAC8Y,oBAAoB,CAAChV,OAAO,CAAC;QAC1D,IAAI,CAACT,gBAAgB,CAACmU,MAAM,CAACjQ,IAAI,CAAC;QAClC9I,MAAM,CAAC8a,kBAAkB,CAAC,GAAGhS,IAAI,CAACxG,EAAE;QACpCwY,kBAAkB,EAAE;MACxB,CAAC,MACI;QACD,IAAIhS,IAAI,EAAE;UACN,OAAO,IAAI,CAACpE,YAAY,CAACoE,IAAI,CAACxG,EAAE,CAAC;QACrC;MACJ;IACJ;IACA,OAAOtC,MAAM;EACjB;EACAib,SAASA,CAACC,MAAM,EAAE;IACd,IAAIA,MAAM,CAAC7a,MAAM,KAAK,CAAC,EAAE;MACrB;IACJ;IACA,IAAI8a,MAAM,GAAG,EAAE;IACf,KAAK,IAAIvS,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGqS,MAAM,CAAC7a,MAAM,EAAEuI,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC/C,MAAMwS,OAAO,GAAGF,MAAM,CAACtS,CAAC,CAAC;MACzB,IAAIyS,oBAAoB,GAAG,CAAC;MAC5B,IAAIC,oBAAoB,GAAG,CAAC;MAC5B,IAAIC,SAAS,GAAG,KAAK;MACrB,KAAK,IAAI1H,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGsH,OAAO,CAACF,MAAM,CAAC7a,MAAM,EAAEwT,CAAC,GAAGC,IAAI,EAAED,CAAC,EAAE,EAAE;QACzD,MAAMxJ,UAAU,GAAG+Q,OAAO,CAAChS,eAAe,GAAGyK,CAAC;QAC9C,IAAI0H,SAAS,EAAE;UACX,IAAI,CAACrW,OAAO,CAAC+V,SAAS,CAAC,IAAI,CAAC/W,mBAAmB,CAAC5B,EAAE,EAAE+H,UAAU,GAAG,CAAC,EAAE,IAAI,CAACvH,OAAO,CAACQ,aAAa,CAAC+G,UAAU,CAAC,EAAE+Q,OAAO,CAACF,MAAM,CAACrH,CAAC,CAAC,EAAE,KAAK,CAAC;UACrIyH,oBAAoB,GAAGjR,UAAU;QACrC,CAAC,MACI;UACD,MAAMmR,aAAa,GAAG,IAAI,CAACtW,OAAO,CAAC+V,SAAS,CAAC,IAAI,CAAC/W,mBAAmB,CAAC5B,EAAE,EAAE+H,UAAU,GAAG,CAAC,EAAE,IAAI,CAACvH,OAAO,CAACQ,aAAa,CAAC+G,UAAU,CAAC,EAAE+Q,OAAO,CAACF,MAAM,CAACrH,CAAC,CAAC,EAAE,IAAI,CAAC;UAC1J,IAAI2H,aAAa,EAAE;YACfD,SAAS,GAAG,IAAI;YAChBF,oBAAoB,GAAGhR,UAAU;YACjCiR,oBAAoB,GAAGjR,UAAU;UACrC;QACJ;MACJ;MACA,IAAIkR,SAAS,EAAE;QACXJ,MAAM,CAAC/J,IAAI,CAAC;UAAE2F,cAAc,EAAEsE,oBAAoB;UAAEI,YAAY,EAAEH;QAAqB,CAAC,CAAC;MAC7F;IACJ;IACA,IAAIH,MAAM,CAAC9a,MAAM,GAAG,CAAC,EAAE;MACnB,IAAI,CAACqb,4BAA4B,CAAC;QAC9BC,0BAA0B,EAAE,KAAK;QACjCC,qBAAqB,EAAE,KAAK;QAC5BT,MAAM,EAAEA;MACZ,CAAC,CAAC;IACN;EACJ;EACAU,iBAAiBA,CAACX,MAAM,EAAEY,UAAU,EAAE;IAClC,IAAI,CAAC3W,QAAQ,CAAC4W,GAAG,CAACb,MAAM,EAAEY,UAAU,CAAC;IACrC,IAAI,CAACJ,4BAA4B,CAAC;MAC9BC,0BAA0B,EAAE,KAAK;MACjCC,qBAAqB,EAAEV,MAAM,KAAK,IAAI;MACtCC,MAAM,EAAE,CAAC;QAAEpE,cAAc,EAAE,CAAC;QAAE0E,YAAY,EAAE,IAAI,CAACtY,YAAY,CAAC;MAAE,CAAC;IACrE,CAAC,CAAC;EACN;EACA6Y,yBAAyBA,CAAA,EAAG;IACxB,OAAO,IAAI,CAAC7W,QAAQ,CAAC2W,UAAU,CAAC,CAAC;EACrC;EACAG,qBAAqBA,CAAA,EAAG;IACpB,OAAO,CAAC,IAAI,CAAC9W,QAAQ,CAACmP,OAAO,CAAC,CAAC;EACnC;EACA4H,wBAAwBA,CAACpV,KAAK,EAAEoU,MAAM,EAAE;IACpC,IAAI,IAAI,CAACc,yBAAyB,CAAC,CAAC,EAAE;MAClC;IACJ;IACA,MAAMG,YAAY,GAAG,IAAI,CAAChX,QAAQ,CAACiX,UAAU,CAACtV,KAAK,EAAEoU,MAAM,CAAC;IAC5D,IAAI,CAACQ,4BAA4B,CAAC;MAC9BC,0BAA0B,EAAE,KAAK;MACjCC,qBAAqB,EAAE,IAAI;MAC3BT,MAAM,EAAE,CAAC;QAAEpE,cAAc,EAAEoF,YAAY,CAAC/S,eAAe;QAAEqS,YAAY,EAAEU,YAAY,CAACtU;MAAc,CAAC;IACvG,CAAC,CAAC;EACN;EACAwU,gBAAgBA,CAACjT,eAAe,EAAEvB,aAAa,EAAE;IAC7CuB,eAAe,GAAGkC,IAAI,CAAC4B,GAAG,CAAC,CAAC,EAAE9D,eAAe,CAAC;IAC9CvB,aAAa,GAAGyD,IAAI,CAAC0B,GAAG,CAAC,IAAI,CAAClK,OAAO,CAACK,YAAY,CAAC,CAAC,EAAE0E,aAAa,CAAC;IACpE,IAAI,CAACzC,aAAa,CAACiX,gBAAgB,CAACjT,eAAe,EAAEvB,aAAa,CAAC;EACvE;EACAyU,WAAWA,CAAA,EAAG;IACV,IAAI,CAACpX,OAAO,CAAC+C,KAAK,CAAC,CAAC;IACpB,IAAI,CAACyT,4BAA4B,CAAC;MAC9BC,0BAA0B,EAAE,IAAI;MAChCC,qBAAqB,EAAE,KAAK;MAC5BT,MAAM,EAAE,CAAC;QACDpE,cAAc,EAAE,CAAC;QACjB0E,YAAY,EAAE,IAAI,CAAC3Y,OAAO,CAACK,YAAY,CAAC;MAC5C,CAAC;IACT,CAAC,CAAC;EACN;EACAuY,4BAA4BA,CAACrX,CAAC,EAAE;IAC5B,IAAI,CAAC,IAAI,CAACJ,YAAY,EAAE;MACpB,IAAI,CAACnC,kBAAkB,CAACwC,IAAI,CAACD,CAAC,CAAC;IACnC;EACJ;EACAkY,iBAAiBA,CAAA,EAAG;IAChB,IAAI,CAACnX,aAAa,CAACyT,KAAK,CAAC,CAAC;EAC9B;EACA2D,iBAAiBA,CAACnS,UAAU,EAAE;IAC1B,IAAIA,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAAClH,YAAY,CAAC,CAAC,EAAE;MACpD,MAAM,IAAI5C,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,IAAI,CAAC6E,aAAa,CAACoX,iBAAiB,CAACnS,UAAU,CAAC;EACpD;EACAoS,iBAAiBA,CAACpS,UAAU,EAAE;IAC1B,OAAO,IAAI,CAACjF,aAAa,CAACqX,iBAAiB,CAACpS,UAAU,CAAC;EAC3D;EACAqS,eAAeA,CAACrS,UAAU,EAAE;IACxB,IAAI,IAAI,CAACoS,iBAAiB,CAACpS,UAAU,CAAC,EAAE;MACpC,IAAI,CAACmS,iBAAiB,CAACnS,UAAU,CAAC;IACtC;EACJ;EACAsS,aAAaA,CAACtS,UAAU,EAAE;IACtB,IAAIA,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,IAAI,CAAClH,YAAY,CAAC,CAAC,EAAE;MACpD,MAAM,IAAI5C,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,OAAO,IAAI,CAACqc,cAAc,CAACvS,UAAU,CAAC;EAC1C;EACAuS,cAAcA,CAACvS,UAAU,EAAE;IACvB,MAAMwS,QAAQ,GAAG,IAAI,CAAC3O,cAAc,CAAC7D,UAAU,CAAC;IAChD,MAAMyS,eAAe,GAAG,IAAI,CAAC5X,OAAO,CAAC6X,SAAS,CAAC,IAAI,CAAC7Y,mBAAmB,CAAC5B,EAAE,EAAE+H,UAAU,GAAG,CAAC,EAAEwS,QAAQ,CAAC;IACrG,OAAO,IAAI,CAAC1X,QAAQ,CAAC6X,iBAAiB,CAAC3S,UAAU,EAAEyS,eAAe,CAAC;EACvE;EACAG,qBAAqBA,CAAA,EAAG;IACpB,OAAO,IAAI,CAAC/Y,mBAAmB;EACnC;EACAgZ,SAASA,CAAA,EAAG;IACR,OAAO,IAAI,CAAChZ,mBAAmB,CAACiZ,QAAQ;EAC5C;EACAC,OAAOA,CAACrc,kBAAkB,EAAE;IACxB,IAAI,IAAI,CAACmD,mBAAmB,CAAC5B,EAAE,KAAKvB,kBAAkB,CAACuB,EAAE,EAAE;MACvD;MACA;IACJ;IACA,IAAI+B,CAAC,GAAG;MACJgZ,WAAW,EAAE,IAAI,CAACnZ,mBAAmB,CAACiZ,QAAQ;MAC9CG,WAAW,EAAEvc,kBAAkB,CAACoc;IACpC,CAAC;IACD,IAAI,CAACjZ,mBAAmB,GAAGnD,kBAAkB;IAC7C,IAAI,CAACW,oBAAoB,CAAC4C,IAAI,CAACD,CAAC,CAAC;IACjC,IAAI,CAACzC,iCAAiC,CAAC0C,IAAI,CAAC,CAAC,CAAC,CAAC;EACnD;EACAiZ,uBAAuBA,CAAClT,UAAU,EAAEuC,MAAM,EAAE;IACxC,MAAMF,QAAQ,GAAG,IAAI,CAAC6C,gBAAgB,CAAC,IAAI1S,QAAQ,CAACwN,UAAU,EAAEuC,MAAM,CAAC,CAAC;IACxE,MAAM4Q,UAAU,GAAG,IAAI,CAACb,aAAa,CAACjQ,QAAQ,CAACrC,UAAU,CAAC;IAC1D,OAAOmT,UAAU,CAACC,aAAa,CAACD,UAAU,CAACE,sBAAsB,CAAChR,QAAQ,CAACE,MAAM,GAAG,CAAC,CAAC,CAAC;EAC3F;EACA;EACA+Q,iBAAiBA,CAACC,SAAS,EAAE;IACzB,IAAI,CAACrX,kBAAkB,CAAC,CAAC;IACzB,MAAMmG,QAAQ,GAAG,IAAI,CAAC6C,gBAAgB,CAACqO,SAAS,CAAC;IACjD,MAAMC,WAAW,GAAG,IAAI,CAAC3P,cAAc,CAACxB,QAAQ,CAACrC,UAAU,CAAC;IAC5D,MAAMmT,UAAU,GAAG,IAAI,CAACZ,cAAc,CAAClQ,QAAQ,CAACrC,UAAU,CAAC;IAC3D,MAAMyT,UAAU,GAAGN,UAAU,CAACE,sBAAsB,CAAChR,QAAQ,CAACE,MAAM,GAAG,CAAC,CAAC;IACzE;IACA,MAAM,CAACmR,aAAa,EAAEC,WAAW,CAAC,GAAGnd,SAAS,CAACod,uBAAuB,CAACT,UAAU,EAAEM,UAAU,CAAC;IAC9F,MAAMI,eAAe,GAAGhgB,aAAa,CAACwO,QAAQ,CAACE,MAAM,EAAEzO,6BAA6B,CAACggB,iBAAiB,CAACX,UAAU,CAACC,aAAa,CAACK,UAAU,CAAC,CAAC,EAAED,WAAW,CAACnS,SAAS,CAACqS,aAAa,EAAEC,WAAW,CAAC,EAAED,aAAa,CAAC;IAC/M;IACA,IAAIG,eAAe,IAAIA,eAAe,CAAC7U,WAAW,IAAIuU,SAAS,CAAChR,MAAM,IAAIgR,SAAS,CAAChR,MAAM,IAAIsR,eAAe,CAACpW,SAAS,EAAE;MACrH,OAAOoW,eAAe;IAC1B;IACA;IACA,IAAIJ,UAAU,GAAG,CAAC,IAAIC,aAAa,KAAKrR,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;MACzD;MACA,MAAM,CAACwR,aAAa,EAAEC,WAAW,CAAC,GAAGxd,SAAS,CAACod,uBAAuB,CAACT,UAAU,EAAEM,UAAU,GAAG,CAAC,CAAC;MAClG,MAAMQ,cAAc,GAAGpgB,aAAa,CAACwO,QAAQ,CAACE,MAAM,EAAEzO,6BAA6B,CAACggB,iBAAiB,CAACX,UAAU,CAACC,aAAa,CAACK,UAAU,GAAG,CAAC,CAAC,CAAC,EAAED,WAAW,CAACnS,SAAS,CAAC0S,aAAa,EAAEC,WAAW,CAAC,EAAED,aAAa,CAAC;MAClN;MACA,IAAIE,cAAc,IAAIA,cAAc,CAACjV,WAAW,IAAIuU,SAAS,CAAChR,MAAM,IAAIgR,SAAS,CAAChR,MAAM,IAAI0R,cAAc,CAACxW,SAAS,EAAE;QAClH,OAAOwW,cAAc;MACzB;IACJ;IACA,OAAO,IAAI;EACf;EACA,OAAOL,uBAAuBA,CAACT,UAAU,EAAEM,UAAU,EAAE;IACnD,MAAMS,UAAU,GAAGf,UAAU,CAACC,aAAa,CAACK,UAAU,CAAC;IACvD;IACA,IAAI5U,WAAW,GAAG,CAAC;IACnB,KAAK,IAAIN,CAAC,GAAGkV,UAAU,EAAElV,CAAC,IAAI,CAAC,IAAI4U,UAAU,CAACC,aAAa,CAAC7U,CAAC,CAAC,KAAK2V,UAAU,EAAE3V,CAAC,EAAE,EAAE;MAChFM,WAAW,GAAGsU,UAAU,CAACgB,cAAc,CAAC5V,CAAC,CAAC;IAC9C;IACA;IACA,IAAIU,SAAS,GAAGkU,UAAU,CAACtP,cAAc,CAAC,CAAC,CAAC7N,MAAM;IAClD,KAAK,IAAIuI,CAAC,GAAGkV,UAAU,EAAEW,UAAU,GAAGjB,UAAU,CAACkB,QAAQ,CAAC,CAAC,EAAE9V,CAAC,GAAG6V,UAAU,IAAIjB,UAAU,CAACC,aAAa,CAAC7U,CAAC,CAAC,KAAK2V,UAAU,EAAE3V,CAAC,EAAE,EAAE;MAC5HU,SAAS,GAAGkU,UAAU,CAACmB,YAAY,CAAC/V,CAAC,CAAC;IAC1C;IACA,OAAO,CAACM,WAAW,EAAEI,SAAS,CAAC;EACnC;EACAsV,oBAAoBA,CAAClS,QAAQ,EAAE;IAC3B,MAAMmS,cAAc,GAAG,IAAI,CAAClB,iBAAiB,CAACjR,QAAQ,CAAC;IACvD,IAAI,CAACmS,cAAc,EAAE;MACjB,OAAO;QACHC,IAAI,EAAE,EAAE;QACRzV,WAAW,EAAEqD,QAAQ,CAACE,MAAM;QAC5B9E,SAAS,EAAE4E,QAAQ,CAACE;MACxB,CAAC;IACL;IACA,OAAO;MACHkS,IAAI,EAAED,cAAc,CAACC,IAAI,CAACC,MAAM,CAAC,CAAC,EAAErS,QAAQ,CAACE,MAAM,GAAGiS,cAAc,CAACxV,WAAW,CAAC;MACjFA,WAAW,EAAEwV,cAAc,CAACxV,WAAW;MACvCvB,SAAS,EAAE4E,QAAQ,CAACE;IACxB,CAAC;EACL;EACAoS,qBAAqBA,CAACC,QAAQ,EAAErB,SAAS,EAAE;IACvC,IAAIsB,OAAO,GAAGD,QAAQ,CAACE,WAAW,CAAC,CAAC;IACpC,IAAIzS,QAAQ,GAAG,IAAI,CAAC6C,gBAAgB,CAACqO,SAAS,CAAC;IAC/C,IAAIJ,UAAU,GAAG,IAAI,CAACZ,cAAc,CAAClQ,QAAQ,CAACrC,UAAU,CAAC;IACzD,IAAIkU,UAAU,GAAGf,UAAU,CAACC,aAAa,CAACD,UAAU,CAACE,sBAAsB,CAAChR,QAAQ,CAACE,MAAM,GAAG,CAAC,CAAC,CAAC;IACjG,IAAIwS,eAAe,GAAGjhB,6BAA6B,CAACkhB,kBAAkB,CAACd,UAAU,CAAC;IAClF,IAAI,CAACa,eAAe,EAAE;MAClB,OAAO,IAAI;IACf;IACA,IAAIE,IAAI,GAAGF,eAAe,CAACG,aAAa,CAACL,OAAO,CAAC;IACjD,IAAI,CAACI,IAAI,EAAE;MACP,OAAO,IAAI;IACf;IACA,OAAO1e,0BAA0B,CAAC,IAAI,CAAC4e,sBAAsB,CAACF,IAAI,EAAE5S,QAAQ,EAAE,IAAI,CAAC,CAAC;EACxF;EACA+S,YAAYA,CAAC/S,QAAQ,EAAE;IACnB,OAAO,IAAI,CAACgT,aAAa,CAAC,IAAI,CAACnQ,gBAAgB,CAAC7C,QAAQ,CAAC,CAAC;EAC9D;EACAgT,aAAaA,CAAChT,QAAQ,EAAE;IACpB,MAAMrC,UAAU,GAAGqC,QAAQ,CAACrC,UAAU;IACtC,MAAMmT,UAAU,GAAG,IAAI,CAACZ,cAAc,CAACvS,UAAU,CAAC;IAClD,MAAMoU,UAAU,GAAGjB,UAAU,CAACkB,QAAQ,CAAC,CAAC;IACxC,MAAM7B,QAAQ,GAAG,IAAI,CAAC/Z,OAAO,CAACoL,cAAc,CAAC7D,UAAU,CAAC;IACxD,MAAMyT,UAAU,GAAGN,UAAU,CAACE,sBAAsB,CAAChR,QAAQ,CAACE,MAAM,GAAG,CAAC,CAAC;IACzE,IAAIkR,UAAU,GAAG,CAAC,EAAE;MAChB,OAAO,IAAI;IACf;IACA,MAAM6B,mBAAmB,GAAGxhB,6BAA6B,CAACkhB,kBAAkB,CAAC7B,UAAU,CAACC,aAAa,CAACK,UAAU,CAAC,CAAC;IAClH;IACA,IAAI6B,mBAAmB,IAAI,CAACthB,qBAAqB,CAACmf,UAAU,CAACoC,oBAAoB,CAAC9B,UAAU,CAAC,CAAC,EAAE;MAC5F;MACA,IAAI+B,iBAAiB,GAAGvU,IAAI,CAAC4B,GAAG,CAAC,CAAC,EAAER,QAAQ,CAACE,MAAM,GAAG,CAAC,GAAG+S,mBAAmB,CAACG,gBAAgB,CAAC;MAC/F,KAAK,IAAIlX,CAAC,GAAGkV,UAAU,GAAG,CAAC,EAAElV,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QACtC,MAAMmX,cAAc,GAAGvC,UAAU,CAACmB,YAAY,CAAC/V,CAAC,CAAC;QACjD,IAAImX,cAAc,IAAIF,iBAAiB,EAAE;UACrC;QACJ;QACA,IAAIxhB,qBAAqB,CAACmf,UAAU,CAACoC,oBAAoB,CAAChX,CAAC,CAAC,CAAC,EAAE;UAC3DiX,iBAAiB,GAAGE,cAAc;QACtC;MACJ;MACA;MACA,MAAMC,eAAe,GAAG1U,IAAI,CAAC0B,GAAG,CAAC6P,QAAQ,CAACxc,MAAM,EAAEqM,QAAQ,CAACE,MAAM,GAAG,CAAC,GAAG+S,mBAAmB,CAACG,gBAAgB,CAAC;MAC7G;MACA;MACA,IAAIG,UAAU,GAAG,IAAI;MACrB,OAAO,IAAI,EAAE;QACT,MAAMC,YAAY,GAAG5hB,aAAa,CAAC6hB,sBAAsB,CAACR,mBAAmB,CAACS,YAAY,EAAE/V,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;QACrJ,IAAI,CAACE,YAAY,EAAE;UACf;UACA;QACJ;QACA;QACA,IAAIA,YAAY,CAAC7W,WAAW,IAAIqD,QAAQ,CAACE,MAAM,IAAIF,QAAQ,CAACE,MAAM,IAAIsT,YAAY,CAACpY,SAAS,EAAE;UAC1F,MAAMuY,gBAAgB,GAAGxD,QAAQ,CAACnR,SAAS,CAACwU,YAAY,CAAC7W,WAAW,GAAG,CAAC,EAAE6W,YAAY,CAACpY,SAAS,GAAG,CAAC,CAAC,CAACqX,WAAW,CAAC,CAAC;UACnH,MAAMmB,CAAC,GAAG,IAAI,CAACC,kBAAkB,CAACL,YAAY,EAAEP,mBAAmB,CAACJ,aAAa,CAACc,gBAAgB,CAAC,EAAEV,mBAAmB,CAACa,iBAAiB,CAACH,gBAAgB,CAAC,EAAE,IAAI,CAAC;UACnK,IAAIC,CAAC,EAAE;YACH,IAAIA,CAAC,YAAY9f,qBAAqB,EAAE;cACpC,OAAO,IAAI;YACf;YACAyf,UAAU,GAAGK,CAAC;UAClB;QACJ;QACAT,iBAAiB,GAAGK,YAAY,CAACpY,SAAS,GAAG,CAAC;MAClD;MACA,IAAImY,UAAU,EAAE;QACZ,OAAOA,UAAU;MACrB;IACJ;IACA;IACA,IAAInC,UAAU,GAAG,CAAC,IAAIN,UAAU,CAACgB,cAAc,CAACV,UAAU,CAAC,KAAKpR,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;MACjF,MAAM6T,cAAc,GAAG3C,UAAU,GAAG,CAAC;MACrC,MAAM4C,gBAAgB,GAAGviB,6BAA6B,CAACkhB,kBAAkB,CAAC7B,UAAU,CAACC,aAAa,CAACgD,cAAc,CAAC,CAAC;MACnH;MACA,IAAIC,gBAAgB,IAAI,CAACriB,qBAAqB,CAACmf,UAAU,CAACoC,oBAAoB,CAACa,cAAc,CAAC,CAAC,EAAE;QAC7F;QACA,MAAMZ,iBAAiB,GAAGvU,IAAI,CAAC4B,GAAG,CAAC,CAAC,EAAER,QAAQ,CAACE,MAAM,GAAG,CAAC,GAAG8T,gBAAgB,CAACZ,gBAAgB,CAAC;QAC9F,IAAIE,eAAe,GAAG1U,IAAI,CAAC0B,GAAG,CAAC6P,QAAQ,CAACxc,MAAM,EAAEqM,QAAQ,CAACE,MAAM,GAAG,CAAC,GAAG8T,gBAAgB,CAACZ,gBAAgB,CAAC;QACxG,KAAK,IAAIlX,CAAC,GAAG6X,cAAc,GAAG,CAAC,EAAE7X,CAAC,GAAG6V,UAAU,EAAE7V,CAAC,EAAE,EAAE;UAClD,MAAM+X,gBAAgB,GAAGnD,UAAU,CAACgB,cAAc,CAAC5V,CAAC,CAAC;UACrD,IAAI+X,gBAAgB,IAAIX,eAAe,EAAE;YACrC;UACJ;UACA,IAAI3hB,qBAAqB,CAACmf,UAAU,CAACoC,oBAAoB,CAAChX,CAAC,CAAC,CAAC,EAAE;YAC3DoX,eAAe,GAAGW,gBAAgB;UACtC;QACJ;QACA,MAAMT,YAAY,GAAG5hB,aAAa,CAACsiB,sBAAsB,CAACF,gBAAgB,CAACG,aAAa,EAAExW,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;QACnJ;QACA,IAAIE,YAAY,IAAIA,YAAY,CAAC7W,WAAW,IAAIqD,QAAQ,CAACE,MAAM,IAAIF,QAAQ,CAACE,MAAM,IAAIsT,YAAY,CAACpY,SAAS,EAAE;UAC1G,MAAMuY,gBAAgB,GAAGxD,QAAQ,CAACnR,SAAS,CAACwU,YAAY,CAAC7W,WAAW,GAAG,CAAC,EAAE6W,YAAY,CAACpY,SAAS,GAAG,CAAC,CAAC,CAACqX,WAAW,CAAC,CAAC;UACnH,MAAMmB,CAAC,GAAG,IAAI,CAACC,kBAAkB,CAACL,YAAY,EAAEQ,gBAAgB,CAACnB,aAAa,CAACc,gBAAgB,CAAC,EAAEK,gBAAgB,CAACF,iBAAiB,CAACH,gBAAgB,CAAC,EAAE,IAAI,CAAC;UAC7J,IAAIC,CAAC,EAAE;YACH,IAAIA,CAAC,YAAY9f,qBAAqB,EAAE;cACpC,OAAO,IAAI;YACf;YACA,OAAO8f,CAAC;UACZ;QACJ;MACJ;IACJ;IACA,OAAO,IAAI;EACf;EACAC,kBAAkBA,CAACL,YAAY,EAAEZ,IAAI,EAAEwB,MAAM,EAAEC,uBAAuB,EAAE;IACpE,IAAI,CAACzB,IAAI,EAAE;MACP,OAAO,IAAI;IACf;IACA,MAAM0B,OAAO,GAAIF,MAAM,GACjB,IAAI,CAACG,wBAAwB,CAAC3B,IAAI,EAAEY,YAAY,CAACgB,cAAc,CAAC,CAAC,EAAEH,uBAAuB,CAAC,GAC3F,IAAI,CAACvB,sBAAsB,CAACF,IAAI,EAAEY,YAAY,CAACiB,gBAAgB,CAAC,CAAC,EAAEJ,uBAAuB,CAAE;IAClG,IAAI,CAACC,OAAO,EAAE;MACV,OAAO,IAAI;IACf;IACA,IAAIA,OAAO,YAAYxgB,qBAAqB,EAAE;MAC1C,OAAOwgB,OAAO;IAClB;IACA,OAAO,CAACd,YAAY,EAAEc,OAAO,CAAC;EAClC;EACAxB,sBAAsBA,CAACN,OAAO,EAAExS,QAAQ,EAAEqU,uBAAuB,EAAE;IAC/D;IACA,MAAMxC,UAAU,GAAGW,OAAO,CAACne,kBAAkB,CAACuB,EAAE;IAChD,MAAM8e,oBAAoB,GAAGlC,OAAO,CAAC2B,aAAa;IAClD,IAAIQ,KAAK,GAAG,CAAC,CAAC;IACd,IAAIC,cAAc,GAAG,CAAC;IACtB,MAAMC,gCAAgC,GAAGA,CAAClX,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,KAAK;MACnG,OAAO,IAAI,EAAE;QACT,IAAIe,uBAAuB,IAAK,EAAEO,cAAc,GAAI,GAAG,KAAK,CAAC,IAAI,CAACP,uBAAuB,CAAC,CAAC,EAAE;UACzF,OAAOvgB,qBAAqB,CAACG,QAAQ;QACzC;QACA,MAAM2f,CAAC,GAAGhiB,aAAa,CAACsiB,sBAAsB,CAACQ,oBAAoB,EAAE/W,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;QAC9H,IAAI,CAACM,CAAC,EAAE;UACJ;QACJ;QACA,MAAMkB,OAAO,GAAG3E,QAAQ,CAACnR,SAAS,CAAC4U,CAAC,CAACjX,WAAW,GAAG,CAAC,EAAEiX,CAAC,CAACxY,SAAS,GAAG,CAAC,CAAC,CAACqX,WAAW,CAAC,CAAC;QACpF,IAAID,OAAO,CAAC4B,MAAM,CAACU,OAAO,CAAC,EAAE;UACzBH,KAAK,EAAE;QACX,CAAC,MACI,IAAInC,OAAO,CAACuC,OAAO,CAACD,OAAO,CAAC,EAAE;UAC/BH,KAAK,EAAE;QACX;QACA,IAAIA,KAAK,KAAK,CAAC,EAAE;UACb,OAAOf,CAAC;QACZ;QACAN,eAAe,GAAGM,CAAC,CAACjX,WAAW,GAAG,CAAC;MACvC;MACA,OAAO,IAAI;IACf,CAAC;IACD,KAAK,IAAIgB,UAAU,GAAGqC,QAAQ,CAACrC,UAAU,EAAEA,UAAU,IAAI,CAAC,EAAEA,UAAU,EAAE,EAAE;MACtE,MAAMmT,UAAU,GAAG,IAAI,CAACZ,cAAc,CAACvS,UAAU,CAAC;MAClD,MAAMoU,UAAU,GAAGjB,UAAU,CAACkB,QAAQ,CAAC,CAAC;MACxC,MAAM7B,QAAQ,GAAG,IAAI,CAAC/Z,OAAO,CAACoL,cAAc,CAAC7D,UAAU,CAAC;MACxD,IAAIyT,UAAU,GAAGW,UAAU,GAAG,CAAC;MAC/B,IAAIoB,iBAAiB,GAAGhD,QAAQ,CAACxc,MAAM;MACvC,IAAI2f,eAAe,GAAGnD,QAAQ,CAACxc,MAAM;MACrC,IAAIgK,UAAU,KAAKqC,QAAQ,CAACrC,UAAU,EAAE;QACpCyT,UAAU,GAAGN,UAAU,CAACE,sBAAsB,CAAChR,QAAQ,CAACE,MAAM,GAAG,CAAC,CAAC;QACnEiT,iBAAiB,GAAGnT,QAAQ,CAACE,MAAM,GAAG,CAAC;QACvCoT,eAAe,GAAGtT,QAAQ,CAACE,MAAM,GAAG,CAAC;MACzC;MACA,IAAI8U,iBAAiB,GAAG,IAAI;MAC5B,OAAO5D,UAAU,IAAI,CAAC,EAAEA,UAAU,EAAE,EAAE;QAClC,MAAM6D,aAAa,GAAInE,UAAU,CAACC,aAAa,CAACK,UAAU,CAAC,KAAKS,UAAU,IAAI,CAAClgB,qBAAqB,CAACmf,UAAU,CAACoC,oBAAoB,CAAC9B,UAAU,CAAC,CAAE;QAClJ,IAAI6D,aAAa,EAAE;UACf;UACA,IAAID,iBAAiB,EAAE;YACnB;YACA7B,iBAAiB,GAAGrC,UAAU,CAACgB,cAAc,CAACV,UAAU,CAAC;UAC7D,CAAC,MACI;YACD;YACA+B,iBAAiB,GAAGrC,UAAU,CAACgB,cAAc,CAACV,UAAU,CAAC;YACzDkC,eAAe,GAAGxC,UAAU,CAACmB,YAAY,CAACb,UAAU,CAAC;UACzD;QACJ,CAAC,MACI;UACD;UACA,IAAI4D,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;YAC5D,MAAMM,CAAC,GAAGiB,gCAAgC,CAAClX,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;YACpG,IAAIM,CAAC,EAAE;cACH,OAAOA,CAAC;YACZ;UACJ;QACJ;QACAoB,iBAAiB,GAAGC,aAAa;MACrC;MACA,IAAID,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;QAC5D,MAAMM,CAAC,GAAGiB,gCAAgC,CAAClX,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;QACpG,IAAIM,CAAC,EAAE;UACH,OAAOA,CAAC;QACZ;MACJ;IACJ;IACA,OAAO,IAAI;EACf;EACAW,wBAAwBA,CAAC/B,OAAO,EAAExS,QAAQ,EAAEqU,uBAAuB,EAAE;IACjE;IACA,MAAMxC,UAAU,GAAGW,OAAO,CAACne,kBAAkB,CAACuB,EAAE;IAChD,MAAMsf,YAAY,GAAG1C,OAAO,CAACkB,YAAY;IACzC,IAAIiB,KAAK,GAAG,CAAC;IACb,IAAIC,cAAc,GAAG,CAAC;IACtB,MAAMO,gCAAgC,GAAGA,CAACxX,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,KAAK;MACnG,OAAO,IAAI,EAAE;QACT,IAAIe,uBAAuB,IAAK,EAAEO,cAAc,GAAI,GAAG,KAAK,CAAC,IAAI,CAACP,uBAAuB,CAAC,CAAC,EAAE;UACzF,OAAOvgB,qBAAqB,CAACG,QAAQ;QACzC;QACA,MAAM2f,CAAC,GAAGhiB,aAAa,CAAC6hB,sBAAsB,CAACyB,YAAY,EAAEvX,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;QACtH,IAAI,CAACM,CAAC,EAAE;UACJ;QACJ;QACA,MAAMkB,OAAO,GAAG3E,QAAQ,CAACnR,SAAS,CAAC4U,CAAC,CAACjX,WAAW,GAAG,CAAC,EAAEiX,CAAC,CAACxY,SAAS,GAAG,CAAC,CAAC,CAACqX,WAAW,CAAC,CAAC;QACpF,IAAID,OAAO,CAAC4B,MAAM,CAACU,OAAO,CAAC,EAAE;UACzBH,KAAK,EAAE;QACX,CAAC,MACI,IAAInC,OAAO,CAACuC,OAAO,CAACD,OAAO,CAAC,EAAE;UAC/BH,KAAK,EAAE;QACX;QACA,IAAIA,KAAK,KAAK,CAAC,EAAE;UACb,OAAOf,CAAC;QACZ;QACAT,iBAAiB,GAAGS,CAAC,CAACxY,SAAS,GAAG,CAAC;MACvC;MACA,OAAO,IAAI;IACf,CAAC;IACD,MAAMsC,SAAS,GAAG,IAAI,CAACjH,YAAY,CAAC,CAAC;IACrC,KAAK,IAAIkH,UAAU,GAAGqC,QAAQ,CAACrC,UAAU,EAAEA,UAAU,IAAID,SAAS,EAAEC,UAAU,EAAE,EAAE;MAC9E,MAAMmT,UAAU,GAAG,IAAI,CAACZ,cAAc,CAACvS,UAAU,CAAC;MAClD,MAAMoU,UAAU,GAAGjB,UAAU,CAACkB,QAAQ,CAAC,CAAC;MACxC,MAAM7B,QAAQ,GAAG,IAAI,CAAC/Z,OAAO,CAACoL,cAAc,CAAC7D,UAAU,CAAC;MACxD,IAAIyT,UAAU,GAAG,CAAC;MAClB,IAAI+B,iBAAiB,GAAG,CAAC;MACzB,IAAIG,eAAe,GAAG,CAAC;MACvB,IAAI3V,UAAU,KAAKqC,QAAQ,CAACrC,UAAU,EAAE;QACpCyT,UAAU,GAAGN,UAAU,CAACE,sBAAsB,CAAChR,QAAQ,CAACE,MAAM,GAAG,CAAC,CAAC;QACnEiT,iBAAiB,GAAGnT,QAAQ,CAACE,MAAM,GAAG,CAAC;QACvCoT,eAAe,GAAGtT,QAAQ,CAACE,MAAM,GAAG,CAAC;MACzC;MACA,IAAI8U,iBAAiB,GAAG,IAAI;MAC5B,OAAO5D,UAAU,GAAGW,UAAU,EAAEX,UAAU,EAAE,EAAE;QAC1C,MAAM6D,aAAa,GAAInE,UAAU,CAACC,aAAa,CAACK,UAAU,CAAC,KAAKS,UAAU,IAAI,CAAClgB,qBAAqB,CAACmf,UAAU,CAACoC,oBAAoB,CAAC9B,UAAU,CAAC,CAAE;QAClJ,IAAI6D,aAAa,EAAE;UACf;UACA,IAAID,iBAAiB,EAAE;YACnB;YACA1B,eAAe,GAAGxC,UAAU,CAACmB,YAAY,CAACb,UAAU,CAAC;UACzD,CAAC,MACI;YACD;YACA+B,iBAAiB,GAAGrC,UAAU,CAACgB,cAAc,CAACV,UAAU,CAAC;YACzDkC,eAAe,GAAGxC,UAAU,CAACmB,YAAY,CAACb,UAAU,CAAC;UACzD;QACJ,CAAC,MACI;UACD;UACA,IAAI4D,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;YAC5D,MAAMM,CAAC,GAAGuB,gCAAgC,CAACxX,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;YACpG,IAAIM,CAAC,EAAE;cACH,OAAOA,CAAC;YACZ;UACJ;QACJ;QACAoB,iBAAiB,GAAGC,aAAa;MACrC;MACA,IAAID,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;QAC5D,MAAMM,CAAC,GAAGuB,gCAAgC,CAACxX,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;QACpG,IAAIM,CAAC,EAAE;UACH,OAAOA,CAAC;QACZ;MACJ;IACJ;IACA,OAAO,IAAI;EACf;EACAwB,eAAeA,CAAClE,SAAS,EAAE;IACvB,MAAMlR,QAAQ,GAAG,IAAI,CAAC6C,gBAAgB,CAACqO,SAAS,CAAC;IACjD,IAAIW,UAAU,GAAG,CAAC,CAAC;IACnB,IAAIwD,YAAY,GAAG,IAAI;IACvB,KAAK,IAAI1X,UAAU,GAAGqC,QAAQ,CAACrC,UAAU,EAAEA,UAAU,IAAI,CAAC,EAAEA,UAAU,EAAE,EAAE;MACtE,MAAMmT,UAAU,GAAG,IAAI,CAACZ,cAAc,CAACvS,UAAU,CAAC;MAClD,MAAMoU,UAAU,GAAGjB,UAAU,CAACkB,QAAQ,CAAC,CAAC;MACxC,MAAM7B,QAAQ,GAAG,IAAI,CAAC/Z,OAAO,CAACoL,cAAc,CAAC7D,UAAU,CAAC;MACxD,IAAIyT,UAAU,GAAGW,UAAU,GAAG,CAAC;MAC/B,IAAIoB,iBAAiB,GAAGhD,QAAQ,CAACxc,MAAM;MACvC,IAAI2f,eAAe,GAAGnD,QAAQ,CAACxc,MAAM;MACrC,IAAIgK,UAAU,KAAKqC,QAAQ,CAACrC,UAAU,EAAE;QACpCyT,UAAU,GAAGN,UAAU,CAACE,sBAAsB,CAAChR,QAAQ,CAACE,MAAM,GAAG,CAAC,CAAC;QACnEiT,iBAAiB,GAAGnT,QAAQ,CAACE,MAAM,GAAG,CAAC;QACvCoT,eAAe,GAAGtT,QAAQ,CAACE,MAAM,GAAG,CAAC;QACrC,MAAMoV,eAAe,GAAGxE,UAAU,CAACC,aAAa,CAACK,UAAU,CAAC;QAC5D,IAAIS,UAAU,KAAKyD,eAAe,EAAE;UAChCzD,UAAU,GAAGyD,eAAe;UAC5BD,YAAY,GAAG5jB,6BAA6B,CAACkhB,kBAAkB,CAACd,UAAU,CAAC;QAC/E;MACJ;MACA,IAAImD,iBAAiB,GAAG,IAAI;MAC5B,OAAO5D,UAAU,IAAI,CAAC,EAAEA,UAAU,EAAE,EAAE;QAClC,MAAMkE,eAAe,GAAGxE,UAAU,CAACC,aAAa,CAACK,UAAU,CAAC;QAC5D,IAAIS,UAAU,KAAKyD,eAAe,EAAE;UAChC;UACA,IAAID,YAAY,IAAIL,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;YAC5E,MAAMM,CAAC,GAAGhiB,aAAa,CAACsiB,sBAAsB,CAACmB,YAAY,CAAClB,aAAa,EAAExW,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;YACpI,IAAIM,CAAC,EAAE;cACH,OAAO,IAAI,CAAC2B,eAAe,CAACF,YAAY,EAAEzB,CAAC,CAAC;YAChD;YACAoB,iBAAiB,GAAG,KAAK;UAC7B;UACAnD,UAAU,GAAGyD,eAAe;UAC5BD,YAAY,GAAG5jB,6BAA6B,CAACkhB,kBAAkB,CAACd,UAAU,CAAC;QAC/E;QACA,MAAMoD,aAAa,GAAI,CAAC,CAACI,YAAY,IAAI,CAAC1jB,qBAAqB,CAACmf,UAAU,CAACoC,oBAAoB,CAAC9B,UAAU,CAAC,CAAE;QAC7G,IAAI6D,aAAa,EAAE;UACf;UACA,IAAID,iBAAiB,EAAE;YACnB;YACA7B,iBAAiB,GAAGrC,UAAU,CAACgB,cAAc,CAACV,UAAU,CAAC;UAC7D,CAAC,MACI;YACD;YACA+B,iBAAiB,GAAGrC,UAAU,CAACgB,cAAc,CAACV,UAAU,CAAC;YACzDkC,eAAe,GAAGxC,UAAU,CAACmB,YAAY,CAACb,UAAU,CAAC;UACzD;QACJ,CAAC,MACI;UACD;UACA,IAAIiE,YAAY,IAAIL,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;YAC5E,MAAMM,CAAC,GAAGhiB,aAAa,CAACsiB,sBAAsB,CAACmB,YAAY,CAAClB,aAAa,EAAExW,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;YACpI,IAAIM,CAAC,EAAE;cACH,OAAO,IAAI,CAAC2B,eAAe,CAACF,YAAY,EAAEzB,CAAC,CAAC;YAChD;UACJ;QACJ;QACAoB,iBAAiB,GAAGC,aAAa;MACrC;MACA,IAAII,YAAY,IAAIL,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;QAC5E,MAAMM,CAAC,GAAGhiB,aAAa,CAACsiB,sBAAsB,CAACmB,YAAY,CAAClB,aAAa,EAAExW,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;QACpI,IAAIM,CAAC,EAAE;UACH,OAAO,IAAI,CAAC2B,eAAe,CAACF,YAAY,EAAEzB,CAAC,CAAC;QAChD;MACJ;IACJ;IACA,OAAO,IAAI;EACf;EACA4B,eAAeA,CAACtE,SAAS,EAAE;IACvB,MAAMlR,QAAQ,GAAG,IAAI,CAAC6C,gBAAgB,CAACqO,SAAS,CAAC;IACjD,MAAMxT,SAAS,GAAG,IAAI,CAACjH,YAAY,CAAC,CAAC;IACrC,IAAIob,UAAU,GAAG,CAAC,CAAC;IACnB,IAAIwD,YAAY,GAAG,IAAI;IACvB,KAAK,IAAI1X,UAAU,GAAGqC,QAAQ,CAACrC,UAAU,EAAEA,UAAU,IAAID,SAAS,EAAEC,UAAU,EAAE,EAAE;MAC9E,MAAMmT,UAAU,GAAG,IAAI,CAACZ,cAAc,CAACvS,UAAU,CAAC;MAClD,MAAMoU,UAAU,GAAGjB,UAAU,CAACkB,QAAQ,CAAC,CAAC;MACxC,MAAM7B,QAAQ,GAAG,IAAI,CAAC/Z,OAAO,CAACoL,cAAc,CAAC7D,UAAU,CAAC;MACxD,IAAIyT,UAAU,GAAG,CAAC;MAClB,IAAI+B,iBAAiB,GAAG,CAAC;MACzB,IAAIG,eAAe,GAAG,CAAC;MACvB,IAAI3V,UAAU,KAAKqC,QAAQ,CAACrC,UAAU,EAAE;QACpCyT,UAAU,GAAGN,UAAU,CAACE,sBAAsB,CAAChR,QAAQ,CAACE,MAAM,GAAG,CAAC,CAAC;QACnEiT,iBAAiB,GAAGnT,QAAQ,CAACE,MAAM,GAAG,CAAC;QACvCoT,eAAe,GAAGtT,QAAQ,CAACE,MAAM,GAAG,CAAC;QACrC,MAAMoV,eAAe,GAAGxE,UAAU,CAACC,aAAa,CAACK,UAAU,CAAC;QAC5D,IAAIS,UAAU,KAAKyD,eAAe,EAAE;UAChCzD,UAAU,GAAGyD,eAAe;UAC5BD,YAAY,GAAG5jB,6BAA6B,CAACkhB,kBAAkB,CAACd,UAAU,CAAC;QAC/E;MACJ;MACA,IAAImD,iBAAiB,GAAG,IAAI;MAC5B,OAAO5D,UAAU,GAAGW,UAAU,EAAEX,UAAU,EAAE,EAAE;QAC1C,MAAMkE,eAAe,GAAGxE,UAAU,CAACC,aAAa,CAACK,UAAU,CAAC;QAC5D,IAAIS,UAAU,KAAKyD,eAAe,EAAE;UAChC;UACA,IAAID,YAAY,IAAIL,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;YAC5E,MAAMM,CAAC,GAAGhiB,aAAa,CAAC6hB,sBAAsB,CAAC4B,YAAY,CAAC3B,YAAY,EAAE/V,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;YACnI,IAAIM,CAAC,EAAE;cACH,OAAO,IAAI,CAAC2B,eAAe,CAACF,YAAY,EAAEzB,CAAC,CAAC;YAChD;YACAoB,iBAAiB,GAAG,KAAK;UAC7B;UACAnD,UAAU,GAAGyD,eAAe;UAC5BD,YAAY,GAAG5jB,6BAA6B,CAACkhB,kBAAkB,CAACd,UAAU,CAAC;QAC/E;QACA,MAAMoD,aAAa,GAAI,CAAC,CAACI,YAAY,IAAI,CAAC1jB,qBAAqB,CAACmf,UAAU,CAACoC,oBAAoB,CAAC9B,UAAU,CAAC,CAAE;QAC7G,IAAI6D,aAAa,EAAE;UACf;UACA,IAAID,iBAAiB,EAAE;YACnB;YACA1B,eAAe,GAAGxC,UAAU,CAACmB,YAAY,CAACb,UAAU,CAAC;UACzD,CAAC,MACI;YACD;YACA+B,iBAAiB,GAAGrC,UAAU,CAACgB,cAAc,CAACV,UAAU,CAAC;YACzDkC,eAAe,GAAGxC,UAAU,CAACmB,YAAY,CAACb,UAAU,CAAC;UACzD;QACJ,CAAC,MACI;UACD;UACA,IAAIiE,YAAY,IAAIL,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;YAC5E,MAAMM,CAAC,GAAGhiB,aAAa,CAAC6hB,sBAAsB,CAAC4B,YAAY,CAAC3B,YAAY,EAAE/V,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;YACnI,IAAIM,CAAC,EAAE;cACH,OAAO,IAAI,CAAC2B,eAAe,CAACF,YAAY,EAAEzB,CAAC,CAAC;YAChD;UACJ;QACJ;QACAoB,iBAAiB,GAAGC,aAAa;MACrC;MACA,IAAII,YAAY,IAAIL,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;QAC5E,MAAMM,CAAC,GAAGhiB,aAAa,CAAC6hB,sBAAsB,CAAC4B,YAAY,CAAC3B,YAAY,EAAE/V,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;QACnI,IAAIM,CAAC,EAAE;UACH,OAAO,IAAI,CAAC2B,eAAe,CAACF,YAAY,EAAEzB,CAAC,CAAC;QAChD;MACJ;IACJ;IACA,OAAO,IAAI;EACf;EACA6B,qBAAqBA,CAACvE,SAAS,EAAEwE,WAAW,EAAE;IAC1C,IAAIrB,uBAAuB;IAC3B,IAAI,OAAOqB,WAAW,KAAK,WAAW,EAAE;MACpCrB,uBAAuB,GAAG,IAAI;IAClC,CAAC,MACI;MACD,MAAMsB,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;MAC5BxB,uBAAuB,GAAGA,CAAA,KAAM;QAC5B,OAAQuB,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,SAAS,IAAID,WAAW;MACjD,CAAC;IACL;IACA,MAAM1V,QAAQ,GAAG,IAAI,CAAC6C,gBAAgB,CAACqO,SAAS,CAAC;IACjD,MAAMxT,SAAS,GAAG,IAAI,CAACjH,YAAY,CAAC,CAAC;IACrC,MAAMqf,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC7B,IAAIC,MAAM,GAAG,EAAE;IACf,MAAMC,WAAW,GAAGA,CAACpE,UAAU,EAAEwD,YAAY,KAAK;MAC9C,IAAI,CAACS,WAAW,CAACI,GAAG,CAACrE,UAAU,CAAC,EAAE;QAC9B,IAAIpe,GAAG,GAAG,EAAE;QACZ,KAAK,IAAIyI,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGkZ,YAAY,GAAGA,YAAY,CAACc,QAAQ,CAACxiB,MAAM,GAAG,CAAC,EAAEuI,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;UACjFzI,GAAG,CAACyI,CAAC,CAAC,GAAG,CAAC;QACd;QACA4Z,WAAW,CAACzG,GAAG,CAACwC,UAAU,EAAEpe,GAAG,CAAC;MACpC;MACAuiB,MAAM,GAAGF,WAAW,CAACM,GAAG,CAACvE,UAAU,CAAC;IACxC,CAAC;IACD,IAAI+C,cAAc,GAAG,CAAC;IACtB,MAAMyB,aAAa,GAAGA,CAAChB,YAAY,EAAE1X,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,KAAK;MAC9F,OAAO,IAAI,EAAE;QACT,IAAIe,uBAAuB,IAAK,EAAEO,cAAc,GAAI,GAAG,KAAK,CAAC,IAAI,CAACP,uBAAuB,CAAC,CAAC,EAAE;UACzF,OAAOvgB,qBAAqB,CAACG,QAAQ;QACzC;QACA,MAAM2f,CAAC,GAAGhiB,aAAa,CAAC6hB,sBAAsB,CAAC4B,YAAY,CAAC3B,YAAY,EAAE/V,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;QACnI,IAAI,CAACM,CAAC,EAAE;UACJ;QACJ;QACA,MAAMkB,OAAO,GAAG3E,QAAQ,CAACnR,SAAS,CAAC4U,CAAC,CAACjX,WAAW,GAAG,CAAC,EAAEiX,CAAC,CAACxY,SAAS,GAAG,CAAC,CAAC,CAACqX,WAAW,CAAC,CAAC;QACpF,MAAMD,OAAO,GAAG6C,YAAY,CAACxC,aAAa,CAACiC,OAAO,CAAC;QACnD,IAAItC,OAAO,EAAE;UACT,IAAIA,OAAO,CAAC4B,MAAM,CAACU,OAAO,CAAC,EAAE;YACzBkB,MAAM,CAACxD,OAAO,CAAC8D,KAAK,CAAC,EAAE;UAC3B,CAAC,MACI,IAAI9D,OAAO,CAACuC,OAAO,CAACD,OAAO,CAAC,EAAE;YAC/BkB,MAAM,CAACxD,OAAO,CAAC8D,KAAK,CAAC,EAAE;UAC3B;UACA,IAAIN,MAAM,CAACxD,OAAO,CAAC8D,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;YAC9B,OAAO,IAAI,CAACzC,kBAAkB,CAACD,CAAC,EAAEpB,OAAO,EAAE,KAAK,EAAE6B,uBAAuB,CAAC;UAC9E;QACJ;QACAlB,iBAAiB,GAAGS,CAAC,CAACxY,SAAS,GAAG,CAAC;MACvC;MACA,OAAO,IAAI;IACf,CAAC;IACD,IAAIyW,UAAU,GAAG,CAAC,CAAC;IACnB,IAAIwD,YAAY,GAAG,IAAI;IACvB,KAAK,IAAI1X,UAAU,GAAGqC,QAAQ,CAACrC,UAAU,EAAEA,UAAU,IAAID,SAAS,EAAEC,UAAU,EAAE,EAAE;MAC9E,MAAMmT,UAAU,GAAG,IAAI,CAACZ,cAAc,CAACvS,UAAU,CAAC;MAClD,MAAMoU,UAAU,GAAGjB,UAAU,CAACkB,QAAQ,CAAC,CAAC;MACxC,MAAM7B,QAAQ,GAAG,IAAI,CAAC/Z,OAAO,CAACoL,cAAc,CAAC7D,UAAU,CAAC;MACxD,IAAIyT,UAAU,GAAG,CAAC;MAClB,IAAI+B,iBAAiB,GAAG,CAAC;MACzB,IAAIG,eAAe,GAAG,CAAC;MACvB,IAAI3V,UAAU,KAAKqC,QAAQ,CAACrC,UAAU,EAAE;QACpCyT,UAAU,GAAGN,UAAU,CAACE,sBAAsB,CAAChR,QAAQ,CAACE,MAAM,GAAG,CAAC,CAAC;QACnEiT,iBAAiB,GAAGnT,QAAQ,CAACE,MAAM,GAAG,CAAC;QACvCoT,eAAe,GAAGtT,QAAQ,CAACE,MAAM,GAAG,CAAC;QACrC,MAAMoV,eAAe,GAAGxE,UAAU,CAACC,aAAa,CAACK,UAAU,CAAC;QAC5D,IAAIS,UAAU,KAAKyD,eAAe,EAAE;UAChCzD,UAAU,GAAGyD,eAAe;UAC5BD,YAAY,GAAG5jB,6BAA6B,CAACkhB,kBAAkB,CAACd,UAAU,CAAC;UAC3EoE,WAAW,CAACpE,UAAU,EAAEwD,YAAY,CAAC;QACzC;MACJ;MACA,IAAIL,iBAAiB,GAAG,IAAI;MAC5B,OAAO5D,UAAU,GAAGW,UAAU,EAAEX,UAAU,EAAE,EAAE;QAC1C,MAAMkE,eAAe,GAAGxE,UAAU,CAACC,aAAa,CAACK,UAAU,CAAC;QAC5D,IAAIS,UAAU,KAAKyD,eAAe,EAAE;UAChC;UACA,IAAID,YAAY,IAAIL,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;YAC5E,MAAMM,CAAC,GAAGyC,aAAa,CAAChB,YAAY,EAAE1X,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;YAC/F,IAAIM,CAAC,EAAE;cACH,OAAO1f,0BAA0B,CAAC0f,CAAC,CAAC;YACxC;YACAoB,iBAAiB,GAAG,KAAK;UAC7B;UACAnD,UAAU,GAAGyD,eAAe;UAC5BD,YAAY,GAAG5jB,6BAA6B,CAACkhB,kBAAkB,CAACd,UAAU,CAAC;UAC3EoE,WAAW,CAACpE,UAAU,EAAEwD,YAAY,CAAC;QACzC;QACA,MAAMJ,aAAa,GAAI,CAAC,CAACI,YAAY,IAAI,CAAC1jB,qBAAqB,CAACmf,UAAU,CAACoC,oBAAoB,CAAC9B,UAAU,CAAC,CAAE;QAC7G,IAAI6D,aAAa,EAAE;UACf;UACA,IAAID,iBAAiB,EAAE;YACnB;YACA1B,eAAe,GAAGxC,UAAU,CAACmB,YAAY,CAACb,UAAU,CAAC;UACzD,CAAC,MACI;YACD;YACA+B,iBAAiB,GAAGrC,UAAU,CAACgB,cAAc,CAACV,UAAU,CAAC;YACzDkC,eAAe,GAAGxC,UAAU,CAACmB,YAAY,CAACb,UAAU,CAAC;UACzD;QACJ,CAAC,MACI;UACD;UACA,IAAIiE,YAAY,IAAIL,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;YAC5E,MAAMM,CAAC,GAAGyC,aAAa,CAAChB,YAAY,EAAE1X,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;YAC/F,IAAIM,CAAC,EAAE;cACH,OAAO1f,0BAA0B,CAAC0f,CAAC,CAAC;YACxC;UACJ;QACJ;QACAoB,iBAAiB,GAAGC,aAAa;MACrC;MACA,IAAII,YAAY,IAAIL,iBAAiB,IAAI7B,iBAAiB,KAAKG,eAAe,EAAE;QAC5E,MAAMM,CAAC,GAAGyC,aAAa,CAAChB,YAAY,EAAE1X,UAAU,EAAEwS,QAAQ,EAAEgD,iBAAiB,EAAEG,eAAe,CAAC;QAC/F,IAAIM,CAAC,EAAE;UACH,OAAO1f,0BAA0B,CAAC0f,CAAC,CAAC;QACxC;MACJ;IACJ;IACA,OAAO,IAAI;EACf;EACA2B,eAAeA,CAACF,YAAY,EAAEzB,CAAC,EAAE;IAC7B,IAAI,CAACA,CAAC,EAAE;MACJ,OAAO,IAAI;IACf;IACA,IAAIxhB,IAAI,GAAG,IAAI,CAAC6O,eAAe,CAAC2S,CAAC,CAAC;IAClCxhB,IAAI,GAAGA,IAAI,CAACqgB,WAAW,CAAC,CAAC;IACzB,IAAIG,IAAI,GAAGyC,YAAY,CAACxC,aAAa,CAACzgB,IAAI,CAAC;IAC3C,IAAI,CAACwgB,IAAI,EAAE;MACP,OAAO,IAAI;IACf;IACA,OAAO;MACHxY,KAAK,EAAEwZ,CAAC;MACR2C,IAAI,EAAE3D,IAAI,CAAC2D,IAAI;MACfC,KAAK,EAAE5D,IAAI,CAAC4D,KAAK;MACjBpC,MAAM,EAAEiB,YAAY,CAACvB,iBAAiB,CAAC1hB,IAAI;IAC/C,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;EACI,OAAOqkB,kBAAkBA,CAACC,IAAI,EAAE5d,OAAO,EAAE;IACrC,IAAI6d,MAAM,GAAG,CAAC;IACd,IAAIza,CAAC,GAAG,CAAC;IACT,IAAIC,GAAG,GAAGua,IAAI,CAAC/iB,MAAM;IACrB,OAAOuI,CAAC,GAAGC,GAAG,EAAE;MACZ,IAAIya,MAAM,GAAGF,IAAI,CAAChN,UAAU,CAACxN,CAAC,CAAC;MAC/B,IAAI0a,MAAM,KAAK,EAAE,CAAC,aAAa;QAC3BD,MAAM,EAAE;MACZ,CAAC,MACI,IAAIC,MAAM,KAAK,CAAC,CAAC,WAAW;QAC7BD,MAAM,GAAGA,MAAM,GAAGA,MAAM,GAAG7d,OAAO,GAAGA,OAAO;MAChD,CAAC,MACI;QACD;MACJ;MACAoD,CAAC,EAAE;IACP;IACA,IAAIA,CAAC,KAAKC,GAAG,EAAE;MACX,OAAO,CAAC,CAAC,CAAC,CAAC;IACf;;IACA,OAAOwa,MAAM;EACjB;EACAE,mBAAmBA,CAACC,SAAS,EAAE;IAC3B,OAAO3iB,SAAS,CAACsiB,kBAAkB,CAAC,IAAI,CAACrgB,OAAO,CAACoL,cAAc,CAACsV,SAAS,GAAG,CAAC,CAAC,EAAE,IAAI,CAACxgB,QAAQ,CAACwC,OAAO,CAAC;EAC1G;EACAie,oBAAoBA,CAACpZ,UAAU,EAAEqZ,aAAa,EAAEC,aAAa,EAAE;IAC3D,IAAI,CAACpd,kBAAkB,CAAC,CAAC;IACzB,MAAM6D,SAAS,GAAG,IAAI,CAACjH,YAAY,CAAC,CAAC;IACrC,IAAIkH,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAGD,SAAS,EAAE;MAC1C,MAAM,IAAI7J,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,MAAMqjB,YAAY,GAAGzlB,6BAA6B,CAAC0lB,eAAe,CAAC,IAAI,CAAC3f,mBAAmB,CAAC5B,EAAE,CAAC;IAC/F,MAAMwhB,OAAO,GAAGC,OAAO,CAACH,YAAY,IAAIA,YAAY,CAACE,OAAO,CAAC;IAC7D,IAAIE,wBAAwB,GAAG,CAAC,CAAC,CAAC,CAAC;IACnC,IAAIC,yBAAyB,GAAG,CAAC,CAAC;IAClC,IAAIC,wBAAwB,GAAG,CAAC,CAAC,CAAC,CAAC;IACnC,IAAIC,yBAAyB,GAAG,CAAC,CAAC;IAClC,MAAMC,iBAAiB,GAAI/Z,UAAU,IAAK;MACtC,IAAI2Z,wBAAwB,KAAK,CAAC,CAAC,KAAKA,wBAAwB,KAAK,CAAC,CAAC,IAAIA,wBAAwB,GAAG3Z,UAAU,GAAG,CAAC,CAAC,EAAE;QACnH2Z,wBAAwB,GAAG,CAAC,CAAC;QAC7BC,yBAAyB,GAAG,CAAC,CAAC;QAC9B;QACA,KAAK,IAAIT,SAAS,GAAGnZ,UAAU,GAAG,CAAC,EAAEmZ,SAAS,IAAI,CAAC,EAAEA,SAAS,EAAE,EAAE;UAC9D,IAAIH,MAAM,GAAG,IAAI,CAACE,mBAAmB,CAACC,SAAS,CAAC;UAChD,IAAIH,MAAM,IAAI,CAAC,EAAE;YACbW,wBAAwB,GAAGR,SAAS;YACpCS,yBAAyB,GAAGZ,MAAM;YAClC;UACJ;QACJ;MACJ;MACA,IAAIa,wBAAwB,KAAK,CAAC,CAAC,EAAE;QACjCA,wBAAwB,GAAG,CAAC,CAAC;QAC7BC,yBAAyB,GAAG,CAAC,CAAC;QAC9B;QACA,KAAK,IAAIX,SAAS,GAAGnZ,UAAU,EAAEmZ,SAAS,GAAGpZ,SAAS,EAAEoZ,SAAS,EAAE,EAAE;UACjE,IAAIH,MAAM,GAAG,IAAI,CAACE,mBAAmB,CAACC,SAAS,CAAC;UAChD,IAAIH,MAAM,IAAI,CAAC,EAAE;YACba,wBAAwB,GAAGV,SAAS;YACpCW,yBAAyB,GAAGd,MAAM;YAClC;UACJ;QACJ;MACJ;IACJ,CAAC;IACD,IAAIgB,0BAA0B,GAAG,CAAC,CAAC,CAAC,CAAC;IACrC,IAAIC,2BAA2B,GAAG,CAAC,CAAC;IACpC,IAAIC,0BAA0B,GAAG,CAAC,CAAC,CAAC,CAAC;IACrC,IAAIC,2BAA2B,GAAG,CAAC,CAAC;IACpC,MAAMC,mBAAmB,GAAIpa,UAAU,IAAK;MACxC,IAAIga,0BAA0B,KAAK,CAAC,CAAC,EAAE;QACnCA,0BAA0B,GAAG,CAAC,CAAC;QAC/BC,2BAA2B,GAAG,CAAC,CAAC;QAChC;QACA,KAAK,IAAId,SAAS,GAAGnZ,UAAU,GAAG,CAAC,EAAEmZ,SAAS,IAAI,CAAC,EAAEA,SAAS,EAAE,EAAE;UAC9D,IAAIH,MAAM,GAAG,IAAI,CAACE,mBAAmB,CAACC,SAAS,CAAC;UAChD,IAAIH,MAAM,IAAI,CAAC,EAAE;YACbgB,0BAA0B,GAAGb,SAAS;YACtCc,2BAA2B,GAAGjB,MAAM;YACpC;UACJ;QACJ;MACJ;MACA,IAAIkB,0BAA0B,KAAK,CAAC,CAAC,KAAKA,0BAA0B,KAAK,CAAC,CAAC,IAAIA,0BAA0B,GAAGla,UAAU,GAAG,CAAC,CAAC,EAAE;QACzHka,0BAA0B,GAAG,CAAC,CAAC;QAC/BC,2BAA2B,GAAG,CAAC,CAAC;QAChC;QACA,KAAK,IAAIhB,SAAS,GAAGnZ,UAAU,EAAEmZ,SAAS,GAAGpZ,SAAS,EAAEoZ,SAAS,EAAE,EAAE;UACjE,IAAIH,MAAM,GAAG,IAAI,CAACE,mBAAmB,CAACC,SAAS,CAAC;UAChD,IAAIH,MAAM,IAAI,CAAC,EAAE;YACbkB,0BAA0B,GAAGf,SAAS;YACtCgB,2BAA2B,GAAGnB,MAAM;YACpC;UACJ;QACJ;MACJ;IACJ,CAAC;IACD,IAAIja,eAAe,GAAG,CAAC;IACvB,IAAIsb,IAAI,GAAG,IAAI;IACf,IAAI7c,aAAa,GAAG,CAAC;IACrB,IAAI8c,MAAM,GAAG,IAAI;IACjB,IAAItB,MAAM,GAAG,CAAC;IACd,IAAIuB,aAAa,GAAG,CAAC;IACrB,KAAK,IAAIC,QAAQ,GAAG,CAAC,EAAEH,IAAI,IAAIC,MAAM,EAAEE,QAAQ,EAAE,EAAE;MAC/C,MAAMC,YAAY,GAAGza,UAAU,GAAGwa,QAAQ;MAC1C,MAAME,cAAc,GAAG1a,UAAU,GAAGwa,QAAQ;MAC5C,IAAIA,QAAQ,GAAG,CAAC,KAAKC,YAAY,GAAG,CAAC,IAAIA,YAAY,GAAGpB,aAAa,CAAC,EAAE;QACpEgB,IAAI,GAAG,KAAK;MAChB;MACA,IAAIG,QAAQ,GAAG,CAAC,KAAKE,cAAc,GAAG3a,SAAS,IAAI2a,cAAc,GAAGpB,aAAa,CAAC,EAAE;QAChFgB,MAAM,GAAG,KAAK;MAClB;MACA,IAAIE,QAAQ,GAAG,KAAK,EAAE;QAClB;QACAH,IAAI,GAAG,KAAK;QACZC,MAAM,GAAG,KAAK;MAClB;MACA,IAAIK,iBAAiB,GAAG,CAAC,CAAC;MAC1B,IAAIN,IAAI,EAAE;QACN;QACA,MAAMO,aAAa,GAAG,IAAI,CAAC1B,mBAAmB,CAACuB,YAAY,GAAG,CAAC,CAAC;QAChE,IAAIG,aAAa,IAAI,CAAC,EAAE;UACpB;UACA;UACAf,wBAAwB,GAAGY,YAAY,GAAG,CAAC;UAC3CX,yBAAyB,GAAGc,aAAa;UACzCD,iBAAiB,GAAG1Z,IAAI,CAAC4Z,IAAI,CAACD,aAAa,GAAG,IAAI,CAACjiB,QAAQ,CAAC2C,UAAU,CAAC;QAC3E,CAAC,MACI;UACDye,iBAAiB,CAACU,YAAY,CAAC;UAC/BE,iBAAiB,GAAG,IAAI,CAACG,gCAAgC,CAACrB,OAAO,EAAEG,yBAAyB,EAAEE,yBAAyB,CAAC;QAC5H;MACJ;MACA,IAAIiB,mBAAmB,GAAG,CAAC,CAAC;MAC5B,IAAIT,MAAM,EAAE;QACR;QACA,MAAMM,aAAa,GAAG,IAAI,CAAC1B,mBAAmB,CAACwB,cAAc,GAAG,CAAC,CAAC;QAClE,IAAIE,aAAa,IAAI,CAAC,EAAE;UACpB;UACA;UACAZ,0BAA0B,GAAGU,cAAc,GAAG,CAAC;UAC/CT,2BAA2B,GAAGW,aAAa;UAC3CG,mBAAmB,GAAG9Z,IAAI,CAAC4Z,IAAI,CAACD,aAAa,GAAG,IAAI,CAACjiB,QAAQ,CAAC2C,UAAU,CAAC;QAC7E,CAAC,MACI;UACD8e,mBAAmB,CAACM,cAAc,CAAC;UACnCK,mBAAmB,GAAG,IAAI,CAACD,gCAAgC,CAACrB,OAAO,EAAEQ,2BAA2B,EAAEE,2BAA2B,CAAC;QAClI;MACJ;MACA,IAAIK,QAAQ,KAAK,CAAC,EAAE;QAChBD,aAAa,GAAGI,iBAAiB;QACjC;MACJ;MACA,IAAIH,QAAQ,KAAK,CAAC,EAAE;QAChB,IAAIE,cAAc,IAAI3a,SAAS,IAAIgb,mBAAmB,IAAI,CAAC,IAAIR,aAAa,GAAG,CAAC,KAAKQ,mBAAmB,EAAE;UACtG;UACA;UACAV,IAAI,GAAG,KAAK;UACZtb,eAAe,GAAG2b,cAAc;UAChCld,aAAa,GAAGkd,cAAc;UAC9B1B,MAAM,GAAG+B,mBAAmB;UAC5B;QACJ;QACA,IAAIN,YAAY,IAAI,CAAC,IAAIE,iBAAiB,IAAI,CAAC,IAAIA,iBAAiB,GAAG,CAAC,KAAKJ,aAAa,EAAE;UACxF;UACAD,MAAM,GAAG,KAAK;UACdvb,eAAe,GAAG0b,YAAY;UAC9Bjd,aAAa,GAAGid,YAAY;UAC5BzB,MAAM,GAAG2B,iBAAiB;UAC1B;QACJ;QACA5b,eAAe,GAAGiB,UAAU;QAC5BxC,aAAa,GAAGwC,UAAU;QAC1BgZ,MAAM,GAAGuB,aAAa;QACtB,IAAIvB,MAAM,KAAK,CAAC,EAAE;UACd;UACA,OAAO;YAAEja,eAAe;YAAEvB,aAAa;YAAEwb;UAAO,CAAC;QACrD;MACJ;MACA,IAAIqB,IAAI,EAAE;QACN,IAAIM,iBAAiB,IAAI3B,MAAM,EAAE;UAC7Bja,eAAe,GAAG0b,YAAY;QAClC,CAAC,MACI;UACDJ,IAAI,GAAG,KAAK;QAChB;MACJ;MACA,IAAIC,MAAM,EAAE;QACR,IAAIS,mBAAmB,IAAI/B,MAAM,EAAE;UAC/Bxb,aAAa,GAAGkd,cAAc;QAClC,CAAC,MACI;UACDJ,MAAM,GAAG,KAAK;QAClB;MACJ;IACJ;IACA,OAAO;MAAEvb,eAAe;MAAEvB,aAAa;MAAEwb;IAAO,CAAC;EACrD;EACAgC,oBAAoBA,CAACjc,eAAe,EAAEvB,aAAa,EAAE;IACjD,IAAI,CAACtB,kBAAkB,CAAC,CAAC;IACzB,MAAM6D,SAAS,GAAG,IAAI,CAACjH,YAAY,CAAC,CAAC;IACrC,IAAIiG,eAAe,GAAG,CAAC,IAAIA,eAAe,GAAGgB,SAAS,EAAE;MACpD,MAAM,IAAI7J,KAAK,CAAC,mCAAmC,CAAC;IACxD;IACA,IAAIsH,aAAa,GAAG,CAAC,IAAIA,aAAa,GAAGuC,SAAS,EAAE;MAChD,MAAM,IAAI7J,KAAK,CAAC,iCAAiC,CAAC;IACtD;IACA,MAAMqjB,YAAY,GAAGzlB,6BAA6B,CAAC0lB,eAAe,CAAC,IAAI,CAAC3f,mBAAmB,CAAC5B,EAAE,CAAC;IAC/F,MAAMwhB,OAAO,GAAGC,OAAO,CAACH,YAAY,IAAIA,YAAY,CAACE,OAAO,CAAC;IAC7D,IAAI9jB,MAAM,GAAG,IAAI2Q,KAAK,CAAC9I,aAAa,GAAGuB,eAAe,GAAG,CAAC,CAAC;IAC3D,IAAIkc,qBAAqB,GAAG,CAAC,CAAC,CAAC,CAAC;IAChC,IAAIC,sBAAsB,GAAG,CAAC,CAAC;IAC/B,IAAIC,qBAAqB,GAAG,CAAC,CAAC,CAAC,CAAC;IAChC,IAAIC,sBAAsB,GAAG,CAAC,CAAC;IAC/B,KAAK,IAAIpb,UAAU,GAAGjB,eAAe,EAAEiB,UAAU,IAAIxC,aAAa,EAAEwC,UAAU,EAAE,EAAE;MAC9E,IAAIqb,WAAW,GAAGrb,UAAU,GAAGjB,eAAe;MAC9C,MAAM6b,aAAa,GAAG,IAAI,CAAC1B,mBAAmB,CAAClZ,UAAU,GAAG,CAAC,CAAC;MAC9D,IAAI4a,aAAa,IAAI,CAAC,EAAE;QACpB;QACA;QACAK,qBAAqB,GAAGjb,UAAU,GAAG,CAAC;QACtCkb,sBAAsB,GAAGN,aAAa;QACtCjlB,MAAM,CAAC0lB,WAAW,CAAC,GAAGpa,IAAI,CAAC4Z,IAAI,CAACD,aAAa,GAAG,IAAI,CAACjiB,QAAQ,CAAC2C,UAAU,CAAC;QACzE;MACJ;MACA,IAAI2f,qBAAqB,KAAK,CAAC,CAAC,EAAE;QAC9BA,qBAAqB,GAAG,CAAC,CAAC;QAC1BC,sBAAsB,GAAG,CAAC,CAAC;QAC3B;QACA,KAAK,IAAI/B,SAAS,GAAGnZ,UAAU,GAAG,CAAC,EAAEmZ,SAAS,IAAI,CAAC,EAAEA,SAAS,EAAE,EAAE;UAC9D,IAAIH,MAAM,GAAG,IAAI,CAACE,mBAAmB,CAACC,SAAS,CAAC;UAChD,IAAIH,MAAM,IAAI,CAAC,EAAE;YACbiC,qBAAqB,GAAG9B,SAAS;YACjC+B,sBAAsB,GAAGlC,MAAM;YAC/B;UACJ;QACJ;MACJ;MACA,IAAImC,qBAAqB,KAAK,CAAC,CAAC,KAAKA,qBAAqB,KAAK,CAAC,CAAC,IAAIA,qBAAqB,GAAGnb,UAAU,GAAG,CAAC,CAAC,EAAE;QAC1Gmb,qBAAqB,GAAG,CAAC,CAAC;QAC1BC,sBAAsB,GAAG,CAAC,CAAC;QAC3B;QACA,KAAK,IAAIjC,SAAS,GAAGnZ,UAAU,EAAEmZ,SAAS,GAAGpZ,SAAS,EAAEoZ,SAAS,EAAE,EAAE;UACjE,IAAIH,MAAM,GAAG,IAAI,CAACE,mBAAmB,CAACC,SAAS,CAAC;UAChD,IAAIH,MAAM,IAAI,CAAC,EAAE;YACbmC,qBAAqB,GAAGhC,SAAS;YACjCiC,sBAAsB,GAAGpC,MAAM;YAC/B;UACJ;QACJ;MACJ;MACArjB,MAAM,CAAC0lB,WAAW,CAAC,GAAG,IAAI,CAACP,gCAAgC,CAACrB,OAAO,EAAEyB,sBAAsB,EAAEE,sBAAsB,CAAC;IACxH;IACA,OAAOzlB,MAAM;EACjB;EACAmlB,gCAAgCA,CAACrB,OAAO,EAAEyB,sBAAsB,EAAEE,sBAAsB,EAAE;IACtF,IAAIF,sBAAsB,KAAK,CAAC,CAAC,IAAIE,sBAAsB,KAAK,CAAC,CAAC,EAAE;MAChE;MACA,OAAO,CAAC;IACZ,CAAC,MACI,IAAIF,sBAAsB,GAAGE,sBAAsB,EAAE;MACtD;MACA,OAAQ,CAAC,GAAGna,IAAI,CAACC,KAAK,CAACga,sBAAsB,GAAG,IAAI,CAACviB,QAAQ,CAAC2C,UAAU,CAAC;IAC7E,CAAC,MACI,IAAI4f,sBAAsB,KAAKE,sBAAsB,EAAE;MACxD;MACA,OAAOna,IAAI,CAAC4Z,IAAI,CAACO,sBAAsB,GAAG,IAAI,CAACziB,QAAQ,CAAC2C,UAAU,CAAC;IACvE,CAAC,MACI;MACD,IAAIme,OAAO,EAAE;QACT;QACA,OAAOxY,IAAI,CAAC4Z,IAAI,CAACO,sBAAsB,GAAG,IAAI,CAACziB,QAAQ,CAAC2C,UAAU,CAAC;MACvE,CAAC,MACI;QACD;QACA,OAAQ,CAAC,GAAG2F,IAAI,CAACC,KAAK,CAACka,sBAAsB,GAAG,IAAI,CAACziB,QAAQ,CAAC2C,UAAU,CAAC;MAC7E;IACJ;EACJ;AACJ;AACA9E,SAAS,CAAC+C,gBAAgB,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC;AAC/C/C,SAAS,CAAC4C,yBAAyB,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC;AACxD5C,SAAS,CAAC6C,+BAA+B,GAAG,GAAG,GAAG,IAAI,CAAC,CAAC;AACxD7C,SAAS,CAAC8kB,wBAAwB,GAAG;EACjCpjB,iBAAiB,EAAE,KAAK;EACxBiD,OAAO,EAAE5I,qBAAqB,CAAC4I,OAAO;EACtCG,UAAU,EAAE/I,qBAAqB,CAAC+I,UAAU;EAC5CF,YAAY,EAAE7I,qBAAqB,CAAC6I,YAAY;EAChDH,iBAAiB,EAAE,KAAK;EACxBlG,UAAU,EAAE,CAAC,CAAC;EACdwG,kBAAkB,EAAEhJ,qBAAqB,CAACgJ,kBAAkB;EAC5DrC,sBAAsB,EAAE3G,qBAAqB,CAAC2G;AAClD,CAAC;AACD;AACA,MAAMsB,gBAAgB,CAAC;EACnBlF,WAAWA,CAAA,EAAG;IACV,IAAI,CAACimB,iBAAiB,GAAG,IAAIxoB,YAAY,CAAC,CAAC;IAC3C,IAAI,CAACyoB,iBAAiB,GAAG,IAAIzoB,YAAY,CAAC,CAAC;EAC/C;EACA+c,cAAcA,CAAClR,KAAK,EAAEQ,GAAG,EAAEyQ,aAAa,EAAEV,mBAAmB,EAAEhQ,eAAe,EAAE;IAC5E,MAAMsc,EAAE,GAAG,IAAI,CAACF,iBAAiB,CAACzL,cAAc,CAAClR,KAAK,EAAEQ,GAAG,EAAEyQ,aAAa,EAAEV,mBAAmB,EAAEhQ,eAAe,CAAC;IACjH,MAAMuc,EAAE,GAAG,IAAI,CAACF,iBAAiB,CAAC1L,cAAc,CAAClR,KAAK,EAAEQ,GAAG,EAAEyQ,aAAa,EAAEV,mBAAmB,EAAEhQ,eAAe,CAAC;IACjH,OAAOsc,EAAE,CAAC/T,MAAM,CAACgU,EAAE,CAAC;EACxB;EACAtd,MAAMA,CAACyR,aAAa,EAAEV,mBAAmB,EAAEwM,iBAAiB,EAAExc,eAAe,EAAE;IAC3E,IAAIwc,iBAAiB,EAAE;MACnB,OAAO,IAAI,CAACH,iBAAiB,CAACpd,MAAM,CAACyR,aAAa,EAAEV,mBAAmB,EAAEhQ,eAAe,CAAC;IAC7F,CAAC,MACI;MACD,MAAMsc,EAAE,GAAG,IAAI,CAACF,iBAAiB,CAACnd,MAAM,CAACyR,aAAa,EAAEV,mBAAmB,EAAEhQ,eAAe,CAAC;MAC7F,MAAMuc,EAAE,GAAG,IAAI,CAACF,iBAAiB,CAACpd,MAAM,CAACyR,aAAa,EAAEV,mBAAmB,EAAEhQ,eAAe,CAAC;MAC7F,OAAOsc,EAAE,CAAC/T,MAAM,CAACgU,EAAE,CAAC;IACxB;EACJ;EACA7M,qBAAqBA,CAAC1B,OAAO,EAAE;IAC3B,MAAMsO,EAAE,GAAG,IAAI,CAACF,iBAAiB,CAAC1M,qBAAqB,CAAC1B,OAAO,CAAC;IAChE,MAAMuO,EAAE,GAAG,IAAI,CAACF,iBAAiB,CAAC3M,qBAAqB,CAAC1B,OAAO,CAAC;IAChE,OAAOsO,EAAE,CAAC/T,MAAM,CAACgU,EAAE,CAAC;EACxB;EACApd,qBAAqBA,CAAA,EAAG;IACpB,MAAMmd,EAAE,GAAG,IAAI,CAACF,iBAAiB,CAACjd,qBAAqB,CAAC,CAAC;IACzD,MAAMod,EAAE,GAAG,IAAI,CAACF,iBAAiB,CAACld,qBAAqB,CAAC,CAAC;IACzD,OAAOmd,EAAE,CAAC/T,MAAM,CAACgU,EAAE,CAAC;EACxB;EACAhN,MAAMA,CAACjQ,IAAI,EAAE;IACT,IAAIzL,wBAAwB,CAACyL,IAAI,CAAC,EAAE;MAChC,IAAI,CAAC+c,iBAAiB,CAAC9M,MAAM,CAACjQ,IAAI,CAAC;IACvC,CAAC,MACI;MACD,IAAI,CAAC8c,iBAAiB,CAAC7M,MAAM,CAACjQ,IAAI,CAAC;IACvC;EACJ;EACA8P,MAAMA,CAAC9P,IAAI,EAAE;IACT,IAAIzL,wBAAwB,CAACyL,IAAI,CAAC,EAAE;MAChC,IAAI,CAAC+c,iBAAiB,CAACjN,MAAM,CAAC9P,IAAI,CAAC;IACvC,CAAC,MACI;MACD,IAAI,CAAC8c,iBAAiB,CAAChN,MAAM,CAAC9P,IAAI,CAAC;IACvC;EACJ;EACAuQ,WAAWA,CAACvQ,IAAI,EAAEU,eAAe,EAAE;IAC/B,IAAInM,wBAAwB,CAACyL,IAAI,CAAC,EAAE;MAChC,IAAI,CAAC+c,iBAAiB,CAACxM,WAAW,CAACvQ,IAAI,EAAEU,eAAe,CAAC;IAC7D,CAAC,MACI;MACD,IAAI,CAACoc,iBAAiB,CAACvM,WAAW,CAACvQ,IAAI,EAAEU,eAAe,CAAC;IAC7D;EACJ;EACA6M,aAAaA,CAACtJ,MAAM,EAAE1M,MAAM,EAAE4lB,UAAU,EAAElT,gBAAgB,EAAE;IACxD,IAAI,CAAC6S,iBAAiB,CAACvP,aAAa,CAACtJ,MAAM,EAAE1M,MAAM,EAAE4lB,UAAU,EAAElT,gBAAgB,CAAC;IAClF,IAAI,CAAC8S,iBAAiB,CAACxP,aAAa,CAACtJ,MAAM,EAAE1M,MAAM,EAAE4lB,UAAU,EAAElT,gBAAgB,CAAC;EACtF;AACJ;AACA,SAASmT,cAAcA,CAACC,SAAS,EAAE;EAC/B,OAAOA,SAAS,CAACC,OAAO,CAAC,gBAAgB,EAAE,GAAG,CAAC;AACnD;AACA,MAAMC,iBAAiB,CAAC;EACpB1mB,WAAWA,CAAC0F,OAAO,EAAE;IACjB,IAAI,CAACmV,KAAK,GAAGnV,OAAO,CAACmV,KAAK,IAAI,EAAE;IAChC,IAAI,CAAC8L,SAAS,GAAGjhB,OAAO,CAACihB,SAAS,IAAI,EAAE;EAC5C;AACJ;AACA,OAAO,MAAMC,mCAAmC,SAASF,iBAAiB,CAAC;EACvE1mB,WAAWA,CAAC0F,OAAO,EAAE;IACjB,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACmhB,cAAc,GAAG,IAAI;IAC1B,IAAI,CAAC9Z,QAAQ,GAAI,OAAOrH,OAAO,CAACqH,QAAQ,KAAK,QAAQ,GAAGrH,OAAO,CAACqH,QAAQ,GAAG1P,KAAK,CAACypB,iBAAiB,CAACC,MAAO;EAC9G;EACAC,QAAQA,CAACC,KAAK,EAAE;IACZ,IAAI,CAAC,IAAI,CAACJ,cAAc,EAAE;MACtB,IAAII,KAAK,CAACC,IAAI,KAAK,OAAO,IAAI,IAAI,CAACP,SAAS,EAAE;QAC1C,IAAI,CAACE,cAAc,GAAG,IAAI,CAACM,aAAa,CAAC,IAAI,CAACR,SAAS,EAAEM,KAAK,CAAC;MACnE,CAAC,MACI;QACD,IAAI,CAACJ,cAAc,GAAG,IAAI,CAACM,aAAa,CAAC,IAAI,CAACtM,KAAK,EAAEoM,KAAK,CAAC;MAC/D;IACJ;IACA,OAAO,IAAI,CAACJ,cAAc;EAC9B;EACAO,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAACP,cAAc,GAAG,IAAI;EAC9B;EACAM,aAAaA,CAACtM,KAAK,EAAEoM,KAAK,EAAE;IACxB,IAAI,OAAOpM,KAAK,KAAK,QAAQ,EAAE;MAC3B,OAAOA,KAAK;IAChB;IACA,IAAIwM,CAAC,GAAGxM,KAAK,GAAGoM,KAAK,CAACD,QAAQ,CAACnM,KAAK,CAAClY,EAAE,CAAC,GAAG,IAAI;IAC/C,IAAI,CAAC0kB,CAAC,EAAE;MACJ,OAAO,EAAE;IACb;IACA,OAAOA,CAAC,CAACC,QAAQ,CAAC,CAAC;EACvB;AACJ;AACA,OAAO,MAAMC,6BAA6B,SAASb,iBAAiB,CAAC;EACjE1mB,WAAWA,CAAC0F,OAAO,EAAE;IACjB,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACqH,QAAQ,GAAGrH,OAAO,CAACqH,QAAQ;EACpC;EACAia,QAAQA,CAACC,KAAK,EAAE;IACZ,IAAI,CAAC,IAAI,CAACJ,cAAc,EAAE;MACtB,IAAII,KAAK,CAACC,IAAI,KAAK,OAAO,IAAI,IAAI,CAACP,SAAS,EAAE;QAC1C,IAAI,CAACE,cAAc,GAAG,IAAI,CAACM,aAAa,CAAC,IAAI,CAACR,SAAS,EAAEM,KAAK,CAAC;MACnE,CAAC,MACI;QACD,IAAI,CAACJ,cAAc,GAAG,IAAI,CAACM,aAAa,CAAC,IAAI,CAACtM,KAAK,EAAEoM,KAAK,CAAC;MAC/D;IACJ;IACA,OAAO,IAAI,CAACJ,cAAc;EAC9B;EACAO,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAACP,cAAc,GAAG9lB,SAAS;EACnC;EACAomB,aAAaA,CAACtM,KAAK,EAAEoM,KAAK,EAAE;IACxB,IAAI,OAAOpM,KAAK,KAAK,QAAQ,EAAE;MAC3B,OAAO9b,KAAK,CAACyoB,OAAO,CAAC3M,KAAK,CAAC;IAC/B;IACA,OAAOoM,KAAK,CAACD,QAAQ,CAACnM,KAAK,CAAClY,EAAE,CAAC;EACnC;AACJ;AACA,OAAO,MAAM8kB,sBAAsB,CAAC;EAChCznB,WAAWA,CAAC0F,OAAO,EAAE;IACjB,IAAI,CAACgiB,UAAU,GAAGhiB,OAAO,CAACgiB,UAAU,IAAI,CAAC,CAAC;IAC1C,IAAI,CAACC,MAAM,GAAGjiB,OAAO,CAACiiB,MAAM,IAAI,CAAC;IACjC,IAAI,CAACnB,SAAS,GAAG9gB,OAAO,CAAC8gB,SAAS,GAAGD,cAAc,CAAC7gB,OAAO,CAAC8gB,SAAS,CAAC,GAAG,IAAI;IAC7E,IAAI,CAACoB,YAAY,GAAGliB,OAAO,CAACkiB,YAAY,IAAI,IAAI;IAChD,IAAI,CAACC,uBAAuB,GAAGniB,OAAO,CAACmiB,uBAAuB,IAAI,IAAI;IACtE,IAAI,CAACC,WAAW,GAAGpiB,OAAO,CAACoiB,WAAW,IAAI,KAAK;IAC/C,IAAI,CAACC,eAAe,GAAGriB,OAAO,CAACqiB,eAAe,IAAI,KAAK;IACvD,IAAI,CAACC,qBAAqB,GAAGtiB,OAAO,CAACsiB,qBAAqB,IAAI,KAAK;IACnE,IAAI,CAACpN,aAAa,GAAGlV,OAAO,CAACkV,aAAa,GAAG,IAAIgM,mCAAmC,CAAClhB,OAAO,CAACkV,aAAa,CAAC,GAAG,IAAI;IAClH,IAAI,CAACqN,OAAO,GAAGviB,OAAO,CAACuiB,OAAO,GAAG,IAAIV,6BAA6B,CAAC7hB,OAAO,CAACuiB,OAAO,CAAC,GAAG,IAAI;IAC1F,IAAI,CAACC,oBAAoB,GAAGxiB,OAAO,CAACwiB,oBAAoB,GAAG3B,cAAc,CAAC7gB,OAAO,CAACwiB,oBAAoB,CAAC,GAAG,IAAI;IAC9G,IAAI,CAACC,yBAAyB,GAAGziB,OAAO,CAACyiB,yBAAyB,GAAG5B,cAAc,CAAC7gB,OAAO,CAACyiB,yBAAyB,CAAC,GAAG,IAAI;IAC7H,IAAI,CAACC,4BAA4B,GAAG1iB,OAAO,CAAC0iB,4BAA4B,GAAG7B,cAAc,CAAC7gB,OAAO,CAAC0iB,4BAA4B,CAAC,GAAG,IAAI;IACtI,IAAI,CAACC,eAAe,GAAG3iB,OAAO,CAAC2iB,eAAe,GAAG9B,cAAc,CAAC7gB,OAAO,CAAC2iB,eAAe,CAAC,GAAG,IAAI;IAC/F,IAAI,CAACC,eAAe,GAAG5iB,OAAO,CAAC4iB,eAAe,GAAG/B,cAAc,CAAC7gB,OAAO,CAAC4iB,eAAe,CAAC,GAAG,IAAI;IAC/F,IAAI,CAACC,mCAAmC,GAAG7iB,OAAO,CAAC6iB,mCAAmC,IAAI,KAAK;IAC/F,IAAI,CAACC,sBAAsB,GAAG9iB,OAAO,CAAC8iB,sBAAsB,GAAGjC,cAAc,CAAC7gB,OAAO,CAAC8iB,sBAAsB,CAAC,GAAG,IAAI;IACpH,IAAI,CAACC,qBAAqB,GAAG/iB,OAAO,CAAC+iB,qBAAqB,GAAGlC,cAAc,CAAC7gB,OAAO,CAAC+iB,qBAAqB,CAAC,GAAG,IAAI;EACrH;EACA,OAAOC,QAAQA,CAAChjB,OAAO,EAAE;IACrB,OAAO,IAAI+hB,sBAAsB,CAAC/hB,OAAO,CAAC;EAC9C;EACA,OAAOijB,aAAaA,CAACjjB,OAAO,EAAE;IAC1B,OAAO,IAAI+hB,sBAAsB,CAAC/hB,OAAO,CAAC;EAC9C;AACJ;AACA+hB,sBAAsB,CAACmB,KAAK,GAAGnB,sBAAsB,CAACiB,QAAQ,CAAC,CAAC,CAAC,CAAC;AAClE;AACA;AACA;AACA,MAAM1P,qBAAqB,GAAG,CAC1ByO,sBAAsB,CAACiB,QAAQ,CAAC;EAAEhB,UAAU,EAAE,CAAC,CAAC;AAAmC,CAAC,CAAC,EACrFD,sBAAsB,CAACiB,QAAQ,CAAC;EAAEhB,UAAU,EAAE,CAAC,CAAC;AAAkC,CAAC,CAAC,EACpFD,sBAAsB,CAACiB,QAAQ,CAAC;EAAEhB,UAAU,EAAE,CAAC,CAAC;AAAgC,CAAC,CAAC,EAClFD,sBAAsB,CAACiB,QAAQ,CAAC;EAAEhB,UAAU,EAAE,CAAC,CAAC;AAA+B,CAAC,CAAC,CACpF;;AACD,SAASnP,iBAAiBA,CAAC7S,OAAO,EAAE;EAChC,IAAIA,OAAO,YAAY+hB,sBAAsB,EAAE;IAC3C,OAAO/hB,OAAO;EAClB;EACA,OAAO+hB,sBAAsB,CAACkB,aAAa,CAACjjB,OAAO,CAAC;AACxD;AACA,OAAO,MAAM7D,2BAA2B,SAAS/E,UAAU,CAAC;EACxDkD,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,CAAC;IACP,IAAI,CAAC6oB,OAAO,GAAG,IAAI,CAACpnB,SAAS,CAAC,IAAI5E,OAAO,CAAC,CAAC,CAAC;IAC5C,IAAI,CAAC8E,KAAK,GAAG,IAAI,CAACknB,OAAO,CAAClnB,KAAK;IAC/B,IAAI,CAACmnB,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACC,qBAAqB,GAAG,KAAK;EACtC;EACAnW,iBAAiBA,CAAA,EAAG;IAChB,IAAI,CAACgW,YAAY,EAAE;EACvB;EACA/V,eAAeA,CAAA,EAAG;IACd,IAAI,CAAC+V,YAAY,EAAE;IACnB,IAAI,IAAI,CAACA,YAAY,KAAK,CAAC,EAAE;MACzB,IAAI,IAAI,CAACC,WAAW,EAAE;QAClB,MAAMpnB,KAAK,GAAG;UACVunB,cAAc,EAAE,IAAI,CAACF,eAAe;UACpCG,oBAAoB,EAAE,IAAI,CAACF;QAC/B,CAAC;QACD,IAAI,CAACF,WAAW,GAAG,KAAK;QACxB,IAAI,CAACC,eAAe,GAAG,KAAK;QAC5B,IAAI,CAACC,qBAAqB,GAAG,KAAK;QAClC,IAAI,CAACJ,OAAO,CAAClkB,IAAI,CAAChD,KAAK,CAAC;MAC5B;IACJ;EACJ;EACA+Y,oBAAoBA,CAAChV,OAAO,EAAE;IAC1B,IAAI,CAAC,IAAI,CAACsjB,eAAe,EAAE;MACvB,IAAI,CAACA,eAAe,GAAGtjB,OAAO,CAACuiB,OAAO,IAAIviB,OAAO,CAACuiB,OAAO,CAAClb,QAAQ,GAAG,IAAI,GAAG,KAAK;IACrF;IACA,IAAI,CAAC,IAAI,CAACkc,qBAAqB,EAAE;MAC7B,IAAI,CAACA,qBAAqB,GAAGvjB,OAAO,CAACkV,aAAa,IAAIlV,OAAO,CAACkV,aAAa,CAACC,KAAK,GAAG,IAAI,GAAG,KAAK;IACpG;IACA,IAAI,CAACkO,WAAW,GAAG,IAAI;EAC3B;EACApkB,IAAIA,CAAA,EAAG;IACH,IAAI,CAACqkB,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACC,qBAAqB,GAAG,IAAI;IACjC,IAAI,CAACF,WAAW,GAAG,IAAI;EAC3B;AACJ;AACA;AACA,OAAO,MAAMrmB,uBAAuB,SAAS5F,UAAU,CAAC;EACpDkD,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,CAAC;IACP;AACR;AACA;IACQ,IAAI,CAACopB,YAAY,GAAG,IAAI,CAAC3nB,SAAS,CAAC,IAAI5E,OAAO,CAAC,CAAC,CAAC;IACjD,IAAI,CAACuJ,SAAS,GAAG,IAAI,CAACgjB,YAAY,CAACznB,KAAK;IACxC,IAAI,CAAC0nB,YAAY,GAAG,IAAI,CAAC5nB,SAAS,CAAC,IAAI5E,OAAO,CAAC,CAAC,CAAC;IACjD,IAAI,CAAC4J,SAAS,GAAG,IAAI,CAAC4iB,YAAY,CAAC1nB,KAAK;IACxC,IAAI,CAACmnB,YAAY,GAAG,CAAC;IACrB,IAAI,CAACQ,cAAc,GAAG,IAAI;EAC9B;EACAxW,iBAAiBA,CAAA,EAAG;IAChB,IAAI,CAACgW,YAAY,EAAE;EACvB;EACA/V,eAAeA,CAAA,EAA4B;IAAA,IAA3BiC,kBAAkB,GAAA1T,SAAA,CAAAZ,MAAA,QAAAY,SAAA,QAAAP,SAAA,GAAAO,SAAA,MAAG,IAAI;IACrC,IAAI,CAACwnB,YAAY,EAAE;IACnB,IAAI,IAAI,CAACA,YAAY,KAAK,CAAC,EAAE;MACzB,IAAI,IAAI,CAACQ,cAAc,KAAK,IAAI,EAAE;QAC9B,IAAI,CAACA,cAAc,CAACjjB,sBAAsB,CAAC2O,kBAAkB,GAAGA,kBAAkB;QAClF,MAAMtQ,CAAC,GAAG,IAAI,CAAC4kB,cAAc;QAC7B,IAAI,CAACA,cAAc,GAAG,IAAI;QAC1B,IAAI,CAACF,YAAY,CAACzkB,IAAI,CAACD,CAAC,CAAC;QACzB,IAAI,CAAC2kB,YAAY,CAAC1kB,IAAI,CAACD,CAAC,CAAC;MAC7B;IACJ;EACJ;EACAC,IAAIA,CAACD,CAAC,EAAE;IACJ,IAAI,IAAI,CAACokB,YAAY,GAAG,CAAC,EAAE;MACvB,IAAI,IAAI,CAACQ,cAAc,EAAE;QACrB,IAAI,CAACA,cAAc,GAAG,IAAI,CAACA,cAAc,CAACC,KAAK,CAAC7kB,CAAC,CAAC;MACtD,CAAC,MACI;QACD,IAAI,CAAC4kB,cAAc,GAAG5kB,CAAC;MAC3B;MACA;IACJ;IACA,IAAI,CAAC0kB,YAAY,CAACzkB,IAAI,CAACD,CAAC,CAAC;IACzB,IAAI,CAAC2kB,YAAY,CAAC1kB,IAAI,CAACD,CAAC,CAAC;EAC7B;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}