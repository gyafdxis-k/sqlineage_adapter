{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { URI } from './uri.js';\nimport { compareSubstringIgnoreCase, compare, compareSubstring, compareIgnoreCase } from './strings.js';\nexport class StringIterator {\n  constructor() {\n    this._value = '';\n    this._pos = 0;\n  }\n  reset(key) {\n    this._value = key;\n    this._pos = 0;\n    return this;\n  }\n  next() {\n    this._pos += 1;\n    return this;\n  }\n  hasNext() {\n    return this._pos < this._value.length - 1;\n  }\n  cmp(a) {\n    const aCode = a.charCodeAt(0);\n    const thisCode = this._value.charCodeAt(this._pos);\n    return aCode - thisCode;\n  }\n  value() {\n    return this._value[this._pos];\n  }\n}\nexport class ConfigKeysIterator {\n  constructor() {\n    let _caseSensitive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._caseSensitive = _caseSensitive;\n  }\n  reset(key) {\n    this._value = key;\n    this._from = 0;\n    this._to = 0;\n    return this.next();\n  }\n  hasNext() {\n    return this._to < this._value.length;\n  }\n  next() {\n    // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n    this._from = this._to;\n    let justSeps = true;\n    for (; this._to < this._value.length; this._to++) {\n      const ch = this._value.charCodeAt(this._to);\n      if (ch === 46 /* Period */) {\n        if (justSeps) {\n          this._from++;\n        } else {\n          break;\n        }\n      } else {\n        justSeps = false;\n      }\n    }\n    return this;\n  }\n  cmp(a) {\n    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n  }\n  value() {\n    return this._value.substring(this._from, this._to);\n  }\n}\nexport class PathIterator {\n  constructor() {\n    let _splitOnBackslash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let _caseSensitive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this._splitOnBackslash = _splitOnBackslash;\n    this._caseSensitive = _caseSensitive;\n  }\n  reset(key) {\n    this._value = key.replace(/\\\\$|\\/$/, '');\n    this._from = 0;\n    this._to = 0;\n    return this.next();\n  }\n  hasNext() {\n    return this._to < this._value.length;\n  }\n  next() {\n    // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n    this._from = this._to;\n    let justSeps = true;\n    for (; this._to < this._value.length; this._to++) {\n      const ch = this._value.charCodeAt(this._to);\n      if (ch === 47 /* Slash */ || this._splitOnBackslash && ch === 92 /* Backslash */) {\n        if (justSeps) {\n          this._from++;\n        } else {\n          break;\n        }\n      } else {\n        justSeps = false;\n      }\n    }\n    return this;\n  }\n  cmp(a) {\n    return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n  }\n  value() {\n    return this._value.substring(this._from, this._to);\n  }\n}\nexport class UriIterator {\n  constructor(_ignorePathCasing) {\n    this._ignorePathCasing = _ignorePathCasing;\n    this._states = [];\n    this._stateIdx = 0;\n  }\n  reset(key) {\n    this._value = key;\n    this._states = [];\n    if (this._value.scheme) {\n      this._states.push(1 /* Scheme */);\n    }\n\n    if (this._value.authority) {\n      this._states.push(2 /* Authority */);\n    }\n\n    if (this._value.path) {\n      this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));\n      this._pathIterator.reset(key.path);\n      if (this._pathIterator.value()) {\n        this._states.push(3 /* Path */);\n      }\n    }\n\n    if (this._value.query) {\n      this._states.push(4 /* Query */);\n    }\n\n    if (this._value.fragment) {\n      this._states.push(5 /* Fragment */);\n    }\n\n    this._stateIdx = 0;\n    return this;\n  }\n  next() {\n    if (this._states[this._stateIdx] === 3 /* Path */ && this._pathIterator.hasNext()) {\n      this._pathIterator.next();\n    } else {\n      this._stateIdx += 1;\n    }\n    return this;\n  }\n  hasNext() {\n    return this._states[this._stateIdx] === 3 /* Path */ && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;\n  }\n  cmp(a) {\n    if (this._states[this._stateIdx] === 1 /* Scheme */) {\n      return compareIgnoreCase(a, this._value.scheme);\n    } else if (this._states[this._stateIdx] === 2 /* Authority */) {\n      return compareIgnoreCase(a, this._value.authority);\n    } else if (this._states[this._stateIdx] === 3 /* Path */) {\n      return this._pathIterator.cmp(a);\n    } else if (this._states[this._stateIdx] === 4 /* Query */) {\n      return compare(a, this._value.query);\n    } else if (this._states[this._stateIdx] === 5 /* Fragment */) {\n      return compare(a, this._value.fragment);\n    }\n    throw new Error();\n  }\n  value() {\n    if (this._states[this._stateIdx] === 1 /* Scheme */) {\n      return this._value.scheme;\n    } else if (this._states[this._stateIdx] === 2 /* Authority */) {\n      return this._value.authority;\n    } else if (this._states[this._stateIdx] === 3 /* Path */) {\n      return this._pathIterator.value();\n    } else if (this._states[this._stateIdx] === 4 /* Query */) {\n      return this._value.query;\n    } else if (this._states[this._stateIdx] === 5 /* Fragment */) {\n      return this._value.fragment;\n    }\n    throw new Error();\n  }\n}\nclass TernarySearchTreeNode {\n  isEmpty() {\n    return !this.left && !this.mid && !this.right && !this.value;\n  }\n}\nexport class TernarySearchTree {\n  constructor(segments) {\n    this._iter = segments;\n  }\n  static forUris() {\n    let ignorePathCasing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => false;\n    return new TernarySearchTree(new UriIterator(ignorePathCasing));\n  }\n  static forStrings() {\n    return new TernarySearchTree(new StringIterator());\n  }\n  static forConfigKeys() {\n    return new TernarySearchTree(new ConfigKeysIterator());\n  }\n  clear() {\n    this._root = undefined;\n  }\n  set(key, element) {\n    const iter = this._iter.reset(key);\n    let node;\n    if (!this._root) {\n      this._root = new TernarySearchTreeNode();\n      this._root.segment = iter.value();\n    }\n    node = this._root;\n    while (true) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        if (!node.left) {\n          node.left = new TernarySearchTreeNode();\n          node.left.segment = iter.value();\n        }\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        if (!node.right) {\n          node.right = new TernarySearchTreeNode();\n          node.right.segment = iter.value();\n        }\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        if (!node.mid) {\n          node.mid = new TernarySearchTreeNode();\n          node.mid.segment = iter.value();\n        }\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n    const oldElement = node.value;\n    node.value = element;\n    node.key = key;\n    return oldElement;\n  }\n  get(key) {\n    var _a;\n    return (_a = this._getNode(key)) === null || _a === void 0 ? void 0 : _a.value;\n  }\n  _getNode(key) {\n    const iter = this._iter.reset(key);\n    let node = this._root;\n    while (node) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n    return node;\n  }\n  has(key) {\n    const node = this._getNode(key);\n    return !((node === null || node === void 0 ? void 0 : node.value) === undefined && (node === null || node === void 0 ? void 0 : node.mid) === undefined);\n  }\n  delete(key) {\n    return this._delete(key, false);\n  }\n  deleteSuperstr(key) {\n    return this._delete(key, true);\n  }\n  _delete(key, superStr) {\n    const iter = this._iter.reset(key);\n    const stack = [];\n    let node = this._root;\n    // find and unset node\n    while (node) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        stack.push([1, node]);\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        stack.push([-1, node]);\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        stack.push([0, node]);\n        node = node.mid;\n      } else {\n        if (superStr) {\n          // remove children\n          node.left = undefined;\n          node.mid = undefined;\n          node.right = undefined;\n        } else {\n          // remove element\n          node.value = undefined;\n        }\n        // clean up empty nodes\n        while (stack.length > 0 && node.isEmpty()) {\n          let [dir, parent] = stack.pop();\n          switch (dir) {\n            case 1:\n              parent.left = undefined;\n              break;\n            case 0:\n              parent.mid = undefined;\n              break;\n            case -1:\n              parent.right = undefined;\n              break;\n          }\n          node = parent;\n        }\n        break;\n      }\n    }\n  }\n  findSubstr(key) {\n    const iter = this._iter.reset(key);\n    let node = this._root;\n    let candidate = undefined;\n    while (node) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        candidate = node.value || candidate;\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n    return node && node.value || candidate;\n  }\n  findSuperstr(key) {\n    const iter = this._iter.reset(key);\n    let node = this._root;\n    while (node) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        node = node.mid;\n      } else {\n        // collect\n        if (!node.mid) {\n          return undefined;\n        } else {\n          return this._entries(node.mid);\n        }\n      }\n    }\n    return undefined;\n  }\n  forEach(callback) {\n    for (const [key, value] of this) {\n      callback(value, key);\n    }\n  }\n  *[Symbol.iterator]() {\n    yield* this._entries(this._root);\n  }\n  *_entries(node) {\n    if (node) {\n      // left\n      yield* this._entries(node.left);\n      // node\n      if (node.value) {\n        // callback(node.value, this._iter.join(parts));\n        yield [node.key, node.value];\n      }\n      // mid\n      yield* this._entries(node.mid);\n      // right\n      yield* this._entries(node.right);\n    }\n  }\n}\nexport class ResourceMap {\n  constructor(mapOrKeyFn, toKey) {\n    this[Symbol.toStringTag] = 'ResourceMap';\n    if (mapOrKeyFn instanceof ResourceMap) {\n      this.map = new Map(mapOrKeyFn.map);\n      this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\n    } else {\n      this.map = new Map();\n      this.toKey = mapOrKeyFn !== null && mapOrKeyFn !== void 0 ? mapOrKeyFn : ResourceMap.defaultToKey;\n    }\n  }\n  set(resource, value) {\n    this.map.set(this.toKey(resource), value);\n    return this;\n  }\n  get(resource) {\n    return this.map.get(this.toKey(resource));\n  }\n  has(resource) {\n    return this.map.has(this.toKey(resource));\n  }\n  get size() {\n    return this.map.size;\n  }\n  clear() {\n    this.map.clear();\n  }\n  delete(resource) {\n    return this.map.delete(this.toKey(resource));\n  }\n  forEach(clb, thisArg) {\n    if (typeof thisArg !== 'undefined') {\n      clb = clb.bind(thisArg);\n    }\n    for (let [index, value] of this.map) {\n      clb(value, URI.parse(index), this);\n    }\n  }\n  values() {\n    return this.map.values();\n  }\n  *keys() {\n    for (let key of this.map.keys()) {\n      yield URI.parse(key);\n    }\n  }\n  *entries() {\n    for (let tuple of this.map.entries()) {\n      yield [URI.parse(tuple[0]), tuple[1]];\n    }\n  }\n  *[Symbol.iterator]() {\n    for (let item of this.map) {\n      yield [URI.parse(item[0]), item[1]];\n    }\n  }\n}\nResourceMap.defaultToKey = resource => resource.toString();\nexport class LinkedMap {\n  constructor() {\n    this[Symbol.toStringTag] = 'LinkedMap';\n    this._map = new Map();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state = 0;\n  }\n  clear() {\n    this._map.clear();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state++;\n  }\n  isEmpty() {\n    return !this._head && !this._tail;\n  }\n  get size() {\n    return this._size;\n  }\n  get first() {\n    var _a;\n    return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;\n  }\n  get last() {\n    var _a;\n    return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;\n  }\n  has(key) {\n    return this._map.has(key);\n  }\n  get(key) {\n    let touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const item = this._map.get(key);\n    if (!item) {\n      return undefined;\n    }\n    if (touch !== 0 /* None */) {\n      this.touch(item, touch);\n    }\n    return item.value;\n  }\n  set(key, value) {\n    let touch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let item = this._map.get(key);\n    if (item) {\n      item.value = value;\n      if (touch !== 0 /* None */) {\n        this.touch(item, touch);\n      }\n    } else {\n      item = {\n        key,\n        value,\n        next: undefined,\n        previous: undefined\n      };\n      switch (touch) {\n        case 0 /* None */:\n          this.addItemLast(item);\n          break;\n        case 1 /* AsOld */:\n          this.addItemFirst(item);\n          break;\n        case 2 /* AsNew */:\n          this.addItemLast(item);\n          break;\n        default:\n          this.addItemLast(item);\n          break;\n      }\n      this._map.set(key, item);\n      this._size++;\n    }\n    return this;\n  }\n  delete(key) {\n    return !!this.remove(key);\n  }\n  remove(key) {\n    const item = this._map.get(key);\n    if (!item) {\n      return undefined;\n    }\n    this._map.delete(key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  shift() {\n    if (!this._head && !this._tail) {\n      return undefined;\n    }\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n    const item = this._head;\n    this._map.delete(item.key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  forEach(callbackfn, thisArg) {\n    const state = this._state;\n    let current = this._head;\n    while (current) {\n      if (thisArg) {\n        callbackfn.bind(thisArg)(current.value, current.key, this);\n      } else {\n        callbackfn(current.value, current.key, this);\n      }\n      if (this._state !== state) {\n        throw new Error(\"LinkedMap got modified during iteration.\");\n      }\n      current = current.next;\n    }\n  }\n  keys() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(\"LinkedMap got modified during iteration.\");\n        }\n        if (current) {\n          const result = {\n            value: current.key,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  values() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(\"LinkedMap got modified during iteration.\");\n        }\n        if (current) {\n          const result = {\n            value: current.value,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  entries() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(\"LinkedMap got modified during iteration.\");\n        }\n        if (current) {\n          const result = {\n            value: [current.key, current.value],\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  trimOld(newSize) {\n    if (newSize >= this.size) {\n      return;\n    }\n    if (newSize === 0) {\n      this.clear();\n      return;\n    }\n    let current = this._head;\n    let currentSize = this.size;\n    while (current && currentSize > newSize) {\n      this._map.delete(current.key);\n      current = current.next;\n      currentSize--;\n    }\n    this._head = current;\n    this._size = currentSize;\n    if (current) {\n      current.previous = undefined;\n    }\n    this._state++;\n  }\n  addItemFirst(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._tail = item;\n    } else if (!this._head) {\n      throw new Error('Invalid list');\n    } else {\n      item.next = this._head;\n      this._head.previous = item;\n    }\n    this._head = item;\n    this._state++;\n  }\n  addItemLast(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._head = item;\n    } else if (!this._tail) {\n      throw new Error('Invalid list');\n    } else {\n      item.previous = this._tail;\n      this._tail.next = item;\n    }\n    this._tail = item;\n    this._state++;\n  }\n  removeItem(item) {\n    if (item === this._head && item === this._tail) {\n      this._head = undefined;\n      this._tail = undefined;\n    } else if (item === this._head) {\n      // This can only happend if size === 1 which is handle\n      // by the case above.\n      if (!item.next) {\n        throw new Error('Invalid list');\n      }\n      item.next.previous = undefined;\n      this._head = item.next;\n    } else if (item === this._tail) {\n      // This can only happend if size === 1 which is handle\n      // by the case above.\n      if (!item.previous) {\n        throw new Error('Invalid list');\n      }\n      item.previous.next = undefined;\n      this._tail = item.previous;\n    } else {\n      const next = item.next;\n      const previous = item.previous;\n      if (!next || !previous) {\n        throw new Error('Invalid list');\n      }\n      next.previous = previous;\n      previous.next = next;\n    }\n    item.next = undefined;\n    item.previous = undefined;\n    this._state++;\n  }\n  touch(item, touch) {\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n    if (touch !== 1 /* AsOld */ && touch !== 2 /* AsNew */) {\n      return;\n    }\n    if (touch === 1 /* AsOld */) {\n      if (item === this._head) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      // Unlink the item\n      if (item === this._tail) {\n        // previous must be defined since item was not head but is tail\n        // So there are more than on item in the map\n        previous.next = undefined;\n        this._tail = previous;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      }\n      // Insert the node at head\n      item.previous = undefined;\n      item.next = this._head;\n      this._head.previous = item;\n      this._head = item;\n      this._state++;\n    } else if (touch === 2 /* AsNew */) {\n      if (item === this._tail) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      // Unlink the item.\n      if (item === this._head) {\n        // next must be defined since item was not tail but is head\n        // So there are more than on item in the map\n        next.previous = undefined;\n        this._head = next;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      }\n      item.next = undefined;\n      item.previous = this._tail;\n      this._tail.next = item;\n      this._tail = item;\n      this._state++;\n    }\n  }\n  toJSON() {\n    const data = [];\n    this.forEach((value, key) => {\n      data.push([key, value]);\n    });\n    return data;\n  }\n  fromJSON(data) {\n    this.clear();\n    for (const [key, value] of data) {\n      this.set(key, value);\n    }\n  }\n}\nexport class LRUCache extends LinkedMap {\n  constructor(limit) {\n    let ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    super();\n    this._limit = limit;\n    this._ratio = Math.min(Math.max(0, ratio), 1);\n  }\n  get limit() {\n    return this._limit;\n  }\n  set limit(limit) {\n    this._limit = limit;\n    this.checkTrim();\n  }\n  get(key) {\n    let touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    return super.get(key, touch);\n  }\n  peek(key) {\n    return super.get(key, 0 /* None */);\n  }\n\n  set(key, value) {\n    super.set(key, value, 2 /* AsNew */);\n    this.checkTrim();\n    return this;\n  }\n  checkTrim() {\n    if (this.size > this._limit) {\n      this.trimOld(Math.round(this._limit * this._ratio));\n    }\n  }\n}","map":{"version":3,"names":["URI","compareSubstringIgnoreCase","compare","compareSubstring","compareIgnoreCase","StringIterator","constructor","_value","_pos","reset","key","next","hasNext","length","cmp","a","aCode","charCodeAt","thisCode","value","ConfigKeysIterator","_caseSensitive","arguments","undefined","_from","_to","justSeps","ch","substring","PathIterator","_splitOnBackslash","replace","UriIterator","_ignorePathCasing","_states","_stateIdx","scheme","push","authority","path","_pathIterator","query","fragment","Error","TernarySearchTreeNode","isEmpty","left","mid","right","TernarySearchTree","segments","_iter","forUris","ignorePathCasing","forStrings","forConfigKeys","clear","_root","set","element","iter","node","segment","val","oldElement","get","_a","_getNode","has","delete","_delete","deleteSuperstr","superStr","stack","dir","parent","pop","findSubstr","candidate","findSuperstr","_entries","forEach","callback","Symbol","iterator","ResourceMap","mapOrKeyFn","toKey","toStringTag","map","Map","defaultToKey","resource","size","clb","thisArg","bind","index","parse","values","keys","entries","tuple","item","toString","LinkedMap","_map","_head","_tail","_size","_state","first","last","touch","previous","addItemLast","addItemFirst","remove","removeItem","shift","callbackfn","state","current","result","done","trimOld","newSize","currentSize","toJSON","data","fromJSON","LRUCache","limit","ratio","_limit","_ratio","Math","min","max","checkTrim","peek","round"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/map.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { URI } from './uri.js';\r\nimport { compareSubstringIgnoreCase, compare, compareSubstring, compareIgnoreCase } from './strings.js';\r\nexport class StringIterator {\r\n    constructor() {\r\n        this._value = '';\r\n        this._pos = 0;\r\n    }\r\n    reset(key) {\r\n        this._value = key;\r\n        this._pos = 0;\r\n        return this;\r\n    }\r\n    next() {\r\n        this._pos += 1;\r\n        return this;\r\n    }\r\n    hasNext() {\r\n        return this._pos < this._value.length - 1;\r\n    }\r\n    cmp(a) {\r\n        const aCode = a.charCodeAt(0);\r\n        const thisCode = this._value.charCodeAt(this._pos);\r\n        return aCode - thisCode;\r\n    }\r\n    value() {\r\n        return this._value[this._pos];\r\n    }\r\n}\r\nexport class ConfigKeysIterator {\r\n    constructor(_caseSensitive = true) {\r\n        this._caseSensitive = _caseSensitive;\r\n    }\r\n    reset(key) {\r\n        this._value = key;\r\n        this._from = 0;\r\n        this._to = 0;\r\n        return this.next();\r\n    }\r\n    hasNext() {\r\n        return this._to < this._value.length;\r\n    }\r\n    next() {\r\n        // this._data = key.split(/[\\\\/]/).filter(s => !!s);\r\n        this._from = this._to;\r\n        let justSeps = true;\r\n        for (; this._to < this._value.length; this._to++) {\r\n            const ch = this._value.charCodeAt(this._to);\r\n            if (ch === 46 /* Period */) {\r\n                if (justSeps) {\r\n                    this._from++;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                justSeps = false;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    cmp(a) {\r\n        return this._caseSensitive\r\n            ? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\r\n            : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\r\n    }\r\n    value() {\r\n        return this._value.substring(this._from, this._to);\r\n    }\r\n}\r\nexport class PathIterator {\r\n    constructor(_splitOnBackslash = true, _caseSensitive = true) {\r\n        this._splitOnBackslash = _splitOnBackslash;\r\n        this._caseSensitive = _caseSensitive;\r\n    }\r\n    reset(key) {\r\n        this._value = key.replace(/\\\\$|\\/$/, '');\r\n        this._from = 0;\r\n        this._to = 0;\r\n        return this.next();\r\n    }\r\n    hasNext() {\r\n        return this._to < this._value.length;\r\n    }\r\n    next() {\r\n        // this._data = key.split(/[\\\\/]/).filter(s => !!s);\r\n        this._from = this._to;\r\n        let justSeps = true;\r\n        for (; this._to < this._value.length; this._to++) {\r\n            const ch = this._value.charCodeAt(this._to);\r\n            if (ch === 47 /* Slash */ || this._splitOnBackslash && ch === 92 /* Backslash */) {\r\n                if (justSeps) {\r\n                    this._from++;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                justSeps = false;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    cmp(a) {\r\n        return this._caseSensitive\r\n            ? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\r\n            : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\r\n    }\r\n    value() {\r\n        return this._value.substring(this._from, this._to);\r\n    }\r\n}\r\nexport class UriIterator {\r\n    constructor(_ignorePathCasing) {\r\n        this._ignorePathCasing = _ignorePathCasing;\r\n        this._states = [];\r\n        this._stateIdx = 0;\r\n    }\r\n    reset(key) {\r\n        this._value = key;\r\n        this._states = [];\r\n        if (this._value.scheme) {\r\n            this._states.push(1 /* Scheme */);\r\n        }\r\n        if (this._value.authority) {\r\n            this._states.push(2 /* Authority */);\r\n        }\r\n        if (this._value.path) {\r\n            this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));\r\n            this._pathIterator.reset(key.path);\r\n            if (this._pathIterator.value()) {\r\n                this._states.push(3 /* Path */);\r\n            }\r\n        }\r\n        if (this._value.query) {\r\n            this._states.push(4 /* Query */);\r\n        }\r\n        if (this._value.fragment) {\r\n            this._states.push(5 /* Fragment */);\r\n        }\r\n        this._stateIdx = 0;\r\n        return this;\r\n    }\r\n    next() {\r\n        if (this._states[this._stateIdx] === 3 /* Path */ && this._pathIterator.hasNext()) {\r\n            this._pathIterator.next();\r\n        }\r\n        else {\r\n            this._stateIdx += 1;\r\n        }\r\n        return this;\r\n    }\r\n    hasNext() {\r\n        return (this._states[this._stateIdx] === 3 /* Path */ && this._pathIterator.hasNext())\r\n            || this._stateIdx < this._states.length - 1;\r\n    }\r\n    cmp(a) {\r\n        if (this._states[this._stateIdx] === 1 /* Scheme */) {\r\n            return compareIgnoreCase(a, this._value.scheme);\r\n        }\r\n        else if (this._states[this._stateIdx] === 2 /* Authority */) {\r\n            return compareIgnoreCase(a, this._value.authority);\r\n        }\r\n        else if (this._states[this._stateIdx] === 3 /* Path */) {\r\n            return this._pathIterator.cmp(a);\r\n        }\r\n        else if (this._states[this._stateIdx] === 4 /* Query */) {\r\n            return compare(a, this._value.query);\r\n        }\r\n        else if (this._states[this._stateIdx] === 5 /* Fragment */) {\r\n            return compare(a, this._value.fragment);\r\n        }\r\n        throw new Error();\r\n    }\r\n    value() {\r\n        if (this._states[this._stateIdx] === 1 /* Scheme */) {\r\n            return this._value.scheme;\r\n        }\r\n        else if (this._states[this._stateIdx] === 2 /* Authority */) {\r\n            return this._value.authority;\r\n        }\r\n        else if (this._states[this._stateIdx] === 3 /* Path */) {\r\n            return this._pathIterator.value();\r\n        }\r\n        else if (this._states[this._stateIdx] === 4 /* Query */) {\r\n            return this._value.query;\r\n        }\r\n        else if (this._states[this._stateIdx] === 5 /* Fragment */) {\r\n            return this._value.fragment;\r\n        }\r\n        throw new Error();\r\n    }\r\n}\r\nclass TernarySearchTreeNode {\r\n    isEmpty() {\r\n        return !this.left && !this.mid && !this.right && !this.value;\r\n    }\r\n}\r\nexport class TernarySearchTree {\r\n    constructor(segments) {\r\n        this._iter = segments;\r\n    }\r\n    static forUris(ignorePathCasing = () => false) {\r\n        return new TernarySearchTree(new UriIterator(ignorePathCasing));\r\n    }\r\n    static forStrings() {\r\n        return new TernarySearchTree(new StringIterator());\r\n    }\r\n    static forConfigKeys() {\r\n        return new TernarySearchTree(new ConfigKeysIterator());\r\n    }\r\n    clear() {\r\n        this._root = undefined;\r\n    }\r\n    set(key, element) {\r\n        const iter = this._iter.reset(key);\r\n        let node;\r\n        if (!this._root) {\r\n            this._root = new TernarySearchTreeNode();\r\n            this._root.segment = iter.value();\r\n        }\r\n        node = this._root;\r\n        while (true) {\r\n            const val = iter.cmp(node.segment);\r\n            if (val > 0) {\r\n                // left\r\n                if (!node.left) {\r\n                    node.left = new TernarySearchTreeNode();\r\n                    node.left.segment = iter.value();\r\n                }\r\n                node = node.left;\r\n            }\r\n            else if (val < 0) {\r\n                // right\r\n                if (!node.right) {\r\n                    node.right = new TernarySearchTreeNode();\r\n                    node.right.segment = iter.value();\r\n                }\r\n                node = node.right;\r\n            }\r\n            else if (iter.hasNext()) {\r\n                // mid\r\n                iter.next();\r\n                if (!node.mid) {\r\n                    node.mid = new TernarySearchTreeNode();\r\n                    node.mid.segment = iter.value();\r\n                }\r\n                node = node.mid;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        const oldElement = node.value;\r\n        node.value = element;\r\n        node.key = key;\r\n        return oldElement;\r\n    }\r\n    get(key) {\r\n        var _a;\r\n        return (_a = this._getNode(key)) === null || _a === void 0 ? void 0 : _a.value;\r\n    }\r\n    _getNode(key) {\r\n        const iter = this._iter.reset(key);\r\n        let node = this._root;\r\n        while (node) {\r\n            const val = iter.cmp(node.segment);\r\n            if (val > 0) {\r\n                // left\r\n                node = node.left;\r\n            }\r\n            else if (val < 0) {\r\n                // right\r\n                node = node.right;\r\n            }\r\n            else if (iter.hasNext()) {\r\n                // mid\r\n                iter.next();\r\n                node = node.mid;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n    has(key) {\r\n        const node = this._getNode(key);\r\n        return !((node === null || node === void 0 ? void 0 : node.value) === undefined && (node === null || node === void 0 ? void 0 : node.mid) === undefined);\r\n    }\r\n    delete(key) {\r\n        return this._delete(key, false);\r\n    }\r\n    deleteSuperstr(key) {\r\n        return this._delete(key, true);\r\n    }\r\n    _delete(key, superStr) {\r\n        const iter = this._iter.reset(key);\r\n        const stack = [];\r\n        let node = this._root;\r\n        // find and unset node\r\n        while (node) {\r\n            const val = iter.cmp(node.segment);\r\n            if (val > 0) {\r\n                // left\r\n                stack.push([1, node]);\r\n                node = node.left;\r\n            }\r\n            else if (val < 0) {\r\n                // right\r\n                stack.push([-1, node]);\r\n                node = node.right;\r\n            }\r\n            else if (iter.hasNext()) {\r\n                // mid\r\n                iter.next();\r\n                stack.push([0, node]);\r\n                node = node.mid;\r\n            }\r\n            else {\r\n                if (superStr) {\r\n                    // remove children\r\n                    node.left = undefined;\r\n                    node.mid = undefined;\r\n                    node.right = undefined;\r\n                }\r\n                else {\r\n                    // remove element\r\n                    node.value = undefined;\r\n                }\r\n                // clean up empty nodes\r\n                while (stack.length > 0 && node.isEmpty()) {\r\n                    let [dir, parent] = stack.pop();\r\n                    switch (dir) {\r\n                        case 1:\r\n                            parent.left = undefined;\r\n                            break;\r\n                        case 0:\r\n                            parent.mid = undefined;\r\n                            break;\r\n                        case -1:\r\n                            parent.right = undefined;\r\n                            break;\r\n                    }\r\n                    node = parent;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    findSubstr(key) {\r\n        const iter = this._iter.reset(key);\r\n        let node = this._root;\r\n        let candidate = undefined;\r\n        while (node) {\r\n            const val = iter.cmp(node.segment);\r\n            if (val > 0) {\r\n                // left\r\n                node = node.left;\r\n            }\r\n            else if (val < 0) {\r\n                // right\r\n                node = node.right;\r\n            }\r\n            else if (iter.hasNext()) {\r\n                // mid\r\n                iter.next();\r\n                candidate = node.value || candidate;\r\n                node = node.mid;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return node && node.value || candidate;\r\n    }\r\n    findSuperstr(key) {\r\n        const iter = this._iter.reset(key);\r\n        let node = this._root;\r\n        while (node) {\r\n            const val = iter.cmp(node.segment);\r\n            if (val > 0) {\r\n                // left\r\n                node = node.left;\r\n            }\r\n            else if (val < 0) {\r\n                // right\r\n                node = node.right;\r\n            }\r\n            else if (iter.hasNext()) {\r\n                // mid\r\n                iter.next();\r\n                node = node.mid;\r\n            }\r\n            else {\r\n                // collect\r\n                if (!node.mid) {\r\n                    return undefined;\r\n                }\r\n                else {\r\n                    return this._entries(node.mid);\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    forEach(callback) {\r\n        for (const [key, value] of this) {\r\n            callback(value, key);\r\n        }\r\n    }\r\n    *[Symbol.iterator]() {\r\n        yield* this._entries(this._root);\r\n    }\r\n    *_entries(node) {\r\n        if (node) {\r\n            // left\r\n            yield* this._entries(node.left);\r\n            // node\r\n            if (node.value) {\r\n                // callback(node.value, this._iter.join(parts));\r\n                yield [node.key, node.value];\r\n            }\r\n            // mid\r\n            yield* this._entries(node.mid);\r\n            // right\r\n            yield* this._entries(node.right);\r\n        }\r\n    }\r\n}\r\nexport class ResourceMap {\r\n    constructor(mapOrKeyFn, toKey) {\r\n        this[Symbol.toStringTag] = 'ResourceMap';\r\n        if (mapOrKeyFn instanceof ResourceMap) {\r\n            this.map = new Map(mapOrKeyFn.map);\r\n            this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\r\n        }\r\n        else {\r\n            this.map = new Map();\r\n            this.toKey = mapOrKeyFn !== null && mapOrKeyFn !== void 0 ? mapOrKeyFn : ResourceMap.defaultToKey;\r\n        }\r\n    }\r\n    set(resource, value) {\r\n        this.map.set(this.toKey(resource), value);\r\n        return this;\r\n    }\r\n    get(resource) {\r\n        return this.map.get(this.toKey(resource));\r\n    }\r\n    has(resource) {\r\n        return this.map.has(this.toKey(resource));\r\n    }\r\n    get size() {\r\n        return this.map.size;\r\n    }\r\n    clear() {\r\n        this.map.clear();\r\n    }\r\n    delete(resource) {\r\n        return this.map.delete(this.toKey(resource));\r\n    }\r\n    forEach(clb, thisArg) {\r\n        if (typeof thisArg !== 'undefined') {\r\n            clb = clb.bind(thisArg);\r\n        }\r\n        for (let [index, value] of this.map) {\r\n            clb(value, URI.parse(index), this);\r\n        }\r\n    }\r\n    values() {\r\n        return this.map.values();\r\n    }\r\n    *keys() {\r\n        for (let key of this.map.keys()) {\r\n            yield URI.parse(key);\r\n        }\r\n    }\r\n    *entries() {\r\n        for (let tuple of this.map.entries()) {\r\n            yield [URI.parse(tuple[0]), tuple[1]];\r\n        }\r\n    }\r\n    *[Symbol.iterator]() {\r\n        for (let item of this.map) {\r\n            yield [URI.parse(item[0]), item[1]];\r\n        }\r\n    }\r\n}\r\nResourceMap.defaultToKey = (resource) => resource.toString();\r\nexport class LinkedMap {\r\n    constructor() {\r\n        this[Symbol.toStringTag] = 'LinkedMap';\r\n        this._map = new Map();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n        this._state = 0;\r\n    }\r\n    clear() {\r\n        this._map.clear();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n        this._state++;\r\n    }\r\n    isEmpty() {\r\n        return !this._head && !this._tail;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    get first() {\r\n        var _a;\r\n        return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;\r\n    }\r\n    get last() {\r\n        var _a;\r\n        return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;\r\n    }\r\n    has(key) {\r\n        return this._map.has(key);\r\n    }\r\n    get(key, touch = 0 /* None */) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        if (touch !== 0 /* None */) {\r\n            this.touch(item, touch);\r\n        }\r\n        return item.value;\r\n    }\r\n    set(key, value, touch = 0 /* None */) {\r\n        let item = this._map.get(key);\r\n        if (item) {\r\n            item.value = value;\r\n            if (touch !== 0 /* None */) {\r\n                this.touch(item, touch);\r\n            }\r\n        }\r\n        else {\r\n            item = { key, value, next: undefined, previous: undefined };\r\n            switch (touch) {\r\n                case 0 /* None */:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                case 1 /* AsOld */:\r\n                    this.addItemFirst(item);\r\n                    break;\r\n                case 2 /* AsNew */:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                default:\r\n                    this.addItemLast(item);\r\n                    break;\r\n            }\r\n            this._map.set(key, item);\r\n            this._size++;\r\n        }\r\n        return this;\r\n    }\r\n    delete(key) {\r\n        return !!this.remove(key);\r\n    }\r\n    remove(key) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        this._map.delete(key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return item.value;\r\n    }\r\n    shift() {\r\n        if (!this._head && !this._tail) {\r\n            return undefined;\r\n        }\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        const item = this._head;\r\n        this._map.delete(item.key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return item.value;\r\n    }\r\n    forEach(callbackfn, thisArg) {\r\n        const state = this._state;\r\n        let current = this._head;\r\n        while (current) {\r\n            if (thisArg) {\r\n                callbackfn.bind(thisArg)(current.value, current.key, this);\r\n            }\r\n            else {\r\n                callbackfn(current.value, current.key, this);\r\n            }\r\n            if (this._state !== state) {\r\n                throw new Error(`LinkedMap got modified during iteration.`);\r\n            }\r\n            current = current.next;\r\n        }\r\n    }\r\n    keys() {\r\n        const map = this;\r\n        const state = this._state;\r\n        let current = this._head;\r\n        const iterator = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next() {\r\n                if (map._state !== state) {\r\n                    throw new Error(`LinkedMap got modified during iteration.`);\r\n                }\r\n                if (current) {\r\n                    const result = { value: current.key, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                }\r\n                else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    values() {\r\n        const map = this;\r\n        const state = this._state;\r\n        let current = this._head;\r\n        const iterator = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next() {\r\n                if (map._state !== state) {\r\n                    throw new Error(`LinkedMap got modified during iteration.`);\r\n                }\r\n                if (current) {\r\n                    const result = { value: current.value, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                }\r\n                else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    entries() {\r\n        const map = this;\r\n        const state = this._state;\r\n        let current = this._head;\r\n        const iterator = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next() {\r\n                if (map._state !== state) {\r\n                    throw new Error(`LinkedMap got modified during iteration.`);\r\n                }\r\n                if (current) {\r\n                    const result = { value: [current.key, current.value], done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                }\r\n                else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    [Symbol.iterator]() {\r\n        return this.entries();\r\n    }\r\n    trimOld(newSize) {\r\n        if (newSize >= this.size) {\r\n            return;\r\n        }\r\n        if (newSize === 0) {\r\n            this.clear();\r\n            return;\r\n        }\r\n        let current = this._head;\r\n        let currentSize = this.size;\r\n        while (current && currentSize > newSize) {\r\n            this._map.delete(current.key);\r\n            current = current.next;\r\n            currentSize--;\r\n        }\r\n        this._head = current;\r\n        this._size = currentSize;\r\n        if (current) {\r\n            current.previous = undefined;\r\n        }\r\n        this._state++;\r\n    }\r\n    addItemFirst(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._tail = item;\r\n        }\r\n        else if (!this._head) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n        }\r\n        this._head = item;\r\n        this._state++;\r\n    }\r\n    addItemLast(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._head = item;\r\n        }\r\n        else if (!this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n        }\r\n        this._tail = item;\r\n        this._state++;\r\n    }\r\n    removeItem(item) {\r\n        if (item === this._head && item === this._tail) {\r\n            this._head = undefined;\r\n            this._tail = undefined;\r\n        }\r\n        else if (item === this._head) {\r\n            // This can only happend if size === 1 which is handle\r\n            // by the case above.\r\n            if (!item.next) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            item.next.previous = undefined;\r\n            this._head = item.next;\r\n        }\r\n        else if (item === this._tail) {\r\n            // This can only happend if size === 1 which is handle\r\n            // by the case above.\r\n            if (!item.previous) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            item.previous.next = undefined;\r\n            this._tail = item.previous;\r\n        }\r\n        else {\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            if (!next || !previous) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            next.previous = previous;\r\n            previous.next = next;\r\n        }\r\n        item.next = undefined;\r\n        item.previous = undefined;\r\n        this._state++;\r\n    }\r\n    touch(item, touch) {\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        if ((touch !== 1 /* AsOld */ && touch !== 2 /* AsNew */)) {\r\n            return;\r\n        }\r\n        if (touch === 1 /* AsOld */) {\r\n            if (item === this._head) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item\r\n            if (item === this._tail) {\r\n                // previous must be defined since item was not head but is tail\r\n                // So there are more than on item in the map\r\n                previous.next = undefined;\r\n                this._tail = previous;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            // Insert the node at head\r\n            item.previous = undefined;\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n            this._head = item;\r\n            this._state++;\r\n        }\r\n        else if (touch === 2 /* AsNew */) {\r\n            if (item === this._tail) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item.\r\n            if (item === this._head) {\r\n                // next must be defined since item was not tail but is head\r\n                // So there are more than on item in the map\r\n                next.previous = undefined;\r\n                this._head = next;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            item.next = undefined;\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n            this._tail = item;\r\n            this._state++;\r\n        }\r\n    }\r\n    toJSON() {\r\n        const data = [];\r\n        this.forEach((value, key) => {\r\n            data.push([key, value]);\r\n        });\r\n        return data;\r\n    }\r\n    fromJSON(data) {\r\n        this.clear();\r\n        for (const [key, value] of data) {\r\n            this.set(key, value);\r\n        }\r\n    }\r\n}\r\nexport class LRUCache extends LinkedMap {\r\n    constructor(limit, ratio = 1) {\r\n        super();\r\n        this._limit = limit;\r\n        this._ratio = Math.min(Math.max(0, ratio), 1);\r\n    }\r\n    get limit() {\r\n        return this._limit;\r\n    }\r\n    set limit(limit) {\r\n        this._limit = limit;\r\n        this.checkTrim();\r\n    }\r\n    get(key, touch = 2 /* AsNew */) {\r\n        return super.get(key, touch);\r\n    }\r\n    peek(key) {\r\n        return super.get(key, 0 /* None */);\r\n    }\r\n    set(key, value) {\r\n        super.set(key, value, 2 /* AsNew */);\r\n        this.checkTrim();\r\n        return this;\r\n    }\r\n    checkTrim() {\r\n        if (this.size > this._limit) {\r\n            this.trimOld(Math.round(this._limit * this._ratio));\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}