{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { CursorColumns, EditOperationResult, isQuote } from './cursorCommon.js';\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { IndentAction } from '../modes/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nexport class TypeOperations {\n  static indent(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ShiftCommand(selections[i], {\n        isUnshift: false,\n        tabSize: config.tabSize,\n        indentSize: config.indentSize,\n        insertSpaces: config.insertSpaces,\n        useTabStops: config.useTabStops,\n        autoIndent: config.autoIndent\n      });\n    }\n    return commands;\n  }\n  static outdent(config, model, selections) {\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ShiftCommand(selections[i], {\n        isUnshift: true,\n        tabSize: config.tabSize,\n        indentSize: config.indentSize,\n        insertSpaces: config.insertSpaces,\n        useTabStops: config.useTabStops,\n        autoIndent: config.autoIndent\n      });\n    }\n    return commands;\n  }\n  static shiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n  }\n  static unshiftIndent(config, indentation, count) {\n    count = count || 1;\n    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n  }\n  static _distributedPaste(config, model, selections, text) {\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], text[i]);\n    }\n    return new EditOperationResult(0 /* Other */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n  static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      let position = selection.getPosition();\n      if (pasteOnNewLine && !selection.isEmpty()) {\n        pasteOnNewLine = false;\n      }\n      if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n        pasteOnNewLine = false;\n      }\n      if (pasteOnNewLine) {\n        // Paste entire line at the beginning of line\n        let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n        commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n      } else {\n        commands[i] = new ReplaceCommand(selection, text);\n      }\n    }\n    return new EditOperationResult(0 /* Other */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n  static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n    if (pasteOnNewLine) {\n      return null;\n    }\n    if (selections.length === 1) {\n      return null;\n    }\n    if (multicursorText && multicursorText.length === selections.length) {\n      return multicursorText;\n    }\n    if (config.multiCursorPaste === 'spread') {\n      // Try to spread the pasted text in case the line count matches the cursor count\n      // Remove trailing \\n if present\n      if (text.charCodeAt(text.length - 1) === 10 /* LineFeed */) {\n        text = text.substr(0, text.length - 1);\n      }\n      // Remove trailing \\r if present\n      if (text.charCodeAt(text.length - 1) === 13 /* CarriageReturn */) {\n        text = text.substr(0, text.length - 1);\n      }\n      let lines = strings.splitLines(text);\n      if (lines.length === selections.length) {\n        return lines;\n      }\n    }\n    return null;\n  }\n  static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n    const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n    if (distributedPaste) {\n      selections = selections.sort(Range.compareRangesUsingStarts);\n      return this._distributedPaste(config, model, selections, distributedPaste);\n    } else {\n      return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n    }\n  }\n  static _goodIndentForLine(config, model, lineNumber) {\n    let action = null;\n    let indentation = '';\n    const expectedIndentAction = LanguageConfigurationRegistry.getInheritIndentForLine(config.autoIndent, model, lineNumber, false);\n    if (expectedIndentAction) {\n      action = expectedIndentAction.action;\n      indentation = expectedIndentAction.indentation;\n    } else if (lineNumber > 1) {\n      let lastLineNumber;\n      for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n        const lineText = model.getLineContent(lastLineNumber);\n        const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n        if (nonWhitespaceIdx >= 0) {\n          break;\n        }\n      }\n      if (lastLineNumber < 1) {\n        // No previous line with content found\n        return null;\n      }\n      const maxColumn = model.getLineMaxColumn(lastLineNumber);\n      const expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\n      if (expectedEnterAction) {\n        indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n      }\n    }\n    if (action) {\n      if (action === IndentAction.Indent) {\n        indentation = TypeOperations.shiftIndent(config, indentation);\n      }\n      if (action === IndentAction.Outdent) {\n        indentation = TypeOperations.unshiftIndent(config, indentation);\n      }\n      indentation = config.normalizeIndentation(indentation);\n    }\n    if (!indentation) {\n      return null;\n    }\n    return indentation;\n  }\n  static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n    let typeText = '';\n    let position = selection.getStartPosition();\n    if (config.insertSpaces) {\n      let visibleColumnFromColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\n      let indentSize = config.indentSize;\n      let spacesCnt = indentSize - visibleColumnFromColumn % indentSize;\n      for (let i = 0; i < spacesCnt; i++) {\n        typeText += ' ';\n      }\n    } else {\n      typeText = '\\t';\n    }\n    return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n  }\n  static tab(config, model, selections) {\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      if (selection.isEmpty()) {\n        let lineText = model.getLineContent(selection.startLineNumber);\n        if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\n          let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n          goodIndent = goodIndent || '\\t';\n          let possibleTypeText = config.normalizeIndentation(goodIndent);\n          if (!lineText.startsWith(possibleTypeText)) {\n            commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n            continue;\n          }\n        }\n        commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n      } else {\n        if (selection.startLineNumber === selection.endLineNumber) {\n          let lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n          if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n            // This is a single line selection that is not the entire line\n            commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n            continue;\n          }\n        }\n        commands[i] = new ShiftCommand(selection, {\n          isUnshift: false,\n          tabSize: config.tabSize,\n          indentSize: config.indentSize,\n          insertSpaces: config.insertSpaces,\n          useTabStops: config.useTabStops,\n          autoIndent: config.autoIndent\n        });\n      }\n    }\n    return commands;\n  }\n  static replacePreviousChar(prevEditOperationType, config, model, selections, txt, replaceCharCnt) {\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      if (!selection.isEmpty()) {\n        // looks like https://github.com/microsoft/vscode/issues/2773\n        // where a cursor operation occurred before a canceled composition\n        // => ignore composition\n        commands[i] = null;\n        continue;\n      }\n      const pos = selection.getPosition();\n      const startColumn = Math.max(1, pos.column - replaceCharCnt);\n      const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);\n      const oldText = model.getValueInRange(range);\n      if (oldText === txt) {\n        // => ignore composition that doesn't do anything\n        commands[i] = null;\n        continue;\n      }\n      commands[i] = new ReplaceCommand(range, txt);\n    }\n    return new EditOperationResult(1 /* Typing */, commands, {\n      shouldPushStackElementBefore: prevEditOperationType !== 1 /* Typing */,\n      shouldPushStackElementAfter: false\n    });\n  }\n  static _typeCommand(range, text, keepPosition) {\n    if (keepPosition) {\n      return new ReplaceCommandWithoutChangingPosition(range, text, true);\n    } else {\n      return new ReplaceCommand(range, text, true);\n    }\n  }\n  static _enter(config, model, keepPosition, range) {\n    if (config.autoIndent === 0 /* None */) {\n      return TypeOperations._typeCommand(range, '\\n', keepPosition);\n    }\n    if (!model.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* Keep */) {\n      let lineText = model.getLineContent(range.startLineNumber);\n      let indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n      return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    const r = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, range);\n    if (r) {\n      if (r.indentAction === IndentAction.None) {\n        // Nothing special\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n      } else if (r.indentAction === IndentAction.Indent) {\n        // Indent once\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n      } else if (r.indentAction === IndentAction.IndentOutdent) {\n        // Ultra special\n        const normalIndent = config.normalizeIndentation(r.indentation);\n        const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n        const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n        if (keepPosition) {\n          return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n        } else {\n          return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n        }\n      } else if (r.indentAction === IndentAction.Outdent) {\n        const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n      }\n    }\n    const lineText = model.getLineContent(range.startLineNumber);\n    const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n    if (config.autoIndent >= 4 /* Full */) {\n      const ir = LanguageConfigurationRegistry.getIndentForEnter(config.autoIndent, model, range, {\n        unshiftIndent: indent => {\n          return TypeOperations.unshiftIndent(config, indent);\n        },\n        shiftIndent: indent => {\n          return TypeOperations.shiftIndent(config, indent);\n        },\n        normalizeIndentation: indent => {\n          return config.normalizeIndentation(indent);\n        }\n      });\n      if (ir) {\n        let oldEndViewColumn = CursorColumns.visibleColumnFromColumn2(config, model, range.getEndPosition());\n        const oldEndColumn = range.endColumn;\n        const newLineContent = model.getLineContent(range.endLineNumber);\n        const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n        if (firstNonWhitespace >= 0) {\n          range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n        } else {\n          range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n        }\n        if (keepPosition) {\n          return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n        } else {\n          let offset = 0;\n          if (oldEndColumn <= firstNonWhitespace + 1) {\n            if (!config.insertSpaces) {\n              oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n            }\n            offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n          }\n          return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n        }\n      }\n    }\n    return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n  }\n  static _isAutoIndentType(config, model, selections) {\n    if (config.autoIndent < 4 /* Full */) {\n      return false;\n    }\n    for (let i = 0, len = selections.length; i < len; i++) {\n      if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static _runAutoIndentType(config, model, range, ch) {\n    const currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    const actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(config.autoIndent, model, range, ch, {\n      shiftIndent: indentation => {\n        return TypeOperations.shiftIndent(config, indentation);\n      },\n      unshiftIndent: indentation => {\n        return TypeOperations.unshiftIndent(config, indentation);\n      }\n    });\n    if (actualIndentation === null) {\n      return null;\n    }\n    if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n      const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n      if (firstNonWhitespace === 0) {\n        return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n      } else {\n        return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n      }\n    }\n    return null;\n  }\n  static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n    if (config.autoClosingOvertype === 'never') {\n      return false;\n    }\n    if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n      return false;\n    }\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      if (!selection.isEmpty()) {\n        return false;\n      }\n      const position = selection.getPosition();\n      const lineText = model.getLineContent(position.lineNumber);\n      const afterCharacter = lineText.charAt(position.column - 1);\n      if (afterCharacter !== ch) {\n        return false;\n      }\n      // Do not over-type quotes after a backslash\n      const chIsQuote = isQuote(ch);\n      const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* Null */;\n      if (beforeCharacter === 92 /* Backslash */ && chIsQuote) {\n        return false;\n      }\n      // Must over-type a closing character typed by the editor\n      if (config.autoClosingOvertype === 'auto') {\n        let found = false;\n        for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n          const autoClosedCharacter = autoClosedCharacters[j];\n          if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const position = selection.getPosition();\n      const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n      commands[i] = new ReplaceCommand(typeSelection, ch);\n    }\n    return new EditOperationResult(1 /* Typing */, commands, {\n      shouldPushStackElementBefore: prevEditOperationType !== 1 /* Typing */,\n      shouldPushStackElementAfter: false\n    });\n  }\n  static _isBeforeClosingBrace(config, lineAfter) {\n    // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n    const nextChar = lineAfter.charAt(0);\n    const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n    const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n    const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n    const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n    return !isBeforeStartingBrace && isBeforeClosingBrace;\n  }\n  static _findAutoClosingPairOpen(config, model, positions, ch) {\n    const autoClosingPairCandidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n    if (!autoClosingPairCandidates) {\n      return null;\n    }\n    // Determine which auto-closing pair it is\n    let autoClosingPair = null;\n    for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n      if (autoClosingPair === null || autoClosingPairCandidate.open.length > autoClosingPair.open.length) {\n        let candidateIsMatch = true;\n        for (const position of positions) {\n          const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - autoClosingPairCandidate.open.length + 1, position.lineNumber, position.column));\n          if (relevantText + ch !== autoClosingPairCandidate.open) {\n            candidateIsMatch = false;\n            break;\n          }\n        }\n        if (candidateIsMatch) {\n          autoClosingPair = autoClosingPairCandidate;\n        }\n      }\n    }\n    return autoClosingPair;\n  }\n  static _findSubAutoClosingPairClose(config, autoClosingPair) {\n    if (autoClosingPair.open.length <= 1) {\n      return '';\n    }\n    const lastChar = autoClosingPair.close.charAt(autoClosingPair.close.length - 1);\n    // get candidates with the same last character as close\n    const subPairCandidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n    let subPairMatch = null;\n    for (const x of subPairCandidates) {\n      if (x.open !== autoClosingPair.open && autoClosingPair.open.includes(x.open) && autoClosingPair.close.endsWith(x.close)) {\n        if (!subPairMatch || x.open.length > subPairMatch.open.length) {\n          subPairMatch = x;\n        }\n      }\n    }\n    if (subPairMatch) {\n      return subPairMatch.close;\n    } else {\n      return '';\n    }\n  }\n  static _getAutoClosingPairClose(config, model, selections, ch, insertOpenCharacter) {\n    const chIsQuote = isQuote(ch);\n    const autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;\n    if (autoCloseConfig === 'never') {\n      return null;\n    }\n    const autoClosingPair = this._findAutoClosingPairOpen(config, model, selections.map(s => s.getPosition()), ch);\n    if (!autoClosingPair) {\n      return null;\n    }\n    const subAutoClosingPairClose = this._findSubAutoClosingPairClose(config, autoClosingPair);\n    let isSubAutoClosingPairPresent = true;\n    const shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      if (!selection.isEmpty()) {\n        return null;\n      }\n      const position = selection.getPosition();\n      const lineText = model.getLineContent(position.lineNumber);\n      const lineAfter = lineText.substring(position.column - 1);\n      if (!lineAfter.startsWith(subAutoClosingPairClose)) {\n        isSubAutoClosingPairPresent = false;\n      }\n      // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n      if (lineText.length > position.column - 1) {\n        const characterAfter = lineText.charAt(position.column - 1);\n        const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n        if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n          return null;\n        }\n      }\n      if (!model.isCheapToTokenize(position.lineNumber)) {\n        // Do not force tokenization\n        return null;\n      }\n      // Do not auto-close ' or \" after a word character\n      if (autoClosingPair.open.length === 1 && chIsQuote && autoCloseConfig !== 'always') {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n        if (insertOpenCharacter && position.column > 1 && wordSeparators.get(lineText.charCodeAt(position.column - 2)) === 0 /* Regular */) {\n          return null;\n        }\n        if (!insertOpenCharacter && position.column > 2 && wordSeparators.get(lineText.charCodeAt(position.column - 3)) === 0 /* Regular */) {\n          return null;\n        }\n      }\n      model.forceTokenization(position.lineNumber);\n      const lineTokens = model.getLineTokens(position.lineNumber);\n      let shouldAutoClosePair = false;\n      try {\n        shouldAutoClosePair = LanguageConfigurationRegistry.shouldAutoClosePair(autoClosingPair, lineTokens, insertOpenCharacter ? position.column : position.column - 1);\n      } catch (e) {\n        onUnexpectedError(e);\n      }\n      if (!shouldAutoClosePair) {\n        return null;\n      }\n    }\n    if (isSubAutoClosingPairPresent) {\n      return autoClosingPair.close.substring(0, autoClosingPair.close.length - subAutoClosingPairClose.length);\n    } else {\n      return autoClosingPair.close;\n    }\n  }\n  static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, insertOpenCharacter, autoClosingPairClose) {\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      commands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, autoClosingPairClose);\n    }\n    return new EditOperationResult(1 /* Typing */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: false\n    });\n  }\n  static _shouldSurroundChar(config, ch) {\n    if (isQuote(ch)) {\n      return config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined';\n    } else {\n      // Character is a bracket\n      return config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined';\n    }\n  }\n  static _isSurroundSelectionType(config, model, selections, ch) {\n    if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n      return false;\n    }\n    const isTypingAQuoteCharacter = isQuote(ch);\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      if (selection.isEmpty()) {\n        return false;\n      }\n      let selectionContainsOnlyWhitespace = true;\n      for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n        const lineText = model.getLineContent(lineNumber);\n        const startIndex = lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0;\n        const endIndex = lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length;\n        const selectedText = lineText.substring(startIndex, endIndex);\n        if (/[^ \\t]/.test(selectedText)) {\n          // this selected text contains something other than whitespace\n          selectionContainsOnlyWhitespace = false;\n          break;\n        }\n      }\n      if (selectionContainsOnlyWhitespace) {\n        return false;\n      }\n      if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n        const selectionText = model.getValueInRange(selection);\n        if (isQuote(selectionText)) {\n          // Typing a quote character on top of another quote character\n          // => disable surround selection type\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      const closeCharacter = config.surroundingPairs[ch];\n      commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n    }\n    return new EditOperationResult(0 /* Other */, commands, {\n      shouldPushStackElementBefore: true,\n      shouldPushStackElementAfter: true\n    });\n  }\n  static _isTypeInterceptorElectricChar(config, model, selections) {\n    if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n      return true;\n    }\n    return false;\n  }\n  static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n    if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n      return null;\n    }\n    let position = selection.getPosition();\n    model.forceTokenization(position.lineNumber);\n    let lineTokens = model.getLineTokens(position.lineNumber);\n    let electricAction;\n    try {\n      electricAction = LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);\n    } catch (e) {\n      onUnexpectedError(e);\n      return null;\n    }\n    if (!electricAction) {\n      return null;\n    }\n    if (electricAction.matchOpenBracket) {\n      let endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n      let match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {\n        lineNumber: position.lineNumber,\n        column: endColumn\n      });\n      if (match) {\n        if (match.startLineNumber === position.lineNumber) {\n          // matched something on the same line => no change in indentation\n          return null;\n        }\n        let matchLine = model.getLineContent(match.startLineNumber);\n        let matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n        let newIndentation = config.normalizeIndentation(matchLineIndentation);\n        let lineText = model.getLineContent(position.lineNumber);\n        let lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n        let prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n        let typeText = newIndentation + prefix + ch;\n        let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n        const command = new ReplaceCommand(typeSelection, typeText);\n        return new EditOperationResult(1 /* Typing */, [command], {\n          shouldPushStackElementBefore: false,\n          shouldPushStackElementAfter: true\n        });\n      }\n    }\n    return null;\n  }\n  /**\r\n   * This is very similar with typing, but the character is already in the text buffer!\r\n   */\n  static compositionEndWithInterceptors(prevEditOperationType, config, model, selectionsWhenCompositionStarted, selections, autoClosedCharacters) {\n    if (!selectionsWhenCompositionStarted || Selection.selectionsArrEqual(selectionsWhenCompositionStarted, selections)) {\n      // no content was typed\n      return null;\n    }\n    let ch = null;\n    // extract last typed character\n    for (const selection of selections) {\n      if (!selection.isEmpty()) {\n        return null;\n      }\n      const position = selection.getPosition();\n      const currentChar = model.getValueInRange(new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column));\n      if (ch === null) {\n        ch = currentChar;\n      } else if (ch !== currentChar) {\n        return null;\n      }\n    }\n    if (!ch) {\n      return null;\n    }\n    if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n      // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n      const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n      return new EditOperationResult(1 /* Typing */, commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n    const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n    if (autoClosingPairClose !== null) {\n      return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n    }\n    return null;\n  }\n  static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n    if (!isDoingComposition && ch === '\\n') {\n      let commands = [];\n      for (let i = 0, len = selections.length; i < len; i++) {\n        commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n      }\n      return new EditOperationResult(1 /* Typing */, commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n    if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n      let commands = [];\n      let autoIndentFails = false;\n      for (let i = 0, len = selections.length; i < len; i++) {\n        commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n        if (!commands[i]) {\n          autoIndentFails = true;\n          break;\n        }\n      }\n      if (!autoIndentFails) {\n        return new EditOperationResult(1 /* Typing */, commands, {\n          shouldPushStackElementBefore: true,\n          shouldPushStackElementAfter: false\n        });\n      }\n    }\n    if (!isDoingComposition && this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n      return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n    }\n    if (!isDoingComposition) {\n      const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n      if (autoClosingPairClose) {\n        return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n      }\n    }\n    if (this._isSurroundSelectionType(config, model, selections, ch)) {\n      return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n    }\n    // Electric characters make sense only when dealing with a single cursor,\n    // as multiple cursors typing brackets for example would interfer with bracket matching\n    if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n      const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n      if (r) {\n        return r;\n      }\n    }\n    // A simple character type\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], ch);\n    }\n    let shouldPushStackElementBefore = prevEditOperationType !== 1 /* Typing */;\n    if (ch === ' ') {\n      shouldPushStackElementBefore = true;\n    }\n    return new EditOperationResult(1 /* Typing */, commands, {\n      shouldPushStackElementBefore: shouldPushStackElementBefore,\n      shouldPushStackElementAfter: false\n    });\n  }\n  static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = new ReplaceCommand(selections[i], str);\n    }\n    return new EditOperationResult(1 /* Typing */, commands, {\n      shouldPushStackElementBefore: prevEditOperationType !== 1 /* Typing */,\n      shouldPushStackElementAfter: false\n    });\n  }\n  static lineInsertBefore(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      let lineNumber = selections[i].positionLineNumber;\n      if (lineNumber === 1) {\n        commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n      } else {\n        lineNumber--;\n        let column = model.getLineMaxColumn(lineNumber);\n        commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n      }\n    }\n    return commands;\n  }\n  static lineInsertAfter(config, model, selections) {\n    if (model === null || selections === null) {\n      return [];\n    }\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      const lineNumber = selections[i].positionLineNumber;\n      let column = model.getLineMaxColumn(lineNumber);\n      commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n    }\n    return commands;\n  }\n  static lineBreakInsert(config, model, selections) {\n    let commands = [];\n    for (let i = 0, len = selections.length; i < len; i++) {\n      commands[i] = this._enter(config, model, true, selections[i]);\n    }\n    return commands;\n  }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n  constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n    super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n    this._openCharacter = openCharacter;\n    this._closeCharacter = closeCharacter;\n    this.closeCharacterRange = null;\n    this.enclosingRange = null;\n  }\n  computeCursorState(model, helper) {\n    let inverseEditOperations = helper.getInverseEditOperations();\n    let range = inverseEditOperations[0].range;\n    this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n    this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n    return super.computeCursorState(model, helper);\n  }\n}","map":{"version":3,"names":["onUnexpectedError","strings","ReplaceCommand","ReplaceCommandWithOffsetCursorState","ReplaceCommandWithoutChangingPosition","ReplaceCommandThatPreservesSelection","ShiftCommand","SurroundSelectionCommand","CursorColumns","EditOperationResult","isQuote","getMapForWordSeparators","Range","Selection","IndentAction","LanguageConfigurationRegistry","TypeOperations","indent","config","model","selections","commands","i","len","length","isUnshift","tabSize","indentSize","insertSpaces","useTabStops","autoIndent","outdent","shiftIndent","indentation","count","unshiftIndent","_distributedPaste","text","shouldPushStackElementBefore","shouldPushStackElementAfter","_simplePaste","pasteOnNewLine","selection","position","getPosition","isEmpty","indexOf","typeSelection","lineNumber","_distributePasteToCursors","multicursorText","multiCursorPaste","charCodeAt","substr","lines","splitLines","paste","distributedPaste","sort","compareRangesUsingStarts","_goodIndentForLine","action","expectedIndentAction","getInheritIndentForLine","lastLineNumber","lineText","getLineContent","nonWhitespaceIdx","lastNonWhitespaceIndex","maxColumn","getLineMaxColumn","expectedEnterAction","getEnterAction","appendText","Indent","Outdent","normalizeIndentation","_replaceJumpToNextIndent","insertsAutoWhitespace","typeText","getStartPosition","visibleColumnFromColumn","visibleColumnFromColumn2","spacesCnt","tab","startLineNumber","test","isCheapToTokenize","goodIndent","possibleTypeText","startsWith","endLineNumber","lineMaxColumn","startColumn","endColumn","replacePreviousChar","prevEditOperationType","txt","replaceCharCnt","pos","Math","max","column","range","oldText","getValueInRange","_typeCommand","keepPosition","_enter","getLeadingWhitespace","substring","r","indentAction","None","IndentOutdent","normalIndent","increasedIndent","actualIndentation","ir","getIndentForEnter","oldEndViewColumn","getEndPosition","oldEndColumn","newLineContent","firstNonWhitespace","firstNonWhitespaceIndex","setEndPosition","afterEnter","offset","ceil","min","_isAutoIndentType","_runAutoIndentType","ch","currentIndentation","getIndentationAtPosition","getIndentActionForType","getLineFirstNonWhitespaceColumn","_isAutoClosingOvertype","autoClosedCharacters","autoClosingOvertype","autoClosingPairs","autoClosingPairsCloseSingleChar","has","afterCharacter","charAt","chIsQuote","beforeCharacter","found","j","lenJ","autoClosedCharacter","_runAutoClosingOvertype","_isBeforeClosingBrace","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","get","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","some","x","open","isBeforeClosingBrace","close","_findAutoClosingPairOpen","positions","autoClosingPairCandidates","autoClosingPairsOpenByEnd","autoClosingPair","autoClosingPairCandidate","candidateIsMatch","relevantText","_findSubAutoClosingPairClose","lastChar","subPairCandidates","autoClosingPairsCloseByEnd","subPairMatch","includes","endsWith","_getAutoClosingPairClose","insertOpenCharacter","autoCloseConfig","autoClosingQuotes","autoClosingBrackets","map","s","subAutoClosingPairClose","isSubAutoClosingPairPresent","shouldAutoCloseBefore","quote","bracket","characterAfter","isBeforeCloseBrace","wordSeparators","forceTokenization","lineTokens","getLineTokens","shouldAutoClosePair","e","_runAutoClosingOpenCharType","autoClosingPairClose","TypeWithAutoClosingCommand","_shouldSurroundChar","autoSurround","_isSurroundSelectionType","surroundingPairs","hasOwnProperty","isTypingAQuoteCharacter","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","_runSurroundSelectionType","closeCharacter","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","electricChars","electricAction","onElectricCharacter","matchOpenBracket","lastIndexOf","match","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","prefix","command","compositionEndWithInterceptors","selectionsWhenCompositionStarted","selectionsArrEqual","currentChar","positionLineNumber","positionColumn","typeWithInterceptors","isDoingComposition","autoIndentFails","typeWithoutInterceptors","str","lineInsertBefore","lineInsertAfter","lineBreakInsert","constructor","openCharacter","_openCharacter","_closeCharacter","closeCharacterRange","enclosingRange","computeCursorState","helper","inverseEditOperations","getInverseEditOperations"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/controller/cursorTypeOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { onUnexpectedError } from '../../../base/common/errors.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\r\nimport { ShiftCommand } from '../commands/shiftCommand.js';\r\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\r\nimport { CursorColumns, EditOperationResult, isQuote } from './cursorCommon.js';\r\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\r\nimport { Range } from '../core/range.js';\r\nimport { Selection } from '../core/selection.js';\r\nimport { IndentAction } from '../modes/languageConfiguration.js';\r\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\r\nexport class TypeOperations {\r\n    static indent(config, model, selections) {\r\n        if (model === null || selections === null) {\r\n            return [];\r\n        }\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            commands[i] = new ShiftCommand(selections[i], {\r\n                isUnshift: false,\r\n                tabSize: config.tabSize,\r\n                indentSize: config.indentSize,\r\n                insertSpaces: config.insertSpaces,\r\n                useTabStops: config.useTabStops,\r\n                autoIndent: config.autoIndent\r\n            });\r\n        }\r\n        return commands;\r\n    }\r\n    static outdent(config, model, selections) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            commands[i] = new ShiftCommand(selections[i], {\r\n                isUnshift: true,\r\n                tabSize: config.tabSize,\r\n                indentSize: config.indentSize,\r\n                insertSpaces: config.insertSpaces,\r\n                useTabStops: config.useTabStops,\r\n                autoIndent: config.autoIndent\r\n            });\r\n        }\r\n        return commands;\r\n    }\r\n    static shiftIndent(config, indentation, count) {\r\n        count = count || 1;\r\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\r\n    }\r\n    static unshiftIndent(config, indentation, count) {\r\n        count = count || 1;\r\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\r\n    }\r\n    static _distributedPaste(config, model, selections, text) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\r\n        }\r\n        return new EditOperationResult(0 /* Other */, commands, {\r\n            shouldPushStackElementBefore: true,\r\n            shouldPushStackElementAfter: true\r\n        });\r\n    }\r\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            let position = selection.getPosition();\r\n            if (pasteOnNewLine && !selection.isEmpty()) {\r\n                pasteOnNewLine = false;\r\n            }\r\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\r\n                pasteOnNewLine = false;\r\n            }\r\n            if (pasteOnNewLine) {\r\n                // Paste entire line at the beginning of line\r\n                let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\r\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\r\n            }\r\n            else {\r\n                commands[i] = new ReplaceCommand(selection, text);\r\n            }\r\n        }\r\n        return new EditOperationResult(0 /* Other */, commands, {\r\n            shouldPushStackElementBefore: true,\r\n            shouldPushStackElementAfter: true\r\n        });\r\n    }\r\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\r\n        if (pasteOnNewLine) {\r\n            return null;\r\n        }\r\n        if (selections.length === 1) {\r\n            return null;\r\n        }\r\n        if (multicursorText && multicursorText.length === selections.length) {\r\n            return multicursorText;\r\n        }\r\n        if (config.multiCursorPaste === 'spread') {\r\n            // Try to spread the pasted text in case the line count matches the cursor count\r\n            // Remove trailing \\n if present\r\n            if (text.charCodeAt(text.length - 1) === 10 /* LineFeed */) {\r\n                text = text.substr(0, text.length - 1);\r\n            }\r\n            // Remove trailing \\r if present\r\n            if (text.charCodeAt(text.length - 1) === 13 /* CarriageReturn */) {\r\n                text = text.substr(0, text.length - 1);\r\n            }\r\n            let lines = strings.splitLines(text);\r\n            if (lines.length === selections.length) {\r\n                return lines;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\r\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\r\n        if (distributedPaste) {\r\n            selections = selections.sort(Range.compareRangesUsingStarts);\r\n            return this._distributedPaste(config, model, selections, distributedPaste);\r\n        }\r\n        else {\r\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\r\n        }\r\n    }\r\n    static _goodIndentForLine(config, model, lineNumber) {\r\n        let action = null;\r\n        let indentation = '';\r\n        const expectedIndentAction = LanguageConfigurationRegistry.getInheritIndentForLine(config.autoIndent, model, lineNumber, false);\r\n        if (expectedIndentAction) {\r\n            action = expectedIndentAction.action;\r\n            indentation = expectedIndentAction.indentation;\r\n        }\r\n        else if (lineNumber > 1) {\r\n            let lastLineNumber;\r\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\r\n                const lineText = model.getLineContent(lastLineNumber);\r\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\r\n                if (nonWhitespaceIdx >= 0) {\r\n                    break;\r\n                }\r\n            }\r\n            if (lastLineNumber < 1) {\r\n                // No previous line with content found\r\n                return null;\r\n            }\r\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\r\n            const expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\r\n            if (expectedEnterAction) {\r\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\r\n            }\r\n        }\r\n        if (action) {\r\n            if (action === IndentAction.Indent) {\r\n                indentation = TypeOperations.shiftIndent(config, indentation);\r\n            }\r\n            if (action === IndentAction.Outdent) {\r\n                indentation = TypeOperations.unshiftIndent(config, indentation);\r\n            }\r\n            indentation = config.normalizeIndentation(indentation);\r\n        }\r\n        if (!indentation) {\r\n            return null;\r\n        }\r\n        return indentation;\r\n    }\r\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\r\n        let typeText = '';\r\n        let position = selection.getStartPosition();\r\n        if (config.insertSpaces) {\r\n            let visibleColumnFromColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\r\n            let indentSize = config.indentSize;\r\n            let spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\r\n            for (let i = 0; i < spacesCnt; i++) {\r\n                typeText += ' ';\r\n            }\r\n        }\r\n        else {\r\n            typeText = '\\t';\r\n        }\r\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\r\n    }\r\n    static tab(config, model, selections) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            if (selection.isEmpty()) {\r\n                let lineText = model.getLineContent(selection.startLineNumber);\r\n                if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\r\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\r\n                    goodIndent = goodIndent || '\\t';\r\n                    let possibleTypeText = config.normalizeIndentation(goodIndent);\r\n                    if (!lineText.startsWith(possibleTypeText)) {\r\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\r\n                        continue;\r\n                    }\r\n                }\r\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\r\n            }\r\n            else {\r\n                if (selection.startLineNumber === selection.endLineNumber) {\r\n                    let lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\r\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\r\n                        // This is a single line selection that is not the entire line\r\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\r\n                        continue;\r\n                    }\r\n                }\r\n                commands[i] = new ShiftCommand(selection, {\r\n                    isUnshift: false,\r\n                    tabSize: config.tabSize,\r\n                    indentSize: config.indentSize,\r\n                    insertSpaces: config.insertSpaces,\r\n                    useTabStops: config.useTabStops,\r\n                    autoIndent: config.autoIndent\r\n                });\r\n            }\r\n        }\r\n        return commands;\r\n    }\r\n    static replacePreviousChar(prevEditOperationType, config, model, selections, txt, replaceCharCnt) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            if (!selection.isEmpty()) {\r\n                // looks like https://github.com/microsoft/vscode/issues/2773\r\n                // where a cursor operation occurred before a canceled composition\r\n                // => ignore composition\r\n                commands[i] = null;\r\n                continue;\r\n            }\r\n            const pos = selection.getPosition();\r\n            const startColumn = Math.max(1, pos.column - replaceCharCnt);\r\n            const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);\r\n            const oldText = model.getValueInRange(range);\r\n            if (oldText === txt) {\r\n                // => ignore composition that doesn't do anything\r\n                commands[i] = null;\r\n                continue;\r\n            }\r\n            commands[i] = new ReplaceCommand(range, txt);\r\n        }\r\n        return new EditOperationResult(1 /* Typing */, commands, {\r\n            shouldPushStackElementBefore: (prevEditOperationType !== 1 /* Typing */),\r\n            shouldPushStackElementAfter: false\r\n        });\r\n    }\r\n    static _typeCommand(range, text, keepPosition) {\r\n        if (keepPosition) {\r\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\r\n        }\r\n        else {\r\n            return new ReplaceCommand(range, text, true);\r\n        }\r\n    }\r\n    static _enter(config, model, keepPosition, range) {\r\n        if (config.autoIndent === 0 /* None */) {\r\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\r\n        }\r\n        if (!model.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* Keep */) {\r\n            let lineText = model.getLineContent(range.startLineNumber);\r\n            let indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\r\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\r\n        }\r\n        const r = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, range);\r\n        if (r) {\r\n            if (r.indentAction === IndentAction.None) {\r\n                // Nothing special\r\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\r\n            }\r\n            else if (r.indentAction === IndentAction.Indent) {\r\n                // Indent once\r\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\r\n            }\r\n            else if (r.indentAction === IndentAction.IndentOutdent) {\r\n                // Ultra special\r\n                const normalIndent = config.normalizeIndentation(r.indentation);\r\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\r\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\r\n                if (keepPosition) {\r\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\r\n                }\r\n                else {\r\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\r\n                }\r\n            }\r\n            else if (r.indentAction === IndentAction.Outdent) {\r\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\r\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\r\n            }\r\n        }\r\n        const lineText = model.getLineContent(range.startLineNumber);\r\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\r\n        if (config.autoIndent >= 4 /* Full */) {\r\n            const ir = LanguageConfigurationRegistry.getIndentForEnter(config.autoIndent, model, range, {\r\n                unshiftIndent: (indent) => {\r\n                    return TypeOperations.unshiftIndent(config, indent);\r\n                },\r\n                shiftIndent: (indent) => {\r\n                    return TypeOperations.shiftIndent(config, indent);\r\n                },\r\n                normalizeIndentation: (indent) => {\r\n                    return config.normalizeIndentation(indent);\r\n                }\r\n            });\r\n            if (ir) {\r\n                let oldEndViewColumn = CursorColumns.visibleColumnFromColumn2(config, model, range.getEndPosition());\r\n                const oldEndColumn = range.endColumn;\r\n                const newLineContent = model.getLineContent(range.endLineNumber);\r\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\r\n                if (firstNonWhitespace >= 0) {\r\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\r\n                }\r\n                else {\r\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\r\n                }\r\n                if (keepPosition) {\r\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\r\n                }\r\n                else {\r\n                    let offset = 0;\r\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\r\n                        if (!config.insertSpaces) {\r\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\r\n                        }\r\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\r\n                    }\r\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\r\n                }\r\n            }\r\n        }\r\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\r\n    }\r\n    static _isAutoIndentType(config, model, selections) {\r\n        if (config.autoIndent < 4 /* Full */) {\r\n            return false;\r\n        }\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static _runAutoIndentType(config, model, range, ch) {\r\n        const currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\r\n        const actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(config.autoIndent, model, range, ch, {\r\n            shiftIndent: (indentation) => {\r\n                return TypeOperations.shiftIndent(config, indentation);\r\n            },\r\n            unshiftIndent: (indentation) => {\r\n                return TypeOperations.unshiftIndent(config, indentation);\r\n            },\r\n        });\r\n        if (actualIndentation === null) {\r\n            return null;\r\n        }\r\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\r\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\r\n            if (firstNonWhitespace === 0) {\r\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\r\n            }\r\n            else {\r\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\r\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\r\n        if (config.autoClosingOvertype === 'never') {\r\n            return false;\r\n        }\r\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\r\n            return false;\r\n        }\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            if (!selection.isEmpty()) {\r\n                return false;\r\n            }\r\n            const position = selection.getPosition();\r\n            const lineText = model.getLineContent(position.lineNumber);\r\n            const afterCharacter = lineText.charAt(position.column - 1);\r\n            if (afterCharacter !== ch) {\r\n                return false;\r\n            }\r\n            // Do not over-type quotes after a backslash\r\n            const chIsQuote = isQuote(ch);\r\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* Null */;\r\n            if (beforeCharacter === 92 /* Backslash */ && chIsQuote) {\r\n                return false;\r\n            }\r\n            // Must over-type a closing character typed by the editor\r\n            if (config.autoClosingOvertype === 'auto') {\r\n                let found = false;\r\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\r\n                    const autoClosedCharacter = autoClosedCharacters[j];\r\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            const position = selection.getPosition();\r\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\r\n            commands[i] = new ReplaceCommand(typeSelection, ch);\r\n        }\r\n        return new EditOperationResult(1 /* Typing */, commands, {\r\n            shouldPushStackElementBefore: (prevEditOperationType !== 1 /* Typing */),\r\n            shouldPushStackElementAfter: false\r\n        });\r\n    }\r\n    static _isBeforeClosingBrace(config, lineAfter) {\r\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\r\n        const nextChar = lineAfter.charAt(0);\r\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\r\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\r\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\r\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\r\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\r\n    }\r\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\r\n        const autoClosingPairCandidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\r\n        if (!autoClosingPairCandidates) {\r\n            return null;\r\n        }\r\n        // Determine which auto-closing pair it is\r\n        let autoClosingPair = null;\r\n        for (const autoClosingPairCandidate of autoClosingPairCandidates) {\r\n            if (autoClosingPair === null || autoClosingPairCandidate.open.length > autoClosingPair.open.length) {\r\n                let candidateIsMatch = true;\r\n                for (const position of positions) {\r\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - autoClosingPairCandidate.open.length + 1, position.lineNumber, position.column));\r\n                    if (relevantText + ch !== autoClosingPairCandidate.open) {\r\n                        candidateIsMatch = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (candidateIsMatch) {\r\n                    autoClosingPair = autoClosingPairCandidate;\r\n                }\r\n            }\r\n        }\r\n        return autoClosingPair;\r\n    }\r\n    static _findSubAutoClosingPairClose(config, autoClosingPair) {\r\n        if (autoClosingPair.open.length <= 1) {\r\n            return '';\r\n        }\r\n        const lastChar = autoClosingPair.close.charAt(autoClosingPair.close.length - 1);\r\n        // get candidates with the same last character as close\r\n        const subPairCandidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\r\n        let subPairMatch = null;\r\n        for (const x of subPairCandidates) {\r\n            if (x.open !== autoClosingPair.open && autoClosingPair.open.includes(x.open) && autoClosingPair.close.endsWith(x.close)) {\r\n                if (!subPairMatch || x.open.length > subPairMatch.open.length) {\r\n                    subPairMatch = x;\r\n                }\r\n            }\r\n        }\r\n        if (subPairMatch) {\r\n            return subPairMatch.close;\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    static _getAutoClosingPairClose(config, model, selections, ch, insertOpenCharacter) {\r\n        const chIsQuote = isQuote(ch);\r\n        const autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;\r\n        if (autoCloseConfig === 'never') {\r\n            return null;\r\n        }\r\n        const autoClosingPair = this._findAutoClosingPairOpen(config, model, selections.map(s => s.getPosition()), ch);\r\n        if (!autoClosingPair) {\r\n            return null;\r\n        }\r\n        const subAutoClosingPairClose = this._findSubAutoClosingPairClose(config, autoClosingPair);\r\n        let isSubAutoClosingPairPresent = true;\r\n        const shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            if (!selection.isEmpty()) {\r\n                return null;\r\n            }\r\n            const position = selection.getPosition();\r\n            const lineText = model.getLineContent(position.lineNumber);\r\n            const lineAfter = lineText.substring(position.column - 1);\r\n            if (!lineAfter.startsWith(subAutoClosingPairClose)) {\r\n                isSubAutoClosingPairPresent = false;\r\n            }\r\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\r\n            if (lineText.length > position.column - 1) {\r\n                const characterAfter = lineText.charAt(position.column - 1);\r\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\r\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\r\n                    return null;\r\n                }\r\n            }\r\n            if (!model.isCheapToTokenize(position.lineNumber)) {\r\n                // Do not force tokenization\r\n                return null;\r\n            }\r\n            // Do not auto-close ' or \" after a word character\r\n            if (autoClosingPair.open.length === 1 && chIsQuote && autoCloseConfig !== 'always') {\r\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\r\n                if (insertOpenCharacter && position.column > 1 && wordSeparators.get(lineText.charCodeAt(position.column - 2)) === 0 /* Regular */) {\r\n                    return null;\r\n                }\r\n                if (!insertOpenCharacter && position.column > 2 && wordSeparators.get(lineText.charCodeAt(position.column - 3)) === 0 /* Regular */) {\r\n                    return null;\r\n                }\r\n            }\r\n            model.forceTokenization(position.lineNumber);\r\n            const lineTokens = model.getLineTokens(position.lineNumber);\r\n            let shouldAutoClosePair = false;\r\n            try {\r\n                shouldAutoClosePair = LanguageConfigurationRegistry.shouldAutoClosePair(autoClosingPair, lineTokens, insertOpenCharacter ? position.column : position.column - 1);\r\n            }\r\n            catch (e) {\r\n                onUnexpectedError(e);\r\n            }\r\n            if (!shouldAutoClosePair) {\r\n                return null;\r\n            }\r\n        }\r\n        if (isSubAutoClosingPairPresent) {\r\n            return autoClosingPair.close.substring(0, autoClosingPair.close.length - subAutoClosingPairClose.length);\r\n        }\r\n        else {\r\n            return autoClosingPair.close;\r\n        }\r\n    }\r\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, insertOpenCharacter, autoClosingPairClose) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, autoClosingPairClose);\r\n        }\r\n        return new EditOperationResult(1 /* Typing */, commands, {\r\n            shouldPushStackElementBefore: true,\r\n            shouldPushStackElementAfter: false\r\n        });\r\n    }\r\n    static _shouldSurroundChar(config, ch) {\r\n        if (isQuote(ch)) {\r\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\r\n        }\r\n        else {\r\n            // Character is a bracket\r\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\r\n        }\r\n    }\r\n    static _isSurroundSelectionType(config, model, selections, ch) {\r\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\r\n            return false;\r\n        }\r\n        const isTypingAQuoteCharacter = isQuote(ch);\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            if (selection.isEmpty()) {\r\n                return false;\r\n            }\r\n            let selectionContainsOnlyWhitespace = true;\r\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\r\n                const lineText = model.getLineContent(lineNumber);\r\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\r\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\r\n                const selectedText = lineText.substring(startIndex, endIndex);\r\n                if (/[^ \\t]/.test(selectedText)) {\r\n                    // this selected text contains something other than whitespace\r\n                    selectionContainsOnlyWhitespace = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (selectionContainsOnlyWhitespace) {\r\n                return false;\r\n            }\r\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\r\n                const selectionText = model.getValueInRange(selection);\r\n                if (isQuote(selectionText)) {\r\n                    // Typing a quote character on top of another quote character\r\n                    // => disable surround selection type\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            const closeCharacter = config.surroundingPairs[ch];\r\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\r\n        }\r\n        return new EditOperationResult(0 /* Other */, commands, {\r\n            shouldPushStackElementBefore: true,\r\n            shouldPushStackElementAfter: true\r\n        });\r\n    }\r\n    static _isTypeInterceptorElectricChar(config, model, selections) {\r\n        if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\r\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\r\n            return null;\r\n        }\r\n        let position = selection.getPosition();\r\n        model.forceTokenization(position.lineNumber);\r\n        let lineTokens = model.getLineTokens(position.lineNumber);\r\n        let electricAction;\r\n        try {\r\n            electricAction = LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);\r\n        }\r\n        catch (e) {\r\n            onUnexpectedError(e);\r\n            return null;\r\n        }\r\n        if (!electricAction) {\r\n            return null;\r\n        }\r\n        if (electricAction.matchOpenBracket) {\r\n            let endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\r\n            let match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {\r\n                lineNumber: position.lineNumber,\r\n                column: endColumn\r\n            });\r\n            if (match) {\r\n                if (match.startLineNumber === position.lineNumber) {\r\n                    // matched something on the same line => no change in indentation\r\n                    return null;\r\n                }\r\n                let matchLine = model.getLineContent(match.startLineNumber);\r\n                let matchLineIndentation = strings.getLeadingWhitespace(matchLine);\r\n                let newIndentation = config.normalizeIndentation(matchLineIndentation);\r\n                let lineText = model.getLineContent(position.lineNumber);\r\n                let lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\r\n                let prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\r\n                let typeText = newIndentation + prefix + ch;\r\n                let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\r\n                const command = new ReplaceCommand(typeSelection, typeText);\r\n                return new EditOperationResult(1 /* Typing */, [command], {\r\n                    shouldPushStackElementBefore: false,\r\n                    shouldPushStackElementAfter: true\r\n                });\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * This is very similar with typing, but the character is already in the text buffer!\r\n     */\r\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, selectionsWhenCompositionStarted, selections, autoClosedCharacters) {\r\n        if (!selectionsWhenCompositionStarted || Selection.selectionsArrEqual(selectionsWhenCompositionStarted, selections)) {\r\n            // no content was typed\r\n            return null;\r\n        }\r\n        let ch = null;\r\n        // extract last typed character\r\n        for (const selection of selections) {\r\n            if (!selection.isEmpty()) {\r\n                return null;\r\n            }\r\n            const position = selection.getPosition();\r\n            const currentChar = model.getValueInRange(new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column));\r\n            if (ch === null) {\r\n                ch = currentChar;\r\n            }\r\n            else if (ch !== currentChar) {\r\n                return null;\r\n            }\r\n        }\r\n        if (!ch) {\r\n            return null;\r\n        }\r\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\r\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\r\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\r\n            return new EditOperationResult(1 /* Typing */, commands, {\r\n                shouldPushStackElementBefore: true,\r\n                shouldPushStackElementAfter: false\r\n            });\r\n        }\r\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\r\n        if (autoClosingPairClose !== null) {\r\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\r\n        }\r\n        return null;\r\n    }\r\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\r\n        if (!isDoingComposition && ch === '\\n') {\r\n            let commands = [];\r\n            for (let i = 0, len = selections.length; i < len; i++) {\r\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\r\n            }\r\n            return new EditOperationResult(1 /* Typing */, commands, {\r\n                shouldPushStackElementBefore: true,\r\n                shouldPushStackElementAfter: false,\r\n            });\r\n        }\r\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\r\n            let commands = [];\r\n            let autoIndentFails = false;\r\n            for (let i = 0, len = selections.length; i < len; i++) {\r\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\r\n                if (!commands[i]) {\r\n                    autoIndentFails = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!autoIndentFails) {\r\n                return new EditOperationResult(1 /* Typing */, commands, {\r\n                    shouldPushStackElementBefore: true,\r\n                    shouldPushStackElementAfter: false,\r\n                });\r\n            }\r\n        }\r\n        if (!isDoingComposition && this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\r\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\r\n        }\r\n        if (!isDoingComposition) {\r\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\r\n            if (autoClosingPairClose) {\r\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\r\n            }\r\n        }\r\n        if (this._isSurroundSelectionType(config, model, selections, ch)) {\r\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\r\n        }\r\n        // Electric characters make sense only when dealing with a single cursor,\r\n        // as multiple cursors typing brackets for example would interfer with bracket matching\r\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\r\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\r\n            if (r) {\r\n                return r;\r\n            }\r\n        }\r\n        // A simple character type\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            commands[i] = new ReplaceCommand(selections[i], ch);\r\n        }\r\n        let shouldPushStackElementBefore = (prevEditOperationType !== 1 /* Typing */);\r\n        if (ch === ' ') {\r\n            shouldPushStackElementBefore = true;\r\n        }\r\n        return new EditOperationResult(1 /* Typing */, commands, {\r\n            shouldPushStackElementBefore: shouldPushStackElementBefore,\r\n            shouldPushStackElementAfter: false\r\n        });\r\n    }\r\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            commands[i] = new ReplaceCommand(selections[i], str);\r\n        }\r\n        return new EditOperationResult(1 /* Typing */, commands, {\r\n            shouldPushStackElementBefore: (prevEditOperationType !== 1 /* Typing */),\r\n            shouldPushStackElementAfter: false\r\n        });\r\n    }\r\n    static lineInsertBefore(config, model, selections) {\r\n        if (model === null || selections === null) {\r\n            return [];\r\n        }\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            let lineNumber = selections[i].positionLineNumber;\r\n            if (lineNumber === 1) {\r\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\r\n            }\r\n            else {\r\n                lineNumber--;\r\n                let column = model.getLineMaxColumn(lineNumber);\r\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\r\n            }\r\n        }\r\n        return commands;\r\n    }\r\n    static lineInsertAfter(config, model, selections) {\r\n        if (model === null || selections === null) {\r\n            return [];\r\n        }\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const lineNumber = selections[i].positionLineNumber;\r\n            let column = model.getLineMaxColumn(lineNumber);\r\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\r\n        }\r\n        return commands;\r\n    }\r\n    static lineBreakInsert(config, model, selections) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            commands[i] = this._enter(config, model, true, selections[i]);\r\n        }\r\n        return commands;\r\n    }\r\n}\r\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\r\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\r\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\r\n        this._openCharacter = openCharacter;\r\n        this._closeCharacter = closeCharacter;\r\n        this.closeCharacterRange = null;\r\n        this.enclosingRange = null;\r\n    }\r\n    computeCursorState(model, helper) {\r\n        let inverseEditOperations = helper.getInverseEditOperations();\r\n        let range = inverseEditOperations[0].range;\r\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\r\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\r\n        return super.computeCursorState(model, helper);\r\n    }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,iBAAiB,QAAQ,gCAAgC;AAClE,OAAO,KAAKC,OAAO,MAAM,iCAAiC;AAC1D,SAASC,cAAc,EAAEC,mCAAmC,EAAEC,qCAAqC,EAAEC,oCAAoC,QAAQ,+BAA+B;AAChL,SAASC,YAAY,QAAQ,6BAA6B;AAC1D,SAASC,wBAAwB,QAAQ,yCAAyC;AAClF,SAASC,aAAa,EAAEC,mBAAmB,EAAEC,OAAO,QAAQ,mBAAmB;AAC/E,SAASC,uBAAuB,QAAQ,8BAA8B;AACtE,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,SAAS,QAAQ,sBAAsB;AAChD,SAASC,YAAY,QAAQ,mCAAmC;AAChE,SAASC,6BAA6B,QAAQ,2CAA2C;AACzF,OAAO,MAAMC,cAAc,CAAC;EACxB,OAAOC,MAAMA,CAACC,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IACrC,IAAID,KAAK,KAAK,IAAI,IAAIC,UAAU,KAAK,IAAI,EAAE;MACvC,OAAO,EAAE;IACb;IACA,IAAIC,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnDD,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIhB,YAAY,CAACc,UAAU,CAACE,CAAC,CAAC,EAAE;QAC1CG,SAAS,EAAE,KAAK;QAChBC,OAAO,EAAER,MAAM,CAACQ,OAAO;QACvBC,UAAU,EAAET,MAAM,CAACS,UAAU;QAC7BC,YAAY,EAAEV,MAAM,CAACU,YAAY;QACjCC,WAAW,EAAEX,MAAM,CAACW,WAAW;QAC/BC,UAAU,EAAEZ,MAAM,CAACY;MACvB,CAAC,CAAC;IACN;IACA,OAAOT,QAAQ;EACnB;EACA,OAAOU,OAAOA,CAACb,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IACtC,IAAIC,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnDD,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIhB,YAAY,CAACc,UAAU,CAACE,CAAC,CAAC,EAAE;QAC1CG,SAAS,EAAE,IAAI;QACfC,OAAO,EAAER,MAAM,CAACQ,OAAO;QACvBC,UAAU,EAAET,MAAM,CAACS,UAAU;QAC7BC,YAAY,EAAEV,MAAM,CAACU,YAAY;QACjCC,WAAW,EAAEX,MAAM,CAACW,WAAW;QAC/BC,UAAU,EAAEZ,MAAM,CAACY;MACvB,CAAC,CAAC;IACN;IACA,OAAOT,QAAQ;EACnB;EACA,OAAOW,WAAWA,CAACd,MAAM,EAAEe,WAAW,EAAEC,KAAK,EAAE;IAC3CA,KAAK,GAAGA,KAAK,IAAI,CAAC;IAClB,OAAO5B,YAAY,CAAC0B,WAAW,CAACC,WAAW,EAAEA,WAAW,CAACT,MAAM,GAAGU,KAAK,EAAEhB,MAAM,CAACQ,OAAO,EAAER,MAAM,CAACS,UAAU,EAAET,MAAM,CAACU,YAAY,CAAC;EACpI;EACA,OAAOO,aAAaA,CAACjB,MAAM,EAAEe,WAAW,EAAEC,KAAK,EAAE;IAC7CA,KAAK,GAAGA,KAAK,IAAI,CAAC;IAClB,OAAO5B,YAAY,CAAC6B,aAAa,CAACF,WAAW,EAAEA,WAAW,CAACT,MAAM,GAAGU,KAAK,EAAEhB,MAAM,CAACQ,OAAO,EAAER,MAAM,CAACS,UAAU,EAAET,MAAM,CAACU,YAAY,CAAC;EACtI;EACA,OAAOQ,iBAAiBA,CAAClB,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiB,IAAI,EAAE;IACtD,IAAIhB,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnDD,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIpB,cAAc,CAACkB,UAAU,CAACE,CAAC,CAAC,EAAEe,IAAI,CAACf,CAAC,CAAC,CAAC;IAC5D;IACA,OAAO,IAAIb,mBAAmB,CAAC,CAAC,CAAC,aAAaY,QAAQ,EAAE;MACpDiB,4BAA4B,EAAE,IAAI;MAClCC,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;EACA,OAAOC,YAAYA,CAACtB,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiB,IAAI,EAAEI,cAAc,EAAE;IACjE,IAAIpB,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMoB,SAAS,GAAGtB,UAAU,CAACE,CAAC,CAAC;MAC/B,IAAIqB,QAAQ,GAAGD,SAAS,CAACE,WAAW,CAAC,CAAC;MACtC,IAAIH,cAAc,IAAI,CAACC,SAAS,CAACG,OAAO,CAAC,CAAC,EAAE;QACxCJ,cAAc,GAAG,KAAK;MAC1B;MACA,IAAIA,cAAc,IAAIJ,IAAI,CAACS,OAAO,CAAC,IAAI,CAAC,KAAKT,IAAI,CAACb,MAAM,GAAG,CAAC,EAAE;QAC1DiB,cAAc,GAAG,KAAK;MAC1B;MACA,IAAIA,cAAc,EAAE;QAChB;QACA,IAAIM,aAAa,GAAG,IAAInC,KAAK,CAAC+B,QAAQ,CAACK,UAAU,EAAE,CAAC,EAAEL,QAAQ,CAACK,UAAU,EAAE,CAAC,CAAC;QAC7E3B,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIjB,oCAAoC,CAAC0C,aAAa,EAAEV,IAAI,EAAEK,SAAS,EAAE,IAAI,CAAC;MAChG,CAAC,MACI;QACDrB,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIpB,cAAc,CAACwC,SAAS,EAAEL,IAAI,CAAC;MACrD;IACJ;IACA,OAAO,IAAI5B,mBAAmB,CAAC,CAAC,CAAC,aAAaY,QAAQ,EAAE;MACpDiB,4BAA4B,EAAE,IAAI;MAClCC,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;EACA,OAAOU,yBAAyBA,CAAC/B,MAAM,EAAEE,UAAU,EAAEiB,IAAI,EAAEI,cAAc,EAAES,eAAe,EAAE;IACxF,IAAIT,cAAc,EAAE;MAChB,OAAO,IAAI;IACf;IACA,IAAIrB,UAAU,CAACI,MAAM,KAAK,CAAC,EAAE;MACzB,OAAO,IAAI;IACf;IACA,IAAI0B,eAAe,IAAIA,eAAe,CAAC1B,MAAM,KAAKJ,UAAU,CAACI,MAAM,EAAE;MACjE,OAAO0B,eAAe;IAC1B;IACA,IAAIhC,MAAM,CAACiC,gBAAgB,KAAK,QAAQ,EAAE;MACtC;MACA;MACA,IAAId,IAAI,CAACe,UAAU,CAACf,IAAI,CAACb,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,gBAAgB;QACxDa,IAAI,GAAGA,IAAI,CAACgB,MAAM,CAAC,CAAC,EAAEhB,IAAI,CAACb,MAAM,GAAG,CAAC,CAAC;MAC1C;MACA;MACA,IAAIa,IAAI,CAACe,UAAU,CAACf,IAAI,CAACb,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,sBAAsB;QAC9Da,IAAI,GAAGA,IAAI,CAACgB,MAAM,CAAC,CAAC,EAAEhB,IAAI,CAACb,MAAM,GAAG,CAAC,CAAC;MAC1C;MACA,IAAI8B,KAAK,GAAGrD,OAAO,CAACsD,UAAU,CAAClB,IAAI,CAAC;MACpC,IAAIiB,KAAK,CAAC9B,MAAM,KAAKJ,UAAU,CAACI,MAAM,EAAE;QACpC,OAAO8B,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA,OAAOE,KAAKA,CAACtC,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiB,IAAI,EAAEI,cAAc,EAAES,eAAe,EAAE;IAC3E,MAAMO,gBAAgB,GAAG,IAAI,CAACR,yBAAyB,CAAC/B,MAAM,EAAEE,UAAU,EAAEiB,IAAI,EAAEI,cAAc,EAAES,eAAe,CAAC;IAClH,IAAIO,gBAAgB,EAAE;MAClBrC,UAAU,GAAGA,UAAU,CAACsC,IAAI,CAAC9C,KAAK,CAAC+C,wBAAwB,CAAC;MAC5D,OAAO,IAAI,CAACvB,iBAAiB,CAAClB,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEqC,gBAAgB,CAAC;IAC9E,CAAC,MACI;MACD,OAAO,IAAI,CAACjB,YAAY,CAACtB,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiB,IAAI,EAAEI,cAAc,CAAC;IAC7E;EACJ;EACA,OAAOmB,kBAAkBA,CAAC1C,MAAM,EAAEC,KAAK,EAAE6B,UAAU,EAAE;IACjD,IAAIa,MAAM,GAAG,IAAI;IACjB,IAAI5B,WAAW,GAAG,EAAE;IACpB,MAAM6B,oBAAoB,GAAG/C,6BAA6B,CAACgD,uBAAuB,CAAC7C,MAAM,CAACY,UAAU,EAAEX,KAAK,EAAE6B,UAAU,EAAE,KAAK,CAAC;IAC/H,IAAIc,oBAAoB,EAAE;MACtBD,MAAM,GAAGC,oBAAoB,CAACD,MAAM;MACpC5B,WAAW,GAAG6B,oBAAoB,CAAC7B,WAAW;IAClD,CAAC,MACI,IAAIe,UAAU,GAAG,CAAC,EAAE;MACrB,IAAIgB,cAAc;MAClB,KAAKA,cAAc,GAAGhB,UAAU,GAAG,CAAC,EAAEgB,cAAc,IAAI,CAAC,EAAEA,cAAc,EAAE,EAAE;QACzE,MAAMC,QAAQ,GAAG9C,KAAK,CAAC+C,cAAc,CAACF,cAAc,CAAC;QACrD,MAAMG,gBAAgB,GAAGlE,OAAO,CAACmE,sBAAsB,CAACH,QAAQ,CAAC;QACjE,IAAIE,gBAAgB,IAAI,CAAC,EAAE;UACvB;QACJ;MACJ;MACA,IAAIH,cAAc,GAAG,CAAC,EAAE;QACpB;QACA,OAAO,IAAI;MACf;MACA,MAAMK,SAAS,GAAGlD,KAAK,CAACmD,gBAAgB,CAACN,cAAc,CAAC;MACxD,MAAMO,mBAAmB,GAAGxD,6BAA6B,CAACyD,cAAc,CAACtD,MAAM,CAACY,UAAU,EAAEX,KAAK,EAAE,IAAIP,KAAK,CAACoD,cAAc,EAAEK,SAAS,EAAEL,cAAc,EAAEK,SAAS,CAAC,CAAC;MACnK,IAAIE,mBAAmB,EAAE;QACrBtC,WAAW,GAAGsC,mBAAmB,CAACtC,WAAW,GAAGsC,mBAAmB,CAACE,UAAU;MAClF;IACJ;IACA,IAAIZ,MAAM,EAAE;MACR,IAAIA,MAAM,KAAK/C,YAAY,CAAC4D,MAAM,EAAE;QAChCzC,WAAW,GAAGjB,cAAc,CAACgB,WAAW,CAACd,MAAM,EAAEe,WAAW,CAAC;MACjE;MACA,IAAI4B,MAAM,KAAK/C,YAAY,CAAC6D,OAAO,EAAE;QACjC1C,WAAW,GAAGjB,cAAc,CAACmB,aAAa,CAACjB,MAAM,EAAEe,WAAW,CAAC;MACnE;MACAA,WAAW,GAAGf,MAAM,CAAC0D,oBAAoB,CAAC3C,WAAW,CAAC;IAC1D;IACA,IAAI,CAACA,WAAW,EAAE;MACd,OAAO,IAAI;IACf;IACA,OAAOA,WAAW;EACtB;EACA,OAAO4C,wBAAwBA,CAAC3D,MAAM,EAAEC,KAAK,EAAEuB,SAAS,EAAEoC,qBAAqB,EAAE;IAC7E,IAAIC,QAAQ,GAAG,EAAE;IACjB,IAAIpC,QAAQ,GAAGD,SAAS,CAACsC,gBAAgB,CAAC,CAAC;IAC3C,IAAI9D,MAAM,CAACU,YAAY,EAAE;MACrB,IAAIqD,uBAAuB,GAAGzE,aAAa,CAAC0E,wBAAwB,CAAChE,MAAM,EAAEC,KAAK,EAAEwB,QAAQ,CAAC;MAC7F,IAAIhB,UAAU,GAAGT,MAAM,CAACS,UAAU;MAClC,IAAIwD,SAAS,GAAGxD,UAAU,GAAIsD,uBAAuB,GAAGtD,UAAW;MACnE,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6D,SAAS,EAAE7D,CAAC,EAAE,EAAE;QAChCyD,QAAQ,IAAI,GAAG;MACnB;IACJ,CAAC,MACI;MACDA,QAAQ,GAAG,IAAI;IACnB;IACA,OAAO,IAAI7E,cAAc,CAACwC,SAAS,EAAEqC,QAAQ,EAAED,qBAAqB,CAAC;EACzE;EACA,OAAOM,GAAGA,CAAClE,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAClC,IAAIC,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMoB,SAAS,GAAGtB,UAAU,CAACE,CAAC,CAAC;MAC/B,IAAIoB,SAAS,CAACG,OAAO,CAAC,CAAC,EAAE;QACrB,IAAIoB,QAAQ,GAAG9C,KAAK,CAAC+C,cAAc,CAACxB,SAAS,CAAC2C,eAAe,CAAC;QAC9D,IAAI,OAAO,CAACC,IAAI,CAACrB,QAAQ,CAAC,IAAI9C,KAAK,CAACoE,iBAAiB,CAAC7C,SAAS,CAAC2C,eAAe,CAAC,EAAE;UAC9E,IAAIG,UAAU,GAAG,IAAI,CAAC5B,kBAAkB,CAAC1C,MAAM,EAAEC,KAAK,EAAEuB,SAAS,CAAC2C,eAAe,CAAC;UAClFG,UAAU,GAAGA,UAAU,IAAI,IAAI;UAC/B,IAAIC,gBAAgB,GAAGvE,MAAM,CAAC0D,oBAAoB,CAACY,UAAU,CAAC;UAC9D,IAAI,CAACvB,QAAQ,CAACyB,UAAU,CAACD,gBAAgB,CAAC,EAAE;YACxCpE,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIpB,cAAc,CAAC,IAAIU,KAAK,CAAC8B,SAAS,CAAC2C,eAAe,EAAE,CAAC,EAAE3C,SAAS,CAAC2C,eAAe,EAAEpB,QAAQ,CAACzC,MAAM,GAAG,CAAC,CAAC,EAAEiE,gBAAgB,EAAE,IAAI,CAAC;YACjJ;UACJ;QACJ;QACApE,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAI,CAACuD,wBAAwB,CAAC3D,MAAM,EAAEC,KAAK,EAAEuB,SAAS,EAAE,IAAI,CAAC;MAC/E,CAAC,MACI;QACD,IAAIA,SAAS,CAAC2C,eAAe,KAAK3C,SAAS,CAACiD,aAAa,EAAE;UACvD,IAAIC,aAAa,GAAGzE,KAAK,CAACmD,gBAAgB,CAAC5B,SAAS,CAAC2C,eAAe,CAAC;UACrE,IAAI3C,SAAS,CAACmD,WAAW,KAAK,CAAC,IAAInD,SAAS,CAACoD,SAAS,KAAKF,aAAa,EAAE;YACtE;YACAvE,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAI,CAACuD,wBAAwB,CAAC3D,MAAM,EAAEC,KAAK,EAAEuB,SAAS,EAAE,KAAK,CAAC;YAC5E;UACJ;QACJ;QACArB,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIhB,YAAY,CAACoC,SAAS,EAAE;UACtCjB,SAAS,EAAE,KAAK;UAChBC,OAAO,EAAER,MAAM,CAACQ,OAAO;UACvBC,UAAU,EAAET,MAAM,CAACS,UAAU;UAC7BC,YAAY,EAAEV,MAAM,CAACU,YAAY;UACjCC,WAAW,EAAEX,MAAM,CAACW,WAAW;UAC/BC,UAAU,EAAEZ,MAAM,CAACY;QACvB,CAAC,CAAC;MACN;IACJ;IACA,OAAOT,QAAQ;EACnB;EACA,OAAO0E,mBAAmBA,CAACC,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE6E,GAAG,EAAEC,cAAc,EAAE;IAC9F,IAAI7E,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMoB,SAAS,GAAGtB,UAAU,CAACE,CAAC,CAAC;MAC/B,IAAI,CAACoB,SAAS,CAACG,OAAO,CAAC,CAAC,EAAE;QACtB;QACA;QACA;QACAxB,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAI;QAClB;MACJ;MACA,MAAM6E,GAAG,GAAGzD,SAAS,CAACE,WAAW,CAAC,CAAC;MACnC,MAAMiD,WAAW,GAAGO,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEF,GAAG,CAACG,MAAM,GAAGJ,cAAc,CAAC;MAC5D,MAAMK,KAAK,GAAG,IAAI3F,KAAK,CAACuF,GAAG,CAACnD,UAAU,EAAE6C,WAAW,EAAEM,GAAG,CAACnD,UAAU,EAAEmD,GAAG,CAACG,MAAM,CAAC;MAChF,MAAME,OAAO,GAAGrF,KAAK,CAACsF,eAAe,CAACF,KAAK,CAAC;MAC5C,IAAIC,OAAO,KAAKP,GAAG,EAAE;QACjB;QACA5E,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAI;QAClB;MACJ;MACAD,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIpB,cAAc,CAACqG,KAAK,EAAEN,GAAG,CAAC;IAChD;IACA,OAAO,IAAIxF,mBAAmB,CAAC,CAAC,CAAC,cAAcY,QAAQ,EAAE;MACrDiB,4BAA4B,EAAG0D,qBAAqB,KAAK,CAAC,CAAC,YAAa;MACxEzD,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;EACA,OAAOmE,YAAYA,CAACH,KAAK,EAAElE,IAAI,EAAEsE,YAAY,EAAE;IAC3C,IAAIA,YAAY,EAAE;MACd,OAAO,IAAIvG,qCAAqC,CAACmG,KAAK,EAAElE,IAAI,EAAE,IAAI,CAAC;IACvE,CAAC,MACI;MACD,OAAO,IAAInC,cAAc,CAACqG,KAAK,EAAElE,IAAI,EAAE,IAAI,CAAC;IAChD;EACJ;EACA,OAAOuE,MAAMA,CAAC1F,MAAM,EAAEC,KAAK,EAAEwF,YAAY,EAAEJ,KAAK,EAAE;IAC9C,IAAIrF,MAAM,CAACY,UAAU,KAAK,CAAC,CAAC,YAAY;MACpC,OAAOd,cAAc,CAAC0F,YAAY,CAACH,KAAK,EAAE,IAAI,EAAEI,YAAY,CAAC;IACjE;IACA,IAAI,CAACxF,KAAK,CAACoE,iBAAiB,CAACgB,KAAK,CAACvB,gBAAgB,CAAC,CAAC,CAAChC,UAAU,CAAC,IAAI9B,MAAM,CAACY,UAAU,KAAK,CAAC,CAAC,YAAY;MACrG,IAAImC,QAAQ,GAAG9C,KAAK,CAAC+C,cAAc,CAACqC,KAAK,CAAClB,eAAe,CAAC;MAC1D,IAAIpD,WAAW,GAAGhC,OAAO,CAAC4G,oBAAoB,CAAC5C,QAAQ,CAAC,CAAC6C,SAAS,CAAC,CAAC,EAAEP,KAAK,CAACV,WAAW,GAAG,CAAC,CAAC;MAC5F,OAAO7E,cAAc,CAAC0F,YAAY,CAACH,KAAK,EAAE,IAAI,GAAGrF,MAAM,CAAC0D,oBAAoB,CAAC3C,WAAW,CAAC,EAAE0E,YAAY,CAAC;IAC5G;IACA,MAAMI,CAAC,GAAGhG,6BAA6B,CAACyD,cAAc,CAACtD,MAAM,CAACY,UAAU,EAAEX,KAAK,EAAEoF,KAAK,CAAC;IACvF,IAAIQ,CAAC,EAAE;MACH,IAAIA,CAAC,CAACC,YAAY,KAAKlG,YAAY,CAACmG,IAAI,EAAE;QACtC;QACA,OAAOjG,cAAc,CAAC0F,YAAY,CAACH,KAAK,EAAE,IAAI,GAAGrF,MAAM,CAAC0D,oBAAoB,CAACmC,CAAC,CAAC9E,WAAW,GAAG8E,CAAC,CAACtC,UAAU,CAAC,EAAEkC,YAAY,CAAC;MAC7H,CAAC,MACI,IAAII,CAAC,CAACC,YAAY,KAAKlG,YAAY,CAAC4D,MAAM,EAAE;QAC7C;QACA,OAAO1D,cAAc,CAAC0F,YAAY,CAACH,KAAK,EAAE,IAAI,GAAGrF,MAAM,CAAC0D,oBAAoB,CAACmC,CAAC,CAAC9E,WAAW,GAAG8E,CAAC,CAACtC,UAAU,CAAC,EAAEkC,YAAY,CAAC;MAC7H,CAAC,MACI,IAAII,CAAC,CAACC,YAAY,KAAKlG,YAAY,CAACoG,aAAa,EAAE;QACpD;QACA,MAAMC,YAAY,GAAGjG,MAAM,CAAC0D,oBAAoB,CAACmC,CAAC,CAAC9E,WAAW,CAAC;QAC/D,MAAMmF,eAAe,GAAGlG,MAAM,CAAC0D,oBAAoB,CAACmC,CAAC,CAAC9E,WAAW,GAAG8E,CAAC,CAACtC,UAAU,CAAC;QACjF,MAAMM,QAAQ,GAAG,IAAI,GAAGqC,eAAe,GAAG,IAAI,GAAGD,YAAY;QAC7D,IAAIR,YAAY,EAAE;UACd,OAAO,IAAIvG,qCAAqC,CAACmG,KAAK,EAAExB,QAAQ,EAAE,IAAI,CAAC;QAC3E,CAAC,MACI;UACD,OAAO,IAAI5E,mCAAmC,CAACoG,KAAK,EAAExB,QAAQ,EAAE,CAAC,CAAC,EAAEqC,eAAe,CAAC5F,MAAM,GAAG2F,YAAY,CAAC3F,MAAM,EAAE,IAAI,CAAC;QAC3H;MACJ,CAAC,MACI,IAAIuF,CAAC,CAACC,YAAY,KAAKlG,YAAY,CAAC6D,OAAO,EAAE;QAC9C,MAAM0C,iBAAiB,GAAGrG,cAAc,CAACmB,aAAa,CAACjB,MAAM,EAAE6F,CAAC,CAAC9E,WAAW,CAAC;QAC7E,OAAOjB,cAAc,CAAC0F,YAAY,CAACH,KAAK,EAAE,IAAI,GAAGrF,MAAM,CAAC0D,oBAAoB,CAACyC,iBAAiB,GAAGN,CAAC,CAACtC,UAAU,CAAC,EAAEkC,YAAY,CAAC;MACjI;IACJ;IACA,MAAM1C,QAAQ,GAAG9C,KAAK,CAAC+C,cAAc,CAACqC,KAAK,CAAClB,eAAe,CAAC;IAC5D,MAAMpD,WAAW,GAAGhC,OAAO,CAAC4G,oBAAoB,CAAC5C,QAAQ,CAAC,CAAC6C,SAAS,CAAC,CAAC,EAAEP,KAAK,CAACV,WAAW,GAAG,CAAC,CAAC;IAC9F,IAAI3E,MAAM,CAACY,UAAU,IAAI,CAAC,CAAC,YAAY;MACnC,MAAMwF,EAAE,GAAGvG,6BAA6B,CAACwG,iBAAiB,CAACrG,MAAM,CAACY,UAAU,EAAEX,KAAK,EAAEoF,KAAK,EAAE;QACxFpE,aAAa,EAAGlB,MAAM,IAAK;UACvB,OAAOD,cAAc,CAACmB,aAAa,CAACjB,MAAM,EAAED,MAAM,CAAC;QACvD,CAAC;QACDe,WAAW,EAAGf,MAAM,IAAK;UACrB,OAAOD,cAAc,CAACgB,WAAW,CAACd,MAAM,EAAED,MAAM,CAAC;QACrD,CAAC;QACD2D,oBAAoB,EAAG3D,MAAM,IAAK;UAC9B,OAAOC,MAAM,CAAC0D,oBAAoB,CAAC3D,MAAM,CAAC;QAC9C;MACJ,CAAC,CAAC;MACF,IAAIqG,EAAE,EAAE;QACJ,IAAIE,gBAAgB,GAAGhH,aAAa,CAAC0E,wBAAwB,CAAChE,MAAM,EAAEC,KAAK,EAAEoF,KAAK,CAACkB,cAAc,CAAC,CAAC,CAAC;QACpG,MAAMC,YAAY,GAAGnB,KAAK,CAACT,SAAS;QACpC,MAAM6B,cAAc,GAAGxG,KAAK,CAAC+C,cAAc,CAACqC,KAAK,CAACZ,aAAa,CAAC;QAChE,MAAMiC,kBAAkB,GAAG3H,OAAO,CAAC4H,uBAAuB,CAACF,cAAc,CAAC;QAC1E,IAAIC,kBAAkB,IAAI,CAAC,EAAE;UACzBrB,KAAK,GAAGA,KAAK,CAACuB,cAAc,CAACvB,KAAK,CAACZ,aAAa,EAAES,IAAI,CAACC,GAAG,CAACE,KAAK,CAACT,SAAS,EAAE8B,kBAAkB,GAAG,CAAC,CAAC,CAAC;QACxG,CAAC,MACI;UACDrB,KAAK,GAAGA,KAAK,CAACuB,cAAc,CAACvB,KAAK,CAACZ,aAAa,EAAExE,KAAK,CAACmD,gBAAgB,CAACiC,KAAK,CAACZ,aAAa,CAAC,CAAC;QAClG;QACA,IAAIgB,YAAY,EAAE;UACd,OAAO,IAAIvG,qCAAqC,CAACmG,KAAK,EAAE,IAAI,GAAGrF,MAAM,CAAC0D,oBAAoB,CAAC0C,EAAE,CAACS,UAAU,CAAC,EAAE,IAAI,CAAC;QACpH,CAAC,MACI;UACD,IAAIC,MAAM,GAAG,CAAC;UACd,IAAIN,YAAY,IAAIE,kBAAkB,GAAG,CAAC,EAAE;YACxC,IAAI,CAAC1G,MAAM,CAACU,YAAY,EAAE;cACtB4F,gBAAgB,GAAGpB,IAAI,CAAC6B,IAAI,CAACT,gBAAgB,GAAGtG,MAAM,CAACS,UAAU,CAAC;YACtE;YACAqG,MAAM,GAAG5B,IAAI,CAAC8B,GAAG,CAACV,gBAAgB,GAAG,CAAC,GAAGtG,MAAM,CAAC0D,oBAAoB,CAAC0C,EAAE,CAACS,UAAU,CAAC,CAACvG,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;UACtG;UACA,OAAO,IAAIrB,mCAAmC,CAACoG,KAAK,EAAE,IAAI,GAAGrF,MAAM,CAAC0D,oBAAoB,CAAC0C,EAAE,CAACS,UAAU,CAAC,EAAE,CAAC,EAAEC,MAAM,EAAE,IAAI,CAAC;QAC7H;MACJ;IACJ;IACA,OAAOhH,cAAc,CAAC0F,YAAY,CAACH,KAAK,EAAE,IAAI,GAAGrF,MAAM,CAAC0D,oBAAoB,CAAC3C,WAAW,CAAC,EAAE0E,YAAY,CAAC;EAC5G;EACA,OAAOwB,iBAAiBA,CAACjH,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAChD,IAAIF,MAAM,CAACY,UAAU,GAAG,CAAC,CAAC,YAAY;MAClC,OAAO,KAAK;IAChB;IACA,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,IAAI,CAACH,KAAK,CAACoE,iBAAiB,CAACnE,UAAU,CAACE,CAAC,CAAC,CAACmG,cAAc,CAAC,CAAC,CAACzE,UAAU,CAAC,EAAE;QACrE,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA,OAAOoF,kBAAkBA,CAAClH,MAAM,EAAEC,KAAK,EAAEoF,KAAK,EAAE8B,EAAE,EAAE;IAChD,MAAMC,kBAAkB,GAAGvH,6BAA6B,CAACwH,wBAAwB,CAACpH,KAAK,EAAEoF,KAAK,CAAClB,eAAe,EAAEkB,KAAK,CAACV,WAAW,CAAC;IAClI,MAAMwB,iBAAiB,GAAGtG,6BAA6B,CAACyH,sBAAsB,CAACtH,MAAM,CAACY,UAAU,EAAEX,KAAK,EAAEoF,KAAK,EAAE8B,EAAE,EAAE;MAChHrG,WAAW,EAAGC,WAAW,IAAK;QAC1B,OAAOjB,cAAc,CAACgB,WAAW,CAACd,MAAM,EAAEe,WAAW,CAAC;MAC1D,CAAC;MACDE,aAAa,EAAGF,WAAW,IAAK;QAC5B,OAAOjB,cAAc,CAACmB,aAAa,CAACjB,MAAM,EAAEe,WAAW,CAAC;MAC5D;IACJ,CAAC,CAAC;IACF,IAAIoF,iBAAiB,KAAK,IAAI,EAAE;MAC5B,OAAO,IAAI;IACf;IACA,IAAIA,iBAAiB,KAAKnG,MAAM,CAAC0D,oBAAoB,CAAC0D,kBAAkB,CAAC,EAAE;MACvE,MAAMV,kBAAkB,GAAGzG,KAAK,CAACsH,+BAA+B,CAAClC,KAAK,CAAClB,eAAe,CAAC;MACvF,IAAIuC,kBAAkB,KAAK,CAAC,EAAE;QAC1B,OAAO5G,cAAc,CAAC0F,YAAY,CAAC,IAAI9F,KAAK,CAAC2F,KAAK,CAAClB,eAAe,EAAE,CAAC,EAAEkB,KAAK,CAACZ,aAAa,EAAEY,KAAK,CAACT,SAAS,CAAC,EAAE5E,MAAM,CAAC0D,oBAAoB,CAACyC,iBAAiB,CAAC,GAAGgB,EAAE,EAAE,KAAK,CAAC;MAC7K,CAAC,MACI;QACD,OAAOrH,cAAc,CAAC0F,YAAY,CAAC,IAAI9F,KAAK,CAAC2F,KAAK,CAAClB,eAAe,EAAE,CAAC,EAAEkB,KAAK,CAACZ,aAAa,EAAEY,KAAK,CAACT,SAAS,CAAC,EAAE5E,MAAM,CAAC0D,oBAAoB,CAACyC,iBAAiB,CAAC,GACxJlG,KAAK,CAAC+C,cAAc,CAACqC,KAAK,CAAClB,eAAe,CAAC,CAACyB,SAAS,CAACc,kBAAkB,GAAG,CAAC,EAAErB,KAAK,CAACV,WAAW,GAAG,CAAC,CAAC,GAAGwC,EAAE,EAAE,KAAK,CAAC;MACzH;IACJ;IACA,OAAO,IAAI;EACf;EACA,OAAOK,sBAAsBA,CAACxH,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEuH,oBAAoB,EAAEN,EAAE,EAAE;IAC/E,IAAInH,MAAM,CAAC0H,mBAAmB,KAAK,OAAO,EAAE;MACxC,OAAO,KAAK;IAChB;IACA,IAAI,CAAC1H,MAAM,CAAC2H,gBAAgB,CAACC,+BAA+B,CAACC,GAAG,CAACV,EAAE,CAAC,EAAE;MAClE,OAAO,KAAK;IAChB;IACA,KAAK,IAAI/G,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMoB,SAAS,GAAGtB,UAAU,CAACE,CAAC,CAAC;MAC/B,IAAI,CAACoB,SAAS,CAACG,OAAO,CAAC,CAAC,EAAE;QACtB,OAAO,KAAK;MAChB;MACA,MAAMF,QAAQ,GAAGD,SAAS,CAACE,WAAW,CAAC,CAAC;MACxC,MAAMqB,QAAQ,GAAG9C,KAAK,CAAC+C,cAAc,CAACvB,QAAQ,CAACK,UAAU,CAAC;MAC1D,MAAMgG,cAAc,GAAG/E,QAAQ,CAACgF,MAAM,CAACtG,QAAQ,CAAC2D,MAAM,GAAG,CAAC,CAAC;MAC3D,IAAI0C,cAAc,KAAKX,EAAE,EAAE;QACvB,OAAO,KAAK;MAChB;MACA;MACA,MAAMa,SAAS,GAAGxI,OAAO,CAAC2H,EAAE,CAAC;MAC7B,MAAMc,eAAe,GAAGxG,QAAQ,CAAC2D,MAAM,GAAG,CAAC,GAAGrC,QAAQ,CAACb,UAAU,CAACT,QAAQ,CAAC2D,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;MAC3F,IAAI6C,eAAe,KAAK,EAAE,CAAC,mBAAmBD,SAAS,EAAE;QACrD,OAAO,KAAK;MAChB;MACA;MACA,IAAIhI,MAAM,CAAC0H,mBAAmB,KAAK,MAAM,EAAE;QACvC,IAAIQ,KAAK,GAAG,KAAK;QACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGX,oBAAoB,CAACnH,MAAM,EAAE6H,CAAC,GAAGC,IAAI,EAAED,CAAC,EAAE,EAAE;UAC/D,MAAME,mBAAmB,GAAGZ,oBAAoB,CAACU,CAAC,CAAC;UACnD,IAAI1G,QAAQ,CAACK,UAAU,KAAKuG,mBAAmB,CAAClE,eAAe,IAAI1C,QAAQ,CAAC2D,MAAM,KAAKiD,mBAAmB,CAAC1D,WAAW,EAAE;YACpHuD,KAAK,GAAG,IAAI;YACZ;UACJ;QACJ;QACA,IAAI,CAACA,KAAK,EAAE;UACR,OAAO,KAAK;QAChB;MACJ;IACJ;IACA,OAAO,IAAI;EACf;EACA,OAAOI,uBAAuBA,CAACxD,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiH,EAAE,EAAE;IACjF,IAAIhH,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMoB,SAAS,GAAGtB,UAAU,CAACE,CAAC,CAAC;MAC/B,MAAMqB,QAAQ,GAAGD,SAAS,CAACE,WAAW,CAAC,CAAC;MACxC,MAAMG,aAAa,GAAG,IAAInC,KAAK,CAAC+B,QAAQ,CAACK,UAAU,EAAEL,QAAQ,CAAC2D,MAAM,EAAE3D,QAAQ,CAACK,UAAU,EAAEL,QAAQ,CAAC2D,MAAM,GAAG,CAAC,CAAC;MAC/GjF,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIpB,cAAc,CAAC6C,aAAa,EAAEsF,EAAE,CAAC;IACvD;IACA,OAAO,IAAI5H,mBAAmB,CAAC,CAAC,CAAC,cAAcY,QAAQ,EAAE;MACrDiB,4BAA4B,EAAG0D,qBAAqB,KAAK,CAAC,CAAC,YAAa;MACxEzD,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;EACA,OAAOkH,qBAAqBA,CAACvI,MAAM,EAAEwI,SAAS,EAAE;IAC5C;IACA,MAAMC,QAAQ,GAAGD,SAAS,CAACT,MAAM,CAAC,CAAC,CAAC;IACpC,MAAMW,uBAAuB,GAAG1I,MAAM,CAAC2H,gBAAgB,CAACgB,2BAA2B,CAACC,GAAG,CAACH,QAAQ,CAAC,IAAI,EAAE;IACvG,MAAMI,sBAAsB,GAAG7I,MAAM,CAAC2H,gBAAgB,CAACmB,4BAA4B,CAACF,GAAG,CAACH,QAAQ,CAAC,IAAI,EAAE;IACvG,MAAMM,qBAAqB,GAAGL,uBAAuB,CAACM,IAAI,CAACC,CAAC,IAAIT,SAAS,CAAChE,UAAU,CAACyE,CAAC,CAACC,IAAI,CAAC,CAAC;IAC7F,MAAMC,oBAAoB,GAAGN,sBAAsB,CAACG,IAAI,CAACC,CAAC,IAAIT,SAAS,CAAChE,UAAU,CAACyE,CAAC,CAACG,KAAK,CAAC,CAAC;IAC5F,OAAO,CAACL,qBAAqB,IAAII,oBAAoB;EACzD;EACA,OAAOE,wBAAwBA,CAACrJ,MAAM,EAAEC,KAAK,EAAEqJ,SAAS,EAAEnC,EAAE,EAAE;IAC1D,MAAMoC,yBAAyB,GAAGvJ,MAAM,CAAC2H,gBAAgB,CAAC6B,yBAAyB,CAACZ,GAAG,CAACzB,EAAE,CAAC;IAC3F,IAAI,CAACoC,yBAAyB,EAAE;MAC5B,OAAO,IAAI;IACf;IACA;IACA,IAAIE,eAAe,GAAG,IAAI;IAC1B,KAAK,MAAMC,wBAAwB,IAAIH,yBAAyB,EAAE;MAC9D,IAAIE,eAAe,KAAK,IAAI,IAAIC,wBAAwB,CAACR,IAAI,CAAC5I,MAAM,GAAGmJ,eAAe,CAACP,IAAI,CAAC5I,MAAM,EAAE;QAChG,IAAIqJ,gBAAgB,GAAG,IAAI;QAC3B,KAAK,MAAMlI,QAAQ,IAAI6H,SAAS,EAAE;UAC9B,MAAMM,YAAY,GAAG3J,KAAK,CAACsF,eAAe,CAAC,IAAI7F,KAAK,CAAC+B,QAAQ,CAACK,UAAU,EAAEL,QAAQ,CAAC2D,MAAM,GAAGsE,wBAAwB,CAACR,IAAI,CAAC5I,MAAM,GAAG,CAAC,EAAEmB,QAAQ,CAACK,UAAU,EAAEL,QAAQ,CAAC2D,MAAM,CAAC,CAAC;UAC5K,IAAIwE,YAAY,GAAGzC,EAAE,KAAKuC,wBAAwB,CAACR,IAAI,EAAE;YACrDS,gBAAgB,GAAG,KAAK;YACxB;UACJ;QACJ;QACA,IAAIA,gBAAgB,EAAE;UAClBF,eAAe,GAAGC,wBAAwB;QAC9C;MACJ;IACJ;IACA,OAAOD,eAAe;EAC1B;EACA,OAAOI,4BAA4BA,CAAC7J,MAAM,EAAEyJ,eAAe,EAAE;IACzD,IAAIA,eAAe,CAACP,IAAI,CAAC5I,MAAM,IAAI,CAAC,EAAE;MAClC,OAAO,EAAE;IACb;IACA,MAAMwJ,QAAQ,GAAGL,eAAe,CAACL,KAAK,CAACrB,MAAM,CAAC0B,eAAe,CAACL,KAAK,CAAC9I,MAAM,GAAG,CAAC,CAAC;IAC/E;IACA,MAAMyJ,iBAAiB,GAAG/J,MAAM,CAAC2H,gBAAgB,CAACqC,0BAA0B,CAACpB,GAAG,CAACkB,QAAQ,CAAC,IAAI,EAAE;IAChG,IAAIG,YAAY,GAAG,IAAI;IACvB,KAAK,MAAMhB,CAAC,IAAIc,iBAAiB,EAAE;MAC/B,IAAId,CAAC,CAACC,IAAI,KAAKO,eAAe,CAACP,IAAI,IAAIO,eAAe,CAACP,IAAI,CAACgB,QAAQ,CAACjB,CAAC,CAACC,IAAI,CAAC,IAAIO,eAAe,CAACL,KAAK,CAACe,QAAQ,CAAClB,CAAC,CAACG,KAAK,CAAC,EAAE;QACrH,IAAI,CAACa,YAAY,IAAIhB,CAAC,CAACC,IAAI,CAAC5I,MAAM,GAAG2J,YAAY,CAACf,IAAI,CAAC5I,MAAM,EAAE;UAC3D2J,YAAY,GAAGhB,CAAC;QACpB;MACJ;IACJ;IACA,IAAIgB,YAAY,EAAE;MACd,OAAOA,YAAY,CAACb,KAAK;IAC7B,CAAC,MACI;MACD,OAAO,EAAE;IACb;EACJ;EACA,OAAOgB,wBAAwBA,CAACpK,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiH,EAAE,EAAEkD,mBAAmB,EAAE;IAChF,MAAMrC,SAAS,GAAGxI,OAAO,CAAC2H,EAAE,CAAC;IAC7B,MAAMmD,eAAe,GAAGtC,SAAS,GAAGhI,MAAM,CAACuK,iBAAiB,GAAGvK,MAAM,CAACwK,mBAAmB;IACzF,IAAIF,eAAe,KAAK,OAAO,EAAE;MAC7B,OAAO,IAAI;IACf;IACA,MAAMb,eAAe,GAAG,IAAI,CAACJ,wBAAwB,CAACrJ,MAAM,EAAEC,KAAK,EAAEC,UAAU,CAACuK,GAAG,CAACC,CAAC,IAAIA,CAAC,CAAChJ,WAAW,CAAC,CAAC,CAAC,EAAEyF,EAAE,CAAC;IAC9G,IAAI,CAACsC,eAAe,EAAE;MAClB,OAAO,IAAI;IACf;IACA,MAAMkB,uBAAuB,GAAG,IAAI,CAACd,4BAA4B,CAAC7J,MAAM,EAAEyJ,eAAe,CAAC;IAC1F,IAAImB,2BAA2B,GAAG,IAAI;IACtC,MAAMC,qBAAqB,GAAG7C,SAAS,GAAGhI,MAAM,CAAC6K,qBAAqB,CAACC,KAAK,GAAG9K,MAAM,CAAC6K,qBAAqB,CAACE,OAAO;IACnH,KAAK,IAAI3K,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMoB,SAAS,GAAGtB,UAAU,CAACE,CAAC,CAAC;MAC/B,IAAI,CAACoB,SAAS,CAACG,OAAO,CAAC,CAAC,EAAE;QACtB,OAAO,IAAI;MACf;MACA,MAAMF,QAAQ,GAAGD,SAAS,CAACE,WAAW,CAAC,CAAC;MACxC,MAAMqB,QAAQ,GAAG9C,KAAK,CAAC+C,cAAc,CAACvB,QAAQ,CAACK,UAAU,CAAC;MAC1D,MAAM0G,SAAS,GAAGzF,QAAQ,CAAC6C,SAAS,CAACnE,QAAQ,CAAC2D,MAAM,GAAG,CAAC,CAAC;MACzD,IAAI,CAACoD,SAAS,CAAChE,UAAU,CAACmG,uBAAuB,CAAC,EAAE;QAChDC,2BAA2B,GAAG,KAAK;MACvC;MACA;MACA,IAAI7H,QAAQ,CAACzC,MAAM,GAAGmB,QAAQ,CAAC2D,MAAM,GAAG,CAAC,EAAE;QACvC,MAAM4F,cAAc,GAAGjI,QAAQ,CAACgF,MAAM,CAACtG,QAAQ,CAAC2D,MAAM,GAAG,CAAC,CAAC;QAC3D,MAAM6F,kBAAkB,GAAGnL,cAAc,CAACyI,qBAAqB,CAACvI,MAAM,EAAEwI,SAAS,CAAC;QAClF,IAAI,CAACyC,kBAAkB,IAAI,CAACJ,qBAAqB,CAACG,cAAc,CAAC,EAAE;UAC/D,OAAO,IAAI;QACf;MACJ;MACA,IAAI,CAAC/K,KAAK,CAACoE,iBAAiB,CAAC5C,QAAQ,CAACK,UAAU,CAAC,EAAE;QAC/C;QACA,OAAO,IAAI;MACf;MACA;MACA,IAAI2H,eAAe,CAACP,IAAI,CAAC5I,MAAM,KAAK,CAAC,IAAI0H,SAAS,IAAIsC,eAAe,KAAK,QAAQ,EAAE;QAChF,MAAMY,cAAc,GAAGzL,uBAAuB,CAACO,MAAM,CAACkL,cAAc,CAAC;QACrE,IAAIb,mBAAmB,IAAI5I,QAAQ,CAAC2D,MAAM,GAAG,CAAC,IAAI8F,cAAc,CAACtC,GAAG,CAAC7F,QAAQ,CAACb,UAAU,CAACT,QAAQ,CAAC2D,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,eAAe;UAChI,OAAO,IAAI;QACf;QACA,IAAI,CAACiF,mBAAmB,IAAI5I,QAAQ,CAAC2D,MAAM,GAAG,CAAC,IAAI8F,cAAc,CAACtC,GAAG,CAAC7F,QAAQ,CAACb,UAAU,CAACT,QAAQ,CAAC2D,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,eAAe;UACjI,OAAO,IAAI;QACf;MACJ;MACAnF,KAAK,CAACkL,iBAAiB,CAAC1J,QAAQ,CAACK,UAAU,CAAC;MAC5C,MAAMsJ,UAAU,GAAGnL,KAAK,CAACoL,aAAa,CAAC5J,QAAQ,CAACK,UAAU,CAAC;MAC3D,IAAIwJ,mBAAmB,GAAG,KAAK;MAC/B,IAAI;QACAA,mBAAmB,GAAGzL,6BAA6B,CAACyL,mBAAmB,CAAC7B,eAAe,EAAE2B,UAAU,EAAEf,mBAAmB,GAAG5I,QAAQ,CAAC2D,MAAM,GAAG3D,QAAQ,CAAC2D,MAAM,GAAG,CAAC,CAAC;MACrK,CAAC,CACD,OAAOmG,CAAC,EAAE;QACNzM,iBAAiB,CAACyM,CAAC,CAAC;MACxB;MACA,IAAI,CAACD,mBAAmB,EAAE;QACtB,OAAO,IAAI;MACf;IACJ;IACA,IAAIV,2BAA2B,EAAE;MAC7B,OAAOnB,eAAe,CAACL,KAAK,CAACxD,SAAS,CAAC,CAAC,EAAE6D,eAAe,CAACL,KAAK,CAAC9I,MAAM,GAAGqK,uBAAuB,CAACrK,MAAM,CAAC;IAC5G,CAAC,MACI;MACD,OAAOmJ,eAAe,CAACL,KAAK;IAChC;EACJ;EACA,OAAOoC,2BAA2BA,CAAC1G,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiH,EAAE,EAAEkD,mBAAmB,EAAEoB,oBAAoB,EAAE;IAChI,IAAItL,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMoB,SAAS,GAAGtB,UAAU,CAACE,CAAC,CAAC;MAC/BD,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIsL,0BAA0B,CAAClK,SAAS,EAAE2F,EAAE,EAAEkD,mBAAmB,EAAEoB,oBAAoB,CAAC;IAC1G;IACA,OAAO,IAAIlM,mBAAmB,CAAC,CAAC,CAAC,cAAcY,QAAQ,EAAE;MACrDiB,4BAA4B,EAAE,IAAI;MAClCC,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;EACA,OAAOsK,mBAAmBA,CAAC3L,MAAM,EAAEmH,EAAE,EAAE;IACnC,IAAI3H,OAAO,CAAC2H,EAAE,CAAC,EAAE;MACb,OAAQnH,MAAM,CAAC4L,YAAY,KAAK,QAAQ,IAAI5L,MAAM,CAAC4L,YAAY,KAAK,iBAAiB;IACzF,CAAC,MACI;MACD;MACA,OAAQ5L,MAAM,CAAC4L,YAAY,KAAK,UAAU,IAAI5L,MAAM,CAAC4L,YAAY,KAAK,iBAAiB;IAC3F;EACJ;EACA,OAAOC,wBAAwBA,CAAC7L,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiH,EAAE,EAAE;IAC3D,IAAI,CAACrH,cAAc,CAAC6L,mBAAmB,CAAC3L,MAAM,EAAEmH,EAAE,CAAC,IAAI,CAACnH,MAAM,CAAC8L,gBAAgB,CAACC,cAAc,CAAC5E,EAAE,CAAC,EAAE;MAChG,OAAO,KAAK;IAChB;IACA,MAAM6E,uBAAuB,GAAGxM,OAAO,CAAC2H,EAAE,CAAC;IAC3C,KAAK,IAAI/G,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMoB,SAAS,GAAGtB,UAAU,CAACE,CAAC,CAAC;MAC/B,IAAIoB,SAAS,CAACG,OAAO,CAAC,CAAC,EAAE;QACrB,OAAO,KAAK;MAChB;MACA,IAAIsK,+BAA+B,GAAG,IAAI;MAC1C,KAAK,IAAInK,UAAU,GAAGN,SAAS,CAAC2C,eAAe,EAAErC,UAAU,IAAIN,SAAS,CAACiD,aAAa,EAAE3C,UAAU,EAAE,EAAE;QAClG,MAAMiB,QAAQ,GAAG9C,KAAK,CAAC+C,cAAc,CAAClB,UAAU,CAAC;QACjD,MAAMoK,UAAU,GAAIpK,UAAU,KAAKN,SAAS,CAAC2C,eAAe,GAAG3C,SAAS,CAACmD,WAAW,GAAG,CAAC,GAAG,CAAE;QAC7F,MAAMwH,QAAQ,GAAIrK,UAAU,KAAKN,SAAS,CAACiD,aAAa,GAAGjD,SAAS,CAACoD,SAAS,GAAG,CAAC,GAAG7B,QAAQ,CAACzC,MAAO;QACrG,MAAM8L,YAAY,GAAGrJ,QAAQ,CAAC6C,SAAS,CAACsG,UAAU,EAAEC,QAAQ,CAAC;QAC7D,IAAI,QAAQ,CAAC/H,IAAI,CAACgI,YAAY,CAAC,EAAE;UAC7B;UACAH,+BAA+B,GAAG,KAAK;UACvC;QACJ;MACJ;MACA,IAAIA,+BAA+B,EAAE;QACjC,OAAO,KAAK;MAChB;MACA,IAAID,uBAAuB,IAAIxK,SAAS,CAAC2C,eAAe,KAAK3C,SAAS,CAACiD,aAAa,IAAIjD,SAAS,CAACmD,WAAW,GAAG,CAAC,KAAKnD,SAAS,CAACoD,SAAS,EAAE;QACvI,MAAMyH,aAAa,GAAGpM,KAAK,CAACsF,eAAe,CAAC/D,SAAS,CAAC;QACtD,IAAIhC,OAAO,CAAC6M,aAAa,CAAC,EAAE;UACxB;UACA;UACA,OAAO,KAAK;QAChB;MACJ;IACJ;IACA,OAAO,IAAI;EACf;EACA,OAAOC,yBAAyBA,CAACxH,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiH,EAAE,EAAE;IACnF,IAAIhH,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAMoB,SAAS,GAAGtB,UAAU,CAACE,CAAC,CAAC;MAC/B,MAAMmM,cAAc,GAAGvM,MAAM,CAAC8L,gBAAgB,CAAC3E,EAAE,CAAC;MAClDhH,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIf,wBAAwB,CAACmC,SAAS,EAAE2F,EAAE,EAAEoF,cAAc,CAAC;IAC7E;IACA,OAAO,IAAIhN,mBAAmB,CAAC,CAAC,CAAC,aAAaY,QAAQ,EAAE;MACpDiB,4BAA4B,EAAE,IAAI;MAClCC,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;EACA,OAAOmL,8BAA8BA,CAACxM,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAC7D,IAAIA,UAAU,CAACI,MAAM,KAAK,CAAC,IAAIL,KAAK,CAACoE,iBAAiB,CAACnE,UAAU,CAAC,CAAC,CAAC,CAACqG,cAAc,CAAC,CAAC,CAACzE,UAAU,CAAC,EAAE;MAC/F,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACA,OAAO2K,4BAA4BA,CAAC3H,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEuB,SAAS,EAAE2F,EAAE,EAAE;IACrF,IAAI,CAACnH,MAAM,CAAC0M,aAAa,CAACX,cAAc,CAAC5E,EAAE,CAAC,IAAI,CAAC3F,SAAS,CAACG,OAAO,CAAC,CAAC,EAAE;MAClE,OAAO,IAAI;IACf;IACA,IAAIF,QAAQ,GAAGD,SAAS,CAACE,WAAW,CAAC,CAAC;IACtCzB,KAAK,CAACkL,iBAAiB,CAAC1J,QAAQ,CAACK,UAAU,CAAC;IAC5C,IAAIsJ,UAAU,GAAGnL,KAAK,CAACoL,aAAa,CAAC5J,QAAQ,CAACK,UAAU,CAAC;IACzD,IAAI6K,cAAc;IAClB,IAAI;MACAA,cAAc,GAAG9M,6BAA6B,CAAC+M,mBAAmB,CAACzF,EAAE,EAAEiE,UAAU,EAAE3J,QAAQ,CAAC2D,MAAM,CAAC;IACvG,CAAC,CACD,OAAOmG,CAAC,EAAE;MACNzM,iBAAiB,CAACyM,CAAC,CAAC;MACpB,OAAO,IAAI;IACf;IACA,IAAI,CAACoB,cAAc,EAAE;MACjB,OAAO,IAAI;IACf;IACA,IAAIA,cAAc,CAACE,gBAAgB,EAAE;MACjC,IAAIjI,SAAS,GAAG,CAACwG,UAAU,CAACpI,cAAc,CAAC,CAAC,GAAGmE,EAAE,EAAE2F,WAAW,CAACH,cAAc,CAACE,gBAAgB,CAAC,GAAG,CAAC;MACnG,IAAIE,KAAK,GAAG9M,KAAK,CAAC+M,qBAAqB,CAACL,cAAc,CAACE,gBAAgB,EAAE;QACrE/K,UAAU,EAAEL,QAAQ,CAACK,UAAU;QAC/BsD,MAAM,EAAER;MACZ,CAAC,CAAC;MACF,IAAImI,KAAK,EAAE;QACP,IAAIA,KAAK,CAAC5I,eAAe,KAAK1C,QAAQ,CAACK,UAAU,EAAE;UAC/C;UACA,OAAO,IAAI;QACf;QACA,IAAImL,SAAS,GAAGhN,KAAK,CAAC+C,cAAc,CAAC+J,KAAK,CAAC5I,eAAe,CAAC;QAC3D,IAAI+I,oBAAoB,GAAGnO,OAAO,CAAC4G,oBAAoB,CAACsH,SAAS,CAAC;QAClE,IAAIE,cAAc,GAAGnN,MAAM,CAAC0D,oBAAoB,CAACwJ,oBAAoB,CAAC;QACtE,IAAInK,QAAQ,GAAG9C,KAAK,CAAC+C,cAAc,CAACvB,QAAQ,CAACK,UAAU,CAAC;QACxD,IAAIsL,uBAAuB,GAAGnN,KAAK,CAACsH,+BAA+B,CAAC9F,QAAQ,CAACK,UAAU,CAAC,IAAIL,QAAQ,CAAC2D,MAAM;QAC3G,IAAIiI,MAAM,GAAGtK,QAAQ,CAAC6C,SAAS,CAACwH,uBAAuB,GAAG,CAAC,EAAE3L,QAAQ,CAAC2D,MAAM,GAAG,CAAC,CAAC;QACjF,IAAIvB,QAAQ,GAAGsJ,cAAc,GAAGE,MAAM,GAAGlG,EAAE;QAC3C,IAAItF,aAAa,GAAG,IAAInC,KAAK,CAAC+B,QAAQ,CAACK,UAAU,EAAE,CAAC,EAAEL,QAAQ,CAACK,UAAU,EAAEL,QAAQ,CAAC2D,MAAM,CAAC;QAC3F,MAAMkI,OAAO,GAAG,IAAItO,cAAc,CAAC6C,aAAa,EAAEgC,QAAQ,CAAC;QAC3D,OAAO,IAAItE,mBAAmB,CAAC,CAAC,CAAC,cAAc,CAAC+N,OAAO,CAAC,EAAE;UACtDlM,4BAA4B,EAAE,KAAK;UACnCC,2BAA2B,EAAE;QACjC,CAAC,CAAC;MACN;IACJ;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACI,OAAOkM,8BAA8BA,CAACzI,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEuN,gCAAgC,EAAEtN,UAAU,EAAEuH,oBAAoB,EAAE;IAC5I,IAAI,CAAC+F,gCAAgC,IAAI7N,SAAS,CAAC8N,kBAAkB,CAACD,gCAAgC,EAAEtN,UAAU,CAAC,EAAE;MACjH;MACA,OAAO,IAAI;IACf;IACA,IAAIiH,EAAE,GAAG,IAAI;IACb;IACA,KAAK,MAAM3F,SAAS,IAAItB,UAAU,EAAE;MAChC,IAAI,CAACsB,SAAS,CAACG,OAAO,CAAC,CAAC,EAAE;QACtB,OAAO,IAAI;MACf;MACA,MAAMF,QAAQ,GAAGD,SAAS,CAACE,WAAW,CAAC,CAAC;MACxC,MAAMgM,WAAW,GAAGzN,KAAK,CAACsF,eAAe,CAAC,IAAI7F,KAAK,CAAC+B,QAAQ,CAACK,UAAU,EAAEL,QAAQ,CAAC2D,MAAM,GAAG,CAAC,EAAE3D,QAAQ,CAACK,UAAU,EAAEL,QAAQ,CAAC2D,MAAM,CAAC,CAAC;MACpI,IAAI+B,EAAE,KAAK,IAAI,EAAE;QACbA,EAAE,GAAGuG,WAAW;MACpB,CAAC,MACI,IAAIvG,EAAE,KAAKuG,WAAW,EAAE;QACzB,OAAO,IAAI;MACf;IACJ;IACA,IAAI,CAACvG,EAAE,EAAE;MACL,OAAO,IAAI;IACf;IACA,IAAI,IAAI,CAACK,sBAAsB,CAACxH,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEuH,oBAAoB,EAAEN,EAAE,CAAC,EAAE;MAClF;MACA,MAAMhH,QAAQ,GAAGD,UAAU,CAACuK,GAAG,CAACC,CAAC,IAAI,IAAI1L,cAAc,CAAC,IAAIU,KAAK,CAACgL,CAAC,CAACiD,kBAAkB,EAAEjD,CAAC,CAACkD,cAAc,EAAElD,CAAC,CAACiD,kBAAkB,EAAEjD,CAAC,CAACkD,cAAc,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;MAClK,OAAO,IAAIrO,mBAAmB,CAAC,CAAC,CAAC,cAAcY,QAAQ,EAAE;QACrDiB,4BAA4B,EAAE,IAAI;QAClCC,2BAA2B,EAAE;MACjC,CAAC,CAAC;IACN;IACA,MAAMoK,oBAAoB,GAAG,IAAI,CAACrB,wBAAwB,CAACpK,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiH,EAAE,EAAE,KAAK,CAAC;IAChG,IAAIsE,oBAAoB,KAAK,IAAI,EAAE;MAC/B,OAAO,IAAI,CAACD,2BAA2B,CAAC1G,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiH,EAAE,EAAE,KAAK,EAAEsE,oBAAoB,CAAC;IAC9H;IACA,OAAO,IAAI;EACf;EACA,OAAOoC,oBAAoBA,CAACC,kBAAkB,EAAEhJ,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEuH,oBAAoB,EAAEN,EAAE,EAAE;IACxH,IAAI,CAAC2G,kBAAkB,IAAI3G,EAAE,KAAK,IAAI,EAAE;MACpC,IAAIhH,QAAQ,GAAG,EAAE;MACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QACnDD,QAAQ,CAACC,CAAC,CAAC,GAAGN,cAAc,CAAC4F,MAAM,CAAC1F,MAAM,EAAEC,KAAK,EAAE,KAAK,EAAEC,UAAU,CAACE,CAAC,CAAC,CAAC;MAC5E;MACA,OAAO,IAAIb,mBAAmB,CAAC,CAAC,CAAC,cAAcY,QAAQ,EAAE;QACrDiB,4BAA4B,EAAE,IAAI;QAClCC,2BAA2B,EAAE;MACjC,CAAC,CAAC;IACN;IACA,IAAI,CAACyM,kBAAkB,IAAI,IAAI,CAAC7G,iBAAiB,CAACjH,MAAM,EAAEC,KAAK,EAAEC,UAAU,CAAC,EAAE;MAC1E,IAAIC,QAAQ,GAAG,EAAE;MACjB,IAAI4N,eAAe,GAAG,KAAK;MAC3B,KAAK,IAAI3N,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QACnDD,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAI,CAAC8G,kBAAkB,CAAClH,MAAM,EAAEC,KAAK,EAAEC,UAAU,CAACE,CAAC,CAAC,EAAE+G,EAAE,CAAC;QACvE,IAAI,CAAChH,QAAQ,CAACC,CAAC,CAAC,EAAE;UACd2N,eAAe,GAAG,IAAI;UACtB;QACJ;MACJ;MACA,IAAI,CAACA,eAAe,EAAE;QAClB,OAAO,IAAIxO,mBAAmB,CAAC,CAAC,CAAC,cAAcY,QAAQ,EAAE;UACrDiB,4BAA4B,EAAE,IAAI;UAClCC,2BAA2B,EAAE;QACjC,CAAC,CAAC;MACN;IACJ;IACA,IAAI,CAACyM,kBAAkB,IAAI,IAAI,CAACtG,sBAAsB,CAACxH,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEuH,oBAAoB,EAAEN,EAAE,CAAC,EAAE;MACzG,OAAO,IAAI,CAACmB,uBAAuB,CAACxD,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiH,EAAE,CAAC;IAC7F;IACA,IAAI,CAAC2G,kBAAkB,EAAE;MACrB,MAAMrC,oBAAoB,GAAG,IAAI,CAACrB,wBAAwB,CAACpK,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiH,EAAE,EAAE,IAAI,CAAC;MAC/F,IAAIsE,oBAAoB,EAAE;QACtB,OAAO,IAAI,CAACD,2BAA2B,CAAC1G,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiH,EAAE,EAAE,IAAI,EAAEsE,oBAAoB,CAAC;MAC7H;IACJ;IACA,IAAI,IAAI,CAACI,wBAAwB,CAAC7L,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiH,EAAE,CAAC,EAAE;MAC9D,OAAO,IAAI,CAACmF,yBAAyB,CAACxH,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEiH,EAAE,CAAC;IAC/F;IACA;IACA;IACA,IAAI,CAAC2G,kBAAkB,IAAI,IAAI,CAACtB,8BAA8B,CAACxM,MAAM,EAAEC,KAAK,EAAEC,UAAU,CAAC,EAAE;MACvF,MAAM2F,CAAC,GAAG,IAAI,CAAC4G,4BAA4B,CAAC3H,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEC,UAAU,CAAC,CAAC,CAAC,EAAEiH,EAAE,CAAC;MACpG,IAAItB,CAAC,EAAE;QACH,OAAOA,CAAC;MACZ;IACJ;IACA;IACA,IAAI1F,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnDD,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIpB,cAAc,CAACkB,UAAU,CAACE,CAAC,CAAC,EAAE+G,EAAE,CAAC;IACvD;IACA,IAAI/F,4BAA4B,GAAI0D,qBAAqB,KAAK,CAAC,CAAC,YAAa;IAC7E,IAAIqC,EAAE,KAAK,GAAG,EAAE;MACZ/F,4BAA4B,GAAG,IAAI;IACvC;IACA,OAAO,IAAI7B,mBAAmB,CAAC,CAAC,CAAC,cAAcY,QAAQ,EAAE;MACrDiB,4BAA4B,EAAEA,4BAA4B;MAC1DC,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;EACA,OAAO2M,uBAAuBA,CAAClJ,qBAAqB,EAAE9E,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE+N,GAAG,EAAE;IAClF,IAAI9N,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnDD,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIpB,cAAc,CAACkB,UAAU,CAACE,CAAC,CAAC,EAAE6N,GAAG,CAAC;IACxD;IACA,OAAO,IAAI1O,mBAAmB,CAAC,CAAC,CAAC,cAAcY,QAAQ,EAAE;MACrDiB,4BAA4B,EAAG0D,qBAAqB,KAAK,CAAC,CAAC,YAAa;MACxEzD,2BAA2B,EAAE;IACjC,CAAC,CAAC;EACN;EACA,OAAO6M,gBAAgBA,CAAClO,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAC/C,IAAID,KAAK,KAAK,IAAI,IAAIC,UAAU,KAAK,IAAI,EAAE;MACvC,OAAO,EAAE;IACb;IACA,IAAIC,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,IAAI0B,UAAU,GAAG5B,UAAU,CAACE,CAAC,CAAC,CAACuN,kBAAkB;MACjD,IAAI7L,UAAU,KAAK,CAAC,EAAE;QAClB3B,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAIlB,qCAAqC,CAAC,IAAIQ,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC;MACxF,CAAC,MACI;QACDoC,UAAU,EAAE;QACZ,IAAIsD,MAAM,GAAGnF,KAAK,CAACmD,gBAAgB,CAACtB,UAAU,CAAC;QAC/C3B,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAI,CAACsF,MAAM,CAAC1F,MAAM,EAAEC,KAAK,EAAE,KAAK,EAAE,IAAIP,KAAK,CAACoC,UAAU,EAAEsD,MAAM,EAAEtD,UAAU,EAAEsD,MAAM,CAAC,CAAC;MACtG;IACJ;IACA,OAAOjF,QAAQ;EACnB;EACA,OAAOgO,eAAeA,CAACnO,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAC9C,IAAID,KAAK,KAAK,IAAI,IAAIC,UAAU,KAAK,IAAI,EAAE;MACvC,OAAO,EAAE;IACb;IACA,IAAIC,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnD,MAAM0B,UAAU,GAAG5B,UAAU,CAACE,CAAC,CAAC,CAACuN,kBAAkB;MACnD,IAAIvI,MAAM,GAAGnF,KAAK,CAACmD,gBAAgB,CAACtB,UAAU,CAAC;MAC/C3B,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAI,CAACsF,MAAM,CAAC1F,MAAM,EAAEC,KAAK,EAAE,KAAK,EAAE,IAAIP,KAAK,CAACoC,UAAU,EAAEsD,MAAM,EAAEtD,UAAU,EAAEsD,MAAM,CAAC,CAAC;IACtG;IACA,OAAOjF,QAAQ;EACnB;EACA,OAAOiO,eAAeA,CAACpO,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAE;IAC9C,IAAIC,QAAQ,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,UAAU,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACnDD,QAAQ,CAACC,CAAC,CAAC,GAAG,IAAI,CAACsF,MAAM,CAAC1F,MAAM,EAAEC,KAAK,EAAE,IAAI,EAAEC,UAAU,CAACE,CAAC,CAAC,CAAC;IACjE;IACA,OAAOD,QAAQ;EACnB;AACJ;AACA,OAAO,MAAMuL,0BAA0B,SAASzM,mCAAmC,CAAC;EAChFoP,WAAWA,CAAC7M,SAAS,EAAE8M,aAAa,EAAEjE,mBAAmB,EAAEkC,cAAc,EAAE;IACvE,KAAK,CAAC/K,SAAS,EAAE,CAAC6I,mBAAmB,GAAGiE,aAAa,GAAG,EAAE,IAAI/B,cAAc,EAAE,CAAC,EAAE,CAACA,cAAc,CAACjM,MAAM,CAAC;IACxG,IAAI,CAACiO,cAAc,GAAGD,aAAa;IACnC,IAAI,CAACE,eAAe,GAAGjC,cAAc;IACrC,IAAI,CAACkC,mBAAmB,GAAG,IAAI;IAC/B,IAAI,CAACC,cAAc,GAAG,IAAI;EAC9B;EACAC,kBAAkBA,CAAC1O,KAAK,EAAE2O,MAAM,EAAE;IAC9B,IAAIC,qBAAqB,GAAGD,MAAM,CAACE,wBAAwB,CAAC,CAAC;IAC7D,IAAIzJ,KAAK,GAAGwJ,qBAAqB,CAAC,CAAC,CAAC,CAACxJ,KAAK;IAC1C,IAAI,CAACoJ,mBAAmB,GAAG,IAAI/O,KAAK,CAAC2F,KAAK,CAAClB,eAAe,EAAEkB,KAAK,CAACT,SAAS,GAAG,IAAI,CAAC4J,eAAe,CAAClO,MAAM,EAAE+E,KAAK,CAACZ,aAAa,EAAEY,KAAK,CAACT,SAAS,CAAC;IAChJ,IAAI,CAAC8J,cAAc,GAAG,IAAIhP,KAAK,CAAC2F,KAAK,CAAClB,eAAe,EAAEkB,KAAK,CAACT,SAAS,GAAG,IAAI,CAAC2J,cAAc,CAACjO,MAAM,GAAG,IAAI,CAACkO,eAAe,CAAClO,MAAM,EAAE+E,KAAK,CAACZ,aAAa,EAAEY,KAAK,CAACT,SAAS,CAAC;IACxK,OAAO,KAAK,CAAC+J,kBAAkB,CAAC1O,KAAK,EAAE2O,MAAM,CAAC;EAClD;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}