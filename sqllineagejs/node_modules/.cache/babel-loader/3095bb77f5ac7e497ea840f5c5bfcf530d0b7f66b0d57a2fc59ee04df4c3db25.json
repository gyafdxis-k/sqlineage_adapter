{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { groupBy } from '../../../base/common/arrays.js';\nimport { dispose } from '../../../base/common/lifecycle.js';\nimport { getLeadingWhitespace } from '../../../base/common/strings.js';\nimport './snippetSession.css';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { ModelDecorationOptions } from '../../common/model/textModel.js';\nimport { IWorkspaceContextService } from '../../../platform/workspace/common/workspace.js';\nimport { optional } from '../../../platform/instantiation/common/instantiation.js';\nimport { Choice, Placeholder, SnippetParser, Text } from './snippetParser.js';\nimport { ClipboardBasedVariableResolver, CompositeSnippetVariableResolver, ModelBasedVariableResolver, SelectionBasedVariableResolver, TimeBasedVariableResolver, CommentBasedVariableResolver, WorkspaceBasedVariableResolver, RandomBasedVariableResolver } from './snippetVariables.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\nimport * as colors from '../../../platform/theme/common/colorRegistry.js';\nimport { ILabelService } from '../../../platform/label/common/label.js';\nregisterThemingParticipant((theme, collector) => {\n  function getColorGraceful(name) {\n    const color = theme.getColor(name);\n    return color ? color.toString() : 'transparent';\n  }\n  collector.addRule(\".monaco-editor .snippet-placeholder { background-color: \".concat(getColorGraceful(colors.snippetTabstopHighlightBackground), \"; outline-color: \").concat(getColorGraceful(colors.snippetTabstopHighlightBorder), \"; }\"));\n  collector.addRule(\".monaco-editor .finish-snippet-placeholder { background-color: \".concat(getColorGraceful(colors.snippetFinalTabstopHighlightBackground), \"; outline-color: \").concat(getColorGraceful(colors.snippetFinalTabstopHighlightBorder), \"; }\"));\n});\nexport class OneSnippet {\n  constructor(_editor, _snippet, _offset, _snippetLineLeadingWhitespace) {\n    this._editor = _editor;\n    this._snippet = _snippet;\n    this._offset = _offset;\n    this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;\n    this._nestingLevel = 1;\n    this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);\n    this._placeholderGroupsIdx = -1;\n  }\n  dispose() {\n    if (this._placeholderDecorations) {\n      this._editor.deltaDecorations([...this._placeholderDecorations.values()], []);\n    }\n    this._placeholderGroups.length = 0;\n  }\n  _initDecorations() {\n    if (this._placeholderDecorations) {\n      // already initialized\n      return;\n    }\n    this._placeholderDecorations = new Map();\n    const model = this._editor.getModel();\n    this._editor.changeDecorations(accessor => {\n      // create a decoration for each placeholder\n      for (const placeholder of this._snippet.placeholders) {\n        const placeholderOffset = this._snippet.offset(placeholder);\n        const placeholderLen = this._snippet.fullLen(placeholder);\n        const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));\n        const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n        const handle = accessor.addDecoration(range, options);\n        this._placeholderDecorations.set(placeholder, handle);\n      }\n    });\n  }\n  move(fwd) {\n    if (!this._editor.hasModel()) {\n      return [];\n    }\n    this._initDecorations();\n    // Transform placeholder text if necessary\n    if (this._placeholderGroupsIdx >= 0) {\n      let operations = [];\n      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n        // Check if the placeholder has a transformation\n        if (placeholder.transform) {\n          const id = this._placeholderDecorations.get(placeholder);\n          const range = this._editor.getModel().getDecorationRange(id);\n          const currentValue = this._editor.getModel().getValueInRange(range);\n          const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\\r\\n|\\r|\\n/);\n          // fix indentation for transformed lines\n          for (let i = 1; i < transformedValueLines.length; i++) {\n            transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);\n          }\n          operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));\n        }\n      }\n      if (operations.length > 0) {\n        this._editor.executeEdits('snippet.placeholderTransform', operations);\n      }\n    }\n    let couldSkipThisPlaceholder = false;\n    if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n      this._placeholderGroupsIdx += 1;\n      couldSkipThisPlaceholder = true;\n    } else if (fwd === false && this._placeholderGroupsIdx > 0) {\n      this._placeholderGroupsIdx -= 1;\n      couldSkipThisPlaceholder = true;\n    } else {\n      // the selection of the current placeholder might\n      // not acurate any more -> simply restore it\n    }\n    const newSelections = this._editor.getModel().changeDecorations(accessor => {\n      const activePlaceholders = new Set();\n      // change stickiness to always grow when typing at its edges\n      // because these decorations represent the currently active\n      // tabstop.\n      // Special case #1: reaching the final tabstop\n      // Special case #2: placeholders enclosing active placeholders\n      const selections = [];\n      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n        const id = this._placeholderDecorations.get(placeholder);\n        const range = this._editor.getModel().getDecorationRange(id);\n        selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));\n        // consider to skip this placeholder index when the decoration\n        // range is empty but when the placeholder wasn't. that's a strong\n        // hint that the placeholder has been deleted. (all placeholder must match this)\n        couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);\n        accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n        activePlaceholders.add(placeholder);\n        for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {\n          const id = this._placeholderDecorations.get(enclosingPlaceholder);\n          accessor.changeDecorationOptions(id, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n          activePlaceholders.add(enclosingPlaceholder);\n        }\n      }\n      // change stickness to never grow when typing at its edges\n      // so that in-active tabstops never grow\n      for (const [placeholder, id] of this._placeholderDecorations) {\n        if (!activePlaceholders.has(placeholder)) {\n          accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n        }\n      }\n      return selections;\n    });\n    return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);\n  }\n  _hasPlaceholderBeenCollapsed(placeholder) {\n    // A placeholder is empty when it wasn't empty when authored but\n    // when its tracking decoration is empty. This also applies to all\n    // potential parent placeholders\n    let marker = placeholder;\n    while (marker) {\n      if (marker instanceof Placeholder) {\n        const id = this._placeholderDecorations.get(marker);\n        const range = this._editor.getModel().getDecorationRange(id);\n        if (range.isEmpty() && marker.toString().length > 0) {\n          return true;\n        }\n      }\n      marker = marker.parent;\n    }\n    return false;\n  }\n  get isAtFirstPlaceholder() {\n    return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n  }\n  get isAtLastPlaceholder() {\n    return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n  }\n  get hasPlaceholder() {\n    return this._snippet.placeholders.length > 0;\n  }\n  computePossibleSelections() {\n    const result = new Map();\n    for (const placeholdersWithEqualIndex of this._placeholderGroups) {\n      let ranges;\n      for (const placeholder of placeholdersWithEqualIndex) {\n        if (placeholder.isFinalTabstop) {\n          // ignore those\n          break;\n        }\n        if (!ranges) {\n          ranges = [];\n          result.set(placeholder.index, ranges);\n        }\n        const id = this._placeholderDecorations.get(placeholder);\n        const range = this._editor.getModel().getDecorationRange(id);\n        if (!range) {\n          // one of the placeholder lost its decoration and\n          // therefore we bail out and pretend the placeholder\n          // (with its mirrors) doesn't exist anymore.\n          result.delete(placeholder.index);\n          break;\n        }\n        ranges.push(range);\n      }\n    }\n    return result;\n  }\n  get choice() {\n    return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;\n  }\n  merge(others) {\n    const model = this._editor.getModel();\n    this._nestingLevel *= 10;\n    this._editor.changeDecorations(accessor => {\n      // For each active placeholder take one snippet and merge it\n      // in that the placeholder (can be many for `$1foo$1foo`). Because\n      // everything is sorted by editor selection we can simply remove\n      // elements from the beginning of the array\n      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n        const nested = others.shift();\n        console.assert(!nested._placeholderDecorations);\n        // Massage placeholder-indicies of the nested snippet to be\n        // sorted right after the insertion point. This ensures we move\n        // through the placeholders in the correct order\n        const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\n        for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {\n          if (nestedPlaceholder.isFinalTabstop) {\n            nestedPlaceholder.index = placeholder.index + (indexLastPlaceholder + 1) / this._nestingLevel;\n          } else {\n            nestedPlaceholder.index = placeholder.index + nestedPlaceholder.index / this._nestingLevel;\n          }\n        }\n        this._snippet.replace(placeholder, nested._snippet.children);\n        // Remove the placeholder at which position are inserting\n        // the snippet and also remove its decoration.\n        const id = this._placeholderDecorations.get(placeholder);\n        accessor.removeDecoration(id);\n        this._placeholderDecorations.delete(placeholder);\n        // For each *new* placeholder we create decoration to monitor\n        // how and if it grows/shrinks.\n        for (const placeholder of nested._snippet.placeholders) {\n          const placeholderOffset = nested._snippet.offset(placeholder);\n          const placeholderLen = nested._snippet.fullLen(placeholder);\n          const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\n          const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n          this._placeholderDecorations.set(placeholder, handle);\n        }\n      }\n      // Last, re-create the placeholder groups by sorting placeholders by their index.\n      this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);\n    });\n  }\n}\nOneSnippet._decor = {\n  active: ModelDecorationOptions.register({\n    stickiness: 0 /* AlwaysGrowsWhenTypingAtEdges */,\n    className: 'snippet-placeholder'\n  }),\n  inactive: ModelDecorationOptions.register({\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    className: 'snippet-placeholder'\n  }),\n  activeFinal: ModelDecorationOptions.register({\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    className: 'finish-snippet-placeholder'\n  }),\n  inactiveFinal: ModelDecorationOptions.register({\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\n    className: 'finish-snippet-placeholder'\n  })\n};\nconst _defaultOptions = {\n  overwriteBefore: 0,\n  overwriteAfter: 0,\n  adjustWhitespace: true,\n  clipboardText: undefined,\n  overtypingCapturer: undefined\n};\nexport class SnippetSession {\n  constructor(editor, template) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _defaultOptions;\n    this._templateMerges = [];\n    this._snippets = [];\n    this._editor = editor;\n    this._template = template;\n    this._options = options;\n  }\n  static adjustWhitespace(model, position, snippet, adjustIndentation, adjustNewlines) {\n    const line = model.getLineContent(position.lineNumber);\n    const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);\n    // the snippet as inserted\n    let snippetTextString;\n    snippet.walk(marker => {\n      // all text elements that are not inside choice\n      if (!(marker instanceof Text) || marker.parent instanceof Choice) {\n        return true;\n      }\n      const lines = marker.value.split(/\\r\\n|\\r|\\n/);\n      if (adjustIndentation) {\n        // adjust indentation of snippet test\n        // -the snippet-start doesn't get extra-indented (lineLeadingWhitespace), only normalized\n        // -all N+1 lines get extra-indented and normalized\n        // -the text start get extra-indented and normalized when following a linebreak\n        const offset = snippet.offset(marker);\n        if (offset === 0) {\n          // snippet start\n          lines[0] = model.normalizeIndentation(lines[0]);\n        } else {\n          // check if text start is after a linebreak\n          snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();\n          let prevChar = snippetTextString.charCodeAt(offset - 1);\n          if (prevChar === 10 /* LineFeed */ || prevChar === 13 /* CarriageReturn */) {\n            lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);\n          }\n        }\n        for (let i = 1; i < lines.length; i++) {\n          lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);\n        }\n      }\n      const newValue = lines.join(model.getEOL());\n      if (newValue !== marker.value) {\n        marker.parent.replace(marker, [new Text(newValue)]);\n        snippetTextString = undefined;\n      }\n      return true;\n    });\n    return lineLeadingWhitespace;\n  }\n  static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {\n    if (overwriteBefore !== 0 || overwriteAfter !== 0) {\n      // overwrite[Before|After] is compute using the position, not the whole\n      // selection. therefore we adjust the selection around that position\n      const {\n        positionLineNumber,\n        positionColumn\n      } = selection;\n      const positionColumnBefore = positionColumn - overwriteBefore;\n      const positionColumnAfter = positionColumn + overwriteAfter;\n      const range = model.validateRange({\n        startLineNumber: positionLineNumber,\n        startColumn: positionColumnBefore,\n        endLineNumber: positionLineNumber,\n        endColumn: positionColumnAfter\n      });\n      selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\n    }\n    return selection;\n  }\n  static createEditsAndSnippets(editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer) {\n    const edits = [];\n    const snippets = [];\n    if (!editor.hasModel()) {\n      return {\n        edits,\n        snippets\n      };\n    }\n    const model = editor.getModel();\n    const workspaceService = editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService, optional));\n    const modelBasedVariableResolver = editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService, optional), model));\n    const readClipboardText = () => clipboardText;\n    let delta = 0;\n    // know what text the overwrite[Before|After] extensions\n    // of the primary curser have selected because only when\n    // secondary selections extend to the same text we can grow them\n    let firstBeforeText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n    let firstAfterText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\n    // remember the first non-whitespace column to decide if\n    // `keepWhitespace` should be overruled for secondary selections\n    let firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\n    // sort selections by their start position but remeber\n    // the original index. that allows you to create correct\n    // offset-based selection logic without changing the\n    // primary selection\n    const indexedSelections = editor.getSelections().map((selection, idx) => ({\n      selection,\n      idx\n    })).sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));\n    for (const {\n      selection,\n      idx\n    } of indexedSelections) {\n      // extend selection with the `overwriteBefore` and `overwriteAfter` and then\n      // compare if this matches the extensions of the primary selection\n      let extensionBefore = SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);\n      let extensionAfter = SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);\n      if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n        extensionBefore = selection;\n      }\n      if (firstAfterText !== model.getValueInRange(extensionAfter)) {\n        extensionAfter = selection;\n      }\n      // merge the before and after selection into one\n      const snippetSelection = selection.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn).setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n      const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);\n      // adjust the template string to match the indentation and\n      // whitespace rules of this insert location (can be different for each cursor)\n      // happens when being asked for (default) or when this is a secondary\n      // cursor and the leading whitespace is different\n      const start = snippetSelection.getStartPosition();\n      const snippetLineLeadingWhitespace = SnippetSession.adjustWhitespace(model, start, snippet, adjustWhitespace || idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber), true);\n      snippet.resolveVariables(new CompositeSnippetVariableResolver([modelBasedVariableResolver, new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor.getOption(65 /* multiCursorPaste */) === 'spread'), new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer), new CommentBasedVariableResolver(model, selection), new TimeBasedVariableResolver(), new WorkspaceBasedVariableResolver(workspaceService), new RandomBasedVariableResolver()]));\n      const offset = model.getOffsetAt(start) + delta;\n      delta += snippet.toString().length - model.getValueLengthInRange(snippetSelection);\n      // store snippets with the index of their originating selection.\n      // that ensures the primiary cursor stays primary despite not being\n      // the one with lowest start position\n      edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());\n      edits[idx].identifier = {\n        major: idx,\n        minor: 0\n      }; // mark the edit so only our undo edits will be used to generate end cursors\n      snippets[idx] = new OneSnippet(editor, snippet, offset, snippetLineLeadingWhitespace);\n    }\n    return {\n      edits,\n      snippets\n    };\n  }\n  dispose() {\n    dispose(this._snippets);\n  }\n  _logInfo() {\n    return \"template=\\\"\".concat(this._template, \"\\\", merged_templates=\\\"\").concat(this._templateMerges.join(' -> '), \"\\\"\");\n  }\n  insert() {\n    if (!this._editor.hasModel()) {\n      return;\n    }\n    // make insert edit and start with first selections\n    const {\n      edits,\n      snippets\n    } = SnippetSession.createEditsAndSnippets(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer);\n    this._snippets = snippets;\n    this._editor.executeEdits('snippet', edits, undoEdits => {\n      if (this._snippets[0].hasPlaceholder) {\n        return this._move(true);\n      } else {\n        return undoEdits.filter(edit => !!edit.identifier) // only use our undo edits\n        .map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n      }\n    });\n    this._editor.revealRange(this._editor.getSelections()[0]);\n  }\n  merge(template) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultOptions;\n    if (!this._editor.hasModel()) {\n      return;\n    }\n    this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n    const {\n      edits,\n      snippets\n    } = SnippetSession.createEditsAndSnippets(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer);\n    this._editor.executeEdits('snippet', edits, undoEdits => {\n      for (const snippet of this._snippets) {\n        snippet.merge(snippets);\n      }\n      console.assert(snippets.length === 0);\n      if (this._snippets[0].hasPlaceholder) {\n        return this._move(undefined);\n      } else {\n        return undoEdits.filter(edit => !!edit.identifier) // only use our undo edits\n        .map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n      }\n    });\n  }\n  next() {\n    const newSelections = this._move(true);\n    this._editor.setSelections(newSelections);\n    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n  }\n  prev() {\n    const newSelections = this._move(false);\n    this._editor.setSelections(newSelections);\n    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n  }\n  _move(fwd) {\n    const selections = [];\n    for (const snippet of this._snippets) {\n      const oneSelection = snippet.move(fwd);\n      selections.push(...oneSelection);\n    }\n    return selections;\n  }\n  get isAtFirstPlaceholder() {\n    return this._snippets[0].isAtFirstPlaceholder;\n  }\n  get isAtLastPlaceholder() {\n    return this._snippets[0].isAtLastPlaceholder;\n  }\n  get hasPlaceholder() {\n    return this._snippets[0].hasPlaceholder;\n  }\n  get choice() {\n    return this._snippets[0].choice;\n  }\n  isSelectionWithinPlaceholders() {\n    if (!this.hasPlaceholder) {\n      return false;\n    }\n    const selections = this._editor.getSelections();\n    if (selections.length < this._snippets.length) {\n      // this means we started snippet mode with N\n      // selections and have M (N > M) selections.\n      // So one snippet is without selection -> cancel\n      return false;\n    }\n    let allPossibleSelections = new Map();\n    for (const snippet of this._snippets) {\n      const possibleSelections = snippet.computePossibleSelections();\n      // for the first snippet find the placeholder (and its ranges)\n      // that contain at least one selection. for all remaining snippets\n      // the same placeholder (and their ranges) must be used.\n      if (allPossibleSelections.size === 0) {\n        for (const [index, ranges] of possibleSelections) {\n          ranges.sort(Range.compareRangesUsingStarts);\n          for (const selection of selections) {\n            if (ranges[0].containsRange(selection)) {\n              allPossibleSelections.set(index, []);\n              break;\n            }\n          }\n        }\n      }\n      if (allPossibleSelections.size === 0) {\n        // return false if we couldn't associate a selection to\n        // this (the first) snippet\n        return false;\n      }\n      // add selections from 'this' snippet so that we know all\n      // selections for this placeholder\n      allPossibleSelections.forEach((array, index) => {\n        array.push(...possibleSelections.get(index));\n      });\n    }\n    // sort selections (and later placeholder-ranges). then walk both\n    // arrays and make sure the placeholder-ranges contain the corresponding\n    // selection\n    selections.sort(Range.compareRangesUsingStarts);\n    for (let [index, ranges] of allPossibleSelections) {\n      if (ranges.length !== selections.length) {\n        allPossibleSelections.delete(index);\n        continue;\n      }\n      ranges.sort(Range.compareRangesUsingStarts);\n      for (let i = 0; i < ranges.length; i++) {\n        if (!ranges[i].containsRange(selections[i])) {\n          allPossibleSelections.delete(index);\n          continue;\n        }\n      }\n    }\n    // from all possible selections we have deleted those\n    // that don't match with the current selection. if we don't\n    // have any left, we don't have a selection anymore\n    return allPossibleSelections.size > 0;\n  }\n}","map":{"version":3,"names":["groupBy","dispose","getLeadingWhitespace","EditOperation","Range","Selection","ModelDecorationOptions","IWorkspaceContextService","optional","Choice","Placeholder","SnippetParser","Text","ClipboardBasedVariableResolver","CompositeSnippetVariableResolver","ModelBasedVariableResolver","SelectionBasedVariableResolver","TimeBasedVariableResolver","CommentBasedVariableResolver","WorkspaceBasedVariableResolver","RandomBasedVariableResolver","registerThemingParticipant","colors","ILabelService","theme","collector","getColorGraceful","name","color","getColor","toString","addRule","concat","snippetTabstopHighlightBackground","snippetTabstopHighlightBorder","snippetFinalTabstopHighlightBackground","snippetFinalTabstopHighlightBorder","OneSnippet","constructor","_editor","_snippet","_offset","_snippetLineLeadingWhitespace","_nestingLevel","_placeholderGroups","placeholders","compareByIndex","_placeholderGroupsIdx","_placeholderDecorations","deltaDecorations","values","length","_initDecorations","Map","model","getModel","changeDecorations","accessor","placeholder","placeholderOffset","offset","placeholderLen","fullLen","range","fromPositions","getPositionAt","options","isFinalTabstop","_decor","inactiveFinal","inactive","handle","addDecoration","set","move","fwd","hasModel","operations","transform","id","get","getDecorationRange","currentValue","getValueInRange","transformedValueLines","resolve","split","i","normalizeIndentation","push","replace","join","getEOL","executeEdits","couldSkipThisPlaceholder","newSelections","activePlaceholders","Set","selections","startLineNumber","startColumn","endLineNumber","endColumn","_hasPlaceholderBeenCollapsed","changeDecorationOptions","activeFinal","active","add","enclosingPlaceholder","enclosingPlaceholders","has","marker","isEmpty","parent","isAtFirstPlaceholder","isAtLastPlaceholder","hasPlaceholder","computePossibleSelections","result","placeholdersWithEqualIndex","ranges","index","delete","choice","merge","others","nested","shift","console","assert","indexLastPlaceholder","placeholderInfo","last","nestedPlaceholder","all","children","removeDecoration","register","stickiness","className","_defaultOptions","overwriteBefore","overwriteAfter","adjustWhitespace","clipboardText","undefined","overtypingCapturer","SnippetSession","editor","template","arguments","_templateMerges","_snippets","_template","_options","position","snippet","adjustIndentation","adjustNewlines","line","getLineContent","lineNumber","lineLeadingWhitespace","column","snippetTextString","walk","lines","value","prevChar","charCodeAt","newValue","adjustSelection","selection","positionLineNumber","positionColumn","positionColumnBefore","positionColumnAfter","validateRange","createWithDirection","getDirection","createEditsAndSnippets","enforceFinalTabstop","edits","snippets","workspaceService","invokeWithinContext","modelBasedVariableResolver","readClipboardText","delta","firstBeforeText","getSelection","firstAfterText","firstLineFirstNonWhitespace","getLineFirstNonWhitespaceColumn","indexedSelections","getSelections","map","idx","sort","a","b","compareRangesUsingStarts","extensionBefore","extensionAfter","snippetSelection","setStartPosition","setEndPosition","parse","start","getStartPosition","snippetLineLeadingWhitespace","resolveVariables","getOption","getOffsetAt","getValueLengthInRange","identifier","major","minor","_logInfo","insert","undoEdits","_move","filter","edit","getEndPosition","revealRange","next","setSelections","revealPositionInCenterIfOutsideViewport","getPosition","prev","oneSelection","isSelectionWithinPlaceholders","allPossibleSelections","possibleSelections","size","containsRange","forEach","array"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { groupBy } from '../../../base/common/arrays.js';\r\nimport { dispose } from '../../../base/common/lifecycle.js';\r\nimport { getLeadingWhitespace } from '../../../base/common/strings.js';\r\nimport './snippetSession.css';\r\nimport { EditOperation } from '../../common/core/editOperation.js';\r\nimport { Range } from '../../common/core/range.js';\r\nimport { Selection } from '../../common/core/selection.js';\r\nimport { ModelDecorationOptions } from '../../common/model/textModel.js';\r\nimport { IWorkspaceContextService } from '../../../platform/workspace/common/workspace.js';\r\nimport { optional } from '../../../platform/instantiation/common/instantiation.js';\r\nimport { Choice, Placeholder, SnippetParser, Text } from './snippetParser.js';\r\nimport { ClipboardBasedVariableResolver, CompositeSnippetVariableResolver, ModelBasedVariableResolver, SelectionBasedVariableResolver, TimeBasedVariableResolver, CommentBasedVariableResolver, WorkspaceBasedVariableResolver, RandomBasedVariableResolver } from './snippetVariables.js';\r\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\r\nimport * as colors from '../../../platform/theme/common/colorRegistry.js';\r\nimport { ILabelService } from '../../../platform/label/common/label.js';\r\nregisterThemingParticipant((theme, collector) => {\r\n    function getColorGraceful(name) {\r\n        const color = theme.getColor(name);\r\n        return color ? color.toString() : 'transparent';\r\n    }\r\n    collector.addRule(`.monaco-editor .snippet-placeholder { background-color: ${getColorGraceful(colors.snippetTabstopHighlightBackground)}; outline-color: ${getColorGraceful(colors.snippetTabstopHighlightBorder)}; }`);\r\n    collector.addRule(`.monaco-editor .finish-snippet-placeholder { background-color: ${getColorGraceful(colors.snippetFinalTabstopHighlightBackground)}; outline-color: ${getColorGraceful(colors.snippetFinalTabstopHighlightBorder)}; }`);\r\n});\r\nexport class OneSnippet {\r\n    constructor(_editor, _snippet, _offset, _snippetLineLeadingWhitespace) {\r\n        this._editor = _editor;\r\n        this._snippet = _snippet;\r\n        this._offset = _offset;\r\n        this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;\r\n        this._nestingLevel = 1;\r\n        this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);\r\n        this._placeholderGroupsIdx = -1;\r\n    }\r\n    dispose() {\r\n        if (this._placeholderDecorations) {\r\n            this._editor.deltaDecorations([...this._placeholderDecorations.values()], []);\r\n        }\r\n        this._placeholderGroups.length = 0;\r\n    }\r\n    _initDecorations() {\r\n        if (this._placeholderDecorations) {\r\n            // already initialized\r\n            return;\r\n        }\r\n        this._placeholderDecorations = new Map();\r\n        const model = this._editor.getModel();\r\n        this._editor.changeDecorations(accessor => {\r\n            // create a decoration for each placeholder\r\n            for (const placeholder of this._snippet.placeholders) {\r\n                const placeholderOffset = this._snippet.offset(placeholder);\r\n                const placeholderLen = this._snippet.fullLen(placeholder);\r\n                const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));\r\n                const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\r\n                const handle = accessor.addDecoration(range, options);\r\n                this._placeholderDecorations.set(placeholder, handle);\r\n            }\r\n        });\r\n    }\r\n    move(fwd) {\r\n        if (!this._editor.hasModel()) {\r\n            return [];\r\n        }\r\n        this._initDecorations();\r\n        // Transform placeholder text if necessary\r\n        if (this._placeholderGroupsIdx >= 0) {\r\n            let operations = [];\r\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\r\n                // Check if the placeholder has a transformation\r\n                if (placeholder.transform) {\r\n                    const id = this._placeholderDecorations.get(placeholder);\r\n                    const range = this._editor.getModel().getDecorationRange(id);\r\n                    const currentValue = this._editor.getModel().getValueInRange(range);\r\n                    const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\\r\\n|\\r|\\n/);\r\n                    // fix indentation for transformed lines\r\n                    for (let i = 1; i < transformedValueLines.length; i++) {\r\n                        transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);\r\n                    }\r\n                    operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));\r\n                }\r\n            }\r\n            if (operations.length > 0) {\r\n                this._editor.executeEdits('snippet.placeholderTransform', operations);\r\n            }\r\n        }\r\n        let couldSkipThisPlaceholder = false;\r\n        if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\r\n            this._placeholderGroupsIdx += 1;\r\n            couldSkipThisPlaceholder = true;\r\n        }\r\n        else if (fwd === false && this._placeholderGroupsIdx > 0) {\r\n            this._placeholderGroupsIdx -= 1;\r\n            couldSkipThisPlaceholder = true;\r\n        }\r\n        else {\r\n            // the selection of the current placeholder might\r\n            // not acurate any more -> simply restore it\r\n        }\r\n        const newSelections = this._editor.getModel().changeDecorations(accessor => {\r\n            const activePlaceholders = new Set();\r\n            // change stickiness to always grow when typing at its edges\r\n            // because these decorations represent the currently active\r\n            // tabstop.\r\n            // Special case #1: reaching the final tabstop\r\n            // Special case #2: placeholders enclosing active placeholders\r\n            const selections = [];\r\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\r\n                const id = this._placeholderDecorations.get(placeholder);\r\n                const range = this._editor.getModel().getDecorationRange(id);\r\n                selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));\r\n                // consider to skip this placeholder index when the decoration\r\n                // range is empty but when the placeholder wasn't. that's a strong\r\n                // hint that the placeholder has been deleted. (all placeholder must match this)\r\n                couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);\r\n                accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\r\n                activePlaceholders.add(placeholder);\r\n                for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {\r\n                    const id = this._placeholderDecorations.get(enclosingPlaceholder);\r\n                    accessor.changeDecorationOptions(id, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\r\n                    activePlaceholders.add(enclosingPlaceholder);\r\n                }\r\n            }\r\n            // change stickness to never grow when typing at its edges\r\n            // so that in-active tabstops never grow\r\n            for (const [placeholder, id] of this._placeholderDecorations) {\r\n                if (!activePlaceholders.has(placeholder)) {\r\n                    accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\r\n                }\r\n            }\r\n            return selections;\r\n        });\r\n        return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);\r\n    }\r\n    _hasPlaceholderBeenCollapsed(placeholder) {\r\n        // A placeholder is empty when it wasn't empty when authored but\r\n        // when its tracking decoration is empty. This also applies to all\r\n        // potential parent placeholders\r\n        let marker = placeholder;\r\n        while (marker) {\r\n            if (marker instanceof Placeholder) {\r\n                const id = this._placeholderDecorations.get(marker);\r\n                const range = this._editor.getModel().getDecorationRange(id);\r\n                if (range.isEmpty() && marker.toString().length > 0) {\r\n                    return true;\r\n                }\r\n            }\r\n            marker = marker.parent;\r\n        }\r\n        return false;\r\n    }\r\n    get isAtFirstPlaceholder() {\r\n        return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\r\n    }\r\n    get isAtLastPlaceholder() {\r\n        return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\r\n    }\r\n    get hasPlaceholder() {\r\n        return this._snippet.placeholders.length > 0;\r\n    }\r\n    computePossibleSelections() {\r\n        const result = new Map();\r\n        for (const placeholdersWithEqualIndex of this._placeholderGroups) {\r\n            let ranges;\r\n            for (const placeholder of placeholdersWithEqualIndex) {\r\n                if (placeholder.isFinalTabstop) {\r\n                    // ignore those\r\n                    break;\r\n                }\r\n                if (!ranges) {\r\n                    ranges = [];\r\n                    result.set(placeholder.index, ranges);\r\n                }\r\n                const id = this._placeholderDecorations.get(placeholder);\r\n                const range = this._editor.getModel().getDecorationRange(id);\r\n                if (!range) {\r\n                    // one of the placeholder lost its decoration and\r\n                    // therefore we bail out and pretend the placeholder\r\n                    // (with its mirrors) doesn't exist anymore.\r\n                    result.delete(placeholder.index);\r\n                    break;\r\n                }\r\n                ranges.push(range);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    get choice() {\r\n        return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;\r\n    }\r\n    merge(others) {\r\n        const model = this._editor.getModel();\r\n        this._nestingLevel *= 10;\r\n        this._editor.changeDecorations(accessor => {\r\n            // For each active placeholder take one snippet and merge it\r\n            // in that the placeholder (can be many for `$1foo$1foo`). Because\r\n            // everything is sorted by editor selection we can simply remove\r\n            // elements from the beginning of the array\r\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\r\n                const nested = others.shift();\r\n                console.assert(!nested._placeholderDecorations);\r\n                // Massage placeholder-indicies of the nested snippet to be\r\n                // sorted right after the insertion point. This ensures we move\r\n                // through the placeholders in the correct order\r\n                const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\r\n                for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {\r\n                    if (nestedPlaceholder.isFinalTabstop) {\r\n                        nestedPlaceholder.index = placeholder.index + ((indexLastPlaceholder + 1) / this._nestingLevel);\r\n                    }\r\n                    else {\r\n                        nestedPlaceholder.index = placeholder.index + (nestedPlaceholder.index / this._nestingLevel);\r\n                    }\r\n                }\r\n                this._snippet.replace(placeholder, nested._snippet.children);\r\n                // Remove the placeholder at which position are inserting\r\n                // the snippet and also remove its decoration.\r\n                const id = this._placeholderDecorations.get(placeholder);\r\n                accessor.removeDecoration(id);\r\n                this._placeholderDecorations.delete(placeholder);\r\n                // For each *new* placeholder we create decoration to monitor\r\n                // how and if it grows/shrinks.\r\n                for (const placeholder of nested._snippet.placeholders) {\r\n                    const placeholderOffset = nested._snippet.offset(placeholder);\r\n                    const placeholderLen = nested._snippet.fullLen(placeholder);\r\n                    const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\r\n                    const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\r\n                    this._placeholderDecorations.set(placeholder, handle);\r\n                }\r\n            }\r\n            // Last, re-create the placeholder groups by sorting placeholders by their index.\r\n            this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);\r\n        });\r\n    }\r\n}\r\nOneSnippet._decor = {\r\n    active: ModelDecorationOptions.register({ stickiness: 0 /* AlwaysGrowsWhenTypingAtEdges */, className: 'snippet-placeholder' }),\r\n    inactive: ModelDecorationOptions.register({ stickiness: 1 /* NeverGrowsWhenTypingAtEdges */, className: 'snippet-placeholder' }),\r\n    activeFinal: ModelDecorationOptions.register({ stickiness: 1 /* NeverGrowsWhenTypingAtEdges */, className: 'finish-snippet-placeholder' }),\r\n    inactiveFinal: ModelDecorationOptions.register({ stickiness: 1 /* NeverGrowsWhenTypingAtEdges */, className: 'finish-snippet-placeholder' }),\r\n};\r\nconst _defaultOptions = {\r\n    overwriteBefore: 0,\r\n    overwriteAfter: 0,\r\n    adjustWhitespace: true,\r\n    clipboardText: undefined,\r\n    overtypingCapturer: undefined\r\n};\r\nexport class SnippetSession {\r\n    constructor(editor, template, options = _defaultOptions) {\r\n        this._templateMerges = [];\r\n        this._snippets = [];\r\n        this._editor = editor;\r\n        this._template = template;\r\n        this._options = options;\r\n    }\r\n    static adjustWhitespace(model, position, snippet, adjustIndentation, adjustNewlines) {\r\n        const line = model.getLineContent(position.lineNumber);\r\n        const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);\r\n        // the snippet as inserted\r\n        let snippetTextString;\r\n        snippet.walk(marker => {\r\n            // all text elements that are not inside choice\r\n            if (!(marker instanceof Text) || marker.parent instanceof Choice) {\r\n                return true;\r\n            }\r\n            const lines = marker.value.split(/\\r\\n|\\r|\\n/);\r\n            if (adjustIndentation) {\r\n                // adjust indentation of snippet test\r\n                // -the snippet-start doesn't get extra-indented (lineLeadingWhitespace), only normalized\r\n                // -all N+1 lines get extra-indented and normalized\r\n                // -the text start get extra-indented and normalized when following a linebreak\r\n                const offset = snippet.offset(marker);\r\n                if (offset === 0) {\r\n                    // snippet start\r\n                    lines[0] = model.normalizeIndentation(lines[0]);\r\n                }\r\n                else {\r\n                    // check if text start is after a linebreak\r\n                    snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();\r\n                    let prevChar = snippetTextString.charCodeAt(offset - 1);\r\n                    if (prevChar === 10 /* LineFeed */ || prevChar === 13 /* CarriageReturn */) {\r\n                        lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);\r\n                    }\r\n                }\r\n                for (let i = 1; i < lines.length; i++) {\r\n                    lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);\r\n                }\r\n            }\r\n            const newValue = lines.join(model.getEOL());\r\n            if (newValue !== marker.value) {\r\n                marker.parent.replace(marker, [new Text(newValue)]);\r\n                snippetTextString = undefined;\r\n            }\r\n            return true;\r\n        });\r\n        return lineLeadingWhitespace;\r\n    }\r\n    static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {\r\n        if (overwriteBefore !== 0 || overwriteAfter !== 0) {\r\n            // overwrite[Before|After] is compute using the position, not the whole\r\n            // selection. therefore we adjust the selection around that position\r\n            const { positionLineNumber, positionColumn } = selection;\r\n            const positionColumnBefore = positionColumn - overwriteBefore;\r\n            const positionColumnAfter = positionColumn + overwriteAfter;\r\n            const range = model.validateRange({\r\n                startLineNumber: positionLineNumber,\r\n                startColumn: positionColumnBefore,\r\n                endLineNumber: positionLineNumber,\r\n                endColumn: positionColumnAfter\r\n            });\r\n            selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\r\n        }\r\n        return selection;\r\n    }\r\n    static createEditsAndSnippets(editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer) {\r\n        const edits = [];\r\n        const snippets = [];\r\n        if (!editor.hasModel()) {\r\n            return { edits, snippets };\r\n        }\r\n        const model = editor.getModel();\r\n        const workspaceService = editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService, optional));\r\n        const modelBasedVariableResolver = editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService, optional), model));\r\n        const readClipboardText = () => clipboardText;\r\n        let delta = 0;\r\n        // know what text the overwrite[Before|After] extensions\r\n        // of the primary curser have selected because only when\r\n        // secondary selections extend to the same text we can grow them\r\n        let firstBeforeText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\r\n        let firstAfterText = model.getValueInRange(SnippetSession.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\r\n        // remember the first non-whitespace column to decide if\r\n        // `keepWhitespace` should be overruled for secondary selections\r\n        let firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\r\n        // sort selections by their start position but remeber\r\n        // the original index. that allows you to create correct\r\n        // offset-based selection logic without changing the\r\n        // primary selection\r\n        const indexedSelections = editor.getSelections()\r\n            .map((selection, idx) => ({ selection, idx }))\r\n            .sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));\r\n        for (const { selection, idx } of indexedSelections) {\r\n            // extend selection with the `overwriteBefore` and `overwriteAfter` and then\r\n            // compare if this matches the extensions of the primary selection\r\n            let extensionBefore = SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);\r\n            let extensionAfter = SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);\r\n            if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\r\n                extensionBefore = selection;\r\n            }\r\n            if (firstAfterText !== model.getValueInRange(extensionAfter)) {\r\n                extensionAfter = selection;\r\n            }\r\n            // merge the before and after selection into one\r\n            const snippetSelection = selection\r\n                .setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn)\r\n                .setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\r\n            const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);\r\n            // adjust the template string to match the indentation and\r\n            // whitespace rules of this insert location (can be different for each cursor)\r\n            // happens when being asked for (default) or when this is a secondary\r\n            // cursor and the leading whitespace is different\r\n            const start = snippetSelection.getStartPosition();\r\n            const snippetLineLeadingWhitespace = SnippetSession.adjustWhitespace(model, start, snippet, adjustWhitespace || (idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber)), true);\r\n            snippet.resolveVariables(new CompositeSnippetVariableResolver([\r\n                modelBasedVariableResolver,\r\n                new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor.getOption(65 /* multiCursorPaste */) === 'spread'),\r\n                new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer),\r\n                new CommentBasedVariableResolver(model, selection),\r\n                new TimeBasedVariableResolver,\r\n                new WorkspaceBasedVariableResolver(workspaceService),\r\n                new RandomBasedVariableResolver,\r\n            ]));\r\n            const offset = model.getOffsetAt(start) + delta;\r\n            delta += snippet.toString().length - model.getValueLengthInRange(snippetSelection);\r\n            // store snippets with the index of their originating selection.\r\n            // that ensures the primiary cursor stays primary despite not being\r\n            // the one with lowest start position\r\n            edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());\r\n            edits[idx].identifier = { major: idx, minor: 0 }; // mark the edit so only our undo edits will be used to generate end cursors\r\n            snippets[idx] = new OneSnippet(editor, snippet, offset, snippetLineLeadingWhitespace);\r\n        }\r\n        return { edits, snippets };\r\n    }\r\n    dispose() {\r\n        dispose(this._snippets);\r\n    }\r\n    _logInfo() {\r\n        return `template=\"${this._template}\", merged_templates=\"${this._templateMerges.join(' -> ')}\"`;\r\n    }\r\n    insert() {\r\n        if (!this._editor.hasModel()) {\r\n            return;\r\n        }\r\n        // make insert edit and start with first selections\r\n        const { edits, snippets } = SnippetSession.createEditsAndSnippets(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer);\r\n        this._snippets = snippets;\r\n        this._editor.executeEdits('snippet', edits, undoEdits => {\r\n            if (this._snippets[0].hasPlaceholder) {\r\n                return this._move(true);\r\n            }\r\n            else {\r\n                return undoEdits\r\n                    .filter(edit => !!edit.identifier) // only use our undo edits\r\n                    .map(edit => Selection.fromPositions(edit.range.getEndPosition()));\r\n            }\r\n        });\r\n        this._editor.revealRange(this._editor.getSelections()[0]);\r\n    }\r\n    merge(template, options = _defaultOptions) {\r\n        if (!this._editor.hasModel()) {\r\n            return;\r\n        }\r\n        this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\r\n        const { edits, snippets } = SnippetSession.createEditsAndSnippets(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer);\r\n        this._editor.executeEdits('snippet', edits, undoEdits => {\r\n            for (const snippet of this._snippets) {\r\n                snippet.merge(snippets);\r\n            }\r\n            console.assert(snippets.length === 0);\r\n            if (this._snippets[0].hasPlaceholder) {\r\n                return this._move(undefined);\r\n            }\r\n            else {\r\n                return (undoEdits\r\n                    .filter(edit => !!edit.identifier) // only use our undo edits\r\n                    .map(edit => Selection.fromPositions(edit.range.getEndPosition())));\r\n            }\r\n        });\r\n    }\r\n    next() {\r\n        const newSelections = this._move(true);\r\n        this._editor.setSelections(newSelections);\r\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\r\n    }\r\n    prev() {\r\n        const newSelections = this._move(false);\r\n        this._editor.setSelections(newSelections);\r\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\r\n    }\r\n    _move(fwd) {\r\n        const selections = [];\r\n        for (const snippet of this._snippets) {\r\n            const oneSelection = snippet.move(fwd);\r\n            selections.push(...oneSelection);\r\n        }\r\n        return selections;\r\n    }\r\n    get isAtFirstPlaceholder() {\r\n        return this._snippets[0].isAtFirstPlaceholder;\r\n    }\r\n    get isAtLastPlaceholder() {\r\n        return this._snippets[0].isAtLastPlaceholder;\r\n    }\r\n    get hasPlaceholder() {\r\n        return this._snippets[0].hasPlaceholder;\r\n    }\r\n    get choice() {\r\n        return this._snippets[0].choice;\r\n    }\r\n    isSelectionWithinPlaceholders() {\r\n        if (!this.hasPlaceholder) {\r\n            return false;\r\n        }\r\n        const selections = this._editor.getSelections();\r\n        if (selections.length < this._snippets.length) {\r\n            // this means we started snippet mode with N\r\n            // selections and have M (N > M) selections.\r\n            // So one snippet is without selection -> cancel\r\n            return false;\r\n        }\r\n        let allPossibleSelections = new Map();\r\n        for (const snippet of this._snippets) {\r\n            const possibleSelections = snippet.computePossibleSelections();\r\n            // for the first snippet find the placeholder (and its ranges)\r\n            // that contain at least one selection. for all remaining snippets\r\n            // the same placeholder (and their ranges) must be used.\r\n            if (allPossibleSelections.size === 0) {\r\n                for (const [index, ranges] of possibleSelections) {\r\n                    ranges.sort(Range.compareRangesUsingStarts);\r\n                    for (const selection of selections) {\r\n                        if (ranges[0].containsRange(selection)) {\r\n                            allPossibleSelections.set(index, []);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (allPossibleSelections.size === 0) {\r\n                // return false if we couldn't associate a selection to\r\n                // this (the first) snippet\r\n                return false;\r\n            }\r\n            // add selections from 'this' snippet so that we know all\r\n            // selections for this placeholder\r\n            allPossibleSelections.forEach((array, index) => {\r\n                array.push(...possibleSelections.get(index));\r\n            });\r\n        }\r\n        // sort selections (and later placeholder-ranges). then walk both\r\n        // arrays and make sure the placeholder-ranges contain the corresponding\r\n        // selection\r\n        selections.sort(Range.compareRangesUsingStarts);\r\n        for (let [index, ranges] of allPossibleSelections) {\r\n            if (ranges.length !== selections.length) {\r\n                allPossibleSelections.delete(index);\r\n                continue;\r\n            }\r\n            ranges.sort(Range.compareRangesUsingStarts);\r\n            for (let i = 0; i < ranges.length; i++) {\r\n                if (!ranges[i].containsRange(selections[i])) {\r\n                    allPossibleSelections.delete(index);\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        // from all possible selections we have deleted those\r\n        // that don't match with the current selection. if we don't\r\n        // have any left, we don't have a selection anymore\r\n        return allPossibleSelections.size > 0;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}