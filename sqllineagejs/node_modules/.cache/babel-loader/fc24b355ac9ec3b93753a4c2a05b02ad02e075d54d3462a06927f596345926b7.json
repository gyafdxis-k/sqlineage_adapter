{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { isWindows } from './platform.js';\nimport { startsWithIgnoreCase } from './strings.js';\nimport { sep, posix, normalize } from './path.js';\n/**\r\n * Takes a Windows OS path and changes backward slashes to forward slashes.\r\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\r\n * Using it on a Linux or MaxOS path might change it.\r\n */\nexport function toSlashes(osPath) {\n  return osPath.replace(/[\\\\/]/g, posix.sep);\n}\nexport function isEqualOrParent(base, parentCandidate, ignoreCase) {\n  let separator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sep;\n  if (base === parentCandidate) {\n    return true;\n  }\n  if (!base || !parentCandidate) {\n    return false;\n  }\n  if (parentCandidate.length > base.length) {\n    return false;\n  }\n  if (ignoreCase) {\n    const beginsWith = startsWithIgnoreCase(base, parentCandidate);\n    if (!beginsWith) {\n      return false;\n    }\n    if (parentCandidate.length === base.length) {\n      return true; // same path, different casing\n    }\n\n    let sepOffset = parentCandidate.length;\n    if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n      sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n    }\n\n    return base.charAt(sepOffset) === separator;\n  }\n  if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n    parentCandidate += separator;\n  }\n  return base.indexOf(parentCandidate) === 0;\n}\nexport function isWindowsDriveLetter(char0) {\n  return char0 >= 65 /* A */ && char0 <= 90 /* Z */ || char0 >= 97 /* a */ && char0 <= 122 /* z */;\n}\n\nexport function isRootOrDriveLetter(path) {\n  const pathNormalized = normalize(path);\n  if (isWindows) {\n    if (path.length > 3) {\n      return false;\n    }\n    return hasDriveLetter(pathNormalized) && (path.length === 2 || pathNormalized.charCodeAt(2) === 92 /* Backslash */);\n  }\n\n  return pathNormalized === posix.sep;\n}\nexport function hasDriveLetter(path) {\n  if (isWindows) {\n    return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58 /* Colon */;\n  }\n\n  return false;\n}","map":{"version":3,"names":["isWindows","startsWithIgnoreCase","sep","posix","normalize","toSlashes","osPath","replace","isEqualOrParent","base","parentCandidate","ignoreCase","separator","arguments","length","undefined","beginsWith","sepOffset","charAt","indexOf","isWindowsDriveLetter","char0","isRootOrDriveLetter","path","pathNormalized","hasDriveLetter","charCodeAt"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/extpath.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { isWindows } from './platform.js';\r\nimport { startsWithIgnoreCase } from './strings.js';\r\nimport { sep, posix, normalize } from './path.js';\r\n/**\r\n * Takes a Windows OS path and changes backward slashes to forward slashes.\r\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\r\n * Using it on a Linux or MaxOS path might change it.\r\n */\r\nexport function toSlashes(osPath) {\r\n    return osPath.replace(/[\\\\/]/g, posix.sep);\r\n}\r\nexport function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {\r\n    if (base === parentCandidate) {\r\n        return true;\r\n    }\r\n    if (!base || !parentCandidate) {\r\n        return false;\r\n    }\r\n    if (parentCandidate.length > base.length) {\r\n        return false;\r\n    }\r\n    if (ignoreCase) {\r\n        const beginsWith = startsWithIgnoreCase(base, parentCandidate);\r\n        if (!beginsWith) {\r\n            return false;\r\n        }\r\n        if (parentCandidate.length === base.length) {\r\n            return true; // same path, different casing\r\n        }\r\n        let sepOffset = parentCandidate.length;\r\n        if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\r\n            sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\r\n        }\r\n        return base.charAt(sepOffset) === separator;\r\n    }\r\n    if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\r\n        parentCandidate += separator;\r\n    }\r\n    return base.indexOf(parentCandidate) === 0;\r\n}\r\nexport function isWindowsDriveLetter(char0) {\r\n    return char0 >= 65 /* A */ && char0 <= 90 /* Z */ || char0 >= 97 /* a */ && char0 <= 122 /* z */;\r\n}\r\nexport function isRootOrDriveLetter(path) {\r\n    const pathNormalized = normalize(path);\r\n    if (isWindows) {\r\n        if (path.length > 3) {\r\n            return false;\r\n        }\r\n        return hasDriveLetter(pathNormalized) &&\r\n            (path.length === 2 || pathNormalized.charCodeAt(2) === 92 /* Backslash */);\r\n    }\r\n    return pathNormalized === posix.sep;\r\n}\r\nexport function hasDriveLetter(path) {\r\n    if (isWindows) {\r\n        return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58 /* Colon */;\r\n    }\r\n    return false;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,SAAS,QAAQ,eAAe;AACzC,SAASC,oBAAoB,QAAQ,cAAc;AACnD,SAASC,GAAG,EAAEC,KAAK,EAAEC,SAAS,QAAQ,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,SAASA,CAACC,MAAM,EAAE;EAC9B,OAAOA,MAAM,CAACC,OAAO,CAAC,QAAQ,EAAEJ,KAAK,CAACD,GAAG,CAAC;AAC9C;AACA,OAAO,SAASM,eAAeA,CAACC,IAAI,EAAEC,eAAe,EAAEC,UAAU,EAAmB;EAAA,IAAjBC,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGX,GAAG;EAC9E,IAAIO,IAAI,KAAKC,eAAe,EAAE;IAC1B,OAAO,IAAI;EACf;EACA,IAAI,CAACD,IAAI,IAAI,CAACC,eAAe,EAAE;IAC3B,OAAO,KAAK;EAChB;EACA,IAAIA,eAAe,CAACI,MAAM,GAAGL,IAAI,CAACK,MAAM,EAAE;IACtC,OAAO,KAAK;EAChB;EACA,IAAIH,UAAU,EAAE;IACZ,MAAMK,UAAU,GAAGf,oBAAoB,CAACQ,IAAI,EAAEC,eAAe,CAAC;IAC9D,IAAI,CAACM,UAAU,EAAE;MACb,OAAO,KAAK;IAChB;IACA,IAAIN,eAAe,CAACI,MAAM,KAAKL,IAAI,CAACK,MAAM,EAAE;MACxC,OAAO,IAAI,CAAC,CAAC;IACjB;;IACA,IAAIG,SAAS,GAAGP,eAAe,CAACI,MAAM;IACtC,IAAIJ,eAAe,CAACQ,MAAM,CAACR,eAAe,CAACI,MAAM,GAAG,CAAC,CAAC,KAAKF,SAAS,EAAE;MAClEK,SAAS,EAAE,CAAC,CAAC;IACjB;;IACA,OAAOR,IAAI,CAACS,MAAM,CAACD,SAAS,CAAC,KAAKL,SAAS;EAC/C;EACA,IAAIF,eAAe,CAACQ,MAAM,CAACR,eAAe,CAACI,MAAM,GAAG,CAAC,CAAC,KAAKF,SAAS,EAAE;IAClEF,eAAe,IAAIE,SAAS;EAChC;EACA,OAAOH,IAAI,CAACU,OAAO,CAACT,eAAe,CAAC,KAAK,CAAC;AAC9C;AACA,OAAO,SAASU,oBAAoBA,CAACC,KAAK,EAAE;EACxC,OAAOA,KAAK,IAAI,EAAE,CAAC,WAAWA,KAAK,IAAI,EAAE,CAAC,WAAWA,KAAK,IAAI,EAAE,CAAC,WAAWA,KAAK,IAAI,GAAG,CAAC;AAC7F;;AACA,OAAO,SAASC,mBAAmBA,CAACC,IAAI,EAAE;EACtC,MAAMC,cAAc,GAAGpB,SAAS,CAACmB,IAAI,CAAC;EACtC,IAAIvB,SAAS,EAAE;IACX,IAAIuB,IAAI,CAACT,MAAM,GAAG,CAAC,EAAE;MACjB,OAAO,KAAK;IAChB;IACA,OAAOW,cAAc,CAACD,cAAc,CAAC,KAChCD,IAAI,CAACT,MAAM,KAAK,CAAC,IAAIU,cAAc,CAACE,UAAU,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,gBAAgB;EAClF;;EACA,OAAOF,cAAc,KAAKrB,KAAK,CAACD,GAAG;AACvC;AACA,OAAO,SAASuB,cAAcA,CAACF,IAAI,EAAE;EACjC,IAAIvB,SAAS,EAAE;IACX,OAAOoB,oBAAoB,CAACG,IAAI,CAACG,UAAU,CAAC,CAAC,CAAC,CAAC,IAAIH,IAAI,CAACG,UAAU,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;EACjF;;EACA,OAAO,KAAK;AAChB"},"metadata":{},"sourceType":"module","externalDependencies":[]}