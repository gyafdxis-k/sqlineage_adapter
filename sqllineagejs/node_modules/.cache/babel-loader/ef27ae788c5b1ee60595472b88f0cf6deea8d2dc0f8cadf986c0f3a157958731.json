{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../tokensStore.js';\nimport { TextChange } from '../textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n  constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n    super();\n    this._onDidChangeContent = this._register(new Emitter());\n    this._BOM = BOM;\n    this._mightContainNonBasicASCII = !isBasicASCII;\n    this._mightContainRTL = containsRTL;\n    this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n    this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n  }\n  mightContainRTL() {\n    return this._mightContainRTL;\n  }\n  mightContainUnusualLineTerminators() {\n    return this._mightContainUnusualLineTerminators;\n  }\n  resetMightContainUnusualLineTerminators() {\n    this._mightContainUnusualLineTerminators = false;\n  }\n  mightContainNonBasicASCII() {\n    return this._mightContainNonBasicASCII;\n  }\n  getBOM() {\n    return this._BOM;\n  }\n  getEOL() {\n    return this._pieceTree.getEOL();\n  }\n  createSnapshot(preserveBOM) {\n    return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n  }\n  getOffsetAt(lineNumber, column) {\n    return this._pieceTree.getOffsetAt(lineNumber, column);\n  }\n  getPositionAt(offset) {\n    return this._pieceTree.getPositionAt(offset);\n  }\n  getRangeAt(start, length) {\n    let end = start + length;\n    const startPosition = this.getPositionAt(start);\n    const endPosition = this.getPositionAt(end);\n    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n  }\n  getValueInRange(range) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (range.isEmpty()) {\n      return '';\n    }\n    const lineEnding = this._getEndOfLine(eol);\n    return this._pieceTree.getValueInRange(range, lineEnding);\n  }\n  getValueLengthInRange(range) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (range.isEmpty()) {\n      return 0;\n    }\n    if (range.startLineNumber === range.endLineNumber) {\n      return range.endColumn - range.startColumn;\n    }\n    let startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n    let endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n    return endOffset - startOffset;\n  }\n  getCharacterCountInRange(range) {\n    let eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (this._mightContainNonBasicASCII) {\n      // we must count by iterating\n      let result = 0;\n      const fromLineNumber = range.startLineNumber;\n      const toLineNumber = range.endLineNumber;\n      for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n        const lineContent = this.getLineContent(lineNumber);\n        const fromOffset = lineNumber === fromLineNumber ? range.startColumn - 1 : 0;\n        const toOffset = lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length;\n        for (let offset = fromOffset; offset < toOffset; offset++) {\n          if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n            result = result + 1;\n            offset = offset + 1;\n          } else {\n            result = result + 1;\n          }\n        }\n      }\n      result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n      return result;\n    }\n    return this.getValueLengthInRange(range, eol);\n  }\n  getLength() {\n    return this._pieceTree.getLength();\n  }\n  getLineCount() {\n    return this._pieceTree.getLineCount();\n  }\n  getLinesContent() {\n    return this._pieceTree.getLinesContent();\n  }\n  getLineContent(lineNumber) {\n    return this._pieceTree.getLineContent(lineNumber);\n  }\n  getLineCharCode(lineNumber, index) {\n    return this._pieceTree.getLineCharCode(lineNumber, index);\n  }\n  getLineLength(lineNumber) {\n    return this._pieceTree.getLineLength(lineNumber);\n  }\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 1;\n  }\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 2;\n  }\n  _getEndOfLine(eol) {\n    switch (eol) {\n      case 1 /* LF */:\n        return '\\n';\n      case 2 /* CRLF */:\n        return '\\r\\n';\n      case 0 /* TextDefined */:\n        return this.getEOL();\n      default:\n        throw new Error('Unknown EOL preference');\n    }\n  }\n  setEOL(newEOL) {\n    this._pieceTree.setEOL(newEOL);\n  }\n  applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n    let mightContainRTL = this._mightContainRTL;\n    let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n    let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n    let canReduceOperations = true;\n    let operations = [];\n    for (let i = 0; i < rawOperations.length; i++) {\n      let op = rawOperations[i];\n      if (canReduceOperations && op._isTracked) {\n        canReduceOperations = false;\n      }\n      let validatedRange = op.range;\n      if (op.text) {\n        let textMightContainNonBasicASCII = true;\n        if (!mightContainNonBasicASCII) {\n          textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n          mightContainNonBasicASCII = textMightContainNonBasicASCII;\n        }\n        if (!mightContainRTL && textMightContainNonBasicASCII) {\n          // check if the new inserted text contains RTL\n          mightContainRTL = strings.containsRTL(op.text);\n        }\n        if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n          // check if the new inserted text contains unusual line terminators\n          mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n        }\n      }\n      let validText = '';\n      let eolCount = 0;\n      let firstLineLength = 0;\n      let lastLineLength = 0;\n      if (op.text) {\n        let strEOL;\n        [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n        const bufferEOL = this.getEOL();\n        const expectedStrEOL = bufferEOL === '\\r\\n' ? 2 /* CRLF */ : 1 /* LF */;\n        if (strEOL === 0 /* Unknown */ || strEOL === expectedStrEOL) {\n          validText = op.text;\n        } else {\n          validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n        }\n      }\n      operations[i] = {\n        sortIndex: i,\n        identifier: op.identifier || null,\n        range: validatedRange,\n        rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n        rangeLength: this.getValueLengthInRange(validatedRange),\n        text: validText,\n        eolCount: eolCount,\n        firstLineLength: firstLineLength,\n        lastLineLength: lastLineLength,\n        forceMoveMarkers: Boolean(op.forceMoveMarkers),\n        isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n      };\n    }\n    // Sort operations ascending\n    operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n    let hasTouchingRanges = false;\n    for (let i = 0, count = operations.length - 1; i < count; i++) {\n      let rangeEnd = operations[i].range.getEndPosition();\n      let nextRangeStart = operations[i + 1].range.getStartPosition();\n      if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n        if (nextRangeStart.isBefore(rangeEnd)) {\n          // overlapping ranges\n          throw new Error('Overlapping ranges are not allowed!');\n        }\n        hasTouchingRanges = true;\n      }\n    }\n    if (canReduceOperations) {\n      operations = this._reduceOperations(operations);\n    }\n    // Delta encode operations\n    let reverseRanges = computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : [];\n    let newTrimAutoWhitespaceCandidates = [];\n    if (recordTrimAutoWhitespace) {\n      for (let i = 0; i < operations.length; i++) {\n        let op = operations[i];\n        let reverseRange = reverseRanges[i];\n        if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n          // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n          for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n            let currentLineContent = '';\n            if (lineNumber === reverseRange.startLineNumber) {\n              currentLineContent = this.getLineContent(op.range.startLineNumber);\n              if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                continue;\n              }\n            }\n            newTrimAutoWhitespaceCandidates.push({\n              lineNumber: lineNumber,\n              oldContent: currentLineContent\n            });\n          }\n        }\n      }\n    }\n    let reverseOperations = null;\n    if (computeUndoEdits) {\n      let reverseRangeDeltaOffset = 0;\n      reverseOperations = [];\n      for (let i = 0; i < operations.length; i++) {\n        const op = operations[i];\n        const reverseRange = reverseRanges[i];\n        const bufferText = this.getValueInRange(op.range);\n        const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n        reverseRangeDeltaOffset += op.text.length - bufferText.length;\n        reverseOperations[i] = {\n          sortIndex: op.sortIndex,\n          identifier: op.identifier,\n          range: reverseRange,\n          text: bufferText,\n          textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n        };\n      }\n      // Can only sort reverse operations when the order is not significant\n      if (!hasTouchingRanges) {\n        reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n      }\n    }\n    this._mightContainRTL = mightContainRTL;\n    this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n    this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n    const contentChanges = this._doApplyEdits(operations);\n    let trimAutoWhitespaceLineNumbers = null;\n    if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n      // sort line numbers auto whitespace removal candidates for next edit descending\n      newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n      trimAutoWhitespaceLineNumbers = [];\n      for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n        let lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n        if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n          // Do not have the same line number twice\n          continue;\n        }\n        let prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n        let lineContent = this.getLineContent(lineNumber);\n        if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n          continue;\n        }\n        trimAutoWhitespaceLineNumbers.push(lineNumber);\n      }\n    }\n    this._onDidChangeContent.fire();\n    return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n  }\n  /**\r\n   * Transform operations such that they represent the same logic edit,\r\n   * but that they also do not cause OOM crashes.\r\n   */\n  _reduceOperations(operations) {\n    if (operations.length < 1000) {\n      // We know from empirical testing that a thousand edits work fine regardless of their shape.\n      return operations;\n    }\n    // At one point, due to how events are emitted and how each operation is handled,\n    // some operations can trigger a high amount of temporary string allocations,\n    // that will immediately get edited again.\n    // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n    // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n    return [this._toSingleEditOperation(operations)];\n  }\n  _toSingleEditOperation(operations) {\n    let forceMoveMarkers = false;\n    const firstEditRange = operations[0].range;\n    const lastEditRange = operations[operations.length - 1].range;\n    const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n    let lastEndLineNumber = firstEditRange.startLineNumber;\n    let lastEndColumn = firstEditRange.startColumn;\n    const result = [];\n    for (let i = 0, len = operations.length; i < len; i++) {\n      const operation = operations[i];\n      const range = operation.range;\n      forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n      // (1) -- Push old text\n      result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n      // (2) -- Push new text\n      if (operation.text.length > 0) {\n        result.push(operation.text);\n      }\n      lastEndLineNumber = range.endLineNumber;\n      lastEndColumn = range.endColumn;\n    }\n    const text = result.join('');\n    const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n    return {\n      sortIndex: 0,\n      identifier: operations[0].identifier,\n      range: entireEditRange,\n      rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n      rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* TextDefined */),\n      text: text,\n      eolCount: eolCount,\n      firstLineLength: firstLineLength,\n      lastLineLength: lastLineLength,\n      forceMoveMarkers: forceMoveMarkers,\n      isAutoWhitespaceEdit: false\n    };\n  }\n  _doApplyEdits(operations) {\n    operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n    let contentChanges = [];\n    // operations are from bottom to top\n    for (let i = 0; i < operations.length; i++) {\n      let op = operations[i];\n      const startLineNumber = op.range.startLineNumber;\n      const startColumn = op.range.startColumn;\n      const endLineNumber = op.range.endLineNumber;\n      const endColumn = op.range.endColumn;\n      if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n        // no-op\n        continue;\n      }\n      if (op.text) {\n        // replacement\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n        this._pieceTree.insert(op.rangeOffset, op.text, true);\n      } else {\n        // deletion\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n      }\n      const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      contentChanges.push({\n        range: contentChangeRange,\n        rangeLength: op.rangeLength,\n        text: op.text,\n        rangeOffset: op.rangeOffset,\n        forceMoveMarkers: op.forceMoveMarkers\n      });\n    }\n    return contentChanges;\n  }\n  findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n    return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  }\n  /**\r\n   * Assumes `operations` are validated and sorted ascending\r\n   */\n  static _getInverseEditRanges(operations) {\n    let result = [];\n    let prevOpEndLineNumber = 0;\n    let prevOpEndColumn = 0;\n    let prevOp = null;\n    for (let i = 0, len = operations.length; i < len; i++) {\n      let op = operations[i];\n      let startLineNumber;\n      let startColumn;\n      if (prevOp) {\n        if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n          startLineNumber = prevOpEndLineNumber;\n          startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n        } else {\n          startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n          startColumn = op.range.startColumn;\n        }\n      } else {\n        startLineNumber = op.range.startLineNumber;\n        startColumn = op.range.startColumn;\n      }\n      let resultRange;\n      if (op.text.length > 0) {\n        // the operation inserts something\n        const lineCount = op.eolCount + 1;\n        if (lineCount === 1) {\n          // single line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n        } else {\n          // multi line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n        }\n      } else {\n        // There is nothing to insert\n        resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n      }\n      prevOpEndLineNumber = resultRange.endLineNumber;\n      prevOpEndColumn = resultRange.endColumn;\n      result.push(resultRange);\n      prevOp = op;\n    }\n    return result;\n  }\n  static _sortOpsAscending(a, b) {\n    let r = Range.compareRangesUsingEnds(a.range, b.range);\n    if (r === 0) {\n      return a.sortIndex - b.sortIndex;\n    }\n    return r;\n  }\n  static _sortOpsDescending(a, b) {\n    let r = Range.compareRangesUsingEnds(a.range, b.range);\n    if (r === 0) {\n      return b.sortIndex - a.sortIndex;\n    }\n    return -r;\n  }\n}","map":{"version":3,"names":["Emitter","strings","Range","ApplyEditsResult","PieceTreeBase","countEOL","TextChange","Disposable","PieceTreeTextBuffer","constructor","chunks","BOM","eol","containsRTL","containsUnusualLineTerminators","isBasicASCII","eolNormalized","_onDidChangeContent","_register","_BOM","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","mightContainRTL","mightContainUnusualLineTerminators","resetMightContainUnusualLineTerminators","mightContainNonBasicASCII","getBOM","getEOL","createSnapshot","preserveBOM","getOffsetAt","lineNumber","column","getPositionAt","offset","getRangeAt","start","length","end","startPosition","endPosition","getValueInRange","range","arguments","undefined","isEmpty","lineEnding","_getEndOfLine","getValueLengthInRange","startLineNumber","endLineNumber","endColumn","startColumn","startOffset","endOffset","getCharacterCountInRange","result","fromLineNumber","toLineNumber","lineContent","getLineContent","fromOffset","toOffset","isHighSurrogate","charCodeAt","getLength","getLineCount","getLinesContent","getLineCharCode","index","getLineLength","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","Error","setEOL","newEOL","applyEdits","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","canReduceOperations","operations","i","op","_isTracked","validatedRange","text","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","bufferEOL","expectedStrEOL","replace","sortIndex","identifier","rangeOffset","rangeLength","forceMoveMarkers","Boolean","isAutoWhitespaceEdit","sort","_sortOpsAscending","hasTouchingRanges","count","rangeEnd","getEndPosition","nextRangeStart","getStartPosition","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","push","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","a","b","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","len","prevContent","fire","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","join","_sortOpsDescending","delete","insert","contentChangeRange","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","lineCount","r","compareRangesUsingEnds"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Emitter } from '../../../../base/common/event.js';\r\nimport * as strings from '../../../../base/common/strings.js';\r\nimport { Range } from '../../core/range.js';\r\nimport { ApplyEditsResult } from '../../model.js';\r\nimport { PieceTreeBase } from './pieceTreeBase.js';\r\nimport { countEOL } from '../tokensStore.js';\r\nimport { TextChange } from '../textChange.js';\r\nimport { Disposable } from '../../../../base/common/lifecycle.js';\r\nexport class PieceTreeTextBuffer extends Disposable {\r\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\r\n        super();\r\n        this._onDidChangeContent = this._register(new Emitter());\r\n        this._BOM = BOM;\r\n        this._mightContainNonBasicASCII = !isBasicASCII;\r\n        this._mightContainRTL = containsRTL;\r\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\r\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\r\n    }\r\n    mightContainRTL() {\r\n        return this._mightContainRTL;\r\n    }\r\n    mightContainUnusualLineTerminators() {\r\n        return this._mightContainUnusualLineTerminators;\r\n    }\r\n    resetMightContainUnusualLineTerminators() {\r\n        this._mightContainUnusualLineTerminators = false;\r\n    }\r\n    mightContainNonBasicASCII() {\r\n        return this._mightContainNonBasicASCII;\r\n    }\r\n    getBOM() {\r\n        return this._BOM;\r\n    }\r\n    getEOL() {\r\n        return this._pieceTree.getEOL();\r\n    }\r\n    createSnapshot(preserveBOM) {\r\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\r\n    }\r\n    getOffsetAt(lineNumber, column) {\r\n        return this._pieceTree.getOffsetAt(lineNumber, column);\r\n    }\r\n    getPositionAt(offset) {\r\n        return this._pieceTree.getPositionAt(offset);\r\n    }\r\n    getRangeAt(start, length) {\r\n        let end = start + length;\r\n        const startPosition = this.getPositionAt(start);\r\n        const endPosition = this.getPositionAt(end);\r\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\r\n    }\r\n    getValueInRange(range, eol = 0 /* TextDefined */) {\r\n        if (range.isEmpty()) {\r\n            return '';\r\n        }\r\n        const lineEnding = this._getEndOfLine(eol);\r\n        return this._pieceTree.getValueInRange(range, lineEnding);\r\n    }\r\n    getValueLengthInRange(range, eol = 0 /* TextDefined */) {\r\n        if (range.isEmpty()) {\r\n            return 0;\r\n        }\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            return (range.endColumn - range.startColumn);\r\n        }\r\n        let startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\r\n        let endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\r\n        return endOffset - startOffset;\r\n    }\r\n    getCharacterCountInRange(range, eol = 0 /* TextDefined */) {\r\n        if (this._mightContainNonBasicASCII) {\r\n            // we must count by iterating\r\n            let result = 0;\r\n            const fromLineNumber = range.startLineNumber;\r\n            const toLineNumber = range.endLineNumber;\r\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\r\n                const lineContent = this.getLineContent(lineNumber);\r\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\r\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\r\n                for (let offset = fromOffset; offset < toOffset; offset++) {\r\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\r\n                        result = result + 1;\r\n                        offset = offset + 1;\r\n                    }\r\n                    else {\r\n                        result = result + 1;\r\n                    }\r\n                }\r\n            }\r\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\r\n            return result;\r\n        }\r\n        return this.getValueLengthInRange(range, eol);\r\n    }\r\n    getLength() {\r\n        return this._pieceTree.getLength();\r\n    }\r\n    getLineCount() {\r\n        return this._pieceTree.getLineCount();\r\n    }\r\n    getLinesContent() {\r\n        return this._pieceTree.getLinesContent();\r\n    }\r\n    getLineContent(lineNumber) {\r\n        return this._pieceTree.getLineContent(lineNumber);\r\n    }\r\n    getLineCharCode(lineNumber, index) {\r\n        return this._pieceTree.getLineCharCode(lineNumber, index);\r\n    }\r\n    getLineLength(lineNumber) {\r\n        return this._pieceTree.getLineLength(lineNumber);\r\n    }\r\n    getLineFirstNonWhitespaceColumn(lineNumber) {\r\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\r\n        if (result === -1) {\r\n            return 0;\r\n        }\r\n        return result + 1;\r\n    }\r\n    getLineLastNonWhitespaceColumn(lineNumber) {\r\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\r\n        if (result === -1) {\r\n            return 0;\r\n        }\r\n        return result + 2;\r\n    }\r\n    _getEndOfLine(eol) {\r\n        switch (eol) {\r\n            case 1 /* LF */:\r\n                return '\\n';\r\n            case 2 /* CRLF */:\r\n                return '\\r\\n';\r\n            case 0 /* TextDefined */:\r\n                return this.getEOL();\r\n            default:\r\n                throw new Error('Unknown EOL preference');\r\n        }\r\n    }\r\n    setEOL(newEOL) {\r\n        this._pieceTree.setEOL(newEOL);\r\n    }\r\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\r\n        let mightContainRTL = this._mightContainRTL;\r\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\r\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\r\n        let canReduceOperations = true;\r\n        let operations = [];\r\n        for (let i = 0; i < rawOperations.length; i++) {\r\n            let op = rawOperations[i];\r\n            if (canReduceOperations && op._isTracked) {\r\n                canReduceOperations = false;\r\n            }\r\n            let validatedRange = op.range;\r\n            if (op.text) {\r\n                let textMightContainNonBasicASCII = true;\r\n                if (!mightContainNonBasicASCII) {\r\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\r\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\r\n                }\r\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\r\n                    // check if the new inserted text contains RTL\r\n                    mightContainRTL = strings.containsRTL(op.text);\r\n                }\r\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\r\n                    // check if the new inserted text contains unusual line terminators\r\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\r\n                }\r\n            }\r\n            let validText = '';\r\n            let eolCount = 0;\r\n            let firstLineLength = 0;\r\n            let lastLineLength = 0;\r\n            if (op.text) {\r\n                let strEOL;\r\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\r\n                const bufferEOL = this.getEOL();\r\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* CRLF */ : 1 /* LF */);\r\n                if (strEOL === 0 /* Unknown */ || strEOL === expectedStrEOL) {\r\n                    validText = op.text;\r\n                }\r\n                else {\r\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\r\n                }\r\n            }\r\n            operations[i] = {\r\n                sortIndex: i,\r\n                identifier: op.identifier || null,\r\n                range: validatedRange,\r\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\r\n                rangeLength: this.getValueLengthInRange(validatedRange),\r\n                text: validText,\r\n                eolCount: eolCount,\r\n                firstLineLength: firstLineLength,\r\n                lastLineLength: lastLineLength,\r\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\r\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\r\n            };\r\n        }\r\n        // Sort operations ascending\r\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\r\n        let hasTouchingRanges = false;\r\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\r\n            let rangeEnd = operations[i].range.getEndPosition();\r\n            let nextRangeStart = operations[i + 1].range.getStartPosition();\r\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\r\n                if (nextRangeStart.isBefore(rangeEnd)) {\r\n                    // overlapping ranges\r\n                    throw new Error('Overlapping ranges are not allowed!');\r\n                }\r\n                hasTouchingRanges = true;\r\n            }\r\n        }\r\n        if (canReduceOperations) {\r\n            operations = this._reduceOperations(operations);\r\n        }\r\n        // Delta encode operations\r\n        let reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\r\n        let newTrimAutoWhitespaceCandidates = [];\r\n        if (recordTrimAutoWhitespace) {\r\n            for (let i = 0; i < operations.length; i++) {\r\n                let op = operations[i];\r\n                let reverseRange = reverseRanges[i];\r\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\r\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\r\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\r\n                        let currentLineContent = '';\r\n                        if (lineNumber === reverseRange.startLineNumber) {\r\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\r\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let reverseOperations = null;\r\n        if (computeUndoEdits) {\r\n            let reverseRangeDeltaOffset = 0;\r\n            reverseOperations = [];\r\n            for (let i = 0; i < operations.length; i++) {\r\n                const op = operations[i];\r\n                const reverseRange = reverseRanges[i];\r\n                const bufferText = this.getValueInRange(op.range);\r\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\r\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\r\n                reverseOperations[i] = {\r\n                    sortIndex: op.sortIndex,\r\n                    identifier: op.identifier,\r\n                    range: reverseRange,\r\n                    text: bufferText,\r\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\r\n                };\r\n            }\r\n            // Can only sort reverse operations when the order is not significant\r\n            if (!hasTouchingRanges) {\r\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\r\n            }\r\n        }\r\n        this._mightContainRTL = mightContainRTL;\r\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\r\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\r\n        const contentChanges = this._doApplyEdits(operations);\r\n        let trimAutoWhitespaceLineNumbers = null;\r\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\r\n            // sort line numbers auto whitespace removal candidates for next edit descending\r\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\r\n            trimAutoWhitespaceLineNumbers = [];\r\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\r\n                let lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\r\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\r\n                    // Do not have the same line number twice\r\n                    continue;\r\n                }\r\n                let prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\r\n                let lineContent = this.getLineContent(lineNumber);\r\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\r\n                    continue;\r\n                }\r\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\r\n            }\r\n        }\r\n        this._onDidChangeContent.fire();\r\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\r\n    }\r\n    /**\r\n     * Transform operations such that they represent the same logic edit,\r\n     * but that they also do not cause OOM crashes.\r\n     */\r\n    _reduceOperations(operations) {\r\n        if (operations.length < 1000) {\r\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\r\n            return operations;\r\n        }\r\n        // At one point, due to how events are emitted and how each operation is handled,\r\n        // some operations can trigger a high amount of temporary string allocations,\r\n        // that will immediately get edited again.\r\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\r\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\r\n        return [this._toSingleEditOperation(operations)];\r\n    }\r\n    _toSingleEditOperation(operations) {\r\n        let forceMoveMarkers = false;\r\n        const firstEditRange = operations[0].range;\r\n        const lastEditRange = operations[operations.length - 1].range;\r\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\r\n        let lastEndLineNumber = firstEditRange.startLineNumber;\r\n        let lastEndColumn = firstEditRange.startColumn;\r\n        const result = [];\r\n        for (let i = 0, len = operations.length; i < len; i++) {\r\n            const operation = operations[i];\r\n            const range = operation.range;\r\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\r\n            // (1) -- Push old text\r\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\r\n            // (2) -- Push new text\r\n            if (operation.text.length > 0) {\r\n                result.push(operation.text);\r\n            }\r\n            lastEndLineNumber = range.endLineNumber;\r\n            lastEndColumn = range.endColumn;\r\n        }\r\n        const text = result.join('');\r\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\r\n        return {\r\n            sortIndex: 0,\r\n            identifier: operations[0].identifier,\r\n            range: entireEditRange,\r\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\r\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* TextDefined */),\r\n            text: text,\r\n            eolCount: eolCount,\r\n            firstLineLength: firstLineLength,\r\n            lastLineLength: lastLineLength,\r\n            forceMoveMarkers: forceMoveMarkers,\r\n            isAutoWhitespaceEdit: false\r\n        };\r\n    }\r\n    _doApplyEdits(operations) {\r\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\r\n        let contentChanges = [];\r\n        // operations are from bottom to top\r\n        for (let i = 0; i < operations.length; i++) {\r\n            let op = operations[i];\r\n            const startLineNumber = op.range.startLineNumber;\r\n            const startColumn = op.range.startColumn;\r\n            const endLineNumber = op.range.endLineNumber;\r\n            const endColumn = op.range.endColumn;\r\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\r\n                // no-op\r\n                continue;\r\n            }\r\n            if (op.text) {\r\n                // replacement\r\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\r\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\r\n            }\r\n            else {\r\n                // deletion\r\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\r\n            }\r\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n            contentChanges.push({\r\n                range: contentChangeRange,\r\n                rangeLength: op.rangeLength,\r\n                text: op.text,\r\n                rangeOffset: op.rangeOffset,\r\n                forceMoveMarkers: op.forceMoveMarkers\r\n            });\r\n        }\r\n        return contentChanges;\r\n    }\r\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\r\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\r\n    }\r\n    /**\r\n     * Assumes `operations` are validated and sorted ascending\r\n     */\r\n    static _getInverseEditRanges(operations) {\r\n        let result = [];\r\n        let prevOpEndLineNumber = 0;\r\n        let prevOpEndColumn = 0;\r\n        let prevOp = null;\r\n        for (let i = 0, len = operations.length; i < len; i++) {\r\n            let op = operations[i];\r\n            let startLineNumber;\r\n            let startColumn;\r\n            if (prevOp) {\r\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\r\n                    startLineNumber = prevOpEndLineNumber;\r\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\r\n                }\r\n                else {\r\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\r\n                    startColumn = op.range.startColumn;\r\n                }\r\n            }\r\n            else {\r\n                startLineNumber = op.range.startLineNumber;\r\n                startColumn = op.range.startColumn;\r\n            }\r\n            let resultRange;\r\n            if (op.text.length > 0) {\r\n                // the operation inserts something\r\n                const lineCount = op.eolCount + 1;\r\n                if (lineCount === 1) {\r\n                    // single line insert\r\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\r\n                }\r\n                else {\r\n                    // multi line insert\r\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\r\n                }\r\n            }\r\n            else {\r\n                // There is nothing to insert\r\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\r\n            }\r\n            prevOpEndLineNumber = resultRange.endLineNumber;\r\n            prevOpEndColumn = resultRange.endColumn;\r\n            result.push(resultRange);\r\n            prevOp = op;\r\n        }\r\n        return result;\r\n    }\r\n    static _sortOpsAscending(a, b) {\r\n        let r = Range.compareRangesUsingEnds(a.range, b.range);\r\n        if (r === 0) {\r\n            return a.sortIndex - b.sortIndex;\r\n        }\r\n        return r;\r\n    }\r\n    static _sortOpsDescending(a, b) {\r\n        let r = Range.compareRangesUsingEnds(a.range, b.range);\r\n        if (r === 0) {\r\n            return b.sortIndex - a.sortIndex;\r\n        }\r\n        return -r;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}