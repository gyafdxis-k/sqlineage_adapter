{"ast":null,"code":"import { Iterable } from './iterator.js';\n/**\r\n * Enables logging of potentially leaked disposables.\r\n *\r\n * A disposable is considered leaked if it is not disposed or not registered as the child of\r\n * another disposable. This tracking is very simple an only works for classes that either\r\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\r\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nif (TRACK_DISPOSABLES) {\n  const __is_disposable_tracked__ = '__is_disposable_tracked__';\n  disposableTracker = new class {\n    trackDisposable(x) {\n      const stack = new Error('Potentially leaked disposable').stack;\n      setTimeout(() => {\n        if (!x[__is_disposable_tracked__]) {\n          console.log(stack);\n        }\n      }, 3000);\n    }\n    markTracked(x) {\n      if (x && x !== Disposable.None) {\n        try {\n          x[__is_disposable_tracked__] = true;\n        } catch (_a) {\n          // noop\n        }\n      }\n    }\n  }();\n}\nfunction markTracked(x) {\n  if (!disposableTracker) {\n    return;\n  }\n  disposableTracker.markTracked(x);\n}\nexport function trackDisposable(x) {\n  if (!disposableTracker) {\n    return x;\n  }\n  disposableTracker.trackDisposable(x);\n  return x;\n}\nexport class MultiDisposeError extends Error {\n  constructor(errors) {\n    super(\"Encounter errors while disposing of store. Errors: [\".concat(errors.join(', '), \"]\"));\n    this.errors = errors;\n  }\n}\nexport function isDisposable(thing) {\n  return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(arg) {\n  if (Iterable.is(arg)) {\n    let errors = [];\n    for (const d of arg) {\n      if (d) {\n        markTracked(d);\n        try {\n          d.dispose();\n        } catch (e) {\n          errors.push(e);\n        }\n      }\n    }\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length > 1) {\n      throw new MultiDisposeError(errors);\n    }\n    return Array.isArray(arg) ? [] : arg;\n  } else if (arg) {\n    markTracked(arg);\n    arg.dispose();\n    return arg;\n  }\n}\nexport function combinedDisposable() {\n  for (var _len = arguments.length, disposables = new Array(_len), _key = 0; _key < _len; _key++) {\n    disposables[_key] = arguments[_key];\n  }\n  disposables.forEach(markTracked);\n  return toDisposable(() => dispose(disposables));\n}\nexport function toDisposable(fn) {\n  const self = trackDisposable({\n    dispose: () => {\n      markTracked(self);\n      fn();\n    }\n  });\n  return self;\n}\nexport class DisposableStore {\n  constructor() {\n    this._toDispose = new Set();\n    this._isDisposed = false;\n  }\n  /**\r\n   * Dispose of all registered disposables and mark this object as disposed.\r\n   *\r\n   * Any future disposables added to this object will be disposed of on `add`.\r\n   */\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n    markTracked(this);\n    this._isDisposed = true;\n    this.clear();\n  }\n  /**\r\n   * Dispose of all registered disposables but do not mark this object as disposed.\r\n   */\n  clear() {\n    try {\n      dispose(this._toDispose.values());\n    } finally {\n      this._toDispose.clear();\n    }\n  }\n  add(t) {\n    if (!t) {\n      return t;\n    }\n    if (t === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n    markTracked(t);\n    if (this._isDisposed) {\n      if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n        console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n      }\n    } else {\n      this._toDispose.add(t);\n    }\n    return t;\n  }\n}\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\nexport class Disposable {\n  constructor() {\n    this._store = new DisposableStore();\n    trackDisposable(this);\n  }\n  dispose() {\n    markTracked(this);\n    this._store.dispose();\n  }\n  _register(t) {\n    if (t === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n    return this._store.add(t);\n  }\n}\nDisposable.None = Object.freeze({\n  dispose() {}\n});\n/**\r\n * Manages the lifecycle of a disposable value that may be changed.\r\n *\r\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\r\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\r\n */\nexport class MutableDisposable {\n  constructor() {\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  get value() {\n    return this._isDisposed ? undefined : this._value;\n  }\n  set value(value) {\n    if (this._isDisposed || value === this._value) {\n      return;\n    }\n    if (this._value) {\n      this._value.dispose();\n    }\n    if (value) {\n      markTracked(value);\n    }\n    this._value = value;\n  }\n  clear() {\n    this.value = undefined;\n  }\n  dispose() {\n    this._isDisposed = true;\n    markTracked(this);\n    if (this._value) {\n      this._value.dispose();\n    }\n    this._value = undefined;\n  }\n}\nexport class ImmortalReference {\n  constructor(object) {\n    this.object = object;\n  }\n  dispose() {}\n}","map":{"version":3,"names":["Iterable","TRACK_DISPOSABLES","disposableTracker","__is_disposable_tracked__","trackDisposable","x","stack","Error","setTimeout","console","log","markTracked","Disposable","None","_a","MultiDisposeError","constructor","errors","concat","join","isDisposable","thing","dispose","length","arg","is","d","e","push","Array","isArray","combinedDisposable","_len","arguments","disposables","_key","forEach","toDisposable","fn","self","DisposableStore","_toDispose","Set","_isDisposed","clear","values","add","t","DISABLE_DISPOSED_WARNING","warn","_store","_register","Object","freeze","MutableDisposable","value","undefined","_value","ImmortalReference","object"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"],"sourcesContent":["import { Iterable } from './iterator.js';\r\n/**\r\n * Enables logging of potentially leaked disposables.\r\n *\r\n * A disposable is considered leaked if it is not disposed or not registered as the child of\r\n * another disposable. This tracking is very simple an only works for classes that either\r\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\r\n */\r\nconst TRACK_DISPOSABLES = false;\r\nlet disposableTracker = null;\r\nif (TRACK_DISPOSABLES) {\r\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\r\n    disposableTracker = new class {\r\n        trackDisposable(x) {\r\n            const stack = new Error('Potentially leaked disposable').stack;\r\n            setTimeout(() => {\r\n                if (!x[__is_disposable_tracked__]) {\r\n                    console.log(stack);\r\n                }\r\n            }, 3000);\r\n        }\r\n        markTracked(x) {\r\n            if (x && x !== Disposable.None) {\r\n                try {\r\n                    x[__is_disposable_tracked__] = true;\r\n                }\r\n                catch (_a) {\r\n                    // noop\r\n                }\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction markTracked(x) {\r\n    if (!disposableTracker) {\r\n        return;\r\n    }\r\n    disposableTracker.markTracked(x);\r\n}\r\nexport function trackDisposable(x) {\r\n    if (!disposableTracker) {\r\n        return x;\r\n    }\r\n    disposableTracker.trackDisposable(x);\r\n    return x;\r\n}\r\nexport class MultiDisposeError extends Error {\r\n    constructor(errors) {\r\n        super(`Encounter errors while disposing of store. Errors: [${errors.join(', ')}]`);\r\n        this.errors = errors;\r\n    }\r\n}\r\nexport function isDisposable(thing) {\r\n    return typeof thing.dispose === 'function' && thing.dispose.length === 0;\r\n}\r\nexport function dispose(arg) {\r\n    if (Iterable.is(arg)) {\r\n        let errors = [];\r\n        for (const d of arg) {\r\n            if (d) {\r\n                markTracked(d);\r\n                try {\r\n                    d.dispose();\r\n                }\r\n                catch (e) {\r\n                    errors.push(e);\r\n                }\r\n            }\r\n        }\r\n        if (errors.length === 1) {\r\n            throw errors[0];\r\n        }\r\n        else if (errors.length > 1) {\r\n            throw new MultiDisposeError(errors);\r\n        }\r\n        return Array.isArray(arg) ? [] : arg;\r\n    }\r\n    else if (arg) {\r\n        markTracked(arg);\r\n        arg.dispose();\r\n        return arg;\r\n    }\r\n}\r\nexport function combinedDisposable(...disposables) {\r\n    disposables.forEach(markTracked);\r\n    return toDisposable(() => dispose(disposables));\r\n}\r\nexport function toDisposable(fn) {\r\n    const self = trackDisposable({\r\n        dispose: () => {\r\n            markTracked(self);\r\n            fn();\r\n        }\r\n    });\r\n    return self;\r\n}\r\nexport class DisposableStore {\r\n    constructor() {\r\n        this._toDispose = new Set();\r\n        this._isDisposed = false;\r\n    }\r\n    /**\r\n     * Dispose of all registered disposables and mark this object as disposed.\r\n     *\r\n     * Any future disposables added to this object will be disposed of on `add`.\r\n     */\r\n    dispose() {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        markTracked(this);\r\n        this._isDisposed = true;\r\n        this.clear();\r\n    }\r\n    /**\r\n     * Dispose of all registered disposables but do not mark this object as disposed.\r\n     */\r\n    clear() {\r\n        try {\r\n            dispose(this._toDispose.values());\r\n        }\r\n        finally {\r\n            this._toDispose.clear();\r\n        }\r\n    }\r\n    add(t) {\r\n        if (!t) {\r\n            return t;\r\n        }\r\n        if (t === this) {\r\n            throw new Error('Cannot register a disposable on itself!');\r\n        }\r\n        markTracked(t);\r\n        if (this._isDisposed) {\r\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\r\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\r\n            }\r\n        }\r\n        else {\r\n            this._toDispose.add(t);\r\n        }\r\n        return t;\r\n    }\r\n}\r\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\r\nexport class Disposable {\r\n    constructor() {\r\n        this._store = new DisposableStore();\r\n        trackDisposable(this);\r\n    }\r\n    dispose() {\r\n        markTracked(this);\r\n        this._store.dispose();\r\n    }\r\n    _register(t) {\r\n        if (t === this) {\r\n            throw new Error('Cannot register a disposable on itself!');\r\n        }\r\n        return this._store.add(t);\r\n    }\r\n}\r\nDisposable.None = Object.freeze({ dispose() { } });\r\n/**\r\n * Manages the lifecycle of a disposable value that may be changed.\r\n *\r\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\r\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\r\n */\r\nexport class MutableDisposable {\r\n    constructor() {\r\n        this._isDisposed = false;\r\n        trackDisposable(this);\r\n    }\r\n    get value() {\r\n        return this._isDisposed ? undefined : this._value;\r\n    }\r\n    set value(value) {\r\n        if (this._isDisposed || value === this._value) {\r\n            return;\r\n        }\r\n        if (this._value) {\r\n            this._value.dispose();\r\n        }\r\n        if (value) {\r\n            markTracked(value);\r\n        }\r\n        this._value = value;\r\n    }\r\n    clear() {\r\n        this.value = undefined;\r\n    }\r\n    dispose() {\r\n        this._isDisposed = true;\r\n        markTracked(this);\r\n        if (this._value) {\r\n            this._value.dispose();\r\n        }\r\n        this._value = undefined;\r\n    }\r\n}\r\nexport class ImmortalReference {\r\n    constructor(object) {\r\n        this.object = object;\r\n    }\r\n    dispose() { }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}