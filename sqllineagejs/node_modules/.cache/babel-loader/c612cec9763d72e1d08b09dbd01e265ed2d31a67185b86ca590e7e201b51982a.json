{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { IntervalTimer } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class AbstractKeybindingService extends Disposable {\n  constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\n    super();\n    this._contextKeyService = _contextKeyService;\n    this._commandService = _commandService;\n    this._telemetryService = _telemetryService;\n    this._notificationService = _notificationService;\n    this._logService = _logService;\n    this._onDidUpdateKeybindings = this._register(new Emitter());\n    this._currentChord = null;\n    this._currentChordChecker = new IntervalTimer();\n    this._currentChordStatusMessage = null;\n    this._logging = false;\n  }\n  get onDidUpdateKeybindings() {\n    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n  }\n\n  dispose() {\n    super.dispose();\n  }\n  _log(str) {\n    if (this._logging) {\n      this._logService.info(\"[KeybindingService]: \".concat(str));\n    }\n  }\n  getKeybindings() {\n    return this._getResolver().getKeybindings();\n  }\n  lookupKeybinding(commandId) {\n    const result = this._getResolver().lookupPrimaryKeybinding(commandId);\n    if (!result) {\n      return undefined;\n    }\n    return result.resolvedKeybinding;\n  }\n  dispatchEvent(e, target) {\n    return this._dispatch(e, target);\n  }\n  softDispatch(e, target) {\n    const keybinding = this.resolveKeyboardEvent(e);\n    if (keybinding.isChord()) {\n      console.warn('Unexpected keyboard event mapped to a chord');\n      return null;\n    }\n    const [firstPart] = keybinding.getDispatchParts();\n    if (firstPart === null) {\n      // cannot be dispatched, probably only modifier keys\n      return null;\n    }\n    const contextValue = this._contextKeyService.getContext(target);\n    const currentChord = this._currentChord ? this._currentChord.keypress : null;\n    return this._getResolver().resolve(contextValue, currentChord, firstPart);\n  }\n  _enterChordMode(firstPart, keypressLabel) {\n    this._currentChord = {\n      keypress: firstPart,\n      label: keypressLabel\n    };\n    this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n    const chordEnterTime = Date.now();\n    this._currentChordChecker.cancelAndSet(() => {\n      if (!this._documentHasFocus()) {\n        // Focus has been lost => leave chord mode\n        this._leaveChordMode();\n        return;\n      }\n      if (Date.now() - chordEnterTime > 5000) {\n        // 5 seconds elapsed => leave chord mode\n        this._leaveChordMode();\n      }\n    }, 500);\n  }\n  _leaveChordMode() {\n    if (this._currentChordStatusMessage) {\n      this._currentChordStatusMessage.dispose();\n      this._currentChordStatusMessage = null;\n    }\n    this._currentChordChecker.cancel();\n    this._currentChord = null;\n  }\n  _dispatch(e, target) {\n    return this._doDispatch(this.resolveKeyboardEvent(e), target);\n  }\n  _doDispatch(keybinding, target) {\n    let shouldPreventDefault = false;\n    if (keybinding.isChord()) {\n      console.warn('Unexpected keyboard event mapped to a chord');\n      return false;\n    }\n    const [firstPart] = keybinding.getDispatchParts();\n    if (firstPart === null) {\n      this._log(\"\\\\ Keyboard event cannot be dispatched.\");\n      // cannot be dispatched, probably only modifier keys\n      return shouldPreventDefault;\n    }\n    const contextValue = this._contextKeyService.getContext(target);\n    const currentChord = this._currentChord ? this._currentChord.keypress : null;\n    const keypressLabel = keybinding.getLabel();\n    const resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);\n    this._logService.trace('KeybindingService#dispatch', keypressLabel, resolveResult === null || resolveResult === void 0 ? void 0 : resolveResult.commandId);\n    if (resolveResult && resolveResult.enterChord) {\n      shouldPreventDefault = true;\n      this._enterChordMode(firstPart, keypressLabel);\n      return shouldPreventDefault;\n    }\n    if (this._currentChord) {\n      if (!resolveResult || !resolveResult.commandId) {\n        this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", this._currentChord.label, keypressLabel), {\n          hideAfter: 10 * 1000 /* 10s */\n        });\n        shouldPreventDefault = true;\n      }\n    }\n    this._leaveChordMode();\n    if (resolveResult && resolveResult.commandId) {\n      if (!resolveResult.bubble) {\n        shouldPreventDefault = true;\n      }\n      if (typeof resolveResult.commandArgs === 'undefined') {\n        this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\n      } else {\n        this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\n      }\n      this._telemetryService.publicLog2('workbenchActionExecuted', {\n        id: resolveResult.commandId,\n        from: 'keybinding'\n      });\n    }\n    return shouldPreventDefault;\n  }\n  mightProducePrintableCharacter(event) {\n    if (event.ctrlKey || event.metaKey) {\n      // ignore ctrl/cmd-combination but not shift/alt-combinatios\n      return false;\n    }\n    // weak check for certain ranges. this is properly implemented in a subclass\n    // with access to the KeyboardMapperFactory.\n    if (event.keyCode >= 31 /* KEY_A */ && event.keyCode <= 56 /* KEY_Z */ || event.keyCode >= 21 /* KEY_0 */ && event.keyCode <= 30 /* KEY_9 */) {\n      return true;\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["nls","IntervalTimer","Emitter","Event","Disposable","AbstractKeybindingService","constructor","_contextKeyService","_commandService","_telemetryService","_notificationService","_logService","_onDidUpdateKeybindings","_register","_currentChord","_currentChordChecker","_currentChordStatusMessage","_logging","onDidUpdateKeybindings","event","None","dispose","_log","str","info","concat","getKeybindings","_getResolver","lookupKeybinding","commandId","result","lookupPrimaryKeybinding","undefined","resolvedKeybinding","dispatchEvent","e","target","_dispatch","softDispatch","keybinding","resolveKeyboardEvent","isChord","console","warn","firstPart","getDispatchParts","contextValue","getContext","currentChord","keypress","resolve","_enterChordMode","keypressLabel","label","status","localize","chordEnterTime","Date","now","cancelAndSet","_documentHasFocus","_leaveChordMode","cancel","_doDispatch","shouldPreventDefault","getLabel","resolveResult","trace","enterChord","hideAfter","bubble","commandArgs","executeCommand","then","err","publicLog2","id","from","mightProducePrintableCharacter","ctrlKey","metaKey","keyCode"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as nls from '../../../nls.js';\r\nimport { IntervalTimer } from '../../../base/common/async.js';\r\nimport { Emitter, Event } from '../../../base/common/event.js';\r\nimport { Disposable } from '../../../base/common/lifecycle.js';\r\nexport class AbstractKeybindingService extends Disposable {\r\n    constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\r\n        super();\r\n        this._contextKeyService = _contextKeyService;\r\n        this._commandService = _commandService;\r\n        this._telemetryService = _telemetryService;\r\n        this._notificationService = _notificationService;\r\n        this._logService = _logService;\r\n        this._onDidUpdateKeybindings = this._register(new Emitter());\r\n        this._currentChord = null;\r\n        this._currentChordChecker = new IntervalTimer();\r\n        this._currentChordStatusMessage = null;\r\n        this._logging = false;\r\n    }\r\n    get onDidUpdateKeybindings() {\r\n        return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n    }\r\n    _log(str) {\r\n        if (this._logging) {\r\n            this._logService.info(`[KeybindingService]: ${str}`);\r\n        }\r\n    }\r\n    getKeybindings() {\r\n        return this._getResolver().getKeybindings();\r\n    }\r\n    lookupKeybinding(commandId) {\r\n        const result = this._getResolver().lookupPrimaryKeybinding(commandId);\r\n        if (!result) {\r\n            return undefined;\r\n        }\r\n        return result.resolvedKeybinding;\r\n    }\r\n    dispatchEvent(e, target) {\r\n        return this._dispatch(e, target);\r\n    }\r\n    softDispatch(e, target) {\r\n        const keybinding = this.resolveKeyboardEvent(e);\r\n        if (keybinding.isChord()) {\r\n            console.warn('Unexpected keyboard event mapped to a chord');\r\n            return null;\r\n        }\r\n        const [firstPart,] = keybinding.getDispatchParts();\r\n        if (firstPart === null) {\r\n            // cannot be dispatched, probably only modifier keys\r\n            return null;\r\n        }\r\n        const contextValue = this._contextKeyService.getContext(target);\r\n        const currentChord = this._currentChord ? this._currentChord.keypress : null;\r\n        return this._getResolver().resolve(contextValue, currentChord, firstPart);\r\n    }\r\n    _enterChordMode(firstPart, keypressLabel) {\r\n        this._currentChord = {\r\n            keypress: firstPart,\r\n            label: keypressLabel\r\n        };\r\n        this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\r\n        const chordEnterTime = Date.now();\r\n        this._currentChordChecker.cancelAndSet(() => {\r\n            if (!this._documentHasFocus()) {\r\n                // Focus has been lost => leave chord mode\r\n                this._leaveChordMode();\r\n                return;\r\n            }\r\n            if (Date.now() - chordEnterTime > 5000) {\r\n                // 5 seconds elapsed => leave chord mode\r\n                this._leaveChordMode();\r\n            }\r\n        }, 500);\r\n    }\r\n    _leaveChordMode() {\r\n        if (this._currentChordStatusMessage) {\r\n            this._currentChordStatusMessage.dispose();\r\n            this._currentChordStatusMessage = null;\r\n        }\r\n        this._currentChordChecker.cancel();\r\n        this._currentChord = null;\r\n    }\r\n    _dispatch(e, target) {\r\n        return this._doDispatch(this.resolveKeyboardEvent(e), target);\r\n    }\r\n    _doDispatch(keybinding, target) {\r\n        let shouldPreventDefault = false;\r\n        if (keybinding.isChord()) {\r\n            console.warn('Unexpected keyboard event mapped to a chord');\r\n            return false;\r\n        }\r\n        const [firstPart,] = keybinding.getDispatchParts();\r\n        if (firstPart === null) {\r\n            this._log(`\\\\ Keyboard event cannot be dispatched.`);\r\n            // cannot be dispatched, probably only modifier keys\r\n            return shouldPreventDefault;\r\n        }\r\n        const contextValue = this._contextKeyService.getContext(target);\r\n        const currentChord = this._currentChord ? this._currentChord.keypress : null;\r\n        const keypressLabel = keybinding.getLabel();\r\n        const resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);\r\n        this._logService.trace('KeybindingService#dispatch', keypressLabel, resolveResult === null || resolveResult === void 0 ? void 0 : resolveResult.commandId);\r\n        if (resolveResult && resolveResult.enterChord) {\r\n            shouldPreventDefault = true;\r\n            this._enterChordMode(firstPart, keypressLabel);\r\n            return shouldPreventDefault;\r\n        }\r\n        if (this._currentChord) {\r\n            if (!resolveResult || !resolveResult.commandId) {\r\n                this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", this._currentChord.label, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });\r\n                shouldPreventDefault = true;\r\n            }\r\n        }\r\n        this._leaveChordMode();\r\n        if (resolveResult && resolveResult.commandId) {\r\n            if (!resolveResult.bubble) {\r\n                shouldPreventDefault = true;\r\n            }\r\n            if (typeof resolveResult.commandArgs === 'undefined') {\r\n                this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\r\n            }\r\n            else {\r\n                this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\r\n            }\r\n            this._telemetryService.publicLog2('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding' });\r\n        }\r\n        return shouldPreventDefault;\r\n    }\r\n    mightProducePrintableCharacter(event) {\r\n        if (event.ctrlKey || event.metaKey) {\r\n            // ignore ctrl/cmd-combination but not shift/alt-combinatios\r\n            return false;\r\n        }\r\n        // weak check for certain ranges. this is properly implemented in a subclass\r\n        // with access to the KeyboardMapperFactory.\r\n        if ((event.keyCode >= 31 /* KEY_A */ && event.keyCode <= 56 /* KEY_Z */)\r\n            || (event.keyCode >= 21 /* KEY_0 */ && event.keyCode <= 30 /* KEY_9 */)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}