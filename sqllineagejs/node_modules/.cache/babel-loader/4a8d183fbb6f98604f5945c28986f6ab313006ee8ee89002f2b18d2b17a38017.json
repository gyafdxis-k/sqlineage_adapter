{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n  return (node.metadata & 1 /* ColorMask */) >>> 0 /* ColorOffset */;\n}\n\nfunction setNodeColor(node, color) {\n  node.metadata = node.metadata & 254 /* ColorMaskInverse */ | color << 0 /* ColorOffset */;\n}\n\nfunction getNodeIsVisited(node) {\n  return (node.metadata & 2 /* IsVisitedMask */) >>> 1 /* IsVisitedOffset */ === 1;\n}\nfunction setNodeIsVisited(node, value) {\n  node.metadata = node.metadata & 253 /* IsVisitedMaskInverse */ | (value ? 1 : 0) << 1 /* IsVisitedOffset */;\n}\n\nfunction getNodeIsForValidation(node) {\n  return (node.metadata & 4 /* IsForValidationMask */) >>> 2 /* IsForValidationOffset */ === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n  node.metadata = node.metadata & 251 /* IsForValidationMaskInverse */ | (value ? 1 : 0) << 2 /* IsForValidationOffset */;\n}\n\nexport function getNodeIsInOverviewRuler(node) {\n  return (node.metadata & 8 /* IsInOverviewRulerMask */) >>> 3 /* IsInOverviewRulerOffset */ === 1;\n}\nfunction setNodeIsInOverviewRuler(node, value) {\n  node.metadata = node.metadata & 247 /* IsInOverviewRulerMaskInverse */ | (value ? 1 : 0) << 3 /* IsInOverviewRulerOffset */;\n}\n\nfunction getNodeStickiness(node) {\n  return (node.metadata & 48 /* StickinessMask */) >>> 4 /* StickinessOffset */;\n}\n\nfunction _setNodeStickiness(node, stickiness) {\n  node.metadata = node.metadata & 207 /* StickinessMaskInverse */ | stickiness << 4 /* StickinessOffset */;\n}\n\nfunction getCollapseOnReplaceEdit(node) {\n  return (node.metadata & 64 /* CollapseOnReplaceEditMask */) >>> 6 /* CollapseOnReplaceEditOffset */ === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n  node.metadata = node.metadata & 191 /* CollapseOnReplaceEditMaskInverse */ | (value ? 1 : 0) << 6 /* CollapseOnReplaceEditOffset */;\n}\n\nexport class IntervalNode {\n  constructor(id, start, end) {\n    this.metadata = 0;\n    this.parent = this;\n    this.left = this;\n    this.right = this;\n    setNodeColor(this, 1 /* Red */);\n    this.start = start;\n    this.end = end;\n    // FORCE_OVERFLOWING_TEST: this.delta = start;\n    this.delta = 0;\n    this.maxEnd = end;\n    this.id = id;\n    this.ownerId = 0;\n    this.options = null;\n    setNodeIsForValidation(this, false);\n    _setNodeStickiness(this, 1 /* NeverGrowsWhenTypingAtEdges */);\n    setNodeIsInOverviewRuler(this, false);\n    setCollapseOnReplaceEdit(this, false);\n    this.cachedVersionId = 0;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = null;\n    setNodeIsVisited(this, false);\n  }\n  reset(versionId, start, end, range) {\n    this.start = start;\n    this.end = end;\n    this.maxEnd = end;\n    this.cachedVersionId = versionId;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = range;\n  }\n  setOptions(options) {\n    this.options = options;\n    let className = this.options.className;\n    setNodeIsForValidation(this, className === \"squiggly-error\" /* EditorErrorDecoration */ || className === \"squiggly-warning\" /* EditorWarningDecoration */ || className === \"squiggly-info\" /* EditorInfoDecoration */);\n    _setNodeStickiness(this, this.options.stickiness);\n    setNodeIsInOverviewRuler(this, this.options.overviewRuler && this.options.overviewRuler.color ? true : false);\n    setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n  }\n  setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n    if (this.cachedVersionId !== cachedVersionId) {\n      this.range = null;\n    }\n    this.cachedVersionId = cachedVersionId;\n    this.cachedAbsoluteStart = absoluteStart;\n    this.cachedAbsoluteEnd = absoluteEnd;\n  }\n  detach() {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* Black */);\nexport class IntervalTree {\n  constructor() {\n    this.root = SENTINEL;\n    this.requestNormalizeDelta = false;\n  }\n  intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n    return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n  }\n  search(filterOwnerId, filterOutValidation, cachedVersionId) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n    return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n  }\n  /**\r\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n   */\n  collectNodesFromOwner(ownerId) {\n    return collectNodesFromOwner(this, ownerId);\n  }\n  /**\r\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n   */\n  collectNodesPostOrder() {\n    return collectNodesPostOrder(this);\n  }\n  insert(node) {\n    rbTreeInsert(this, node);\n    this._normalizeDeltaIfNecessary();\n  }\n  delete(node) {\n    rbTreeDelete(this, node);\n    this._normalizeDeltaIfNecessary();\n  }\n  resolveNode(node, cachedVersionId) {\n    const initialNode = node;\n    let delta = 0;\n    while (node !== this.root) {\n      if (node === node.parent.right) {\n        delta += node.parent.delta;\n      }\n      node = node.parent;\n    }\n    const nodeStart = initialNode.start + delta;\n    const nodeEnd = initialNode.end + delta;\n    initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n  }\n  acceptReplace(offset, length, textLength, forceMoveMarkers) {\n    // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n    // (1) collect all nodes that are intersecting this edit as nodes of interest\n    const nodesOfInterest = searchForEditing(this, offset, offset + length);\n    // (2) remove all nodes that are intersecting this edit\n    for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n      const node = nodesOfInterest[i];\n      rbTreeDelete(this, node);\n    }\n    this._normalizeDeltaIfNecessary();\n    // (3) edit all tree nodes except the nodes of interest\n    noOverlapReplace(this, offset, offset + length, textLength);\n    this._normalizeDeltaIfNecessary();\n    // (4) edit the nodes of interest and insert them back in the tree\n    for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n      const node = nodesOfInterest[i];\n      node.start = node.cachedAbsoluteStart;\n      node.end = node.cachedAbsoluteEnd;\n      nodeAcceptEdit(node, offset, offset + length, textLength, forceMoveMarkers);\n      node.maxEnd = node.end;\n      rbTreeInsert(this, node);\n    }\n    this._normalizeDeltaIfNecessary();\n  }\n  _normalizeDeltaIfNecessary() {\n    if (!this.requestNormalizeDelta) {\n      return;\n    }\n    this.requestNormalizeDelta = false;\n    normalizeDelta(this);\n  }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n  let node = T.root;\n  let delta = 0;\n  while (node !== SENTINEL) {\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n    // handle current node\n    node.start = delta + node.start;\n    node.end = delta + node.end;\n    node.delta = 0;\n    recomputeMaxEnd(node);\n    setNodeIsVisited(node, true);\n    // going up from this node\n    setNodeIsVisited(node.left, false);\n    setNodeIsVisited(node.right, false);\n    if (node === node.parent.right) {\n      delta -= node.parent.delta;\n    }\n    node = node.parent;\n  }\n  setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n  if (markerOffset < checkOffset) {\n    return true;\n  }\n  if (markerOffset > checkOffset) {\n    return false;\n  }\n  if (moveSemantics === 1 /* ForceMove */) {\n    return false;\n  }\n  if (moveSemantics === 2 /* ForceStay */) {\n    return true;\n  }\n  return markerStickToPreviousCharacter;\n}\n/**\r\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\r\n * as when decorations were implemented using two markers.\r\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n  const nodeStickiness = getNodeStickiness(node);\n  const startStickToPreviousCharacter = nodeStickiness === 0 /* AlwaysGrowsWhenTypingAtEdges */ || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */;\n  const endStickToPreviousCharacter = nodeStickiness === 1 /* NeverGrowsWhenTypingAtEdges */ || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */;\n  const deletingCnt = end - start;\n  const insertingCnt = textLength;\n  const commonLength = Math.min(deletingCnt, insertingCnt);\n  const nodeStart = node.start;\n  let startDone = false;\n  const nodeEnd = node.end;\n  let endDone = false;\n  if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n    // This edit encompasses the entire decoration range\n    // and the decoration has asked to become collapsed\n    node.start = start;\n    startDone = true;\n    node.end = start;\n    endDone = true;\n  }\n  {\n    const moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n      endDone = true;\n    }\n  }\n  if (commonLength > 0 && !forceMoveMarkers) {\n    const moveSemantics = deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      endDone = true;\n    }\n  }\n  {\n    const moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n      node.start = start + insertingCnt;\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n      node.end = start + insertingCnt;\n      endDone = true;\n    }\n  }\n  // Finish\n  const deltaColumn = insertingCnt - deletingCnt;\n  if (!startDone) {\n    node.start = Math.max(0, nodeStart + deltaColumn);\n  }\n  if (!endDone) {\n    node.end = Math.max(0, nodeEnd + deltaColumn);\n  }\n  if (node.start > node.end) {\n    node.end = node.start;\n  }\n}\nfunction searchForEditing(T, start, end) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  let node = T.root;\n  let delta = 0;\n  let nodeMaxEnd = 0;\n  let nodeStart = 0;\n  let nodeEnd = 0;\n  let result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > end) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    nodeEnd = delta + node.end;\n    if (nodeEnd >= start) {\n      node.setCachedOffsets(nodeStart, nodeEnd, 0);\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  let node = T.root;\n  let delta = 0;\n  let nodeMaxEnd = 0;\n  let nodeStart = 0;\n  const editDelta = textLength - (end - start);\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      recomputeMaxEnd(node);\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > end) {\n      node.start += editDelta;\n      node.end += editDelta;\n      node.delta += editDelta;\n      if (node.delta < -1073741824 /* MIN_SAFE_DELTA */ || node.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n      }\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n  let node = T.root;\n  let result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    // handle current node\n    if (node.ownerId === ownerId) {\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction collectNodesPostOrder(T) {\n  let node = T.root;\n  let result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n    // handle current node\n    result[resultLen++] = node;\n    setNodeIsVisited(node, true);\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n  let node = T.root;\n  let delta = 0;\n  let nodeStart = 0;\n  let nodeEnd = 0;\n  let result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    nodeEnd = delta + node.end;\n    node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    let include = true;\n    if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n      include = false;\n    }\n    if (filterOutValidation && getNodeIsForValidation(node)) {\n      include = false;\n    }\n    if (include) {\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  let node = T.root;\n  let delta = 0;\n  let nodeMaxEnd = 0;\n  let nodeStart = 0;\n  let nodeEnd = 0;\n  let result = [];\n  let resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < intervalStart) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > intervalEnd) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    nodeEnd = delta + node.end;\n    if (nodeEnd >= intervalStart) {\n      // There is overlap\n      node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n      let include = true;\n      if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n        include = false;\n      }\n      if (filterOutValidation && getNodeIsForValidation(node)) {\n        include = false;\n      }\n      if (include) {\n        result[resultLen++] = node;\n      }\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n  if (T.root === SENTINEL) {\n    newNode.parent = SENTINEL;\n    newNode.left = SENTINEL;\n    newNode.right = SENTINEL;\n    setNodeColor(newNode, 0 /* Black */);\n    T.root = newNode;\n    return T.root;\n  }\n  treeInsert(T, newNode);\n  recomputeMaxEndWalkToRoot(newNode.parent);\n  // repair tree\n  let x = newNode;\n  while (x !== T.root && getNodeColor(x.parent) === 1 /* Red */) {\n    if (x.parent === x.parent.parent.left) {\n      const y = x.parent.parent.right;\n      if (getNodeColor(y) === 1 /* Red */) {\n        setNodeColor(x.parent, 0 /* Black */);\n        setNodeColor(y, 0 /* Black */);\n        setNodeColor(x.parent.parent, 1 /* Red */);\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.right) {\n          x = x.parent;\n          leftRotate(T, x);\n        }\n        setNodeColor(x.parent, 0 /* Black */);\n        setNodeColor(x.parent.parent, 1 /* Red */);\n        rightRotate(T, x.parent.parent);\n      }\n    } else {\n      const y = x.parent.parent.left;\n      if (getNodeColor(y) === 1 /* Red */) {\n        setNodeColor(x.parent, 0 /* Black */);\n        setNodeColor(y, 0 /* Black */);\n        setNodeColor(x.parent.parent, 1 /* Red */);\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.left) {\n          x = x.parent;\n          rightRotate(T, x);\n        }\n        setNodeColor(x.parent, 0 /* Black */);\n        setNodeColor(x.parent.parent, 1 /* Red */);\n        leftRotate(T, x.parent.parent);\n      }\n    }\n  }\n  setNodeColor(T.root, 0 /* Black */);\n  return newNode;\n}\nfunction treeInsert(T, z) {\n  let delta = 0;\n  let x = T.root;\n  const zAbsoluteStart = z.start;\n  const zAbsoluteEnd = z.end;\n  while (true) {\n    const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n    if (cmp < 0) {\n      // this node should be inserted to the left\n      // => it is not affected by the node's delta\n      if (x.left === SENTINEL) {\n        z.start -= delta;\n        z.end -= delta;\n        z.maxEnd -= delta;\n        x.left = z;\n        break;\n      } else {\n        x = x.left;\n      }\n    } else {\n      // this node should be inserted to the right\n      // => it is not affected by the node's delta\n      if (x.right === SENTINEL) {\n        z.start -= delta + x.delta;\n        z.end -= delta + x.delta;\n        z.maxEnd -= delta + x.delta;\n        x.right = z;\n        break;\n      } else {\n        delta += x.delta;\n        x = x.right;\n      }\n    }\n  }\n  z.parent = x;\n  z.left = SENTINEL;\n  z.right = SENTINEL;\n  setNodeColor(z, 1 /* Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n  let x;\n  let y;\n  // RB-DELETE except we don't swap z and y in case c)\n  // i.e. we always delete what's pointed at by z.\n  if (z.left === SENTINEL) {\n    x = z.right;\n    y = z;\n    // x's delta is no longer influenced by z's delta\n    x.delta += z.delta;\n    if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n    x.start += z.delta;\n    x.end += z.delta;\n  } else if (z.right === SENTINEL) {\n    x = z.left;\n    y = z;\n  } else {\n    y = leftest(z.right);\n    x = y.right;\n    // y's delta is no longer influenced by z's delta,\n    // but we don't want to walk the entire right-hand-side subtree of x.\n    // we therefore maintain z's delta in y, and adjust only x\n    x.start += y.delta;\n    x.end += y.delta;\n    x.delta += y.delta;\n    if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n    y.start += z.delta;\n    y.end += z.delta;\n    y.delta = z.delta;\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n  }\n  if (y === T.root) {\n    T.root = x;\n    setNodeColor(x, 0 /* Black */);\n    z.detach();\n    resetSentinel();\n    recomputeMaxEnd(x);\n    T.root.parent = SENTINEL;\n    return;\n  }\n  let yWasRed = getNodeColor(y) === 1 /* Red */;\n  if (y === y.parent.left) {\n    y.parent.left = x;\n  } else {\n    y.parent.right = x;\n  }\n  if (y === z) {\n    x.parent = y.parent;\n  } else {\n    if (y.parent === z) {\n      x.parent = y;\n    } else {\n      x.parent = y.parent;\n    }\n    y.left = z.left;\n    y.right = z.right;\n    y.parent = z.parent;\n    setNodeColor(y, getNodeColor(z));\n    if (z === T.root) {\n      T.root = y;\n    } else {\n      if (z === z.parent.left) {\n        z.parent.left = y;\n      } else {\n        z.parent.right = y;\n      }\n    }\n    if (y.left !== SENTINEL) {\n      y.left.parent = y;\n    }\n    if (y.right !== SENTINEL) {\n      y.right.parent = y;\n    }\n  }\n  z.detach();\n  if (yWasRed) {\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n      recomputeMaxEndWalkToRoot(y);\n      recomputeMaxEndWalkToRoot(y.parent);\n    }\n    resetSentinel();\n    return;\n  }\n  recomputeMaxEndWalkToRoot(x);\n  recomputeMaxEndWalkToRoot(x.parent);\n  if (y !== z) {\n    recomputeMaxEndWalkToRoot(y);\n    recomputeMaxEndWalkToRoot(y.parent);\n  }\n  // RB-DELETE-FIXUP\n  let w;\n  while (x !== T.root && getNodeColor(x) === 0 /* Black */) {\n    if (x === x.parent.left) {\n      w = x.parent.right;\n      if (getNodeColor(w) === 1 /* Red */) {\n        setNodeColor(w, 0 /* Black */);\n        setNodeColor(x.parent, 1 /* Red */);\n        leftRotate(T, x.parent);\n        w = x.parent.right;\n      }\n      if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\n        setNodeColor(w, 1 /* Red */);\n        x = x.parent;\n      } else {\n        if (getNodeColor(w.right) === 0 /* Black */) {\n          setNodeColor(w.left, 0 /* Black */);\n          setNodeColor(w, 1 /* Red */);\n          rightRotate(T, w);\n          w = x.parent.right;\n        }\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0 /* Black */);\n        setNodeColor(w.right, 0 /* Black */);\n        leftRotate(T, x.parent);\n        x = T.root;\n      }\n    } else {\n      w = x.parent.left;\n      if (getNodeColor(w) === 1 /* Red */) {\n        setNodeColor(w, 0 /* Black */);\n        setNodeColor(x.parent, 1 /* Red */);\n        rightRotate(T, x.parent);\n        w = x.parent.left;\n      }\n      if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\n        setNodeColor(w, 1 /* Red */);\n        x = x.parent;\n      } else {\n        if (getNodeColor(w.left) === 0 /* Black */) {\n          setNodeColor(w.right, 0 /* Black */);\n          setNodeColor(w, 1 /* Red */);\n          leftRotate(T, w);\n          w = x.parent.left;\n        }\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0 /* Black */);\n        setNodeColor(w.left, 0 /* Black */);\n        rightRotate(T, x.parent);\n        x = T.root;\n      }\n    }\n  }\n  setNodeColor(x, 0 /* Black */);\n  resetSentinel();\n}\nfunction leftest(node) {\n  while (node.left !== SENTINEL) {\n    node = node.left;\n  }\n  return node;\n}\nfunction resetSentinel() {\n  SENTINEL.parent = SENTINEL;\n  SENTINEL.delta = 0; // optional\n  SENTINEL.start = 0; // optional\n  SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n  const y = x.right; // set y.\n  y.delta += x.delta; // y's delta is no longer influenced by x's delta\n  if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n    T.requestNormalizeDelta = true;\n  }\n  y.start += x.delta;\n  y.end += x.delta;\n  x.right = y.left; // turn y's left subtree into x's right subtree.\n  if (y.left !== SENTINEL) {\n    y.left.parent = x;\n  }\n  y.parent = x.parent; // link x's parent to y.\n  if (x.parent === SENTINEL) {\n    T.root = y;\n  } else if (x === x.parent.left) {\n    x.parent.left = y;\n  } else {\n    x.parent.right = y;\n  }\n  y.left = x; // put x on y's left.\n  x.parent = y;\n  recomputeMaxEnd(x);\n  recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n  const x = y.left;\n  y.delta -= x.delta;\n  if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n    T.requestNormalizeDelta = true;\n  }\n  y.start -= x.delta;\n  y.end -= x.delta;\n  y.left = x.right;\n  if (x.right !== SENTINEL) {\n    x.right.parent = y;\n  }\n  x.parent = y.parent;\n  if (y.parent === SENTINEL) {\n    T.root = x;\n  } else if (y === y.parent.right) {\n    y.parent.right = x;\n  } else {\n    y.parent.left = x;\n  }\n  x.right = y;\n  y.parent = x;\n  recomputeMaxEnd(y);\n  recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n  let maxEnd = node.end;\n  if (node.left !== SENTINEL) {\n    const leftMaxEnd = node.left.maxEnd;\n    if (leftMaxEnd > maxEnd) {\n      maxEnd = leftMaxEnd;\n    }\n  }\n  if (node.right !== SENTINEL) {\n    const rightMaxEnd = node.right.maxEnd + node.delta;\n    if (rightMaxEnd > maxEnd) {\n      maxEnd = rightMaxEnd;\n    }\n  }\n  return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n  node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n  while (node !== SENTINEL) {\n    const maxEnd = computeMaxEnd(node);\n    if (node.maxEnd === maxEnd) {\n      // no need to go further\n      return;\n    }\n    node.maxEnd = maxEnd;\n    node = node.parent;\n  }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n  if (aStart === bStart) {\n    return aEnd - bEnd;\n  }\n  return aStart - bStart;\n}\n//#endregion","map":{"version":3,"names":["getNodeColor","node","metadata","setNodeColor","color","getNodeIsVisited","setNodeIsVisited","value","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInOverviewRuler","setNodeIsInOverviewRuler","getNodeStickiness","_setNodeStickiness","stickiness","getCollapseOnReplaceEdit","setCollapseOnReplaceEdit","IntervalNode","constructor","id","start","end","parent","left","right","delta","maxEnd","ownerId","options","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","range","reset","versionId","setOptions","className","overviewRuler","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","root","requestNormalizeDelta","intervalSearch","filterOwnerId","filterOutValidation","search","collectNodesFromOwner","collectNodesPostOrder","insert","rbTreeInsert","_normalizeDeltaIfNecessary","delete","rbTreeDelete","resolveNode","initialNode","nodeStart","nodeEnd","acceptReplace","offset","length","textLength","forceMoveMarkers","nodesOfInterest","searchForEditing","i","len","noOverlapReplace","nodeAcceptEdit","normalizeDelta","T","recomputeMaxEnd","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","Math","min","startDone","endDone","deltaColumn","max","nodeMaxEnd","result","resultLen","editDelta","include","intervalStart","intervalEnd","newNode","treeInsert","recomputeMaxEndWalkToRoot","x","y","leftRotate","rightRotate","z","zAbsoluteStart","zAbsoluteEnd","cmp","intervalCompare","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport function getNodeColor(node) {\r\n    return ((node.metadata & 1 /* ColorMask */) >>> 0 /* ColorOffset */);\r\n}\r\nfunction setNodeColor(node, color) {\r\n    node.metadata = ((node.metadata & 254 /* ColorMaskInverse */) | (color << 0 /* ColorOffset */));\r\n}\r\nfunction getNodeIsVisited(node) {\r\n    return ((node.metadata & 2 /* IsVisitedMask */) >>> 1 /* IsVisitedOffset */) === 1;\r\n}\r\nfunction setNodeIsVisited(node, value) {\r\n    node.metadata = ((node.metadata & 253 /* IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* IsVisitedOffset */));\r\n}\r\nfunction getNodeIsForValidation(node) {\r\n    return ((node.metadata & 4 /* IsForValidationMask */) >>> 2 /* IsForValidationOffset */) === 1;\r\n}\r\nfunction setNodeIsForValidation(node, value) {\r\n    node.metadata = ((node.metadata & 251 /* IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* IsForValidationOffset */));\r\n}\r\nexport function getNodeIsInOverviewRuler(node) {\r\n    return ((node.metadata & 8 /* IsInOverviewRulerMask */) >>> 3 /* IsInOverviewRulerOffset */) === 1;\r\n}\r\nfunction setNodeIsInOverviewRuler(node, value) {\r\n    node.metadata = ((node.metadata & 247 /* IsInOverviewRulerMaskInverse */) | ((value ? 1 : 0) << 3 /* IsInOverviewRulerOffset */));\r\n}\r\nfunction getNodeStickiness(node) {\r\n    return ((node.metadata & 48 /* StickinessMask */) >>> 4 /* StickinessOffset */);\r\n}\r\nfunction _setNodeStickiness(node, stickiness) {\r\n    node.metadata = ((node.metadata & 207 /* StickinessMaskInverse */) | (stickiness << 4 /* StickinessOffset */));\r\n}\r\nfunction getCollapseOnReplaceEdit(node) {\r\n    return ((node.metadata & 64 /* CollapseOnReplaceEditMask */) >>> 6 /* CollapseOnReplaceEditOffset */) === 1;\r\n}\r\nfunction setCollapseOnReplaceEdit(node, value) {\r\n    node.metadata = ((node.metadata & 191 /* CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 6 /* CollapseOnReplaceEditOffset */));\r\n}\r\nexport class IntervalNode {\r\n    constructor(id, start, end) {\r\n        this.metadata = 0;\r\n        this.parent = this;\r\n        this.left = this;\r\n        this.right = this;\r\n        setNodeColor(this, 1 /* Red */);\r\n        this.start = start;\r\n        this.end = end;\r\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\r\n        this.delta = 0;\r\n        this.maxEnd = end;\r\n        this.id = id;\r\n        this.ownerId = 0;\r\n        this.options = null;\r\n        setNodeIsForValidation(this, false);\r\n        _setNodeStickiness(this, 1 /* NeverGrowsWhenTypingAtEdges */);\r\n        setNodeIsInOverviewRuler(this, false);\r\n        setCollapseOnReplaceEdit(this, false);\r\n        this.cachedVersionId = 0;\r\n        this.cachedAbsoluteStart = start;\r\n        this.cachedAbsoluteEnd = end;\r\n        this.range = null;\r\n        setNodeIsVisited(this, false);\r\n    }\r\n    reset(versionId, start, end, range) {\r\n        this.start = start;\r\n        this.end = end;\r\n        this.maxEnd = end;\r\n        this.cachedVersionId = versionId;\r\n        this.cachedAbsoluteStart = start;\r\n        this.cachedAbsoluteEnd = end;\r\n        this.range = range;\r\n    }\r\n    setOptions(options) {\r\n        this.options = options;\r\n        let className = this.options.className;\r\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* EditorErrorDecoration */\r\n            || className === \"squiggly-warning\" /* EditorWarningDecoration */\r\n            || className === \"squiggly-info\" /* EditorInfoDecoration */));\r\n        _setNodeStickiness(this, this.options.stickiness);\r\n        setNodeIsInOverviewRuler(this, (this.options.overviewRuler && this.options.overviewRuler.color) ? true : false);\r\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\r\n    }\r\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\r\n        if (this.cachedVersionId !== cachedVersionId) {\r\n            this.range = null;\r\n        }\r\n        this.cachedVersionId = cachedVersionId;\r\n        this.cachedAbsoluteStart = absoluteStart;\r\n        this.cachedAbsoluteEnd = absoluteEnd;\r\n    }\r\n    detach() {\r\n        this.parent = null;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n}\r\nexport const SENTINEL = new IntervalNode(null, 0, 0);\r\nSENTINEL.parent = SENTINEL;\r\nSENTINEL.left = SENTINEL;\r\nSENTINEL.right = SENTINEL;\r\nsetNodeColor(SENTINEL, 0 /* Black */);\r\nexport class IntervalTree {\r\n    constructor() {\r\n        this.root = SENTINEL;\r\n        this.requestNormalizeDelta = false;\r\n    }\r\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n        if (this.root === SENTINEL) {\r\n            return [];\r\n        }\r\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\r\n    }\r\n    search(filterOwnerId, filterOutValidation, cachedVersionId) {\r\n        if (this.root === SENTINEL) {\r\n            return [];\r\n        }\r\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\r\n    }\r\n    /**\r\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n     */\r\n    collectNodesFromOwner(ownerId) {\r\n        return collectNodesFromOwner(this, ownerId);\r\n    }\r\n    /**\r\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n     */\r\n    collectNodesPostOrder() {\r\n        return collectNodesPostOrder(this);\r\n    }\r\n    insert(node) {\r\n        rbTreeInsert(this, node);\r\n        this._normalizeDeltaIfNecessary();\r\n    }\r\n    delete(node) {\r\n        rbTreeDelete(this, node);\r\n        this._normalizeDeltaIfNecessary();\r\n    }\r\n    resolveNode(node, cachedVersionId) {\r\n        const initialNode = node;\r\n        let delta = 0;\r\n        while (node !== this.root) {\r\n            if (node === node.parent.right) {\r\n                delta += node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        const nodeStart = initialNode.start + delta;\r\n        const nodeEnd = initialNode.end + delta;\r\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\r\n    }\r\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\r\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\r\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\r\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\r\n        // (2) remove all nodes that are intersecting this edit\r\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\r\n            const node = nodesOfInterest[i];\r\n            rbTreeDelete(this, node);\r\n        }\r\n        this._normalizeDeltaIfNecessary();\r\n        // (3) edit all tree nodes except the nodes of interest\r\n        noOverlapReplace(this, offset, offset + length, textLength);\r\n        this._normalizeDeltaIfNecessary();\r\n        // (4) edit the nodes of interest and insert them back in the tree\r\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\r\n            const node = nodesOfInterest[i];\r\n            node.start = node.cachedAbsoluteStart;\r\n            node.end = node.cachedAbsoluteEnd;\r\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\r\n            node.maxEnd = node.end;\r\n            rbTreeInsert(this, node);\r\n        }\r\n        this._normalizeDeltaIfNecessary();\r\n    }\r\n    _normalizeDeltaIfNecessary() {\r\n        if (!this.requestNormalizeDelta) {\r\n            return;\r\n        }\r\n        this.requestNormalizeDelta = false;\r\n        normalizeDelta(this);\r\n    }\r\n}\r\n//#region Delta Normalization\r\nfunction normalizeDelta(T) {\r\n    let node = T.root;\r\n    let delta = 0;\r\n    while (node !== SENTINEL) {\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        node.start = delta + node.start;\r\n        node.end = delta + node.end;\r\n        node.delta = 0;\r\n        recomputeMaxEnd(node);\r\n        setNodeIsVisited(node, true);\r\n        // going up from this node\r\n        setNodeIsVisited(node.left, false);\r\n        setNodeIsVisited(node.right, false);\r\n        if (node === node.parent.right) {\r\n            delta -= node.parent.delta;\r\n        }\r\n        node = node.parent;\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n}\r\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\r\n    if (markerOffset < checkOffset) {\r\n        return true;\r\n    }\r\n    if (markerOffset > checkOffset) {\r\n        return false;\r\n    }\r\n    if (moveSemantics === 1 /* ForceMove */) {\r\n        return false;\r\n    }\r\n    if (moveSemantics === 2 /* ForceStay */) {\r\n        return true;\r\n    }\r\n    return markerStickToPreviousCharacter;\r\n}\r\n/**\r\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\r\n * as when decorations were implemented using two markers.\r\n */\r\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\r\n    const nodeStickiness = getNodeStickiness(node);\r\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* AlwaysGrowsWhenTypingAtEdges */\r\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\r\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* NeverGrowsWhenTypingAtEdges */\r\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\r\n    const deletingCnt = (end - start);\r\n    const insertingCnt = textLength;\r\n    const commonLength = Math.min(deletingCnt, insertingCnt);\r\n    const nodeStart = node.start;\r\n    let startDone = false;\r\n    const nodeEnd = node.end;\r\n    let endDone = false;\r\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\r\n        // This edit encompasses the entire decoration range\r\n        // and the decoration has asked to become collapsed\r\n        node.start = start;\r\n        startDone = true;\r\n        node.end = start;\r\n        endDone = true;\r\n    }\r\n    {\r\n        const moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\r\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\r\n            startDone = true;\r\n        }\r\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\r\n            endDone = true;\r\n        }\r\n    }\r\n    if (commonLength > 0 && !forceMoveMarkers) {\r\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\r\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\r\n            startDone = true;\r\n        }\r\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\r\n            endDone = true;\r\n        }\r\n    }\r\n    {\r\n        const moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */;\r\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\r\n            node.start = start + insertingCnt;\r\n            startDone = true;\r\n        }\r\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\r\n            node.end = start + insertingCnt;\r\n            endDone = true;\r\n        }\r\n    }\r\n    // Finish\r\n    const deltaColumn = (insertingCnt - deletingCnt);\r\n    if (!startDone) {\r\n        node.start = Math.max(0, nodeStart + deltaColumn);\r\n    }\r\n    if (!endDone) {\r\n        node.end = Math.max(0, nodeEnd + deltaColumn);\r\n    }\r\n    if (node.start > node.end) {\r\n        node.end = node.start;\r\n    }\r\n}\r\nfunction searchForEditing(T, start, end) {\r\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\r\n    // Now, it is known that two intervals A and B overlap only when both\r\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\r\n    // nodes overlapping with a given interval, you can immediately skip:\r\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\r\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\r\n    let node = T.root;\r\n    let delta = 0;\r\n    let nodeMaxEnd = 0;\r\n    let nodeStart = 0;\r\n    let nodeEnd = 0;\r\n    let result = [];\r\n    let resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (!getNodeIsVisited(node.left)) {\r\n            // first time seeing this node\r\n            nodeMaxEnd = delta + node.maxEnd;\r\n            if (nodeMaxEnd < start) {\r\n                // cover case b) from above\r\n                // there is no need to search this node or its children\r\n                setNodeIsVisited(node, true);\r\n                continue;\r\n            }\r\n            if (node.left !== SENTINEL) {\r\n                // go left\r\n                node = node.left;\r\n                continue;\r\n            }\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        if (nodeStart > end) {\r\n            // cover case a) from above\r\n            // there is no need to search this node or its right subtree\r\n            setNodeIsVisited(node, true);\r\n            continue;\r\n        }\r\n        nodeEnd = delta + node.end;\r\n        if (nodeEnd >= start) {\r\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\r\n            result[resultLen++] = node;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction noOverlapReplace(T, start, end, textLength) {\r\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\r\n    // Now, it is known that two intervals A and B overlap only when both\r\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\r\n    // nodes overlapping with a given interval, you can immediately skip:\r\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\r\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\r\n    let node = T.root;\r\n    let delta = 0;\r\n    let nodeMaxEnd = 0;\r\n    let nodeStart = 0;\r\n    const editDelta = (textLength - (end - start));\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            recomputeMaxEnd(node);\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (!getNodeIsVisited(node.left)) {\r\n            // first time seeing this node\r\n            nodeMaxEnd = delta + node.maxEnd;\r\n            if (nodeMaxEnd < start) {\r\n                // cover case b) from above\r\n                // there is no need to search this node or its children\r\n                setNodeIsVisited(node, true);\r\n                continue;\r\n            }\r\n            if (node.left !== SENTINEL) {\r\n                // go left\r\n                node = node.left;\r\n                continue;\r\n            }\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        if (nodeStart > end) {\r\n            node.start += editDelta;\r\n            node.end += editDelta;\r\n            node.delta += editDelta;\r\n            if (node.delta < -1073741824 /* MIN_SAFE_DELTA */ || node.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n                T.requestNormalizeDelta = true;\r\n            }\r\n            // cover case a) from above\r\n            // there is no need to search this node or its right subtree\r\n            setNodeIsVisited(node, true);\r\n            continue;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n}\r\n//#endregion\r\n//#region Searching\r\nfunction collectNodesFromOwner(T, ownerId) {\r\n    let node = T.root;\r\n    let result = [];\r\n    let resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        if (node.ownerId === ownerId) {\r\n            result[resultLen++] = node;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction collectNodesPostOrder(T) {\r\n    let node = T.root;\r\n    let result = [];\r\n    let resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            node = node.right;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        result[resultLen++] = node;\r\n        setNodeIsVisited(node, true);\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n    let node = T.root;\r\n    let delta = 0;\r\n    let nodeStart = 0;\r\n    let nodeEnd = 0;\r\n    let result = [];\r\n    let resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        nodeEnd = delta + node.end;\r\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\r\n        let include = true;\r\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\r\n            include = false;\r\n        }\r\n        if (filterOutValidation && getNodeIsForValidation(node)) {\r\n            include = false;\r\n        }\r\n        if (include) {\r\n            result[resultLen++] = node;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\r\n    // Now, it is known that two intervals A and B overlap only when both\r\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\r\n    // nodes overlapping with a given interval, you can immediately skip:\r\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\r\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\r\n    let node = T.root;\r\n    let delta = 0;\r\n    let nodeMaxEnd = 0;\r\n    let nodeStart = 0;\r\n    let nodeEnd = 0;\r\n    let result = [];\r\n    let resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (!getNodeIsVisited(node.left)) {\r\n            // first time seeing this node\r\n            nodeMaxEnd = delta + node.maxEnd;\r\n            if (nodeMaxEnd < intervalStart) {\r\n                // cover case b) from above\r\n                // there is no need to search this node or its children\r\n                setNodeIsVisited(node, true);\r\n                continue;\r\n            }\r\n            if (node.left !== SENTINEL) {\r\n                // go left\r\n                node = node.left;\r\n                continue;\r\n            }\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        if (nodeStart > intervalEnd) {\r\n            // cover case a) from above\r\n            // there is no need to search this node or its right subtree\r\n            setNodeIsVisited(node, true);\r\n            continue;\r\n        }\r\n        nodeEnd = delta + node.end;\r\n        if (nodeEnd >= intervalStart) {\r\n            // There is overlap\r\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\r\n            let include = true;\r\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\r\n                include = false;\r\n            }\r\n            if (filterOutValidation && getNodeIsForValidation(node)) {\r\n                include = false;\r\n            }\r\n            if (include) {\r\n                result[resultLen++] = node;\r\n            }\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\n//#endregion\r\n//#region Insertion\r\nfunction rbTreeInsert(T, newNode) {\r\n    if (T.root === SENTINEL) {\r\n        newNode.parent = SENTINEL;\r\n        newNode.left = SENTINEL;\r\n        newNode.right = SENTINEL;\r\n        setNodeColor(newNode, 0 /* Black */);\r\n        T.root = newNode;\r\n        return T.root;\r\n    }\r\n    treeInsert(T, newNode);\r\n    recomputeMaxEndWalkToRoot(newNode.parent);\r\n    // repair tree\r\n    let x = newNode;\r\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* Red */) {\r\n        if (x.parent === x.parent.parent.left) {\r\n            const y = x.parent.parent.right;\r\n            if (getNodeColor(y) === 1 /* Red */) {\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(y, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                x = x.parent.parent;\r\n            }\r\n            else {\r\n                if (x === x.parent.right) {\r\n                    x = x.parent;\r\n                    leftRotate(T, x);\r\n                }\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                rightRotate(T, x.parent.parent);\r\n            }\r\n        }\r\n        else {\r\n            const y = x.parent.parent.left;\r\n            if (getNodeColor(y) === 1 /* Red */) {\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(y, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                x = x.parent.parent;\r\n            }\r\n            else {\r\n                if (x === x.parent.left) {\r\n                    x = x.parent;\r\n                    rightRotate(T, x);\r\n                }\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                leftRotate(T, x.parent.parent);\r\n            }\r\n        }\r\n    }\r\n    setNodeColor(T.root, 0 /* Black */);\r\n    return newNode;\r\n}\r\nfunction treeInsert(T, z) {\r\n    let delta = 0;\r\n    let x = T.root;\r\n    const zAbsoluteStart = z.start;\r\n    const zAbsoluteEnd = z.end;\r\n    while (true) {\r\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\r\n        if (cmp < 0) {\r\n            // this node should be inserted to the left\r\n            // => it is not affected by the node's delta\r\n            if (x.left === SENTINEL) {\r\n                z.start -= delta;\r\n                z.end -= delta;\r\n                z.maxEnd -= delta;\r\n                x.left = z;\r\n                break;\r\n            }\r\n            else {\r\n                x = x.left;\r\n            }\r\n        }\r\n        else {\r\n            // this node should be inserted to the right\r\n            // => it is not affected by the node's delta\r\n            if (x.right === SENTINEL) {\r\n                z.start -= (delta + x.delta);\r\n                z.end -= (delta + x.delta);\r\n                z.maxEnd -= (delta + x.delta);\r\n                x.right = z;\r\n                break;\r\n            }\r\n            else {\r\n                delta += x.delta;\r\n                x = x.right;\r\n            }\r\n        }\r\n    }\r\n    z.parent = x;\r\n    z.left = SENTINEL;\r\n    z.right = SENTINEL;\r\n    setNodeColor(z, 1 /* Red */);\r\n}\r\n//#endregion\r\n//#region Deletion\r\nfunction rbTreeDelete(T, z) {\r\n    let x;\r\n    let y;\r\n    // RB-DELETE except we don't swap z and y in case c)\r\n    // i.e. we always delete what's pointed at by z.\r\n    if (z.left === SENTINEL) {\r\n        x = z.right;\r\n        y = z;\r\n        // x's delta is no longer influenced by z's delta\r\n        x.delta += z.delta;\r\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n            T.requestNormalizeDelta = true;\r\n        }\r\n        x.start += z.delta;\r\n        x.end += z.delta;\r\n    }\r\n    else if (z.right === SENTINEL) {\r\n        x = z.left;\r\n        y = z;\r\n    }\r\n    else {\r\n        y = leftest(z.right);\r\n        x = y.right;\r\n        // y's delta is no longer influenced by z's delta,\r\n        // but we don't want to walk the entire right-hand-side subtree of x.\r\n        // we therefore maintain z's delta in y, and adjust only x\r\n        x.start += y.delta;\r\n        x.end += y.delta;\r\n        x.delta += y.delta;\r\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n            T.requestNormalizeDelta = true;\r\n        }\r\n        y.start += z.delta;\r\n        y.end += z.delta;\r\n        y.delta = z.delta;\r\n        if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n            T.requestNormalizeDelta = true;\r\n        }\r\n    }\r\n    if (y === T.root) {\r\n        T.root = x;\r\n        setNodeColor(x, 0 /* Black */);\r\n        z.detach();\r\n        resetSentinel();\r\n        recomputeMaxEnd(x);\r\n        T.root.parent = SENTINEL;\r\n        return;\r\n    }\r\n    let yWasRed = (getNodeColor(y) === 1 /* Red */);\r\n    if (y === y.parent.left) {\r\n        y.parent.left = x;\r\n    }\r\n    else {\r\n        y.parent.right = x;\r\n    }\r\n    if (y === z) {\r\n        x.parent = y.parent;\r\n    }\r\n    else {\r\n        if (y.parent === z) {\r\n            x.parent = y;\r\n        }\r\n        else {\r\n            x.parent = y.parent;\r\n        }\r\n        y.left = z.left;\r\n        y.right = z.right;\r\n        y.parent = z.parent;\r\n        setNodeColor(y, getNodeColor(z));\r\n        if (z === T.root) {\r\n            T.root = y;\r\n        }\r\n        else {\r\n            if (z === z.parent.left) {\r\n                z.parent.left = y;\r\n            }\r\n            else {\r\n                z.parent.right = y;\r\n            }\r\n        }\r\n        if (y.left !== SENTINEL) {\r\n            y.left.parent = y;\r\n        }\r\n        if (y.right !== SENTINEL) {\r\n            y.right.parent = y;\r\n        }\r\n    }\r\n    z.detach();\r\n    if (yWasRed) {\r\n        recomputeMaxEndWalkToRoot(x.parent);\r\n        if (y !== z) {\r\n            recomputeMaxEndWalkToRoot(y);\r\n            recomputeMaxEndWalkToRoot(y.parent);\r\n        }\r\n        resetSentinel();\r\n        return;\r\n    }\r\n    recomputeMaxEndWalkToRoot(x);\r\n    recomputeMaxEndWalkToRoot(x.parent);\r\n    if (y !== z) {\r\n        recomputeMaxEndWalkToRoot(y);\r\n        recomputeMaxEndWalkToRoot(y.parent);\r\n    }\r\n    // RB-DELETE-FIXUP\r\n    let w;\r\n    while (x !== T.root && getNodeColor(x) === 0 /* Black */) {\r\n        if (x === x.parent.left) {\r\n            w = x.parent.right;\r\n            if (getNodeColor(w) === 1 /* Red */) {\r\n                setNodeColor(w, 0 /* Black */);\r\n                setNodeColor(x.parent, 1 /* Red */);\r\n                leftRotate(T, x.parent);\r\n                w = x.parent.right;\r\n            }\r\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\r\n                setNodeColor(w, 1 /* Red */);\r\n                x = x.parent;\r\n            }\r\n            else {\r\n                if (getNodeColor(w.right) === 0 /* Black */) {\r\n                    setNodeColor(w.left, 0 /* Black */);\r\n                    setNodeColor(w, 1 /* Red */);\r\n                    rightRotate(T, w);\r\n                    w = x.parent.right;\r\n                }\r\n                setNodeColor(w, getNodeColor(x.parent));\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(w.right, 0 /* Black */);\r\n                leftRotate(T, x.parent);\r\n                x = T.root;\r\n            }\r\n        }\r\n        else {\r\n            w = x.parent.left;\r\n            if (getNodeColor(w) === 1 /* Red */) {\r\n                setNodeColor(w, 0 /* Black */);\r\n                setNodeColor(x.parent, 1 /* Red */);\r\n                rightRotate(T, x.parent);\r\n                w = x.parent.left;\r\n            }\r\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\r\n                setNodeColor(w, 1 /* Red */);\r\n                x = x.parent;\r\n            }\r\n            else {\r\n                if (getNodeColor(w.left) === 0 /* Black */) {\r\n                    setNodeColor(w.right, 0 /* Black */);\r\n                    setNodeColor(w, 1 /* Red */);\r\n                    leftRotate(T, w);\r\n                    w = x.parent.left;\r\n                }\r\n                setNodeColor(w, getNodeColor(x.parent));\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(w.left, 0 /* Black */);\r\n                rightRotate(T, x.parent);\r\n                x = T.root;\r\n            }\r\n        }\r\n    }\r\n    setNodeColor(x, 0 /* Black */);\r\n    resetSentinel();\r\n}\r\nfunction leftest(node) {\r\n    while (node.left !== SENTINEL) {\r\n        node = node.left;\r\n    }\r\n    return node;\r\n}\r\nfunction resetSentinel() {\r\n    SENTINEL.parent = SENTINEL;\r\n    SENTINEL.delta = 0; // optional\r\n    SENTINEL.start = 0; // optional\r\n    SENTINEL.end = 0; // optional\r\n}\r\n//#endregion\r\n//#region Rotations\r\nfunction leftRotate(T, x) {\r\n    const y = x.right; // set y.\r\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\r\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n        T.requestNormalizeDelta = true;\r\n    }\r\n    y.start += x.delta;\r\n    y.end += x.delta;\r\n    x.right = y.left; // turn y's left subtree into x's right subtree.\r\n    if (y.left !== SENTINEL) {\r\n        y.left.parent = x;\r\n    }\r\n    y.parent = x.parent; // link x's parent to y.\r\n    if (x.parent === SENTINEL) {\r\n        T.root = y;\r\n    }\r\n    else if (x === x.parent.left) {\r\n        x.parent.left = y;\r\n    }\r\n    else {\r\n        x.parent.right = y;\r\n    }\r\n    y.left = x; // put x on y's left.\r\n    x.parent = y;\r\n    recomputeMaxEnd(x);\r\n    recomputeMaxEnd(y);\r\n}\r\nfunction rightRotate(T, y) {\r\n    const x = y.left;\r\n    y.delta -= x.delta;\r\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n        T.requestNormalizeDelta = true;\r\n    }\r\n    y.start -= x.delta;\r\n    y.end -= x.delta;\r\n    y.left = x.right;\r\n    if (x.right !== SENTINEL) {\r\n        x.right.parent = y;\r\n    }\r\n    x.parent = y.parent;\r\n    if (y.parent === SENTINEL) {\r\n        T.root = x;\r\n    }\r\n    else if (y === y.parent.right) {\r\n        y.parent.right = x;\r\n    }\r\n    else {\r\n        y.parent.left = x;\r\n    }\r\n    x.right = y;\r\n    y.parent = x;\r\n    recomputeMaxEnd(y);\r\n    recomputeMaxEnd(x);\r\n}\r\n//#endregion\r\n//#region max end computation\r\nfunction computeMaxEnd(node) {\r\n    let maxEnd = node.end;\r\n    if (node.left !== SENTINEL) {\r\n        const leftMaxEnd = node.left.maxEnd;\r\n        if (leftMaxEnd > maxEnd) {\r\n            maxEnd = leftMaxEnd;\r\n        }\r\n    }\r\n    if (node.right !== SENTINEL) {\r\n        const rightMaxEnd = node.right.maxEnd + node.delta;\r\n        if (rightMaxEnd > maxEnd) {\r\n            maxEnd = rightMaxEnd;\r\n        }\r\n    }\r\n    return maxEnd;\r\n}\r\nexport function recomputeMaxEnd(node) {\r\n    node.maxEnd = computeMaxEnd(node);\r\n}\r\nfunction recomputeMaxEndWalkToRoot(node) {\r\n    while (node !== SENTINEL) {\r\n        const maxEnd = computeMaxEnd(node);\r\n        if (node.maxEnd === maxEnd) {\r\n            // no need to go further\r\n            return;\r\n        }\r\n        node.maxEnd = maxEnd;\r\n        node = node.parent;\r\n    }\r\n}\r\n//#endregion\r\n//#region utils\r\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\r\n    if (aStart === bStart) {\r\n        return aEnd - bEnd;\r\n    }\r\n    return aStart - bStart;\r\n}\r\n//#endregion\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}