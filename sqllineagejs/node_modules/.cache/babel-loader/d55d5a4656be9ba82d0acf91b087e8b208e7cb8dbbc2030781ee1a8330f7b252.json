{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport './viewLines.css';\nimport * as platform from '../../../../base/common/platform.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Configuration } from '../../config/configuration.js';\nimport { VisibleLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { DomReadingContext, ViewLine, ViewLineOptions } from './viewLine.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LineVisibleRanges, HorizontalPosition } from '../../../common/view/renderingContext.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../../base/browser/ui/mouseCursor/mouseCursor.js';\nclass LastRenderedData {\n  constructor() {\n    this._currentVisibleRange = new Range(1, 1, 1, 1);\n  }\n  getCurrentVisibleRange() {\n    return this._currentVisibleRange;\n  }\n  setCurrentVisibleRange(currentVisibleRange) {\n    this._currentVisibleRange = currentVisibleRange;\n  }\n}\nclass HorizontalRevealRangeRequest {\n  constructor(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\n    this.lineNumber = lineNumber;\n    this.startColumn = startColumn;\n    this.endColumn = endColumn;\n    this.startScrollTop = startScrollTop;\n    this.stopScrollTop = stopScrollTop;\n    this.scrollType = scrollType;\n    this.type = 'range';\n    this.minLineNumber = lineNumber;\n    this.maxLineNumber = lineNumber;\n  }\n}\nclass HorizontalRevealSelectionsRequest {\n  constructor(selections, startScrollTop, stopScrollTop, scrollType) {\n    this.selections = selections;\n    this.startScrollTop = startScrollTop;\n    this.stopScrollTop = stopScrollTop;\n    this.scrollType = scrollType;\n    this.type = 'selections';\n    let minLineNumber = selections[0].startLineNumber;\n    let maxLineNumber = selections[0].endLineNumber;\n    for (let i = 1, len = selections.length; i < len; i++) {\n      const selection = selections[i];\n      minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n      maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n    }\n    this.minLineNumber = minLineNumber;\n    this.maxLineNumber = maxLineNumber;\n  }\n}\nexport class ViewLines extends ViewPart {\n  constructor(context, linesContent) {\n    super(context);\n    this._linesContent = linesContent;\n    this._textRangeRestingSpot = document.createElement('div');\n    this._visibleLines = new VisibleLinesCollection(this);\n    this.domNode = this._visibleLines.domNode;\n    const conf = this._context.configuration;\n    const options = this._context.configuration.options;\n    const fontInfo = options.get(38 /* fontInfo */);\n    const wrappingInfo = options.get(125 /* wrappingInfo */);\n    this._lineHeight = options.get(53 /* lineHeight */);\n    this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n    this._revealHorizontalRightPadding = options.get(84 /* revealHorizontalRightPadding */);\n    this._cursorSurroundingLines = options.get(22 /* cursorSurroundingLines */);\n    this._cursorSurroundingLinesStyle = options.get(23 /* cursorSurroundingLinesStyle */);\n    this._canUseLayerHinting = !options.get(25 /* disableLayerHinting */);\n    this._viewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n    PartFingerprints.write(this.domNode, 7 /* ViewLines */);\n    this.domNode.setClassName(\"view-lines \".concat(MOUSE_CURSOR_TEXT_CSS_CLASS_NAME));\n    Configuration.applyFontInfo(this.domNode, fontInfo);\n    // --- width & height\n    this._maxLineWidth = 0;\n    this._asyncUpdateLineWidths = new RunOnceScheduler(() => {\n      this._updateLineWidthsSlow();\n    }, 200);\n    this._asyncCheckMonospaceFontAssumptions = new RunOnceScheduler(() => {\n      this._checkMonospaceFontAssumptions();\n    }, 2000);\n    this._lastRenderedData = new LastRenderedData();\n    this._horizontalRevealRequest = null;\n  }\n  dispose() {\n    this._asyncUpdateLineWidths.dispose();\n    this._asyncCheckMonospaceFontAssumptions.dispose();\n    super.dispose();\n  }\n  getDomNode() {\n    return this.domNode;\n  }\n  // ---- begin IVisibleLinesHost\n  createVisibleLine() {\n    return new ViewLine(this._viewLineOptions);\n  }\n  // ---- end IVisibleLinesHost\n  // ---- begin view event handlers\n  onConfigurationChanged(e) {\n    this._visibleLines.onConfigurationChanged(e);\n    if (e.hasChanged(125 /* wrappingInfo */)) {\n      this._maxLineWidth = 0;\n    }\n    const options = this._context.configuration.options;\n    const fontInfo = options.get(38 /* fontInfo */);\n    const wrappingInfo = options.get(125 /* wrappingInfo */);\n    this._lineHeight = options.get(53 /* lineHeight */);\n    this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n    this._revealHorizontalRightPadding = options.get(84 /* revealHorizontalRightPadding */);\n    this._cursorSurroundingLines = options.get(22 /* cursorSurroundingLines */);\n    this._cursorSurroundingLinesStyle = options.get(23 /* cursorSurroundingLinesStyle */);\n    this._canUseLayerHinting = !options.get(25 /* disableLayerHinting */);\n    Configuration.applyFontInfo(this.domNode, fontInfo);\n    this._onOptionsMaybeChanged();\n    if (e.hasChanged(124 /* layoutInfo */)) {\n      this._maxLineWidth = 0;\n    }\n    return true;\n  }\n  _onOptionsMaybeChanged() {\n    const conf = this._context.configuration;\n    const newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n    if (!this._viewLineOptions.equals(newViewLineOptions)) {\n      this._viewLineOptions = newViewLineOptions;\n      const startLineNumber = this._visibleLines.getStartLineNumber();\n      const endLineNumber = this._visibleLines.getEndLineNumber();\n      for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        const line = this._visibleLines.getVisibleLine(lineNumber);\n        line.onOptionsChanged(this._viewLineOptions);\n      }\n      return true;\n    }\n    return false;\n  }\n  onCursorStateChanged(e) {\n    const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n    const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n    let r = false;\n    for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n      r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\n    }\n    return r;\n  }\n  onDecorationsChanged(e) {\n    if (true /*e.inlineDecorationsChanged*/) {\n      const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n      const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n      for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\n      }\n    }\n    return true;\n  }\n  onFlushed(e) {\n    const shouldRender = this._visibleLines.onFlushed(e);\n    this._maxLineWidth = 0;\n    return shouldRender;\n  }\n  onLinesChanged(e) {\n    return this._visibleLines.onLinesChanged(e);\n  }\n  onLinesDeleted(e) {\n    return this._visibleLines.onLinesDeleted(e);\n  }\n  onLinesInserted(e) {\n    return this._visibleLines.onLinesInserted(e);\n  }\n  onRevealRangeRequest(e) {\n    // Using the future viewport here in order to handle multiple\n    // incoming reveal range requests that might all desire to be animated\n    const desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.range, e.selections, e.verticalType);\n    if (desiredScrollTop === -1) {\n      // marker to abort the reveal range request\n      return false;\n    }\n    // validate the new desired scroll top\n    let newScrollPosition = this._context.viewLayout.validateScrollPosition({\n      scrollTop: desiredScrollTop\n    });\n    if (e.revealHorizontal) {\n      if (e.range && e.range.startLineNumber !== e.range.endLineNumber) {\n        // Two or more lines? => scroll to base (That's how you see most of the two lines)\n        newScrollPosition = {\n          scrollTop: newScrollPosition.scrollTop,\n          scrollLeft: 0\n        };\n      } else if (e.range) {\n        // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\n        this._horizontalRevealRequest = new HorizontalRevealRangeRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n      } else if (e.selections && e.selections.length > 0) {\n        this._horizontalRevealRequest = new HorizontalRevealSelectionsRequest(e.selections, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n      }\n    } else {\n      this._horizontalRevealRequest = null;\n    }\n    const scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\n    const scrollType = scrollTopDelta <= this._lineHeight ? 1 /* Immediate */ : e.scrollType;\n    this._context.model.setScrollPosition(newScrollPosition, scrollType);\n    return true;\n  }\n  onScrollChanged(e) {\n    if (this._horizontalRevealRequest && e.scrollLeftChanged) {\n      // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\n      this._horizontalRevealRequest = null;\n    }\n    if (this._horizontalRevealRequest && e.scrollTopChanged) {\n      const min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n      const max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n      if (e.scrollTop < min || e.scrollTop > max) {\n        // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\n        this._horizontalRevealRequest = null;\n      }\n    }\n    this.domNode.setWidth(e.scrollWidth);\n    return this._visibleLines.onScrollChanged(e) || true;\n  }\n  onTokensChanged(e) {\n    return this._visibleLines.onTokensChanged(e);\n  }\n  onZonesChanged(e) {\n    this._context.model.setMaxLineWidth(this._maxLineWidth);\n    return this._visibleLines.onZonesChanged(e);\n  }\n  onThemeChanged(e) {\n    return this._onOptionsMaybeChanged();\n  }\n  // ---- end view event handlers\n  // ----------- HELPERS FOR OTHERS\n  getPositionFromDOMInfo(spanNode, offset) {\n    const viewLineDomNode = this._getViewLineDomNode(spanNode);\n    if (viewLineDomNode === null) {\n      // Couldn't find view line node\n      return null;\n    }\n    const lineNumber = this._getLineNumberFor(viewLineDomNode);\n    if (lineNumber === -1) {\n      // Couldn't find view line node\n      return null;\n    }\n    if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {\n      // lineNumber is outside range\n      return null;\n    }\n    if (this._context.model.getLineMaxColumn(lineNumber) === 1) {\n      // Line is empty\n      return new Position(lineNumber, 1);\n    }\n    const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n    const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n    if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n      // Couldn't find line\n      return null;\n    }\n    let column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);\n    const minColumn = this._context.model.getLineMinColumn(lineNumber);\n    if (column < minColumn) {\n      column = minColumn;\n    }\n    return new Position(lineNumber, column);\n  }\n  _getViewLineDomNode(node) {\n    while (node && node.nodeType === 1) {\n      if (node.className === ViewLine.CLASS_NAME) {\n        return node;\n      }\n      node = node.parentElement;\n    }\n    return null;\n  }\n  /**\r\n   * @returns the line number of this view line dom node.\r\n   */\n  _getLineNumberFor(domNode) {\n    const startLineNumber = this._visibleLines.getStartLineNumber();\n    const endLineNumber = this._visibleLines.getEndLineNumber();\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const line = this._visibleLines.getVisibleLine(lineNumber);\n      if (domNode === line.getDomNode()) {\n        return lineNumber;\n      }\n    }\n    return -1;\n  }\n  getLineWidth(lineNumber) {\n    const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n    const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n    if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n      // Couldn't find line\n      return -1;\n    }\n    return this._visibleLines.getVisibleLine(lineNumber).getWidth();\n  }\n  linesVisibleRangesForRange(_range, includeNewLines) {\n    if (this.shouldRender()) {\n      // Cannot read from the DOM because it is dirty\n      // i.e. the model & the dom are out of sync, so I'd be reading something stale\n      return null;\n    }\n    const originalEndLineNumber = _range.endLineNumber;\n    const range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n    if (!range) {\n      return null;\n    }\n    let visibleRanges = [],\n      visibleRangesLen = 0;\n    const domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n    let nextLineModelLineNumber = 0;\n    if (includeNewLines) {\n      nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\n    }\n    const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n    const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n    for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n      if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n        continue;\n      }\n      const startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n      const endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\n      const visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\n      if (!visibleRangesForLine) {\n        continue;\n      }\n      if (includeNewLines && lineNumber < originalEndLineNumber) {\n        const currentLineModelLineNumber = nextLineModelLineNumber;\n        nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\n        if (currentLineModelLineNumber !== nextLineModelLineNumber) {\n          visibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth;\n        }\n      }\n      visibleRanges[visibleRangesLen++] = new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, visibleRangesForLine.ranges);\n    }\n    if (visibleRangesLen === 0) {\n      return null;\n    }\n    return visibleRanges;\n  }\n  _visibleRangesForLineRange(lineNumber, startColumn, endColumn) {\n    if (this.shouldRender()) {\n      // Cannot read from the DOM because it is dirty\n      // i.e. the model & the dom are out of sync, so I'd be reading something stale\n      return null;\n    }\n    if (lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {\n      return null;\n    }\n    return this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot));\n  }\n  visibleRangeForPosition(position) {\n    const visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\n    if (!visibleRanges) {\n      return null;\n    }\n    return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\n  }\n  // --- implementation\n  updateLineWidths() {\n    this._updateLineWidths(false);\n  }\n  /**\r\n   * Updates the max line width if it is fast to compute.\r\n   * Returns true if all lines were taken into account.\r\n   * Returns false if some lines need to be reevaluated (in a slow fashion).\r\n   */\n  _updateLineWidthsFast() {\n    return this._updateLineWidths(true);\n  }\n  _updateLineWidthsSlow() {\n    this._updateLineWidths(false);\n  }\n  _updateLineWidths(fast) {\n    const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n    const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n    let localMaxLineWidth = 1;\n    let allWidthsComputed = true;\n    for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n      const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n      if (fast && !visibleLine.getWidthIsFast()) {\n        // Cannot compute width in a fast way for this line\n        allWidthsComputed = false;\n        continue;\n      }\n      localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());\n    }\n    if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {\n      // we know the max line width for all the lines\n      this._maxLineWidth = 0;\n    }\n    this._ensureMaxLineWidth(localMaxLineWidth);\n    return allWidthsComputed;\n  }\n  _checkMonospaceFontAssumptions() {\n    // Problems with monospace assumptions are more apparent for longer lines,\n    // as small rounding errors start to sum up, so we will select the longest\n    // line for a closer inspection\n    let longestLineNumber = -1;\n    let longestWidth = -1;\n    const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n    const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n    for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n      const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n      if (visibleLine.needsMonospaceFontCheck()) {\n        const lineWidth = visibleLine.getWidth();\n        if (lineWidth > longestWidth) {\n          longestWidth = lineWidth;\n          longestLineNumber = lineNumber;\n        }\n      }\n    }\n    if (longestLineNumber === -1) {\n      return;\n    }\n    if (!this._visibleLines.getVisibleLine(longestLineNumber).monospaceAssumptionsAreValid()) {\n      for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n        visibleLine.onMonospaceAssumptionsInvalidated();\n      }\n    }\n  }\n  prepareRender() {\n    throw new Error('Not supported');\n  }\n  render() {\n    throw new Error('Not supported');\n  }\n  renderText(viewportData) {\n    // (1) render lines - ensures lines are in the DOM\n    this._visibleLines.renderLines(viewportData);\n    this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\n    this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\n    this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));\n    // (2) compute horizontal scroll position:\n    //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\n    //  - it might change `scrollWidth` and `scrollLeft`\n    if (this._horizontalRevealRequest) {\n      const horizontalRevealRequest = this._horizontalRevealRequest;\n      // Check that we have the line that contains the horizontal range in the viewport\n      if (viewportData.startLineNumber <= horizontalRevealRequest.minLineNumber && horizontalRevealRequest.maxLineNumber <= viewportData.endLineNumber) {\n        this._horizontalRevealRequest = null;\n        // allow `visibleRangesForRange2` to work\n        this.onDidRender();\n        // compute new scroll position\n        const newScrollLeft = this._computeScrollLeftToReveal(horizontalRevealRequest);\n        if (newScrollLeft) {\n          if (!this._isViewportWrapping) {\n            // ensure `scrollWidth` is large enough\n            this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\n          }\n          // set `scrollLeft`\n          this._context.model.setScrollPosition({\n            scrollLeft: newScrollLeft.scrollLeft\n          }, horizontalRevealRequest.scrollType);\n        }\n      }\n    }\n    // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\n    if (!this._updateLineWidthsFast()) {\n      // Computing the width of some lines would be slow => delay it\n      this._asyncUpdateLineWidths.schedule();\n    }\n    if (platform.isLinux && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {\n      const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n      const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n      for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n        if (visibleLine.needsMonospaceFontCheck()) {\n          this._asyncCheckMonospaceFontAssumptions.schedule();\n          break;\n        }\n      }\n    }\n    // (3) handle scrolling\n    this._linesContent.setLayerHinting(this._canUseLayerHinting);\n    this._linesContent.setContain('strict');\n    const adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\n    this._linesContent.setTop(-adjustedScrollTop);\n    this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\n  }\n  // --- width\n  _ensureMaxLineWidth(lineWidth) {\n    const iLineWidth = Math.ceil(lineWidth);\n    if (this._maxLineWidth < iLineWidth) {\n      this._maxLineWidth = iLineWidth;\n      this._context.model.setMaxLineWidth(this._maxLineWidth);\n    }\n  }\n  _computeScrollTopToRevealRange(viewport, source, range, selections, verticalType) {\n    const viewportStartY = viewport.top;\n    const viewportHeight = viewport.height;\n    const viewportEndY = viewportStartY + viewportHeight;\n    let boxIsSingleRange;\n    let boxStartY;\n    let boxEndY;\n    // Have a box that includes one extra line height (for the horizontal scrollbar)\n    if (selections && selections.length > 0) {\n      let minLineNumber = selections[0].startLineNumber;\n      let maxLineNumber = selections[0].endLineNumber;\n      for (let i = 1, len = selections.length; i < len; i++) {\n        const selection = selections[i];\n        minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n        maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n      }\n      boxIsSingleRange = false;\n      boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(minLineNumber);\n      boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(maxLineNumber) + this._lineHeight;\n    } else if (range) {\n      boxIsSingleRange = true;\n      boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\n      boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\n    } else {\n      return -1;\n    }\n    const shouldIgnoreScrollOff = source === 'mouse' && this._cursorSurroundingLinesStyle === 'default';\n    if (!shouldIgnoreScrollOff) {\n      const context = Math.min(viewportHeight / this._lineHeight / 2, this._cursorSurroundingLines);\n      boxStartY -= context * this._lineHeight;\n      boxEndY += Math.max(0, context - 1) * this._lineHeight;\n    }\n    if (verticalType === 0 /* Simple */ || verticalType === 4 /* Bottom */) {\n      // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\n      boxEndY += this._lineHeight;\n    }\n    let newScrollTop;\n    if (boxEndY - boxStartY > viewportHeight) {\n      // the box is larger than the viewport ... scroll to its top\n      if (!boxIsSingleRange) {\n        // do not reveal multiple cursors if there are more than fit the viewport\n        return -1;\n      }\n      newScrollTop = boxStartY;\n    } else if (verticalType === 5 /* NearTop */ || verticalType === 6 /* NearTopIfOutsideViewport */) {\n      if (verticalType === 6 /* NearTopIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n        // Box is already in the viewport... do nothing\n        newScrollTop = viewportStartY;\n      } else {\n        // We want a gap that is 20% of the viewport, but with a minimum of 5 lines\n        const desiredGapAbove = Math.max(5 * this._lineHeight, viewportHeight * 0.2);\n        // Try to scroll just above the box with the desired gap\n        const desiredScrollTop = boxStartY - desiredGapAbove;\n        // But ensure that the box is not pushed out of viewport\n        const minScrollTop = boxEndY - viewportHeight;\n        newScrollTop = Math.max(minScrollTop, desiredScrollTop);\n      }\n    } else if (verticalType === 1 /* Center */ || verticalType === 2 /* CenterIfOutsideViewport */) {\n      if (verticalType === 2 /* CenterIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n        // Box is already in the viewport... do nothing\n        newScrollTop = viewportStartY;\n      } else {\n        // Box is outside the viewport... center it\n        const boxMiddleY = (boxStartY + boxEndY) / 2;\n        newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\n      }\n    } else {\n      newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3 /* Top */, verticalType === 4 /* Bottom */);\n    }\n\n    return newScrollTop;\n  }\n  _computeScrollLeftToReveal(horizontalRevealRequest) {\n    const viewport = this._context.viewLayout.getCurrentViewport();\n    const viewportStartX = viewport.left;\n    const viewportEndX = viewportStartX + viewport.width;\n    let boxStartX = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n    let boxEndX = 0;\n    if (horizontalRevealRequest.type === 'range') {\n      const visibleRanges = this._visibleRangesForLineRange(horizontalRevealRequest.lineNumber, horizontalRevealRequest.startColumn, horizontalRevealRequest.endColumn);\n      if (!visibleRanges) {\n        return null;\n      }\n      for (const visibleRange of visibleRanges.ranges) {\n        boxStartX = Math.min(boxStartX, visibleRange.left);\n        boxEndX = Math.max(boxEndX, visibleRange.left + visibleRange.width);\n      }\n    } else {\n      for (const selection of horizontalRevealRequest.selections) {\n        if (selection.startLineNumber !== selection.endLineNumber) {\n          return null;\n        }\n        const visibleRanges = this._visibleRangesForLineRange(selection.startLineNumber, selection.startColumn, selection.endColumn);\n        if (!visibleRanges) {\n          return null;\n        }\n        for (const visibleRange of visibleRanges.ranges) {\n          boxStartX = Math.min(boxStartX, visibleRange.left);\n          boxEndX = Math.max(boxEndX, visibleRange.left + visibleRange.width);\n        }\n      }\n    }\n    boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\n    boxEndX += this._revealHorizontalRightPadding;\n    if (horizontalRevealRequest.type === 'selections' && boxEndX - boxStartX > viewport.width) {\n      return null;\n    }\n    const newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\n    return {\n      scrollLeft: newScrollLeft,\n      maxHorizontalOffset: boxEndX\n    };\n  }\n  _computeMinimumScrolling(viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\n    viewportStart = viewportStart | 0;\n    viewportEnd = viewportEnd | 0;\n    boxStart = boxStart | 0;\n    boxEnd = boxEnd | 0;\n    revealAtStart = !!revealAtStart;\n    revealAtEnd = !!revealAtEnd;\n    const viewportLength = viewportEnd - viewportStart;\n    const boxLength = boxEnd - boxStart;\n    if (boxLength < viewportLength) {\n      // The box would fit in the viewport\n      if (revealAtStart) {\n        return boxStart;\n      }\n      if (revealAtEnd) {\n        return Math.max(0, boxEnd - viewportLength);\n      }\n      if (boxStart < viewportStart) {\n        // The box is above the viewport\n        return boxStart;\n      } else if (boxEnd > viewportEnd) {\n        // The box is below the viewport\n        return Math.max(0, boxEnd - viewportLength);\n      }\n    } else {\n      // The box would not fit in the viewport\n      // Reveal the beginning of the box\n      return boxStart;\n    }\n    return viewportStart;\n  }\n}\n/**\r\n * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\r\n */\nViewLines.HORIZONTAL_EXTRA_PX = 30;","map":{"version":3,"names":["platform","RunOnceScheduler","Configuration","VisibleLinesCollection","PartFingerprints","ViewPart","DomReadingContext","ViewLine","ViewLineOptions","Position","Range","LineVisibleRanges","HorizontalPosition","MOUSE_CURSOR_TEXT_CSS_CLASS_NAME","LastRenderedData","constructor","_currentVisibleRange","getCurrentVisibleRange","setCurrentVisibleRange","currentVisibleRange","HorizontalRevealRangeRequest","lineNumber","startColumn","endColumn","startScrollTop","stopScrollTop","scrollType","type","minLineNumber","maxLineNumber","HorizontalRevealSelectionsRequest","selections","startLineNumber","endLineNumber","i","len","length","selection","Math","min","max","ViewLines","context","linesContent","_linesContent","_textRangeRestingSpot","document","createElement","_visibleLines","domNode","conf","_context","configuration","options","fontInfo","get","wrappingInfo","_lineHeight","_typicalHalfwidthCharacterWidth","typicalHalfwidthCharacterWidth","_isViewportWrapping","isViewportWrapping","_revealHorizontalRightPadding","_cursorSurroundingLines","_cursorSurroundingLinesStyle","_canUseLayerHinting","_viewLineOptions","theme","write","setClassName","concat","applyFontInfo","_maxLineWidth","_asyncUpdateLineWidths","_updateLineWidthsSlow","_asyncCheckMonospaceFontAssumptions","_checkMonospaceFontAssumptions","_lastRenderedData","_horizontalRevealRequest","dispose","getDomNode","createVisibleLine","onConfigurationChanged","e","hasChanged","_onOptionsMaybeChanged","newViewLineOptions","equals","getStartLineNumber","getEndLineNumber","line","getVisibleLine","onOptionsChanged","onCursorStateChanged","rendStartLineNumber","rendEndLineNumber","r","onSelectionChanged","onDecorationsChanged","onFlushed","shouldRender","onLinesChanged","onLinesDeleted","onLinesInserted","onRevealRangeRequest","desiredScrollTop","_computeScrollTopToRevealRange","viewLayout","getFutureViewport","source","range","verticalType","newScrollPosition","validateScrollPosition","scrollTop","revealHorizontal","scrollLeft","getCurrentScrollTop","scrollTopDelta","abs","model","setScrollPosition","onScrollChanged","scrollLeftChanged","scrollTopChanged","setWidth","scrollWidth","onTokensChanged","onZonesChanged","setMaxLineWidth","onThemeChanged","getPositionFromDOMInfo","spanNode","offset","viewLineDomNode","_getViewLineDomNode","_getLineNumberFor","getLineCount","getLineMaxColumn","column","getColumnOfNodeOffset","minColumn","getLineMinColumn","node","nodeType","className","CLASS_NAME","parentElement","getLineWidth","getWidth","linesVisibleRangesForRange","_range","includeNewLines","originalEndLineNumber","intersectRanges","visibleRanges","visibleRangesLen","domReadingContext","nextLineModelLineNumber","coordinatesConverter","convertViewPositionToModelPosition","visibleRangesForLine","getVisibleRangesForRange","currentLineModelLineNumber","ranges","width","outsideRenderedLine","_visibleRangesForLineRange","visibleRangeForPosition","position","left","updateLineWidths","_updateLineWidths","_updateLineWidthsFast","fast","localMaxLineWidth","allWidthsComputed","visibleLine","getWidthIsFast","_ensureMaxLineWidth","longestLineNumber","longestWidth","needsMonospaceFontCheck","lineWidth","monospaceAssumptionsAreValid","onMonospaceAssumptionsInvalidated","prepareRender","Error","render","renderText","viewportData","renderLines","visibleRange","getScrollWidth","setHeight","getScrollHeight","horizontalRevealRequest","onDidRender","newScrollLeft","_computeScrollLeftToReveal","maxHorizontalOffset","schedule","isLinux","isScheduled","setLayerHinting","setContain","adjustedScrollTop","bigNumbersDelta","setTop","setLeft","getCurrentScrollLeft","iLineWidth","ceil","viewport","viewportStartY","top","viewportHeight","height","viewportEndY","boxIsSingleRange","boxStartY","boxEndY","getVerticalOffsetForLineNumber","shouldIgnoreScrollOff","newScrollTop","desiredGapAbove","minScrollTop","boxMiddleY","_computeMinimumScrolling","getCurrentViewport","viewportStartX","viewportEndX","boxStartX","boxEndX","HORIZONTAL_EXTRA_PX","viewportStart","viewportEnd","boxStart","boxEnd","revealAtStart","revealAtEnd","viewportLength","boxLength"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLines.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport './viewLines.css';\r\nimport * as platform from '../../../../base/common/platform.js';\r\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\r\nimport { Configuration } from '../../config/configuration.js';\r\nimport { VisibleLinesCollection } from '../../view/viewLayer.js';\r\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\r\nimport { DomReadingContext, ViewLine, ViewLineOptions } from './viewLine.js';\r\nimport { Position } from '../../../common/core/position.js';\r\nimport { Range } from '../../../common/core/range.js';\r\nimport { LineVisibleRanges, HorizontalPosition } from '../../../common/view/renderingContext.js';\r\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../../base/browser/ui/mouseCursor/mouseCursor.js';\r\nclass LastRenderedData {\r\n    constructor() {\r\n        this._currentVisibleRange = new Range(1, 1, 1, 1);\r\n    }\r\n    getCurrentVisibleRange() {\r\n        return this._currentVisibleRange;\r\n    }\r\n    setCurrentVisibleRange(currentVisibleRange) {\r\n        this._currentVisibleRange = currentVisibleRange;\r\n    }\r\n}\r\nclass HorizontalRevealRangeRequest {\r\n    constructor(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\r\n        this.lineNumber = lineNumber;\r\n        this.startColumn = startColumn;\r\n        this.endColumn = endColumn;\r\n        this.startScrollTop = startScrollTop;\r\n        this.stopScrollTop = stopScrollTop;\r\n        this.scrollType = scrollType;\r\n        this.type = 'range';\r\n        this.minLineNumber = lineNumber;\r\n        this.maxLineNumber = lineNumber;\r\n    }\r\n}\r\nclass HorizontalRevealSelectionsRequest {\r\n    constructor(selections, startScrollTop, stopScrollTop, scrollType) {\r\n        this.selections = selections;\r\n        this.startScrollTop = startScrollTop;\r\n        this.stopScrollTop = stopScrollTop;\r\n        this.scrollType = scrollType;\r\n        this.type = 'selections';\r\n        let minLineNumber = selections[0].startLineNumber;\r\n        let maxLineNumber = selections[0].endLineNumber;\r\n        for (let i = 1, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\r\n            maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\r\n        }\r\n        this.minLineNumber = minLineNumber;\r\n        this.maxLineNumber = maxLineNumber;\r\n    }\r\n}\r\nexport class ViewLines extends ViewPart {\r\n    constructor(context, linesContent) {\r\n        super(context);\r\n        this._linesContent = linesContent;\r\n        this._textRangeRestingSpot = document.createElement('div');\r\n        this._visibleLines = new VisibleLinesCollection(this);\r\n        this.domNode = this._visibleLines.domNode;\r\n        const conf = this._context.configuration;\r\n        const options = this._context.configuration.options;\r\n        const fontInfo = options.get(38 /* fontInfo */);\r\n        const wrappingInfo = options.get(125 /* wrappingInfo */);\r\n        this._lineHeight = options.get(53 /* lineHeight */);\r\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\r\n        this._isViewportWrapping = wrappingInfo.isViewportWrapping;\r\n        this._revealHorizontalRightPadding = options.get(84 /* revealHorizontalRightPadding */);\r\n        this._cursorSurroundingLines = options.get(22 /* cursorSurroundingLines */);\r\n        this._cursorSurroundingLinesStyle = options.get(23 /* cursorSurroundingLinesStyle */);\r\n        this._canUseLayerHinting = !options.get(25 /* disableLayerHinting */);\r\n        this._viewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\r\n        PartFingerprints.write(this.domNode, 7 /* ViewLines */);\r\n        this.domNode.setClassName(`view-lines ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\r\n        Configuration.applyFontInfo(this.domNode, fontInfo);\r\n        // --- width & height\r\n        this._maxLineWidth = 0;\r\n        this._asyncUpdateLineWidths = new RunOnceScheduler(() => {\r\n            this._updateLineWidthsSlow();\r\n        }, 200);\r\n        this._asyncCheckMonospaceFontAssumptions = new RunOnceScheduler(() => {\r\n            this._checkMonospaceFontAssumptions();\r\n        }, 2000);\r\n        this._lastRenderedData = new LastRenderedData();\r\n        this._horizontalRevealRequest = null;\r\n    }\r\n    dispose() {\r\n        this._asyncUpdateLineWidths.dispose();\r\n        this._asyncCheckMonospaceFontAssumptions.dispose();\r\n        super.dispose();\r\n    }\r\n    getDomNode() {\r\n        return this.domNode;\r\n    }\r\n    // ---- begin IVisibleLinesHost\r\n    createVisibleLine() {\r\n        return new ViewLine(this._viewLineOptions);\r\n    }\r\n    // ---- end IVisibleLinesHost\r\n    // ---- begin view event handlers\r\n    onConfigurationChanged(e) {\r\n        this._visibleLines.onConfigurationChanged(e);\r\n        if (e.hasChanged(125 /* wrappingInfo */)) {\r\n            this._maxLineWidth = 0;\r\n        }\r\n        const options = this._context.configuration.options;\r\n        const fontInfo = options.get(38 /* fontInfo */);\r\n        const wrappingInfo = options.get(125 /* wrappingInfo */);\r\n        this._lineHeight = options.get(53 /* lineHeight */);\r\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\r\n        this._isViewportWrapping = wrappingInfo.isViewportWrapping;\r\n        this._revealHorizontalRightPadding = options.get(84 /* revealHorizontalRightPadding */);\r\n        this._cursorSurroundingLines = options.get(22 /* cursorSurroundingLines */);\r\n        this._cursorSurroundingLinesStyle = options.get(23 /* cursorSurroundingLinesStyle */);\r\n        this._canUseLayerHinting = !options.get(25 /* disableLayerHinting */);\r\n        Configuration.applyFontInfo(this.domNode, fontInfo);\r\n        this._onOptionsMaybeChanged();\r\n        if (e.hasChanged(124 /* layoutInfo */)) {\r\n            this._maxLineWidth = 0;\r\n        }\r\n        return true;\r\n    }\r\n    _onOptionsMaybeChanged() {\r\n        const conf = this._context.configuration;\r\n        const newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\r\n        if (!this._viewLineOptions.equals(newViewLineOptions)) {\r\n            this._viewLineOptions = newViewLineOptions;\r\n            const startLineNumber = this._visibleLines.getStartLineNumber();\r\n            const endLineNumber = this._visibleLines.getEndLineNumber();\r\n            for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n                const line = this._visibleLines.getVisibleLine(lineNumber);\r\n                line.onOptionsChanged(this._viewLineOptions);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    onCursorStateChanged(e) {\r\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        let r = false;\r\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n            r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\r\n        }\r\n        return r;\r\n    }\r\n    onDecorationsChanged(e) {\r\n        if (true /*e.inlineDecorationsChanged*/) {\r\n            const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n            const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n                this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    onFlushed(e) {\r\n        const shouldRender = this._visibleLines.onFlushed(e);\r\n        this._maxLineWidth = 0;\r\n        return shouldRender;\r\n    }\r\n    onLinesChanged(e) {\r\n        return this._visibleLines.onLinesChanged(e);\r\n    }\r\n    onLinesDeleted(e) {\r\n        return this._visibleLines.onLinesDeleted(e);\r\n    }\r\n    onLinesInserted(e) {\r\n        return this._visibleLines.onLinesInserted(e);\r\n    }\r\n    onRevealRangeRequest(e) {\r\n        // Using the future viewport here in order to handle multiple\r\n        // incoming reveal range requests that might all desire to be animated\r\n        const desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.range, e.selections, e.verticalType);\r\n        if (desiredScrollTop === -1) {\r\n            // marker to abort the reveal range request\r\n            return false;\r\n        }\r\n        // validate the new desired scroll top\r\n        let newScrollPosition = this._context.viewLayout.validateScrollPosition({ scrollTop: desiredScrollTop });\r\n        if (e.revealHorizontal) {\r\n            if (e.range && e.range.startLineNumber !== e.range.endLineNumber) {\r\n                // Two or more lines? => scroll to base (That's how you see most of the two lines)\r\n                newScrollPosition = {\r\n                    scrollTop: newScrollPosition.scrollTop,\r\n                    scrollLeft: 0\r\n                };\r\n            }\r\n            else if (e.range) {\r\n                // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\r\n                this._horizontalRevealRequest = new HorizontalRevealRangeRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\r\n            }\r\n            else if (e.selections && e.selections.length > 0) {\r\n                this._horizontalRevealRequest = new HorizontalRevealSelectionsRequest(e.selections, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\r\n            }\r\n        }\r\n        else {\r\n            this._horizontalRevealRequest = null;\r\n        }\r\n        const scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\r\n        const scrollType = (scrollTopDelta <= this._lineHeight ? 1 /* Immediate */ : e.scrollType);\r\n        this._context.model.setScrollPosition(newScrollPosition, scrollType);\r\n        return true;\r\n    }\r\n    onScrollChanged(e) {\r\n        if (this._horizontalRevealRequest && e.scrollLeftChanged) {\r\n            // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\r\n            this._horizontalRevealRequest = null;\r\n        }\r\n        if (this._horizontalRevealRequest && e.scrollTopChanged) {\r\n            const min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\r\n            const max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\r\n            if (e.scrollTop < min || e.scrollTop > max) {\r\n                // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\r\n                this._horizontalRevealRequest = null;\r\n            }\r\n        }\r\n        this.domNode.setWidth(e.scrollWidth);\r\n        return this._visibleLines.onScrollChanged(e) || true;\r\n    }\r\n    onTokensChanged(e) {\r\n        return this._visibleLines.onTokensChanged(e);\r\n    }\r\n    onZonesChanged(e) {\r\n        this._context.model.setMaxLineWidth(this._maxLineWidth);\r\n        return this._visibleLines.onZonesChanged(e);\r\n    }\r\n    onThemeChanged(e) {\r\n        return this._onOptionsMaybeChanged();\r\n    }\r\n    // ---- end view event handlers\r\n    // ----------- HELPERS FOR OTHERS\r\n    getPositionFromDOMInfo(spanNode, offset) {\r\n        const viewLineDomNode = this._getViewLineDomNode(spanNode);\r\n        if (viewLineDomNode === null) {\r\n            // Couldn't find view line node\r\n            return null;\r\n        }\r\n        const lineNumber = this._getLineNumberFor(viewLineDomNode);\r\n        if (lineNumber === -1) {\r\n            // Couldn't find view line node\r\n            return null;\r\n        }\r\n        if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {\r\n            // lineNumber is outside range\r\n            return null;\r\n        }\r\n        if (this._context.model.getLineMaxColumn(lineNumber) === 1) {\r\n            // Line is empty\r\n            return new Position(lineNumber, 1);\r\n        }\r\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\r\n            // Couldn't find line\r\n            return null;\r\n        }\r\n        let column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);\r\n        const minColumn = this._context.model.getLineMinColumn(lineNumber);\r\n        if (column < minColumn) {\r\n            column = minColumn;\r\n        }\r\n        return new Position(lineNumber, column);\r\n    }\r\n    _getViewLineDomNode(node) {\r\n        while (node && node.nodeType === 1) {\r\n            if (node.className === ViewLine.CLASS_NAME) {\r\n                return node;\r\n            }\r\n            node = node.parentElement;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * @returns the line number of this view line dom node.\r\n     */\r\n    _getLineNumberFor(domNode) {\r\n        const startLineNumber = this._visibleLines.getStartLineNumber();\r\n        const endLineNumber = this._visibleLines.getEndLineNumber();\r\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            const line = this._visibleLines.getVisibleLine(lineNumber);\r\n            if (domNode === line.getDomNode()) {\r\n                return lineNumber;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    getLineWidth(lineNumber) {\r\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\r\n            // Couldn't find line\r\n            return -1;\r\n        }\r\n        return this._visibleLines.getVisibleLine(lineNumber).getWidth();\r\n    }\r\n    linesVisibleRangesForRange(_range, includeNewLines) {\r\n        if (this.shouldRender()) {\r\n            // Cannot read from the DOM because it is dirty\r\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\r\n            return null;\r\n        }\r\n        const originalEndLineNumber = _range.endLineNumber;\r\n        const range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\r\n        if (!range) {\r\n            return null;\r\n        }\r\n        let visibleRanges = [], visibleRangesLen = 0;\r\n        const domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\r\n        let nextLineModelLineNumber = 0;\r\n        if (includeNewLines) {\r\n            nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\r\n        }\r\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\r\n            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\r\n                continue;\r\n            }\r\n            const startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\r\n            const endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\r\n            const visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\r\n            if (!visibleRangesForLine) {\r\n                continue;\r\n            }\r\n            if (includeNewLines && lineNumber < originalEndLineNumber) {\r\n                const currentLineModelLineNumber = nextLineModelLineNumber;\r\n                nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\r\n                if (currentLineModelLineNumber !== nextLineModelLineNumber) {\r\n                    visibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth;\r\n                }\r\n            }\r\n            visibleRanges[visibleRangesLen++] = new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, visibleRangesForLine.ranges);\r\n        }\r\n        if (visibleRangesLen === 0) {\r\n            return null;\r\n        }\r\n        return visibleRanges;\r\n    }\r\n    _visibleRangesForLineRange(lineNumber, startColumn, endColumn) {\r\n        if (this.shouldRender()) {\r\n            // Cannot read from the DOM because it is dirty\r\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\r\n            return null;\r\n        }\r\n        if (lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {\r\n            return null;\r\n        }\r\n        return this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot));\r\n    }\r\n    visibleRangeForPosition(position) {\r\n        const visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\r\n        if (!visibleRanges) {\r\n            return null;\r\n        }\r\n        return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\r\n    }\r\n    // --- implementation\r\n    updateLineWidths() {\r\n        this._updateLineWidths(false);\r\n    }\r\n    /**\r\n     * Updates the max line width if it is fast to compute.\r\n     * Returns true if all lines were taken into account.\r\n     * Returns false if some lines need to be reevaluated (in a slow fashion).\r\n     */\r\n    _updateLineWidthsFast() {\r\n        return this._updateLineWidths(true);\r\n    }\r\n    _updateLineWidthsSlow() {\r\n        this._updateLineWidths(false);\r\n    }\r\n    _updateLineWidths(fast) {\r\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        let localMaxLineWidth = 1;\r\n        let allWidthsComputed = true;\r\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n            const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\r\n            if (fast && !visibleLine.getWidthIsFast()) {\r\n                // Cannot compute width in a fast way for this line\r\n                allWidthsComputed = false;\r\n                continue;\r\n            }\r\n            localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());\r\n        }\r\n        if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {\r\n            // we know the max line width for all the lines\r\n            this._maxLineWidth = 0;\r\n        }\r\n        this._ensureMaxLineWidth(localMaxLineWidth);\r\n        return allWidthsComputed;\r\n    }\r\n    _checkMonospaceFontAssumptions() {\r\n        // Problems with monospace assumptions are more apparent for longer lines,\r\n        // as small rounding errors start to sum up, so we will select the longest\r\n        // line for a closer inspection\r\n        let longestLineNumber = -1;\r\n        let longestWidth = -1;\r\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n            const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\r\n            if (visibleLine.needsMonospaceFontCheck()) {\r\n                const lineWidth = visibleLine.getWidth();\r\n                if (lineWidth > longestWidth) {\r\n                    longestWidth = lineWidth;\r\n                    longestLineNumber = lineNumber;\r\n                }\r\n            }\r\n        }\r\n        if (longestLineNumber === -1) {\r\n            return;\r\n        }\r\n        if (!this._visibleLines.getVisibleLine(longestLineNumber).monospaceAssumptionsAreValid()) {\r\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n                const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\r\n                visibleLine.onMonospaceAssumptionsInvalidated();\r\n            }\r\n        }\r\n    }\r\n    prepareRender() {\r\n        throw new Error('Not supported');\r\n    }\r\n    render() {\r\n        throw new Error('Not supported');\r\n    }\r\n    renderText(viewportData) {\r\n        // (1) render lines - ensures lines are in the DOM\r\n        this._visibleLines.renderLines(viewportData);\r\n        this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\r\n        this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\r\n        this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));\r\n        // (2) compute horizontal scroll position:\r\n        //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\r\n        //  - it might change `scrollWidth` and `scrollLeft`\r\n        if (this._horizontalRevealRequest) {\r\n            const horizontalRevealRequest = this._horizontalRevealRequest;\r\n            // Check that we have the line that contains the horizontal range in the viewport\r\n            if (viewportData.startLineNumber <= horizontalRevealRequest.minLineNumber && horizontalRevealRequest.maxLineNumber <= viewportData.endLineNumber) {\r\n                this._horizontalRevealRequest = null;\r\n                // allow `visibleRangesForRange2` to work\r\n                this.onDidRender();\r\n                // compute new scroll position\r\n                const newScrollLeft = this._computeScrollLeftToReveal(horizontalRevealRequest);\r\n                if (newScrollLeft) {\r\n                    if (!this._isViewportWrapping) {\r\n                        // ensure `scrollWidth` is large enough\r\n                        this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\r\n                    }\r\n                    // set `scrollLeft`\r\n                    this._context.model.setScrollPosition({\r\n                        scrollLeft: newScrollLeft.scrollLeft\r\n                    }, horizontalRevealRequest.scrollType);\r\n                }\r\n            }\r\n        }\r\n        // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\r\n        if (!this._updateLineWidthsFast()) {\r\n            // Computing the width of some lines would be slow => delay it\r\n            this._asyncUpdateLineWidths.schedule();\r\n        }\r\n        if (platform.isLinux && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {\r\n            const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n            const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n                const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\r\n                if (visibleLine.needsMonospaceFontCheck()) {\r\n                    this._asyncCheckMonospaceFontAssumptions.schedule();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // (3) handle scrolling\r\n        this._linesContent.setLayerHinting(this._canUseLayerHinting);\r\n        this._linesContent.setContain('strict');\r\n        const adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\r\n        this._linesContent.setTop(-adjustedScrollTop);\r\n        this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\r\n    }\r\n    // --- width\r\n    _ensureMaxLineWidth(lineWidth) {\r\n        const iLineWidth = Math.ceil(lineWidth);\r\n        if (this._maxLineWidth < iLineWidth) {\r\n            this._maxLineWidth = iLineWidth;\r\n            this._context.model.setMaxLineWidth(this._maxLineWidth);\r\n        }\r\n    }\r\n    _computeScrollTopToRevealRange(viewport, source, range, selections, verticalType) {\r\n        const viewportStartY = viewport.top;\r\n        const viewportHeight = viewport.height;\r\n        const viewportEndY = viewportStartY + viewportHeight;\r\n        let boxIsSingleRange;\r\n        let boxStartY;\r\n        let boxEndY;\r\n        // Have a box that includes one extra line height (for the horizontal scrollbar)\r\n        if (selections && selections.length > 0) {\r\n            let minLineNumber = selections[0].startLineNumber;\r\n            let maxLineNumber = selections[0].endLineNumber;\r\n            for (let i = 1, len = selections.length; i < len; i++) {\r\n                const selection = selections[i];\r\n                minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\r\n                maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\r\n            }\r\n            boxIsSingleRange = false;\r\n            boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(minLineNumber);\r\n            boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(maxLineNumber) + this._lineHeight;\r\n        }\r\n        else if (range) {\r\n            boxIsSingleRange = true;\r\n            boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\r\n            boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n        const shouldIgnoreScrollOff = source === 'mouse' && this._cursorSurroundingLinesStyle === 'default';\r\n        if (!shouldIgnoreScrollOff) {\r\n            const context = Math.min((viewportHeight / this._lineHeight) / 2, this._cursorSurroundingLines);\r\n            boxStartY -= context * this._lineHeight;\r\n            boxEndY += Math.max(0, (context - 1)) * this._lineHeight;\r\n        }\r\n        if (verticalType === 0 /* Simple */ || verticalType === 4 /* Bottom */) {\r\n            // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\r\n            boxEndY += this._lineHeight;\r\n        }\r\n        let newScrollTop;\r\n        if (boxEndY - boxStartY > viewportHeight) {\r\n            // the box is larger than the viewport ... scroll to its top\r\n            if (!boxIsSingleRange) {\r\n                // do not reveal multiple cursors if there are more than fit the viewport\r\n                return -1;\r\n            }\r\n            newScrollTop = boxStartY;\r\n        }\r\n        else if (verticalType === 5 /* NearTop */ || verticalType === 6 /* NearTopIfOutsideViewport */) {\r\n            if (verticalType === 6 /* NearTopIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\r\n                // Box is already in the viewport... do nothing\r\n                newScrollTop = viewportStartY;\r\n            }\r\n            else {\r\n                // We want a gap that is 20% of the viewport, but with a minimum of 5 lines\r\n                const desiredGapAbove = Math.max(5 * this._lineHeight, viewportHeight * 0.2);\r\n                // Try to scroll just above the box with the desired gap\r\n                const desiredScrollTop = boxStartY - desiredGapAbove;\r\n                // But ensure that the box is not pushed out of viewport\r\n                const minScrollTop = boxEndY - viewportHeight;\r\n                newScrollTop = Math.max(minScrollTop, desiredScrollTop);\r\n            }\r\n        }\r\n        else if (verticalType === 1 /* Center */ || verticalType === 2 /* CenterIfOutsideViewport */) {\r\n            if (verticalType === 2 /* CenterIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\r\n                // Box is already in the viewport... do nothing\r\n                newScrollTop = viewportStartY;\r\n            }\r\n            else {\r\n                // Box is outside the viewport... center it\r\n                const boxMiddleY = (boxStartY + boxEndY) / 2;\r\n                newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\r\n            }\r\n        }\r\n        else {\r\n            newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3 /* Top */, verticalType === 4 /* Bottom */);\r\n        }\r\n        return newScrollTop;\r\n    }\r\n    _computeScrollLeftToReveal(horizontalRevealRequest) {\r\n        const viewport = this._context.viewLayout.getCurrentViewport();\r\n        const viewportStartX = viewport.left;\r\n        const viewportEndX = viewportStartX + viewport.width;\r\n        let boxStartX = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        let boxEndX = 0;\r\n        if (horizontalRevealRequest.type === 'range') {\r\n            const visibleRanges = this._visibleRangesForLineRange(horizontalRevealRequest.lineNumber, horizontalRevealRequest.startColumn, horizontalRevealRequest.endColumn);\r\n            if (!visibleRanges) {\r\n                return null;\r\n            }\r\n            for (const visibleRange of visibleRanges.ranges) {\r\n                boxStartX = Math.min(boxStartX, visibleRange.left);\r\n                boxEndX = Math.max(boxEndX, visibleRange.left + visibleRange.width);\r\n            }\r\n        }\r\n        else {\r\n            for (const selection of horizontalRevealRequest.selections) {\r\n                if (selection.startLineNumber !== selection.endLineNumber) {\r\n                    return null;\r\n                }\r\n                const visibleRanges = this._visibleRangesForLineRange(selection.startLineNumber, selection.startColumn, selection.endColumn);\r\n                if (!visibleRanges) {\r\n                    return null;\r\n                }\r\n                for (const visibleRange of visibleRanges.ranges) {\r\n                    boxStartX = Math.min(boxStartX, visibleRange.left);\r\n                    boxEndX = Math.max(boxEndX, visibleRange.left + visibleRange.width);\r\n                }\r\n            }\r\n        }\r\n        boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\r\n        boxEndX += this._revealHorizontalRightPadding;\r\n        if (horizontalRevealRequest.type === 'selections' && boxEndX - boxStartX > viewport.width) {\r\n            return null;\r\n        }\r\n        const newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\r\n        return {\r\n            scrollLeft: newScrollLeft,\r\n            maxHorizontalOffset: boxEndX\r\n        };\r\n    }\r\n    _computeMinimumScrolling(viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\r\n        viewportStart = viewportStart | 0;\r\n        viewportEnd = viewportEnd | 0;\r\n        boxStart = boxStart | 0;\r\n        boxEnd = boxEnd | 0;\r\n        revealAtStart = !!revealAtStart;\r\n        revealAtEnd = !!revealAtEnd;\r\n        const viewportLength = viewportEnd - viewportStart;\r\n        const boxLength = boxEnd - boxStart;\r\n        if (boxLength < viewportLength) {\r\n            // The box would fit in the viewport\r\n            if (revealAtStart) {\r\n                return boxStart;\r\n            }\r\n            if (revealAtEnd) {\r\n                return Math.max(0, boxEnd - viewportLength);\r\n            }\r\n            if (boxStart < viewportStart) {\r\n                // The box is above the viewport\r\n                return boxStart;\r\n            }\r\n            else if (boxEnd > viewportEnd) {\r\n                // The box is below the viewport\r\n                return Math.max(0, boxEnd - viewportLength);\r\n            }\r\n        }\r\n        else {\r\n            // The box would not fit in the viewport\r\n            // Reveal the beginning of the box\r\n            return boxStart;\r\n        }\r\n        return viewportStart;\r\n    }\r\n}\r\n/**\r\n * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\r\n */\r\nViewLines.HORIZONTAL_EXTRA_PX = 30;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}