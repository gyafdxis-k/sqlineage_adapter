{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Position } from '../../common/core/position.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { BrowserFeatures } from '../../../base/browser/canIUse.js';\nexport const CopyOptions = {\n  forceCopyWithSyntaxHighlighting: false\n};\n/**\r\n * Every time we write to the clipboard, we record a bit of extra metadata here.\r\n * Every time we read from the cipboard, if the text matches our last written text,\r\n * we can fetch the previous metadata.\r\n */\nexport class InMemoryClipboardMetadataManager {\n  constructor() {\n    this._lastState = null;\n  }\n  set(lastCopiedValue, data) {\n    this._lastState = {\n      lastCopiedValue,\n      data\n    };\n  }\n  get(pastedText) {\n    if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n      // match!\n      return this._lastState.data;\n    }\n    this._lastState = null;\n    return null;\n  }\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\n/**\r\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\r\n *  - onCut\r\n *  - onPaste\r\n *  - onType\r\n *\r\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\r\n */\nexport class TextAreaInput extends Disposable {\n  constructor(host, textArea) {\n    super();\n    this.textArea = textArea;\n    this._onFocus = this._register(new Emitter());\n    this.onFocus = this._onFocus.event;\n    this._onBlur = this._register(new Emitter());\n    this.onBlur = this._onBlur.event;\n    this._onKeyDown = this._register(new Emitter());\n    this.onKeyDown = this._onKeyDown.event;\n    this._onKeyUp = this._register(new Emitter());\n    this.onKeyUp = this._onKeyUp.event;\n    this._onCut = this._register(new Emitter());\n    this.onCut = this._onCut.event;\n    this._onPaste = this._register(new Emitter());\n    this.onPaste = this._onPaste.event;\n    this._onType = this._register(new Emitter());\n    this.onType = this._onType.event;\n    this._onCompositionStart = this._register(new Emitter());\n    this.onCompositionStart = this._onCompositionStart.event;\n    this._onCompositionUpdate = this._register(new Emitter());\n    this.onCompositionUpdate = this._onCompositionUpdate.event;\n    this._onCompositionEnd = this._register(new Emitter());\n    this.onCompositionEnd = this._onCompositionEnd.event;\n    this._onSelectionChangeRequest = this._register(new Emitter());\n    this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n    this._host = host;\n    this._textArea = this._register(new TextAreaWrapper(textArea));\n    this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n    this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\n    this._textAreaState = TextAreaState.EMPTY;\n    this._selectionChangeListener = null;\n    this.writeScreenReaderContent('ctor');\n    this._hasFocus = false;\n    this._isDoingComposition = false;\n    this._nextCommand = 0 /* Type */;\n    let lastKeyDown = null;\n    this._register(dom.addStandardDisposableListener(textArea.domNode, 'keydown', e => {\n      if (e.keyCode === 109 /* KEY_IN_COMPOSITION */ || this._isDoingComposition && e.keyCode === 1 /* Backspace */) {\n        // Stop propagation for keyDown events if the IME is processing key input\n        e.stopPropagation();\n      }\n      if (e.equals(9 /* Escape */)) {\n        // Prevent default always for `Esc`, otherwise it will generate a keypress\n        // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n        e.preventDefault();\n      }\n      lastKeyDown = e;\n      this._onKeyDown.fire(e);\n    }));\n    this._register(dom.addStandardDisposableListener(textArea.domNode, 'keyup', e => {\n      this._onKeyUp.fire(e);\n    }));\n    this._register(dom.addDisposableListener(textArea.domNode, 'compositionstart', e => {\n      if (_debugComposition) {\n        console.log(\"[compositionstart]\", e);\n      }\n      if (this._isDoingComposition) {\n        return;\n      }\n      this._isDoingComposition = true;\n      let moveOneCharacterLeft = false;\n      if (platform.isMacintosh && lastKeyDown && lastKeyDown.equals(109 /* KEY_IN_COMPOSITION */) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data) {\n        // Handling long press case on macOS + arrow key => pretend the character was selected\n        if (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft') {\n          if (_debugComposition) {\n            console.log(\"[compositionstart] Handling long press case on macOS + arrow key\", e);\n          }\n          moveOneCharacterLeft = true;\n        }\n      }\n      if (moveOneCharacterLeft) {\n        this._textAreaState = new TextAreaState(this._textAreaState.value, this._textAreaState.selectionStart - 1, this._textAreaState.selectionEnd, this._textAreaState.selectionStartPosition ? new Position(this._textAreaState.selectionStartPosition.lineNumber, this._textAreaState.selectionStartPosition.column - 1) : null, this._textAreaState.selectionEndPosition);\n      } else {\n        this._setAndWriteTextAreaState('compositionstart', TextAreaState.EMPTY);\n      }\n      this._onCompositionStart.fire({\n        moveOneCharacterLeft\n      });\n    }));\n    /**\r\n     * Deduce the typed input from a text area's value and the last observed state.\r\n     */\n    const deduceInputFromTextAreaValue = couldBeEmojiInput => {\n      const oldState = this._textAreaState;\n      const newState = TextAreaState.readFromTextArea(this._textArea);\n      return [newState, TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput)];\n    };\n    /**\r\n     * Deduce the composition input from a string.\r\n     */\n    const deduceComposition = text => {\n      const oldState = this._textAreaState;\n      const newState = TextAreaState.selectedText(text);\n      const typeInput = {\n        text: newState.value,\n        replaceCharCnt: oldState.selectionEnd - oldState.selectionStart\n      };\n      return [newState, typeInput];\n    };\n    this._register(dom.addDisposableListener(textArea.domNode, 'compositionupdate', e => {\n      if (_debugComposition) {\n        console.log(\"[compositionupdate]\", e);\n      }\n      const [newState, typeInput] = deduceComposition(e.data || '');\n      this._textAreaState = newState;\n      this._onType.fire(typeInput);\n      this._onCompositionUpdate.fire(e);\n    }));\n    this._register(dom.addDisposableListener(textArea.domNode, 'compositionend', e => {\n      if (_debugComposition) {\n        console.log(\"[compositionend]\", e);\n      }\n      // https://github.com/microsoft/monaco-editor/issues/1663\n      // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n      if (!this._isDoingComposition) {\n        return;\n      }\n      const [newState, typeInput] = deduceComposition(e.data || '');\n      this._textAreaState = newState;\n      this._onType.fire(typeInput);\n      // isChrome: the textarea is not updated correctly when composition ends\n      // isFirefox: the textarea is not updated correctly after inserting emojis\n      // => we cannot assume the text at the end consists only of the composited text\n      if (browser.isChrome || browser.isFirefox) {\n        this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n      }\n      if (!this._isDoingComposition) {\n        return;\n      }\n      this._isDoingComposition = false;\n      this._onCompositionEnd.fire();\n    }));\n    this._register(dom.addDisposableListener(textArea.domNode, 'input', () => {\n      // Pretend here we touched the text area, as the `input` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received input event');\n      if (this._isDoingComposition) {\n        return;\n      }\n      const [newState, typeInput] = deduceInputFromTextAreaValue( /*couldBeEmojiInput*/platform.isMacintosh);\n      if (typeInput.replaceCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n        // Ignore invalid input but keep it around for next time\n        return;\n      }\n      this._textAreaState = newState;\n      if (this._nextCommand === 0 /* Type */) {\n        if (typeInput.text !== '') {\n          this._onType.fire(typeInput);\n        }\n      } else {\n        if (typeInput.text !== '' || typeInput.replaceCharCnt !== 0) {\n          this._firePaste(typeInput.text, null);\n        }\n        this._nextCommand = 0 /* Type */;\n      }\n    }));\n    // --- Clipboard operations\n    this._register(dom.addDisposableListener(textArea.domNode, 'cut', e => {\n      // Pretend here we touched the text area, as the `cut` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received cut event');\n      this._ensureClipboardGetsEditorSelection(e);\n      this._asyncTriggerCut.schedule();\n    }));\n    this._register(dom.addDisposableListener(textArea.domNode, 'copy', e => {\n      this._ensureClipboardGetsEditorSelection(e);\n    }));\n    this._register(dom.addDisposableListener(textArea.domNode, 'paste', e => {\n      // Pretend here we touched the text area, as the `paste` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received paste event');\n      if (ClipboardEventUtils.canUseTextData(e)) {\n        const [pastePlainText, metadata] = ClipboardEventUtils.getTextData(e);\n        if (pastePlainText !== '') {\n          this._firePaste(pastePlainText, metadata);\n        }\n      } else {\n        if (this._textArea.getSelectionStart() !== this._textArea.getSelectionEnd()) {\n          // Clean up the textarea, to get a clean paste\n          this._setAndWriteTextAreaState('paste', TextAreaState.EMPTY);\n        }\n        this._nextCommand = 1 /* Paste */;\n      }\n    }));\n\n    this._register(dom.addDisposableListener(textArea.domNode, 'focus', () => {\n      const hadFocus = this._hasFocus;\n      this._setHasFocus(true);\n      if (browser.isSafari && !hadFocus && this._hasFocus) {\n        // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n        // Safari will always move the selection at offset 0 in the textarea\n        this._asyncFocusGainWriteScreenReaderContent.schedule();\n      }\n    }));\n    this._register(dom.addDisposableListener(textArea.domNode, 'blur', () => {\n      if (this._isDoingComposition) {\n        // See https://github.com/microsoft/vscode/issues/112621\n        // where compositionend is not triggered when the editor\n        // is taken off-dom during a composition\n        // Clear the flag to be able to write to the textarea\n        this._isDoingComposition = false;\n        // Clear the textarea to avoid an unwanted cursor type\n        this.writeScreenReaderContent('blurWithoutCompositionEnd');\n        // Fire artificial composition end\n        this._onCompositionEnd.fire();\n      }\n      this._setHasFocus(false);\n    }));\n  }\n  _installSelectionChangeListener() {\n    // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n    // When using a Braille display, it is possible for users to reposition the\n    // system caret. This is reflected in Chrome as a `selectionchange` event.\n    //\n    // The `selectionchange` event appears to be emitted under numerous other circumstances,\n    // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n    // using a Braille display from all the other cases.\n    //\n    // The problems with the `selectionchange` event are:\n    //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n    //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n    //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n    //  * the event is emitted when tabbing into the textarea\n    //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n    //  * the event sometimes comes in bursts for a single logical textarea operation\n    // `selectionchange` events often come multiple times for a single logical change\n    // so throttle multiple `selectionchange` events that burst in a short period of time.\n    let previousSelectionChangeEventTime = 0;\n    return dom.addDisposableListener(document, 'selectionchange', e => {\n      if (!this._hasFocus) {\n        return;\n      }\n      if (this._isDoingComposition) {\n        return;\n      }\n      if (!browser.isChrome) {\n        // Support only for Chrome until testing happens on other browsers\n        return;\n      }\n      const now = Date.now();\n      const delta1 = now - previousSelectionChangeEventTime;\n      previousSelectionChangeEventTime = now;\n      if (delta1 < 5) {\n        // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n        // => ignore it\n        return;\n      }\n      const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n      this._textArea.resetSelectionChangeTime();\n      if (delta2 < 100) {\n        // received a `selectionchange` event within 100ms since we touched the textarea\n        // => ignore it, since we caused it\n        return;\n      }\n      if (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n      const newValue = this._textArea.getValue();\n      if (this._textAreaState.value !== newValue) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n      const newSelectionStart = this._textArea.getSelectionStart();\n      const newSelectionEnd = this._textArea.getSelectionEnd();\n      if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n        // Nothing to do...\n        return;\n      }\n      const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n      const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n      const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n      const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n      const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n      this._onSelectionChangeRequest.fire(newSelection);\n    });\n  }\n  dispose() {\n    super.dispose();\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n      this._selectionChangeListener = null;\n    }\n  }\n  focusTextArea() {\n    // Setting this._hasFocus and writing the screen reader content\n    // will result in a focus() and setSelectionRange() in the textarea\n    this._setHasFocus(true);\n    // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n    this.refreshFocusState();\n  }\n  isFocused() {\n    return this._hasFocus;\n  }\n  refreshFocusState() {\n    const shadowRoot = dom.getShadowRoot(this.textArea.domNode);\n    if (shadowRoot) {\n      this._setHasFocus(shadowRoot.activeElement === this.textArea.domNode);\n    } else if (dom.isInDOM(this.textArea.domNode)) {\n      this._setHasFocus(document.activeElement === this.textArea.domNode);\n    } else {\n      this._setHasFocus(false);\n    }\n  }\n  _setHasFocus(newHasFocus) {\n    if (this._hasFocus === newHasFocus) {\n      // no change\n      return;\n    }\n    this._hasFocus = newHasFocus;\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n      this._selectionChangeListener = null;\n    }\n    if (this._hasFocus) {\n      this._selectionChangeListener = this._installSelectionChangeListener();\n    }\n    if (this._hasFocus) {\n      this.writeScreenReaderContent('focusgain');\n    }\n    if (this._hasFocus) {\n      this._onFocus.fire();\n    } else {\n      this._onBlur.fire();\n    }\n  }\n  _setAndWriteTextAreaState(reason, textAreaState) {\n    if (!this._hasFocus) {\n      textAreaState = textAreaState.collapseSelection();\n    }\n    textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n    this._textAreaState = textAreaState;\n  }\n  writeScreenReaderContent(reason) {\n    if (this._isDoingComposition) {\n      // Do not write to the text area when doing composition\n      return;\n    }\n    this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n  }\n  _ensureClipboardGetsEditorSelection(e) {\n    const dataToCopy = this._host.getDataToCopy(ClipboardEventUtils.canUseTextData(e) && BrowserFeatures.clipboard.richText);\n    const storedMetadata = {\n      version: 1,\n      isFromEmptySelection: dataToCopy.isFromEmptySelection,\n      multicursorText: dataToCopy.multicursorText,\n      mode: dataToCopy.mode\n    };\n    InMemoryClipboardMetadataManager.INSTANCE.set(\n    // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n    // Firefox pastes \"LINE\\n\", so let's work around this quirk\n    browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text, storedMetadata);\n    if (!ClipboardEventUtils.canUseTextData(e)) {\n      // Looks like an old browser. The strategy is to place the text\n      // we'd like to be copied to the clipboard in the textarea and select it.\n      this._setAndWriteTextAreaState('copy or cut', TextAreaState.selectedText(dataToCopy.text));\n      return;\n    }\n    ClipboardEventUtils.setTextData(e, dataToCopy.text, dataToCopy.html, storedMetadata);\n  }\n  _firePaste(text, metadata) {\n    if (!metadata) {\n      // try the in-memory store\n      metadata = InMemoryClipboardMetadataManager.INSTANCE.get(text);\n    }\n    this._onPaste.fire({\n      text: text,\n      metadata: metadata\n    });\n  }\n}\nclass ClipboardEventUtils {\n  static canUseTextData(e) {\n    if (e.clipboardData) {\n      return true;\n    }\n    if (window.clipboardData) {\n      return true;\n    }\n    return false;\n  }\n  static getTextData(e) {\n    if (e.clipboardData) {\n      e.preventDefault();\n      const text = e.clipboardData.getData('text/plain');\n      let metadata = null;\n      const rawmetadata = e.clipboardData.getData('vscode-editor-data');\n      if (typeof rawmetadata === 'string') {\n        try {\n          metadata = JSON.parse(rawmetadata);\n          if (metadata.version !== 1) {\n            metadata = null;\n          }\n        } catch (err) {\n          // no problem!\n        }\n      }\n      return [text, metadata];\n    }\n    if (window.clipboardData) {\n      e.preventDefault();\n      const text = window.clipboardData.getData('Text');\n      return [text, null];\n    }\n    throw new Error('ClipboardEventUtils.getTextData: Cannot use text data!');\n  }\n  static setTextData(e, text, html, metadata) {\n    if (e.clipboardData) {\n      e.clipboardData.setData('text/plain', text);\n      if (typeof html === 'string') {\n        e.clipboardData.setData('text/html', html);\n      }\n      e.clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n      e.preventDefault();\n      return;\n    }\n    if (window.clipboardData) {\n      window.clipboardData.setData('Text', text);\n      e.preventDefault();\n      return;\n    }\n    throw new Error('ClipboardEventUtils.setTextData: Cannot use text data!');\n  }\n}\nclass TextAreaWrapper extends Disposable {\n  constructor(_textArea) {\n    super();\n    this._actual = _textArea;\n    this._ignoreSelectionChangeTime = 0;\n  }\n  setIgnoreSelectionChangeTime(reason) {\n    this._ignoreSelectionChangeTime = Date.now();\n  }\n  getIgnoreSelectionChangeTime() {\n    return this._ignoreSelectionChangeTime;\n  }\n  resetSelectionChangeTime() {\n    this._ignoreSelectionChangeTime = 0;\n  }\n  getValue() {\n    // console.log('current value: ' + this._textArea.value);\n    return this._actual.domNode.value;\n  }\n  setValue(reason, value) {\n    const textArea = this._actual.domNode;\n    if (textArea.value === value) {\n      // No change\n      return;\n    }\n    // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n    this.setIgnoreSelectionChangeTime('setValue');\n    textArea.value = value;\n  }\n  getSelectionStart() {\n    return this._actual.domNode.selectionStart;\n  }\n  getSelectionEnd() {\n    return this._actual.domNode.selectionEnd;\n  }\n  setSelectionRange(reason, selectionStart, selectionEnd) {\n    const textArea = this._actual.domNode;\n    let activeElement = null;\n    const shadowRoot = dom.getShadowRoot(textArea);\n    if (shadowRoot) {\n      activeElement = shadowRoot.activeElement;\n    } else {\n      activeElement = document.activeElement;\n    }\n    const currentIsFocused = activeElement === textArea;\n    const currentSelectionStart = textArea.selectionStart;\n    const currentSelectionEnd = textArea.selectionEnd;\n    if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n      // No change\n      // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n      if (browser.isFirefox && window.parent !== window) {\n        textArea.focus();\n      }\n      return;\n    }\n    // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n    if (currentIsFocused) {\n      // No need to focus, only need to change the selection range\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n      if (browser.isFirefox && window.parent !== window) {\n        textArea.focus();\n      }\n      return;\n    }\n    // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n    // Here, we try to undo the browser's desperate reveal.\n    try {\n      const scrollState = dom.saveParentsScrollTop(textArea);\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.focus();\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n      dom.restoreParentsScrollTop(textArea, scrollState);\n    } catch (e) {\n      // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n    }\n  }\n}","map":{"version":3,"names":["browser","dom","RunOnceScheduler","Emitter","Disposable","platform","strings","TextAreaState","_debugComposition","Position","Selection","BrowserFeatures","CopyOptions","forceCopyWithSyntaxHighlighting","InMemoryClipboardMetadataManager","constructor","_lastState","set","lastCopiedValue","data","get","pastedText","INSTANCE","TextAreaInput","host","textArea","_onFocus","_register","onFocus","event","_onBlur","onBlur","_onKeyDown","onKeyDown","_onKeyUp","onKeyUp","_onCut","onCut","_onPaste","onPaste","_onType","onType","_onCompositionStart","onCompositionStart","_onCompositionUpdate","onCompositionUpdate","_onCompositionEnd","onCompositionEnd","_onSelectionChangeRequest","onSelectionChangeRequest","_host","_textArea","TextAreaWrapper","_asyncTriggerCut","fire","_asyncFocusGainWriteScreenReaderContent","writeScreenReaderContent","_textAreaState","EMPTY","_selectionChangeListener","_hasFocus","_isDoingComposition","_nextCommand","lastKeyDown","addStandardDisposableListener","domNode","e","keyCode","stopPropagation","equals","preventDefault","addDisposableListener","console","log","moveOneCharacterLeft","isMacintosh","selectionStart","selectionEnd","value","substr","code","selectionStartPosition","lineNumber","column","selectionEndPosition","_setAndWriteTextAreaState","deduceInputFromTextAreaValue","couldBeEmojiInput","oldState","newState","readFromTextArea","deduceInput","deduceComposition","text","selectedText","typeInput","replaceCharCnt","isChrome","isFirefox","setIgnoreSelectionChangeTime","length","isHighSurrogate","charCodeAt","_firePaste","_ensureClipboardGetsEditorSelection","schedule","ClipboardEventUtils","canUseTextData","pastePlainText","metadata","getTextData","getSelectionStart","getSelectionEnd","hadFocus","_setHasFocus","isSafari","_installSelectionChangeListener","previousSelectionChangeEventTime","document","now","Date","delta1","delta2","getIgnoreSelectionChangeTime","resetSelectionChangeTime","newValue","getValue","newSelectionStart","newSelectionEnd","_newSelectionStartPosition","deduceEditorPosition","newSelectionStartPosition","deduceModelPosition","_newSelectionEndPosition","newSelectionEndPosition","newSelection","dispose","focusTextArea","refreshFocusState","isFocused","shadowRoot","getShadowRoot","activeElement","isInDOM","newHasFocus","reason","textAreaState","collapseSelection","writeToTextArea","getScreenReaderContent","dataToCopy","getDataToCopy","clipboard","richText","storedMetadata","version","isFromEmptySelection","multicursorText","mode","replace","setTextData","html","clipboardData","window","getData","rawmetadata","JSON","parse","err","Error","setData","stringify","_actual","_ignoreSelectionChangeTime","setValue","setSelectionRange","currentIsFocused","currentSelectionStart","currentSelectionEnd","parent","focus","scrollState","saveParentsScrollTop","restoreParentsScrollTop"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaInput.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as browser from '../../../base/browser/browser.js';\r\nimport * as dom from '../../../base/browser/dom.js';\r\nimport { RunOnceScheduler } from '../../../base/common/async.js';\r\nimport { Emitter } from '../../../base/common/event.js';\r\nimport { Disposable } from '../../../base/common/lifecycle.js';\r\nimport * as platform from '../../../base/common/platform.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Selection } from '../../common/core/selection.js';\r\nimport { BrowserFeatures } from '../../../base/browser/canIUse.js';\r\nexport const CopyOptions = {\r\n    forceCopyWithSyntaxHighlighting: false\r\n};\r\n/**\r\n * Every time we write to the clipboard, we record a bit of extra metadata here.\r\n * Every time we read from the cipboard, if the text matches our last written text,\r\n * we can fetch the previous metadata.\r\n */\r\nexport class InMemoryClipboardMetadataManager {\r\n    constructor() {\r\n        this._lastState = null;\r\n    }\r\n    set(lastCopiedValue, data) {\r\n        this._lastState = { lastCopiedValue, data };\r\n    }\r\n    get(pastedText) {\r\n        if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\r\n            // match!\r\n            return this._lastState.data;\r\n        }\r\n        this._lastState = null;\r\n        return null;\r\n    }\r\n}\r\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\r\n/**\r\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\r\n *  - onCut\r\n *  - onPaste\r\n *  - onType\r\n *\r\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\r\n */\r\nexport class TextAreaInput extends Disposable {\r\n    constructor(host, textArea) {\r\n        super();\r\n        this.textArea = textArea;\r\n        this._onFocus = this._register(new Emitter());\r\n        this.onFocus = this._onFocus.event;\r\n        this._onBlur = this._register(new Emitter());\r\n        this.onBlur = this._onBlur.event;\r\n        this._onKeyDown = this._register(new Emitter());\r\n        this.onKeyDown = this._onKeyDown.event;\r\n        this._onKeyUp = this._register(new Emitter());\r\n        this.onKeyUp = this._onKeyUp.event;\r\n        this._onCut = this._register(new Emitter());\r\n        this.onCut = this._onCut.event;\r\n        this._onPaste = this._register(new Emitter());\r\n        this.onPaste = this._onPaste.event;\r\n        this._onType = this._register(new Emitter());\r\n        this.onType = this._onType.event;\r\n        this._onCompositionStart = this._register(new Emitter());\r\n        this.onCompositionStart = this._onCompositionStart.event;\r\n        this._onCompositionUpdate = this._register(new Emitter());\r\n        this.onCompositionUpdate = this._onCompositionUpdate.event;\r\n        this._onCompositionEnd = this._register(new Emitter());\r\n        this.onCompositionEnd = this._onCompositionEnd.event;\r\n        this._onSelectionChangeRequest = this._register(new Emitter());\r\n        this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\r\n        this._host = host;\r\n        this._textArea = this._register(new TextAreaWrapper(textArea));\r\n        this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\r\n        this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\r\n        this._textAreaState = TextAreaState.EMPTY;\r\n        this._selectionChangeListener = null;\r\n        this.writeScreenReaderContent('ctor');\r\n        this._hasFocus = false;\r\n        this._isDoingComposition = false;\r\n        this._nextCommand = 0 /* Type */;\r\n        let lastKeyDown = null;\r\n        this._register(dom.addStandardDisposableListener(textArea.domNode, 'keydown', (e) => {\r\n            if (e.keyCode === 109 /* KEY_IN_COMPOSITION */\r\n                || (this._isDoingComposition && e.keyCode === 1 /* Backspace */)) {\r\n                // Stop propagation for keyDown events if the IME is processing key input\r\n                e.stopPropagation();\r\n            }\r\n            if (e.equals(9 /* Escape */)) {\r\n                // Prevent default always for `Esc`, otherwise it will generate a keypress\r\n                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\r\n                e.preventDefault();\r\n            }\r\n            lastKeyDown = e;\r\n            this._onKeyDown.fire(e);\r\n        }));\r\n        this._register(dom.addStandardDisposableListener(textArea.domNode, 'keyup', (e) => {\r\n            this._onKeyUp.fire(e);\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'compositionstart', (e) => {\r\n            if (_debugComposition) {\r\n                console.log(`[compositionstart]`, e);\r\n            }\r\n            if (this._isDoingComposition) {\r\n                return;\r\n            }\r\n            this._isDoingComposition = true;\r\n            let moveOneCharacterLeft = false;\r\n            if (platform.isMacintosh\r\n                && lastKeyDown\r\n                && lastKeyDown.equals(109 /* KEY_IN_COMPOSITION */)\r\n                && this._textAreaState.selectionStart === this._textAreaState.selectionEnd\r\n                && this._textAreaState.selectionStart > 0\r\n                && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data) {\r\n                // Handling long press case on macOS + arrow key => pretend the character was selected\r\n                if (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft') {\r\n                    if (_debugComposition) {\r\n                        console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\r\n                    }\r\n                    moveOneCharacterLeft = true;\r\n                }\r\n            }\r\n            if (moveOneCharacterLeft) {\r\n                this._textAreaState = new TextAreaState(this._textAreaState.value, this._textAreaState.selectionStart - 1, this._textAreaState.selectionEnd, this._textAreaState.selectionStartPosition ? new Position(this._textAreaState.selectionStartPosition.lineNumber, this._textAreaState.selectionStartPosition.column - 1) : null, this._textAreaState.selectionEndPosition);\r\n            }\r\n            else {\r\n                this._setAndWriteTextAreaState('compositionstart', TextAreaState.EMPTY);\r\n            }\r\n            this._onCompositionStart.fire({ moveOneCharacterLeft });\r\n        }));\r\n        /**\r\n         * Deduce the typed input from a text area's value and the last observed state.\r\n         */\r\n        const deduceInputFromTextAreaValue = (couldBeEmojiInput) => {\r\n            const oldState = this._textAreaState;\r\n            const newState = TextAreaState.readFromTextArea(this._textArea);\r\n            return [newState, TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput)];\r\n        };\r\n        /**\r\n         * Deduce the composition input from a string.\r\n         */\r\n        const deduceComposition = (text) => {\r\n            const oldState = this._textAreaState;\r\n            const newState = TextAreaState.selectedText(text);\r\n            const typeInput = {\r\n                text: newState.value,\r\n                replaceCharCnt: oldState.selectionEnd - oldState.selectionStart\r\n            };\r\n            return [newState, typeInput];\r\n        };\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'compositionupdate', (e) => {\r\n            if (_debugComposition) {\r\n                console.log(`[compositionupdate]`, e);\r\n            }\r\n            const [newState, typeInput] = deduceComposition(e.data || '');\r\n            this._textAreaState = newState;\r\n            this._onType.fire(typeInput);\r\n            this._onCompositionUpdate.fire(e);\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'compositionend', (e) => {\r\n            if (_debugComposition) {\r\n                console.log(`[compositionend]`, e);\r\n            }\r\n            // https://github.com/microsoft/monaco-editor/issues/1663\r\n            // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\r\n            if (!this._isDoingComposition) {\r\n                return;\r\n            }\r\n            const [newState, typeInput] = deduceComposition(e.data || '');\r\n            this._textAreaState = newState;\r\n            this._onType.fire(typeInput);\r\n            // isChrome: the textarea is not updated correctly when composition ends\r\n            // isFirefox: the textarea is not updated correctly after inserting emojis\r\n            // => we cannot assume the text at the end consists only of the composited text\r\n            if (browser.isChrome || browser.isFirefox) {\r\n                this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\r\n            }\r\n            if (!this._isDoingComposition) {\r\n                return;\r\n            }\r\n            this._isDoingComposition = false;\r\n            this._onCompositionEnd.fire();\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'input', () => {\r\n            // Pretend here we touched the text area, as the `input` event will most likely\r\n            // result in a `selectionchange` event which we want to ignore\r\n            this._textArea.setIgnoreSelectionChangeTime('received input event');\r\n            if (this._isDoingComposition) {\r\n                return;\r\n            }\r\n            const [newState, typeInput] = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/ platform.isMacintosh);\r\n            if (typeInput.replaceCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\r\n                // Ignore invalid input but keep it around for next time\r\n                return;\r\n            }\r\n            this._textAreaState = newState;\r\n            if (this._nextCommand === 0 /* Type */) {\r\n                if (typeInput.text !== '') {\r\n                    this._onType.fire(typeInput);\r\n                }\r\n            }\r\n            else {\r\n                if (typeInput.text !== '' || typeInput.replaceCharCnt !== 0) {\r\n                    this._firePaste(typeInput.text, null);\r\n                }\r\n                this._nextCommand = 0 /* Type */;\r\n            }\r\n        }));\r\n        // --- Clipboard operations\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'cut', (e) => {\r\n            // Pretend here we touched the text area, as the `cut` event will most likely\r\n            // result in a `selectionchange` event which we want to ignore\r\n            this._textArea.setIgnoreSelectionChangeTime('received cut event');\r\n            this._ensureClipboardGetsEditorSelection(e);\r\n            this._asyncTriggerCut.schedule();\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'copy', (e) => {\r\n            this._ensureClipboardGetsEditorSelection(e);\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'paste', (e) => {\r\n            // Pretend here we touched the text area, as the `paste` event will most likely\r\n            // result in a `selectionchange` event which we want to ignore\r\n            this._textArea.setIgnoreSelectionChangeTime('received paste event');\r\n            if (ClipboardEventUtils.canUseTextData(e)) {\r\n                const [pastePlainText, metadata] = ClipboardEventUtils.getTextData(e);\r\n                if (pastePlainText !== '') {\r\n                    this._firePaste(pastePlainText, metadata);\r\n                }\r\n            }\r\n            else {\r\n                if (this._textArea.getSelectionStart() !== this._textArea.getSelectionEnd()) {\r\n                    // Clean up the textarea, to get a clean paste\r\n                    this._setAndWriteTextAreaState('paste', TextAreaState.EMPTY);\r\n                }\r\n                this._nextCommand = 1 /* Paste */;\r\n            }\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'focus', () => {\r\n            const hadFocus = this._hasFocus;\r\n            this._setHasFocus(true);\r\n            if (browser.isSafari && !hadFocus && this._hasFocus) {\r\n                // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\r\n                // Safari will always move the selection at offset 0 in the textarea\r\n                this._asyncFocusGainWriteScreenReaderContent.schedule();\r\n            }\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'blur', () => {\r\n            if (this._isDoingComposition) {\r\n                // See https://github.com/microsoft/vscode/issues/112621\r\n                // where compositionend is not triggered when the editor\r\n                // is taken off-dom during a composition\r\n                // Clear the flag to be able to write to the textarea\r\n                this._isDoingComposition = false;\r\n                // Clear the textarea to avoid an unwanted cursor type\r\n                this.writeScreenReaderContent('blurWithoutCompositionEnd');\r\n                // Fire artificial composition end\r\n                this._onCompositionEnd.fire();\r\n            }\r\n            this._setHasFocus(false);\r\n        }));\r\n    }\r\n    _installSelectionChangeListener() {\r\n        // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\r\n        // When using a Braille display, it is possible for users to reposition the\r\n        // system caret. This is reflected in Chrome as a `selectionchange` event.\r\n        //\r\n        // The `selectionchange` event appears to be emitted under numerous other circumstances,\r\n        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\r\n        // using a Braille display from all the other cases.\r\n        //\r\n        // The problems with the `selectionchange` event are:\r\n        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\r\n        //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\r\n        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\r\n        //  * the event is emitted when tabbing into the textarea\r\n        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\r\n        //  * the event sometimes comes in bursts for a single logical textarea operation\r\n        // `selectionchange` events often come multiple times for a single logical change\r\n        // so throttle multiple `selectionchange` events that burst in a short period of time.\r\n        let previousSelectionChangeEventTime = 0;\r\n        return dom.addDisposableListener(document, 'selectionchange', (e) => {\r\n            if (!this._hasFocus) {\r\n                return;\r\n            }\r\n            if (this._isDoingComposition) {\r\n                return;\r\n            }\r\n            if (!browser.isChrome) {\r\n                // Support only for Chrome until testing happens on other browsers\r\n                return;\r\n            }\r\n            const now = Date.now();\r\n            const delta1 = now - previousSelectionChangeEventTime;\r\n            previousSelectionChangeEventTime = now;\r\n            if (delta1 < 5) {\r\n                // received another `selectionchange` event within 5ms of the previous `selectionchange` event\r\n                // => ignore it\r\n                return;\r\n            }\r\n            const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\r\n            this._textArea.resetSelectionChangeTime();\r\n            if (delta2 < 100) {\r\n                // received a `selectionchange` event within 100ms since we touched the textarea\r\n                // => ignore it, since we caused it\r\n                return;\r\n            }\r\n            if (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\r\n                // Cannot correlate a position in the textarea with a position in the editor...\r\n                return;\r\n            }\r\n            const newValue = this._textArea.getValue();\r\n            if (this._textAreaState.value !== newValue) {\r\n                // Cannot correlate a position in the textarea with a position in the editor...\r\n                return;\r\n            }\r\n            const newSelectionStart = this._textArea.getSelectionStart();\r\n            const newSelectionEnd = this._textArea.getSelectionEnd();\r\n            if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\r\n                // Nothing to do...\r\n                return;\r\n            }\r\n            const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\r\n            const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\r\n            const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\r\n            const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\r\n            const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\r\n            this._onSelectionChangeRequest.fire(newSelection);\r\n        });\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        if (this._selectionChangeListener) {\r\n            this._selectionChangeListener.dispose();\r\n            this._selectionChangeListener = null;\r\n        }\r\n    }\r\n    focusTextArea() {\r\n        // Setting this._hasFocus and writing the screen reader content\r\n        // will result in a focus() and setSelectionRange() in the textarea\r\n        this._setHasFocus(true);\r\n        // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\r\n        this.refreshFocusState();\r\n    }\r\n    isFocused() {\r\n        return this._hasFocus;\r\n    }\r\n    refreshFocusState() {\r\n        const shadowRoot = dom.getShadowRoot(this.textArea.domNode);\r\n        if (shadowRoot) {\r\n            this._setHasFocus(shadowRoot.activeElement === this.textArea.domNode);\r\n        }\r\n        else if (dom.isInDOM(this.textArea.domNode)) {\r\n            this._setHasFocus(document.activeElement === this.textArea.domNode);\r\n        }\r\n        else {\r\n            this._setHasFocus(false);\r\n        }\r\n    }\r\n    _setHasFocus(newHasFocus) {\r\n        if (this._hasFocus === newHasFocus) {\r\n            // no change\r\n            return;\r\n        }\r\n        this._hasFocus = newHasFocus;\r\n        if (this._selectionChangeListener) {\r\n            this._selectionChangeListener.dispose();\r\n            this._selectionChangeListener = null;\r\n        }\r\n        if (this._hasFocus) {\r\n            this._selectionChangeListener = this._installSelectionChangeListener();\r\n        }\r\n        if (this._hasFocus) {\r\n            this.writeScreenReaderContent('focusgain');\r\n        }\r\n        if (this._hasFocus) {\r\n            this._onFocus.fire();\r\n        }\r\n        else {\r\n            this._onBlur.fire();\r\n        }\r\n    }\r\n    _setAndWriteTextAreaState(reason, textAreaState) {\r\n        if (!this._hasFocus) {\r\n            textAreaState = textAreaState.collapseSelection();\r\n        }\r\n        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\r\n        this._textAreaState = textAreaState;\r\n    }\r\n    writeScreenReaderContent(reason) {\r\n        if (this._isDoingComposition) {\r\n            // Do not write to the text area when doing composition\r\n            return;\r\n        }\r\n        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\r\n    }\r\n    _ensureClipboardGetsEditorSelection(e) {\r\n        const dataToCopy = this._host.getDataToCopy(ClipboardEventUtils.canUseTextData(e) && BrowserFeatures.clipboard.richText);\r\n        const storedMetadata = {\r\n            version: 1,\r\n            isFromEmptySelection: dataToCopy.isFromEmptySelection,\r\n            multicursorText: dataToCopy.multicursorText,\r\n            mode: dataToCopy.mode\r\n        };\r\n        InMemoryClipboardMetadataManager.INSTANCE.set(\r\n        // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\r\n        // Firefox pastes \"LINE\\n\", so let's work around this quirk\r\n        (browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text), storedMetadata);\r\n        if (!ClipboardEventUtils.canUseTextData(e)) {\r\n            // Looks like an old browser. The strategy is to place the text\r\n            // we'd like to be copied to the clipboard in the textarea and select it.\r\n            this._setAndWriteTextAreaState('copy or cut', TextAreaState.selectedText(dataToCopy.text));\r\n            return;\r\n        }\r\n        ClipboardEventUtils.setTextData(e, dataToCopy.text, dataToCopy.html, storedMetadata);\r\n    }\r\n    _firePaste(text, metadata) {\r\n        if (!metadata) {\r\n            // try the in-memory store\r\n            metadata = InMemoryClipboardMetadataManager.INSTANCE.get(text);\r\n        }\r\n        this._onPaste.fire({\r\n            text: text,\r\n            metadata: metadata\r\n        });\r\n    }\r\n}\r\nclass ClipboardEventUtils {\r\n    static canUseTextData(e) {\r\n        if (e.clipboardData) {\r\n            return true;\r\n        }\r\n        if (window.clipboardData) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    static getTextData(e) {\r\n        if (e.clipboardData) {\r\n            e.preventDefault();\r\n            const text = e.clipboardData.getData('text/plain');\r\n            let metadata = null;\r\n            const rawmetadata = e.clipboardData.getData('vscode-editor-data');\r\n            if (typeof rawmetadata === 'string') {\r\n                try {\r\n                    metadata = JSON.parse(rawmetadata);\r\n                    if (metadata.version !== 1) {\r\n                        metadata = null;\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    // no problem!\r\n                }\r\n            }\r\n            return [text, metadata];\r\n        }\r\n        if (window.clipboardData) {\r\n            e.preventDefault();\r\n            const text = window.clipboardData.getData('Text');\r\n            return [text, null];\r\n        }\r\n        throw new Error('ClipboardEventUtils.getTextData: Cannot use text data!');\r\n    }\r\n    static setTextData(e, text, html, metadata) {\r\n        if (e.clipboardData) {\r\n            e.clipboardData.setData('text/plain', text);\r\n            if (typeof html === 'string') {\r\n                e.clipboardData.setData('text/html', html);\r\n            }\r\n            e.clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\r\n            e.preventDefault();\r\n            return;\r\n        }\r\n        if (window.clipboardData) {\r\n            window.clipboardData.setData('Text', text);\r\n            e.preventDefault();\r\n            return;\r\n        }\r\n        throw new Error('ClipboardEventUtils.setTextData: Cannot use text data!');\r\n    }\r\n}\r\nclass TextAreaWrapper extends Disposable {\r\n    constructor(_textArea) {\r\n        super();\r\n        this._actual = _textArea;\r\n        this._ignoreSelectionChangeTime = 0;\r\n    }\r\n    setIgnoreSelectionChangeTime(reason) {\r\n        this._ignoreSelectionChangeTime = Date.now();\r\n    }\r\n    getIgnoreSelectionChangeTime() {\r\n        return this._ignoreSelectionChangeTime;\r\n    }\r\n    resetSelectionChangeTime() {\r\n        this._ignoreSelectionChangeTime = 0;\r\n    }\r\n    getValue() {\r\n        // console.log('current value: ' + this._textArea.value);\r\n        return this._actual.domNode.value;\r\n    }\r\n    setValue(reason, value) {\r\n        const textArea = this._actual.domNode;\r\n        if (textArea.value === value) {\r\n            // No change\r\n            return;\r\n        }\r\n        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\r\n        this.setIgnoreSelectionChangeTime('setValue');\r\n        textArea.value = value;\r\n    }\r\n    getSelectionStart() {\r\n        return this._actual.domNode.selectionStart;\r\n    }\r\n    getSelectionEnd() {\r\n        return this._actual.domNode.selectionEnd;\r\n    }\r\n    setSelectionRange(reason, selectionStart, selectionEnd) {\r\n        const textArea = this._actual.domNode;\r\n        let activeElement = null;\r\n        const shadowRoot = dom.getShadowRoot(textArea);\r\n        if (shadowRoot) {\r\n            activeElement = shadowRoot.activeElement;\r\n        }\r\n        else {\r\n            activeElement = document.activeElement;\r\n        }\r\n        const currentIsFocused = (activeElement === textArea);\r\n        const currentSelectionStart = textArea.selectionStart;\r\n        const currentSelectionEnd = textArea.selectionEnd;\r\n        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\r\n            // No change\r\n            // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\r\n            if (browser.isFirefox && window.parent !== window) {\r\n                textArea.focus();\r\n            }\r\n            return;\r\n        }\r\n        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\r\n        if (currentIsFocused) {\r\n            // No need to focus, only need to change the selection range\r\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\r\n            textArea.setSelectionRange(selectionStart, selectionEnd);\r\n            if (browser.isFirefox && window.parent !== window) {\r\n                textArea.focus();\r\n            }\r\n            return;\r\n        }\r\n        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\r\n        // Here, we try to undo the browser's desperate reveal.\r\n        try {\r\n            const scrollState = dom.saveParentsScrollTop(textArea);\r\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\r\n            textArea.focus();\r\n            textArea.setSelectionRange(selectionStart, selectionEnd);\r\n            dom.restoreParentsScrollTop(textArea, scrollState);\r\n        }\r\n        catch (e) {\r\n            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}