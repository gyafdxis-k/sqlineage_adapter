{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\r\n * Create a word definition regular expression based on default word separators.\r\n * Optionally provide allowed separators that should be included in words.\r\n *\r\n * The default would look like this:\r\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n */\nfunction createWordRegExp() {\n  let allowInWords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n  for (const sep of USUAL_WORD_SEPARATORS) {\n    if (allowInWords.indexOf(sep) >= 0) {\n      continue;\n    }\n    source += '\\\\' + sep;\n  }\n  source += '\\\\s]+)';\n  return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n  let result = DEFAULT_WORD_REGEXP;\n  if (wordDefinition && wordDefinition instanceof RegExp) {\n    if (!wordDefinition.global) {\n      let flags = 'g';\n      if (wordDefinition.ignoreCase) {\n        flags += 'i';\n      }\n      if (wordDefinition.multiline) {\n        flags += 'm';\n      }\n      if (wordDefinition.unicode) {\n        flags += 'u';\n      }\n      result = new RegExp(wordDefinition.source, flags);\n    } else {\n      result = wordDefinition;\n    }\n  }\n  result.lastIndex = 0;\n  return result;\n}\nconst _defaultConfig = {\n  maxLen: 1000,\n  windowSize: 15,\n  timeBudget: 150\n};\nexport function getWordAtText(column, wordDefinition, text, textOffset) {\n  let config = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _defaultConfig;\n  if (text.length > config.maxLen) {\n    // don't throw strings that long at the regexp\n    // but use a sub-string in which a word must occur\n    let start = column - config.maxLen / 2;\n    if (start < 0) {\n      start = 0;\n    } else {\n      textOffset += start;\n    }\n    text = text.substring(start, column + config.maxLen / 2);\n    return getWordAtText(column, wordDefinition, text, textOffset, config);\n  }\n  const t1 = Date.now();\n  const pos = column - 1 - textOffset;\n  let prevRegexIndex = -1;\n  let match = null;\n  for (let i = 1;; i++) {\n    // check time budget\n    if (Date.now() - t1 >= config.timeBudget) {\n      break;\n    }\n    // reset the index at which the regexp should start matching, also know where it\n    // should stop so that subsequent search don't repeat previous searches\n    const regexIndex = pos - config.windowSize * i;\n    wordDefinition.lastIndex = Math.max(0, regexIndex);\n    const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n    if (!thisMatch && match) {\n      // stop: we have something\n      break;\n    }\n    match = thisMatch;\n    // stop: searched at start\n    if (regexIndex <= 0) {\n      break;\n    }\n    prevRegexIndex = regexIndex;\n  }\n  if (match) {\n    let result = {\n      word: match[0],\n      startColumn: textOffset + 1 + match.index,\n      endColumn: textOffset + 1 + match.index + match[0].length\n    };\n    wordDefinition.lastIndex = 0;\n    return result;\n  }\n  return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n  let match;\n  while (match = wordDefinition.exec(text)) {\n    const matchIndex = match.index || 0;\n    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n      return match;\n    } else if (stopPos > 0 && matchIndex > stopPos) {\n      return null;\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["USUAL_WORD_SEPARATORS","createWordRegExp","allowInWords","arguments","length","undefined","source","sep","indexOf","RegExp","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","wordDefinition","result","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","maxLen","windowSize","timeBudget","getWordAtText","column","text","textOffset","config","start","substring","t1","Date","now","pos","prevRegexIndex","match","i","regexIndex","Math","max","thisMatch","_findRegexMatchEnclosingPosition","word","startColumn","index","endColumn","stopPos","exec","matchIndex"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\r\n/**\r\n * Create a word definition regular expression based on default word separators.\r\n * Optionally provide allowed separators that should be included in words.\r\n *\r\n * The default would look like this:\r\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n */\r\nfunction createWordRegExp(allowInWords = '') {\r\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\r\n    for (const sep of USUAL_WORD_SEPARATORS) {\r\n        if (allowInWords.indexOf(sep) >= 0) {\r\n            continue;\r\n        }\r\n        source += '\\\\' + sep;\r\n    }\r\n    source += '\\\\s]+)';\r\n    return new RegExp(source, 'g');\r\n}\r\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\r\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\r\nexport function ensureValidWordDefinition(wordDefinition) {\r\n    let result = DEFAULT_WORD_REGEXP;\r\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\r\n        if (!wordDefinition.global) {\r\n            let flags = 'g';\r\n            if (wordDefinition.ignoreCase) {\r\n                flags += 'i';\r\n            }\r\n            if (wordDefinition.multiline) {\r\n                flags += 'm';\r\n            }\r\n            if (wordDefinition.unicode) {\r\n                flags += 'u';\r\n            }\r\n            result = new RegExp(wordDefinition.source, flags);\r\n        }\r\n        else {\r\n            result = wordDefinition;\r\n        }\r\n    }\r\n    result.lastIndex = 0;\r\n    return result;\r\n}\r\nconst _defaultConfig = {\r\n    maxLen: 1000,\r\n    windowSize: 15,\r\n    timeBudget: 150\r\n};\r\nexport function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {\r\n    if (text.length > config.maxLen) {\r\n        // don't throw strings that long at the regexp\r\n        // but use a sub-string in which a word must occur\r\n        let start = column - config.maxLen / 2;\r\n        if (start < 0) {\r\n            start = 0;\r\n        }\r\n        else {\r\n            textOffset += start;\r\n        }\r\n        text = text.substring(start, column + config.maxLen / 2);\r\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\r\n    }\r\n    const t1 = Date.now();\r\n    const pos = column - 1 - textOffset;\r\n    let prevRegexIndex = -1;\r\n    let match = null;\r\n    for (let i = 1;; i++) {\r\n        // check time budget\r\n        if (Date.now() - t1 >= config.timeBudget) {\r\n            break;\r\n        }\r\n        // reset the index at which the regexp should start matching, also know where it\r\n        // should stop so that subsequent search don't repeat previous searches\r\n        const regexIndex = pos - config.windowSize * i;\r\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\r\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\r\n        if (!thisMatch && match) {\r\n            // stop: we have something\r\n            break;\r\n        }\r\n        match = thisMatch;\r\n        // stop: searched at start\r\n        if (regexIndex <= 0) {\r\n            break;\r\n        }\r\n        prevRegexIndex = regexIndex;\r\n    }\r\n    if (match) {\r\n        let result = {\r\n            word: match[0],\r\n            startColumn: textOffset + 1 + match.index,\r\n            endColumn: textOffset + 1 + match.index + match[0].length\r\n        };\r\n        wordDefinition.lastIndex = 0;\r\n        return result;\r\n    }\r\n    return null;\r\n}\r\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\r\n    let match;\r\n    while (match = wordDefinition.exec(text)) {\r\n        const matchIndex = match.index || 0;\r\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\r\n            return match;\r\n        }\r\n        else if (stopPos > 0 && matchIndex > stopPos) {\r\n            return null;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}