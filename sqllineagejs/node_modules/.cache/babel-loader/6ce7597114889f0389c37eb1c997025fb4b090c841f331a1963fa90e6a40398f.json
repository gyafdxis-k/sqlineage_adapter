{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\nexport class RichEditBracket {\n  constructor(languageIdentifier, index, open, close, forwardRegex, reversedRegex) {\n    this.languageIdentifier = languageIdentifier;\n    this.index = index;\n    this.open = open;\n    this.close = close;\n    this.forwardRegex = forwardRegex;\n    this.reversedRegex = reversedRegex;\n    this._openSet = RichEditBracket._toSet(this.open);\n    this._closeSet = RichEditBracket._toSet(this.close);\n  }\n  isOpen(text) {\n    return this._openSet.has(text);\n  }\n  isClose(text) {\n    return this._closeSet.has(text);\n  }\n  static _toSet(arr) {\n    const result = new Set();\n    for (const element of arr) {\n      result.add(element);\n    }\n    return result;\n  }\n}\nfunction groupFuzzyBrackets(brackets) {\n  const N = brackets.length;\n  brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n  const group = [];\n  for (let i = 0; i < N; i++) {\n    group[i] = i;\n  }\n  const areOverlapping = (a, b) => {\n    const [aOpen, aClose] = a;\n    const [bOpen, bClose] = b;\n    return aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose;\n  };\n  const mergeGroups = (g1, g2) => {\n    const newG = Math.min(g1, g2);\n    const oldG = Math.max(g1, g2);\n    for (let i = 0; i < N; i++) {\n      if (group[i] === oldG) {\n        group[i] = newG;\n      }\n    }\n  };\n  // group together brackets that have the same open or the same close sequence\n  for (let i = 0; i < N; i++) {\n    const a = brackets[i];\n    for (let j = i + 1; j < N; j++) {\n      const b = brackets[j];\n      if (areOverlapping(a, b)) {\n        mergeGroups(group[i], group[j]);\n      }\n    }\n  }\n  const result = [];\n  for (let g = 0; g < N; g++) {\n    let currentOpen = [];\n    let currentClose = [];\n    for (let i = 0; i < N; i++) {\n      if (group[i] === g) {\n        const [open, close] = brackets[i];\n        currentOpen.push(open);\n        currentClose.push(close);\n      }\n    }\n    if (currentOpen.length > 0) {\n      result.push({\n        open: currentOpen,\n        close: currentClose\n      });\n    }\n  }\n  return result;\n}\nexport class RichEditBrackets {\n  constructor(languageIdentifier, _brackets) {\n    const brackets = groupFuzzyBrackets(_brackets);\n    this.brackets = brackets.map((b, index) => {\n      return new RichEditBracket(languageIdentifier, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n    });\n    this.forwardRegex = getRegexForBrackets(this.brackets);\n    this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n    this.textIsBracket = {};\n    this.textIsOpenBracket = {};\n    this.maxBracketLength = 0;\n    for (const bracket of this.brackets) {\n      for (const open of bracket.open) {\n        this.textIsBracket[open] = bracket;\n        this.textIsOpenBracket[open] = true;\n        this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n      }\n      for (const close of bracket.close) {\n        this.textIsBracket[close] = bracket;\n        this.textIsOpenBracket[close] = false;\n        this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n      }\n    }\n  }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n  for (let i = 0, len = brackets.length; i < len; i++) {\n    if (i === currentIndex) {\n      continue;\n    }\n    const bracket = brackets[i];\n    for (const open of bracket.open) {\n      if (open.indexOf(str) >= 0) {\n        dest.push(open);\n      }\n    }\n    for (const close of bracket.close) {\n      if (close.indexOf(str) >= 0) {\n        dest.push(close);\n      }\n    }\n  }\n}\nfunction lengthcmp(a, b) {\n  return a.length - b.length;\n}\nfunction unique(arr) {\n  if (arr.length <= 1) {\n    return arr;\n  }\n  const result = [];\n  const seen = new Set();\n  for (const element of arr) {\n    if (seen.has(element)) {\n      continue;\n    }\n    result.push(element);\n    seen.add(element);\n  }\n  return result;\n}\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n  // search in all brackets for other brackets that are a superstring of these brackets\n  let pieces = [];\n  pieces = pieces.concat(open);\n  pieces = pieces.concat(close);\n  for (let i = 0, len = pieces.length; i < len; i++) {\n    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n  }\n  pieces = unique(pieces);\n  pieces.sort(lengthcmp);\n  pieces.reverse();\n  return createBracketOrRegExp(pieces);\n}\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n  // search in all brackets for other brackets that are a superstring of these brackets\n  let pieces = [];\n  pieces = pieces.concat(open);\n  pieces = pieces.concat(close);\n  for (let i = 0, len = pieces.length; i < len; i++) {\n    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n  }\n  pieces = unique(pieces);\n  pieces.sort(lengthcmp);\n  pieces.reverse();\n  return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction getRegexForBrackets(brackets) {\n  let pieces = [];\n  for (const bracket of brackets) {\n    for (const open of bracket.open) {\n      pieces.push(open);\n    }\n    for (const close of bracket.close) {\n      pieces.push(close);\n    }\n  }\n  pieces = unique(pieces);\n  return createBracketOrRegExp(pieces);\n}\nfunction getReversedRegexForBrackets(brackets) {\n  let pieces = [];\n  for (const bracket of brackets) {\n    for (const open of bracket.open) {\n      pieces.push(open);\n    }\n    for (const close of bracket.close) {\n      pieces.push(close);\n    }\n  }\n  pieces = unique(pieces);\n  return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n  // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n  const insertWordBoundaries = /^[\\w ]+$/.test(str);\n  str = strings.escapeRegExpCharacters(str);\n  return insertWordBoundaries ? \"\\\\b\".concat(str, \"\\\\b\") : str;\n}\nfunction createBracketOrRegExp(pieces) {\n  let regexStr = \"(\".concat(pieces.map(prepareBracketForRegExp).join(')|('), \")\");\n  return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = function () {\n  function reverse(str) {\n    if (stringBuilder.hasTextDecoder) {\n      // create a Uint16Array and then use a TextDecoder to create a string\n      const arr = new Uint16Array(str.length);\n      let offset = 0;\n      for (let i = str.length - 1; i >= 0; i--) {\n        arr[offset++] = str.charCodeAt(i);\n      }\n      return stringBuilder.getPlatformTextDecoder().decode(arr);\n    } else {\n      let result = [],\n        resultLen = 0;\n      for (let i = str.length - 1; i >= 0; i--) {\n        result[resultLen++] = str.charAt(i);\n      }\n      return result.join('');\n    }\n  }\n  let lastInput = null;\n  let lastOutput = null;\n  return function toReversedString(str) {\n    if (lastInput !== str) {\n      lastInput = str;\n      lastOutput = reverse(lastInput);\n    }\n    return lastOutput;\n  };\n}();\nexport class BracketsUtils {\n  static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n    let m = reversedText.match(reversedBracketRegex);\n    if (!m) {\n      return null;\n    }\n    let matchOffset = reversedText.length - (m.index || 0);\n    let matchLength = m[0].length;\n    let absoluteMatchOffset = offset + matchOffset;\n    return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n  }\n  static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n    // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n    const reversedLineText = toReversedString(lineText);\n    const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n    return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n  }\n  static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n    let m = text.match(bracketRegex);\n    if (!m) {\n      return null;\n    }\n    let matchOffset = m.index || 0;\n    let matchLength = m[0].length;\n    if (matchLength === 0) {\n      return null;\n    }\n    let absoluteMatchOffset = offset + matchOffset;\n    return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n  }\n  static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n    const substr = lineText.substring(startOffset, endOffset);\n    return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n  }\n}","map":{"version":3,"names":["strings","stringBuilder","Range","RichEditBracket","constructor","languageIdentifier","index","open","close","forwardRegex","reversedRegex","_openSet","_toSet","_closeSet","isOpen","text","has","isClose","arr","result","Set","element","add","groupFuzzyBrackets","brackets","N","length","map","b","toLowerCase","group","i","areOverlapping","a","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","Math","min","oldG","max","j","g","currentOpen","currentClose","push","RichEditBrackets","_brackets","getRegexForBracketPair","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","textIsBracket","textIsOpenBracket","maxBracketLength","bracket","collectSuperstrings","str","currentIndex","dest","len","indexOf","lengthcmp","unique","seen","pieces","concat","sort","reverse","createBracketOrRegExp","toReversedString","prepareBracketForRegExp","insertWordBoundaries","test","escapeRegExpCharacters","regexStr","join","createRegExp","hasTextDecoder","Uint16Array","offset","charCodeAt","getPlatformTextDecoder","decode","resultLen","charAt","lastInput","lastOutput","BracketsUtils","_findPrevBracketInText","reversedBracketRegex","lineNumber","reversedText","m","match","matchOffset","matchLength","absoluteMatchOffset","findPrevBracketInRange","lineText","startOffset","endOffset","reversedLineText","reversedSubstr","substring","findNextBracketInText","bracketRegex","findNextBracketInRange","substr"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/modes/supports/richEditBrackets.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../../base/common/strings.js';\r\nimport * as stringBuilder from '../../core/stringBuilder.js';\r\nimport { Range } from '../../core/range.js';\r\nexport class RichEditBracket {\r\n    constructor(languageIdentifier, index, open, close, forwardRegex, reversedRegex) {\r\n        this.languageIdentifier = languageIdentifier;\r\n        this.index = index;\r\n        this.open = open;\r\n        this.close = close;\r\n        this.forwardRegex = forwardRegex;\r\n        this.reversedRegex = reversedRegex;\r\n        this._openSet = RichEditBracket._toSet(this.open);\r\n        this._closeSet = RichEditBracket._toSet(this.close);\r\n    }\r\n    isOpen(text) {\r\n        return this._openSet.has(text);\r\n    }\r\n    isClose(text) {\r\n        return this._closeSet.has(text);\r\n    }\r\n    static _toSet(arr) {\r\n        const result = new Set();\r\n        for (const element of arr) {\r\n            result.add(element);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nfunction groupFuzzyBrackets(brackets) {\r\n    const N = brackets.length;\r\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\r\n    const group = [];\r\n    for (let i = 0; i < N; i++) {\r\n        group[i] = i;\r\n    }\r\n    const areOverlapping = (a, b) => {\r\n        const [aOpen, aClose] = a;\r\n        const [bOpen, bClose] = b;\r\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\r\n    };\r\n    const mergeGroups = (g1, g2) => {\r\n        const newG = Math.min(g1, g2);\r\n        const oldG = Math.max(g1, g2);\r\n        for (let i = 0; i < N; i++) {\r\n            if (group[i] === oldG) {\r\n                group[i] = newG;\r\n            }\r\n        }\r\n    };\r\n    // group together brackets that have the same open or the same close sequence\r\n    for (let i = 0; i < N; i++) {\r\n        const a = brackets[i];\r\n        for (let j = i + 1; j < N; j++) {\r\n            const b = brackets[j];\r\n            if (areOverlapping(a, b)) {\r\n                mergeGroups(group[i], group[j]);\r\n            }\r\n        }\r\n    }\r\n    const result = [];\r\n    for (let g = 0; g < N; g++) {\r\n        let currentOpen = [];\r\n        let currentClose = [];\r\n        for (let i = 0; i < N; i++) {\r\n            if (group[i] === g) {\r\n                const [open, close] = brackets[i];\r\n                currentOpen.push(open);\r\n                currentClose.push(close);\r\n            }\r\n        }\r\n        if (currentOpen.length > 0) {\r\n            result.push({\r\n                open: currentOpen,\r\n                close: currentClose\r\n            });\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexport class RichEditBrackets {\r\n    constructor(languageIdentifier, _brackets) {\r\n        const brackets = groupFuzzyBrackets(_brackets);\r\n        this.brackets = brackets.map((b, index) => {\r\n            return new RichEditBracket(languageIdentifier, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\r\n        });\r\n        this.forwardRegex = getRegexForBrackets(this.brackets);\r\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\r\n        this.textIsBracket = {};\r\n        this.textIsOpenBracket = {};\r\n        this.maxBracketLength = 0;\r\n        for (const bracket of this.brackets) {\r\n            for (const open of bracket.open) {\r\n                this.textIsBracket[open] = bracket;\r\n                this.textIsOpenBracket[open] = true;\r\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\r\n            }\r\n            for (const close of bracket.close) {\r\n                this.textIsBracket[close] = bracket;\r\n                this.textIsOpenBracket[close] = false;\r\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\r\n    for (let i = 0, len = brackets.length; i < len; i++) {\r\n        if (i === currentIndex) {\r\n            continue;\r\n        }\r\n        const bracket = brackets[i];\r\n        for (const open of bracket.open) {\r\n            if (open.indexOf(str) >= 0) {\r\n                dest.push(open);\r\n            }\r\n        }\r\n        for (const close of bracket.close) {\r\n            if (close.indexOf(str) >= 0) {\r\n                dest.push(close);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction lengthcmp(a, b) {\r\n    return a.length - b.length;\r\n}\r\nfunction unique(arr) {\r\n    if (arr.length <= 1) {\r\n        return arr;\r\n    }\r\n    const result = [];\r\n    const seen = new Set();\r\n    for (const element of arr) {\r\n        if (seen.has(element)) {\r\n            continue;\r\n        }\r\n        result.push(element);\r\n        seen.add(element);\r\n    }\r\n    return result;\r\n}\r\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\r\n    // search in all brackets for other brackets that are a superstring of these brackets\r\n    let pieces = [];\r\n    pieces = pieces.concat(open);\r\n    pieces = pieces.concat(close);\r\n    for (let i = 0, len = pieces.length; i < len; i++) {\r\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\r\n    }\r\n    pieces = unique(pieces);\r\n    pieces.sort(lengthcmp);\r\n    pieces.reverse();\r\n    return createBracketOrRegExp(pieces);\r\n}\r\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\r\n    // search in all brackets for other brackets that are a superstring of these brackets\r\n    let pieces = [];\r\n    pieces = pieces.concat(open);\r\n    pieces = pieces.concat(close);\r\n    for (let i = 0, len = pieces.length; i < len; i++) {\r\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\r\n    }\r\n    pieces = unique(pieces);\r\n    pieces.sort(lengthcmp);\r\n    pieces.reverse();\r\n    return createBracketOrRegExp(pieces.map(toReversedString));\r\n}\r\nfunction getRegexForBrackets(brackets) {\r\n    let pieces = [];\r\n    for (const bracket of brackets) {\r\n        for (const open of bracket.open) {\r\n            pieces.push(open);\r\n        }\r\n        for (const close of bracket.close) {\r\n            pieces.push(close);\r\n        }\r\n    }\r\n    pieces = unique(pieces);\r\n    return createBracketOrRegExp(pieces);\r\n}\r\nfunction getReversedRegexForBrackets(brackets) {\r\n    let pieces = [];\r\n    for (const bracket of brackets) {\r\n        for (const open of bracket.open) {\r\n            pieces.push(open);\r\n        }\r\n        for (const close of bracket.close) {\r\n            pieces.push(close);\r\n        }\r\n    }\r\n    pieces = unique(pieces);\r\n    return createBracketOrRegExp(pieces.map(toReversedString));\r\n}\r\nfunction prepareBracketForRegExp(str) {\r\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\r\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\r\n    str = strings.escapeRegExpCharacters(str);\r\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\r\n}\r\nfunction createBracketOrRegExp(pieces) {\r\n    let regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\r\n    return strings.createRegExp(regexStr, true);\r\n}\r\nconst toReversedString = (function () {\r\n    function reverse(str) {\r\n        if (stringBuilder.hasTextDecoder) {\r\n            // create a Uint16Array and then use a TextDecoder to create a string\r\n            const arr = new Uint16Array(str.length);\r\n            let offset = 0;\r\n            for (let i = str.length - 1; i >= 0; i--) {\r\n                arr[offset++] = str.charCodeAt(i);\r\n            }\r\n            return stringBuilder.getPlatformTextDecoder().decode(arr);\r\n        }\r\n        else {\r\n            let result = [], resultLen = 0;\r\n            for (let i = str.length - 1; i >= 0; i--) {\r\n                result[resultLen++] = str.charAt(i);\r\n            }\r\n            return result.join('');\r\n        }\r\n    }\r\n    let lastInput = null;\r\n    let lastOutput = null;\r\n    return function toReversedString(str) {\r\n        if (lastInput !== str) {\r\n            lastInput = str;\r\n            lastOutput = reverse(lastInput);\r\n        }\r\n        return lastOutput;\r\n    };\r\n})();\r\nexport class BracketsUtils {\r\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\r\n        let m = reversedText.match(reversedBracketRegex);\r\n        if (!m) {\r\n            return null;\r\n        }\r\n        let matchOffset = reversedText.length - (m.index || 0);\r\n        let matchLength = m[0].length;\r\n        let absoluteMatchOffset = offset + matchOffset;\r\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\r\n    }\r\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\r\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\r\n        const reversedLineText = toReversedString(lineText);\r\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\r\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\r\n    }\r\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\r\n        let m = text.match(bracketRegex);\r\n        if (!m) {\r\n            return null;\r\n        }\r\n        let matchOffset = m.index || 0;\r\n        let matchLength = m[0].length;\r\n        if (matchLength === 0) {\r\n            return null;\r\n        }\r\n        let absoluteMatchOffset = offset + matchOffset;\r\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\r\n    }\r\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\r\n        const substr = lineText.substring(startOffset, endOffset);\r\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}