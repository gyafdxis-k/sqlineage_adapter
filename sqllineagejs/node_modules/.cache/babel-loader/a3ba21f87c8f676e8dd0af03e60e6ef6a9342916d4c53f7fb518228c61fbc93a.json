{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TokenizationRegistry } from '../modes.js';\nimport { tokenizeLineToHTML } from '../modes/textToHtmlTokenizer.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport * as viewEvents from '../view/viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { IdentityLinesCollection, SplitLinesCollection } from './splitLinesCollection.js';\nimport { MinimapLinesRenderingData, ViewLineRenderingData } from './viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { Cursor } from '../controller/cursor.js';\nimport { CursorConfiguration } from '../controller/cursorCommon.js';\nimport { ViewModelEventDispatcher, FocusChangedEvent, ScrollChangedEvent, ViewZonesChangedEvent, ReadOnlyEditAttemptEvent } from './viewModelEventDispatcher.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n  constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame) {\n    super();\n    this._editorId = editorId;\n    this._configuration = configuration;\n    this.model = model;\n    this._eventDispatcher = new ViewModelEventDispatcher();\n    this.onEvent = this._eventDispatcher.onEvent;\n    this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\n    this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\n    this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n    this._hasFocus = false;\n    this._viewportStartLine = -1;\n    this._viewportStartLineTrackedRange = null;\n    this._viewportStartLineDelta = 0;\n    if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n      this._lines = new IdentityLinesCollection(this.model);\n    } else {\n      const options = this._configuration.options;\n      const fontInfo = options.get(38 /* fontInfo */);\n      const wrappingStrategy = options.get(118 /* wrappingStrategy */);\n      const wrappingInfo = options.get(125 /* wrappingInfo */);\n      const wrappingIndent = options.get(117 /* wrappingIndent */);\n      this._lines = new SplitLinesCollection(this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\n    }\n    this.coordinatesConverter = this._lines.createCoordinatesConverter();\n    this._cursor = this._register(new Cursor(model, this, this.coordinatesConverter, this.cursorConfig));\n    this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n    this._register(this.viewLayout.onDidScroll(e => {\n      if (e.scrollTopChanged) {\n        this._tokenizeViewportSoon.schedule();\n      }\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n      this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n    }));\n    this._register(this.viewLayout.onDidContentSizeChange(e => {\n      this._eventDispatcher.emitOutgoingEvent(e);\n    }));\n    this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n    this._registerModelEvents();\n    this._register(this._configuration.onDidChangeFast(e => {\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n        this._onConfigurationChanged(eventsCollector, e);\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n    }));\n    this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n    }));\n    this._updateConfigurationViewLineCountNow();\n  }\n  dispose() {\n    // First remove listeners, as disposing the lines might end up sending\n    // model decoration changed events ... and we no longer care about them ...\n    super.dispose();\n    this._decorations.dispose();\n    this._lines.dispose();\n    this.invalidateMinimapColorCache();\n    this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, null, 1 /* NeverGrowsWhenTypingAtEdges */);\n    this._eventDispatcher.dispose();\n  }\n  createLineBreaksComputer() {\n    return this._lines.createLineBreaksComputer();\n  }\n  addViewEventHandler(eventHandler) {\n    this._eventDispatcher.addViewEventHandler(eventHandler);\n  }\n  removeViewEventHandler(eventHandler) {\n    this._eventDispatcher.removeViewEventHandler(eventHandler);\n  }\n  _updateConfigurationViewLineCountNow() {\n    this._configuration.setViewLineCount(this._lines.getViewLineCount());\n  }\n  tokenizeViewport() {\n    const linesViewportData = this.viewLayout.getLinesViewportData();\n    const startPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(linesViewportData.startLineNumber, 1));\n    const endPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(linesViewportData.endLineNumber, 1));\n    this.model.tokenizeViewport(startPosition.lineNumber, endPosition.lineNumber);\n  }\n  setHasFocus(hasFocus) {\n    this._hasFocus = hasFocus;\n    this._cursor.setHasFocus(hasFocus);\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n    this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n  }\n  onCompositionStart() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n  }\n  onCompositionEnd() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n  }\n  onDidColorThemeChange() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent());\n  }\n  _onConfigurationChanged(eventsCollector, e) {\n    // We might need to restore the current centered view range, so save it (if available)\n    let previousViewportStartModelPosition = null;\n    if (this._viewportStartLine !== -1) {\n      let previousViewportStartViewPosition = new Position(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));\n      previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n    }\n    let restorePreviousViewportStart = false;\n    const options = this._configuration.options;\n    const fontInfo = options.get(38 /* fontInfo */);\n    const wrappingStrategy = options.get(118 /* wrappingStrategy */);\n    const wrappingInfo = options.get(125 /* wrappingInfo */);\n    const wrappingIndent = options.get(117 /* wrappingIndent */);\n    if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\n      eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n      eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n      eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n      this._cursor.onLineMappingChanged(eventsCollector);\n      this._decorations.onLineMappingChanged();\n      this.viewLayout.onFlushed(this.getLineCount());\n      if (this.viewLayout.getCurrentScrollTop() !== 0) {\n        // Never change the scroll position from 0 to something else...\n        restorePreviousViewportStart = true;\n      }\n      this._updateConfigurationViewLineCount.schedule();\n    }\n    if (e.hasChanged(75 /* readOnly */)) {\n      // Must read again all decorations due to readOnly filtering\n      this._decorations.reset();\n      eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n    }\n    eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n    this.viewLayout.onConfigurationChanged(e);\n    if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n      const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n      const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n      this.viewLayout.setScrollPosition({\n        scrollTop: viewPositionTop + this._viewportStartLineDelta\n      }, 1 /* Immediate */);\n    }\n\n    if (CursorConfiguration.shouldRecreate(e)) {\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }\n  }\n  _registerModelEvents() {\n    this._register(this.model.onDidChangeRawContentFast(e => {\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n        let hadOtherModelChange = false;\n        let hadModelLineChangeThatChangedLineMapping = false;\n        const changes = e.changes;\n        const versionId = e.versionId;\n        // Do a first pass to compute line mappings, and a second pass to actually interpret them\n        const lineBreaksComputer = this._lines.createLineBreaksComputer();\n        for (const change of changes) {\n          switch (change.changeType) {\n            case 4 /* LinesInserted */:\n              {\n                for (const line of change.detail) {\n                  lineBreaksComputer.addRequest(line, null);\n                }\n                break;\n              }\n            case 2 /* LineChanged */:\n              {\n                lineBreaksComputer.addRequest(change.detail, null);\n                break;\n              }\n          }\n        }\n        const lineBreaks = lineBreaksComputer.finalize();\n        let lineBreaksOffset = 0;\n        for (const change of changes) {\n          switch (change.changeType) {\n            case 1 /* Flush */:\n              {\n                this._lines.onModelFlushed();\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                this._decorations.reset();\n                this.viewLayout.onFlushed(this.getLineCount());\n                hadOtherModelChange = true;\n                break;\n              }\n            case 3 /* LinesDeleted */:\n              {\n                const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                if (linesDeletedEvent !== null) {\n                  eventsCollector.emitViewEvent(linesDeletedEvent);\n                  this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                }\n                hadOtherModelChange = true;\n                break;\n              }\n            case 4 /* LinesInserted */:\n              {\n                const insertedLineBreaks = lineBreaks.slice(lineBreaksOffset, lineBreaksOffset + change.detail.length);\n                lineBreaksOffset += change.detail.length;\n                const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                if (linesInsertedEvent !== null) {\n                  eventsCollector.emitViewEvent(linesInsertedEvent);\n                  this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                }\n                hadOtherModelChange = true;\n                break;\n              }\n            case 2 /* LineChanged */:\n              {\n                const changedLineBreakData = lineBreaks[lineBreaksOffset];\n                lineBreaksOffset++;\n                const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                if (linesChangedEvent) {\n                  eventsCollector.emitViewEvent(linesChangedEvent);\n                }\n                if (linesInsertedEvent) {\n                  eventsCollector.emitViewEvent(linesInsertedEvent);\n                  this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                }\n                if (linesDeletedEvent) {\n                  eventsCollector.emitViewEvent(linesDeletedEvent);\n                  this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                }\n                break;\n              }\n            case 5 /* EOLChanged */:\n              {\n                // Nothing to do. The new version will be accepted below\n                break;\n              }\n          }\n        }\n        this._lines.acceptVersionId(versionId);\n        this.viewLayout.onHeightMaybeChanged();\n        if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n          eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n          this._cursor.onLineMappingChanged(eventsCollector);\n          this._decorations.onLineMappingChanged();\n        }\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n      // Update the configuration and reset the centered view line\n      this._viewportStartLine = -1;\n      this._configuration.setMaxLineNumber(this.model.getLineCount());\n      this._updateConfigurationViewLineCountNow();\n      // Recover viewport\n      if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {\n        const modelRange = this.model._getTrackedRange(this._viewportStartLineTrackedRange);\n        if (modelRange) {\n          const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n          const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n          this.viewLayout.setScrollPosition({\n            scrollTop: viewPositionTop + this._viewportStartLineDelta\n          }, 1 /* Immediate */);\n        }\n      }\n\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n        this._cursor.onModelContentChanged(eventsCollector, e);\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n    }));\n    this._register(this.model.onDidChangeTokens(e => {\n      let viewRanges = [];\n      for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n        const modelRange = e.ranges[j];\n        const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n        const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n        viewRanges[j] = {\n          fromLineNumber: viewStartLineNumber,\n          toLineNumber: viewEndLineNumber\n        };\n      }\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n      if (e.tokenizationSupportChanged) {\n        this._tokenizeViewportSoon.schedule();\n      }\n    }));\n    this._register(this.model.onDidChangeLanguageConfiguration(e => {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }));\n    this._register(this.model.onDidChangeLanguage(e => {\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }));\n    this._register(this.model.onDidChangeOptions(e => {\n      // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n        try {\n          const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n          eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n          this._cursor.onLineMappingChanged(eventsCollector);\n          this._decorations.onLineMappingChanged();\n          this.viewLayout.onFlushed(this.getLineCount());\n        } finally {\n          this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n      }\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }));\n    this._register(this.model.onDidChangeDecorations(e => {\n      this._decorations.onModelDecorationsChanged();\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n    }));\n  }\n  setHiddenAreas(ranges) {\n    try {\n      const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n      let lineMappingChanged = this._lines.setHiddenAreas(ranges);\n      if (lineMappingChanged) {\n        eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n        eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n        eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        this._cursor.onLineMappingChanged(eventsCollector);\n        this._decorations.onLineMappingChanged();\n        this.viewLayout.onFlushed(this.getLineCount());\n        this.viewLayout.onHeightMaybeChanged();\n      }\n    } finally {\n      this._eventDispatcher.endEmitViewEvents();\n    }\n    this._updateConfigurationViewLineCount.schedule();\n  }\n  getVisibleRangesPlusViewportAboveBelow() {\n    const layoutInfo = this._configuration.options.get(124 /* layoutInfo */);\n    const lineHeight = this._configuration.options.get(53 /* lineHeight */);\n    const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n    const partialData = this.viewLayout.getLinesViewportData();\n    const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n    const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n    return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n  }\n  getVisibleRanges() {\n    const visibleViewRange = this.getCompletelyVisibleViewRange();\n    return this._toModelVisibleRanges(visibleViewRange);\n  }\n  _toModelVisibleRanges(visibleViewRange) {\n    const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n    const hiddenAreas = this._lines.getHiddenAreas();\n    if (hiddenAreas.length === 0) {\n      return [visibleRange];\n    }\n    let result = [],\n      resultLen = 0;\n    let startLineNumber = visibleRange.startLineNumber;\n    let startColumn = visibleRange.startColumn;\n    let endLineNumber = visibleRange.endLineNumber;\n    let endColumn = visibleRange.endColumn;\n    for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n      const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n      const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n      if (hiddenEndLineNumber < startLineNumber) {\n        continue;\n      }\n      if (hiddenStartLineNumber > endLineNumber) {\n        continue;\n      }\n      if (startLineNumber < hiddenStartLineNumber) {\n        result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n      }\n      startLineNumber = hiddenEndLineNumber + 1;\n      startColumn = 1;\n    }\n    if (startLineNumber < endLineNumber || startLineNumber === endLineNumber && startColumn < endColumn) {\n      result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    return result;\n  }\n  getCompletelyVisibleViewRange() {\n    const partialData = this.viewLayout.getLinesViewportData();\n    const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n    const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n  }\n  getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n    const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n    const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n    const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n  }\n  saveState() {\n    const compatViewState = this.viewLayout.saveState();\n    const scrollTop = compatViewState.scrollTop;\n    const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n    const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n    const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n    return {\n      scrollLeft: compatViewState.scrollLeft,\n      firstPosition: firstPosition,\n      firstPositionDeltaTop: firstPositionDeltaTop\n    };\n  }\n  reduceRestoreState(state) {\n    if (typeof state.firstPosition === 'undefined') {\n      // This is a view state serialized by an older version\n      return this._reduceRestoreStateCompatibility(state);\n    }\n    const modelPosition = this.model.validatePosition(state.firstPosition);\n    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n    const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n    return {\n      scrollLeft: state.scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n  _reduceRestoreStateCompatibility(state) {\n    return {\n      scrollLeft: state.scrollLeft,\n      scrollTop: state.scrollTopWithoutViewZones\n    };\n  }\n  getTabSize() {\n    return this.model.getOptions().tabSize;\n  }\n  getTextModelOptions() {\n    return this.model.getOptions();\n  }\n  getLineCount() {\n    return this._lines.getViewLineCount();\n  }\n  /**\r\n   * Gives a hint that a lot of requests are about to come in for these line numbers.\r\n   */\n  setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n    this._viewportStartLine = startLineNumber;\n    let position = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, this.getLineMinColumn(startLineNumber)));\n    this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* NeverGrowsWhenTypingAtEdges */);\n    const viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n    const scrollTop = this.viewLayout.getCurrentScrollTop();\n    this._viewportStartLineDelta = scrollTop - viewportStartLineTop;\n  }\n  getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n    return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n  }\n  getLinesIndentGuides(startLineNumber, endLineNumber) {\n    return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n  }\n  getLineContent(lineNumber) {\n    return this._lines.getViewLineContent(lineNumber);\n  }\n  getLineLength(lineNumber) {\n    return this._lines.getViewLineLength(lineNumber);\n  }\n  getLineMinColumn(lineNumber) {\n    return this._lines.getViewLineMinColumn(lineNumber);\n  }\n  getLineMaxColumn(lineNumber) {\n    return this._lines.getViewLineMaxColumn(lineNumber);\n  }\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 1;\n  }\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 2;\n  }\n  getDecorationsInViewport(visibleRange) {\n    return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n  }\n  getViewLineRenderingData(visibleRange, lineNumber) {\n    let mightContainRTL = this.model.mightContainRTL();\n    let mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n    let tabSize = this.getTabSize();\n    let lineData = this._lines.getViewLineData(lineNumber);\n    let allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n    let inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n    return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n  }\n  getViewLineData(lineNumber) {\n    return this._lines.getViewLineData(lineNumber);\n  }\n  getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n    let result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n    return new MinimapLinesRenderingData(this.getTabSize(), result);\n  }\n  getAllOverviewRulerDecorations(theme) {\n    return this._lines.getAllOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options), theme);\n  }\n  invalidateOverviewRulerColorCache() {\n    const decorations = this.model.getOverviewRulerDecorations();\n    for (const decoration of decorations) {\n      const opts = decoration.options.overviewRuler;\n      if (opts) {\n        opts.invalidateCachedColor();\n      }\n    }\n  }\n  invalidateMinimapColorCache() {\n    const decorations = this.model.getAllDecorations();\n    for (const decoration of decorations) {\n      const opts = decoration.options.minimap;\n      if (opts) {\n        opts.invalidateCachedColor();\n      }\n    }\n  }\n  getValueInRange(range, eol) {\n    const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n    return this.model.getValueInRange(modelRange, eol);\n  }\n  getModelLineMaxColumn(modelLineNumber) {\n    return this.model.getLineMaxColumn(modelLineNumber);\n  }\n  validateModelPosition(position) {\n    return this.model.validatePosition(position);\n  }\n  validateModelRange(range) {\n    return this.model.validateRange(range);\n  }\n  deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n    const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n    if (this.model.getEOL().length === 2) {\n      // This model uses CRLF, so the delta must take that into account\n      if (deltaOffset < 0) {\n        deltaOffset -= lineFeedCnt;\n      } else {\n        deltaOffset += lineFeedCnt;\n      }\n    }\n    const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n    const resultOffset = modelAnchorOffset + deltaOffset;\n    return this.model.getPositionAt(resultOffset);\n  }\n  getEOL() {\n    return this.model.getEOL();\n  }\n  getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n    const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n    modelRanges = modelRanges.slice(0);\n    modelRanges.sort(Range.compareRangesUsingStarts);\n    let hasEmptyRange = false;\n    let hasNonEmptyRange = false;\n    for (const range of modelRanges) {\n      if (range.isEmpty()) {\n        hasEmptyRange = true;\n      } else {\n        hasNonEmptyRange = true;\n      }\n    }\n    if (!hasNonEmptyRange) {\n      // all ranges are empty\n      if (!emptySelectionClipboard) {\n        return '';\n      }\n      const modelLineNumbers = modelRanges.map(r => r.startLineNumber);\n      let result = '';\n      for (let i = 0; i < modelLineNumbers.length; i++) {\n        if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n          continue;\n        }\n        result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n      }\n      return result;\n    }\n    if (hasEmptyRange && emptySelectionClipboard) {\n      // mixed empty selections and non-empty selections\n      let result = [];\n      let prevModelLineNumber = 0;\n      for (const modelRange of modelRanges) {\n        const modelLineNumber = modelRange.startLineNumber;\n        if (modelRange.isEmpty()) {\n          if (modelLineNumber !== prevModelLineNumber) {\n            result.push(this.model.getLineContent(modelLineNumber));\n          }\n        } else {\n          result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\n        }\n\n        prevModelLineNumber = modelLineNumber;\n      }\n      return result.length === 1 ? result[0] : result;\n    }\n    let result = [];\n    for (const modelRange of modelRanges) {\n      if (!modelRange.isEmpty()) {\n        result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\n      }\n    }\n\n    return result.length === 1 ? result[0] : result;\n  }\n  getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n    const languageId = this.model.getLanguageIdentifier();\n    if (languageId.id === 1 /* PlainText */) {\n      return null;\n    }\n    if (modelRanges.length !== 1) {\n      // no multiple selection support at this time\n      return null;\n    }\n    let range = modelRanges[0];\n    if (range.isEmpty()) {\n      if (!emptySelectionClipboard) {\n        // nothing to copy\n        return null;\n      }\n      const lineNumber = range.startLineNumber;\n      range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n    }\n    const fontInfo = this._configuration.options.get(38 /* fontInfo */);\n    const colorMap = this._getColorMap();\n    const fontFamily = fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily ? fontInfo.fontFamily : \"'\".concat(fontInfo.fontFamily, \"', \").concat(EDITOR_FONT_DEFAULTS.fontFamily);\n    return {\n      mode: languageId.language,\n      html: \"<div style=\\\"\" + \"color: \".concat(colorMap[1 /* DefaultForeground */], \";\") + \"background-color: \".concat(colorMap[2 /* DefaultBackground */], \";\") + \"font-family: \".concat(fontFamily, \";\") + \"font-weight: \".concat(fontInfo.fontWeight, \";\") + \"font-size: \".concat(fontInfo.fontSize, \"px;\") + \"line-height: \".concat(fontInfo.lineHeight, \"px;\") + \"white-space: pre;\" + \"\\\">\" + this._getHTMLToCopy(range, colorMap) + '</div>'\n    };\n  }\n  _getHTMLToCopy(modelRange, colorMap) {\n    const startLineNumber = modelRange.startLineNumber;\n    const startColumn = modelRange.startColumn;\n    const endLineNumber = modelRange.endLineNumber;\n    const endColumn = modelRange.endColumn;\n    const tabSize = this.getTabSize();\n    let result = '';\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const lineTokens = this.model.getLineTokens(lineNumber);\n      const lineContent = lineTokens.getLineContent();\n      const startOffset = lineNumber === startLineNumber ? startColumn - 1 : 0;\n      const endOffset = lineNumber === endLineNumber ? endColumn - 1 : lineContent.length;\n      if (lineContent === '') {\n        result += '<br>';\n      } else {\n        result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n      }\n    }\n    return result;\n  }\n  _getColorMap() {\n    let colorMap = TokenizationRegistry.getColorMap();\n    let result = ['#000000'];\n    if (colorMap) {\n      for (let i = 1, len = colorMap.length; i < len; i++) {\n        result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n      }\n    }\n    return result;\n  }\n  //#region model\n  pushStackElement() {\n    this.model.pushStackElement();\n  }\n  //#endregion\n  //#region cursor operations\n  getPrimaryCursorState() {\n    return this._cursor.getPrimaryCursorState();\n  }\n  getLastAddedCursorIndex() {\n    return this._cursor.getLastAddedCursorIndex();\n  }\n  getCursorStates() {\n    return this._cursor.getCursorStates();\n  }\n  setCursorStates(source, reason, states) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n  }\n  getCursorColumnSelectData() {\n    return this._cursor.getCursorColumnSelectData();\n  }\n  setCursorColumnSelectData(columnSelectData) {\n    this._cursor.setCursorColumnSelectData(columnSelectData);\n  }\n  getPrevEditOperationType() {\n    return this._cursor.getPrevEditOperationType();\n  }\n  setPrevEditOperationType(type) {\n    this._cursor.setPrevEditOperationType(type);\n  }\n  getSelection() {\n    return this._cursor.getSelection();\n  }\n  getSelections() {\n    return this._cursor.getSelections();\n  }\n  getPosition() {\n    return this._cursor.getPrimaryCursorState().modelState.position;\n  }\n  setSelections(source, selections) {\n    let reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n  }\n  saveCursorState() {\n    return this._cursor.saveState();\n  }\n  restoreCursorState(states) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n  }\n  _executeCursorEdit(callback) {\n    if (this._cursor.context.cursorConfig.readOnly) {\n      // we cannot edit when read only...\n      this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n      return;\n    }\n    this._withViewEventsCollector(callback);\n  }\n  executeEdits(source, edits, cursorStateComputer) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n  }\n  startComposition() {\n    this._cursor.setIsDoingComposition(true);\n    this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n  }\n  endComposition(source) {\n    this._cursor.setIsDoingComposition(false);\n    this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n  }\n  type(text, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n  }\n  replacePreviousChar(text, replaceCharCnt, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.replacePreviousChar(eventsCollector, text, replaceCharCnt, source));\n  }\n  paste(text, pasteOnNewLine, multicursorText, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n  }\n  cut(source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n  }\n  executeCommand(command, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n  }\n  executeCommands(commands, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n  }\n  revealPrimaryCursor(source, revealHorizontal) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, revealHorizontal, 0 /* Smooth */));\n  }\n\n  revealTopMostCursor(source) {\n    const viewPosition = this._cursor.getTopMostViewPosition();\n    const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\n  }\n\n  revealBottomMostCursor(source) {\n    const viewPosition = this._cursor.getBottomMostViewPosition();\n    const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\n  }\n\n  revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, verticalType, revealHorizontal, scrollType)));\n  }\n  //#endregion\n  //#region viewLayout\n  getVerticalOffsetForLineNumber(viewLineNumber) {\n    return this.viewLayout.getVerticalOffsetForLineNumber(viewLineNumber);\n  }\n  getScrollTop() {\n    return this.viewLayout.getCurrentScrollTop();\n  }\n  setScrollTop(newScrollTop, scrollType) {\n    this.viewLayout.setScrollPosition({\n      scrollTop: newScrollTop\n    }, scrollType);\n  }\n  setScrollPosition(position, type) {\n    this.viewLayout.setScrollPosition(position, type);\n  }\n  deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n    this.viewLayout.deltaScrollNow(deltaScrollLeft, deltaScrollTop);\n  }\n  changeWhitespace(callback) {\n    const hadAChange = this.viewLayout.changeWhitespace(callback);\n    if (hadAChange) {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n      this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n    }\n  }\n  setMaxLineWidth(maxLineWidth) {\n    this.viewLayout.setMaxLineWidth(maxLineWidth);\n  }\n  //#endregion\n  _withViewEventsCollector(callback) {\n    try {\n      const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n      callback(eventsCollector);\n    } finally {\n      this._eventDispatcher.endEmitViewEvents();\n    }\n  }\n}","map":{"version":3,"names":["Color","Disposable","strings","EDITOR_FONT_DEFAULTS","filterValidationDecorations","Position","Range","TokenizationRegistry","tokenizeLineToHTML","MinimapTokensColorTracker","viewEvents","ViewLayout","IdentityLinesCollection","SplitLinesCollection","MinimapLinesRenderingData","ViewLineRenderingData","ViewModelDecorations","RunOnceScheduler","platform","Cursor","CursorConfiguration","ViewModelEventDispatcher","FocusChangedEvent","ScrollChangedEvent","ViewZonesChangedEvent","ReadOnlyEditAttemptEvent","USE_IDENTITY_LINES_COLLECTION","ViewModel","constructor","editorId","configuration","model","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","scheduleAtNextAnimationFrame","_editorId","_configuration","_eventDispatcher","onEvent","cursorConfig","getLanguageIdentifier","getOptions","_tokenizeViewportSoon","_register","tokenizeViewport","_updateConfigurationViewLineCount","_updateConfigurationViewLineCountNow","_hasFocus","_viewportStartLine","_viewportStartLineTrackedRange","_viewportStartLineDelta","isTooLargeForTokenization","_lines","options","fontInfo","get","wrappingStrategy","wrappingInfo","wrappingIndent","tabSize","wrappingColumn","coordinatesConverter","createCoordinatesConverter","_cursor","viewLayout","getLineCount","onDidScroll","e","scrollTopChanged","schedule","emitSingleViewEvent","ViewScrollChangedEvent","emitOutgoingEvent","oldScrollWidth","oldScrollLeft","oldScrollHeight","oldScrollTop","scrollWidth","scrollLeft","scrollHeight","scrollTop","onDidContentSizeChange","_decorations","_registerModelEvents","onDidChangeFast","eventsCollector","beginEmitViewEvents","_onConfigurationChanged","endEmitViewEvents","getInstance","onDidChange","ViewTokensColorsChangedEvent","dispose","invalidateMinimapColorCache","_setTrackedRange","createLineBreaksComputer","addViewEventHandler","eventHandler","removeViewEventHandler","setViewLineCount","getViewLineCount","linesViewportData","getLinesViewportData","startPosition","convertViewPositionToModelPosition","startLineNumber","endPosition","endLineNumber","lineNumber","setHasFocus","hasFocus","ViewFocusChangedEvent","onCompositionStart","ViewCompositionStartEvent","onCompositionEnd","ViewCompositionEndEvent","onDidColorThemeChange","ViewThemeChangedEvent","previousViewportStartModelPosition","previousViewportStartViewPosition","getLineMinColumn","restorePreviousViewportStart","setWrappingSettings","emitViewEvent","ViewFlushedEvent","ViewLineMappingChangedEvent","ViewDecorationsChangedEvent","onLineMappingChanged","onFlushed","getCurrentScrollTop","hasChanged","reset","ViewConfigurationChangedEvent","onConfigurationChanged","viewPosition","convertModelPositionToViewPosition","viewPositionTop","getVerticalOffsetForLineNumber","setScrollPosition","shouldRecreate","updateConfiguration","onDidChangeRawContentFast","hadOtherModelChange","hadModelLineChangeThatChangedLineMapping","changes","versionId","lineBreaksComputer","change","changeType","line","detail","addRequest","lineBreaks","finalize","lineBreaksOffset","onModelFlushed","linesDeletedEvent","onModelLinesDeleted","fromLineNumber","toLineNumber","onLinesDeleted","insertedLineBreaks","slice","length","linesInsertedEvent","onModelLinesInserted","onLinesInserted","changedLineBreakData","lineMappingChanged","linesChangedEvent","onModelLineChanged","acceptVersionId","onHeightMaybeChanged","setMaxLineNumber","getAttachedEditorCount","modelRange","_getTrackedRange","getStartPosition","onModelContentChanged","onDidChangeTokens","viewRanges","j","lenJ","ranges","viewStartLineNumber","viewEndLineNumber","getLineMaxColumn","ViewTokensChangedEvent","tokenizationSupportChanged","onDidChangeLanguageConfiguration","ViewLanguageConfigurationEvent","onDidChangeLanguage","onDidChangeOptions","setTabSize","onDidChangeDecorations","onModelDecorationsChanged","setHiddenAreas","getVisibleRangesPlusViewportAboveBelow","layoutInfo","lineHeight","linesAround","Math","max","round","height","partialData","startViewLineNumber","completelyVisibleStartLineNumber","endViewLineNumber","min","completelyVisibleEndLineNumber","_toModelVisibleRanges","getVisibleRanges","visibleViewRange","getCompletelyVisibleViewRange","visibleRange","convertViewRangeToModelRange","hiddenAreas","getHiddenAreas","result","resultLen","startColumn","endColumn","i","len","hiddenStartLineNumber","hiddenEndLineNumber","getCompletelyVisibleViewRangeAtScrollTop","getLinesViewportDataAtScrollTop","saveState","compatViewState","firstViewLineNumber","getLineNumberAtVerticalOffset","firstPosition","firstPositionDeltaTop","reduceRestoreState","state","_reduceRestoreStateCompatibility","modelPosition","validatePosition","scrollTopWithoutViewZones","getTabSize","getTextModelOptions","setViewport","centeredLineNumber","position","column","viewportStartLineTop","getActiveIndentGuide","minLineNumber","maxLineNumber","getLinesIndentGuides","getViewLinesIndentGuides","getLineContent","getViewLineContent","getLineLength","getViewLineLength","getViewLineMinColumn","getViewLineMaxColumn","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","getDecorationsInViewport","getDecorationsViewportData","decorations","getViewLineRenderingData","mightContainRTL","mightContainNonBasicASCII","lineData","getViewLineData","allInlineDecorations","inlineDecorations","minColumn","maxColumn","content","continuesWithWrappedLine","tokens","startVisibleColumn","getMinimapLinesRenderingData","needed","getViewLinesData","getAllOverviewRulerDecorations","theme","invalidateOverviewRulerColorCache","getOverviewRulerDecorations","decoration","opts","overviewRuler","invalidateCachedColor","getAllDecorations","minimap","getValueInRange","range","eol","getModelLineMaxColumn","modelLineNumber","validateModelPosition","validateModelRange","validateRange","deduceModelPositionRelativeToViewPosition","viewAnchorPosition","deltaOffset","lineFeedCnt","modelAnchor","getEOL","modelAnchorOffset","getOffsetAt","resultOffset","getPositionAt","getPlainTextToCopy","modelRanges","emptySelectionClipboard","forceCRLF","newLineCharacter","sort","compareRangesUsingStarts","hasEmptyRange","hasNonEmptyRange","isEmpty","modelLineNumbers","map","r","prevModelLineNumber","push","getRichTextToCopy","languageId","id","colorMap","_getColorMap","fontFamily","concat","mode","language","html","fontWeight","fontSize","_getHTMLToCopy","lineTokens","getLineTokens","lineContent","startOffset","endOffset","inflate","isWindows","getColorMap","Format","CSS","formatHex","pushStackElement","getPrimaryCursorState","getLastAddedCursorIndex","getCursorStates","setCursorStates","source","reason","states","_withViewEventsCollector","setStates","getCursorColumnSelectData","setCursorColumnSelectData","columnSelectData","getPrevEditOperationType","setPrevEditOperationType","type","getSelection","getSelections","getPosition","modelState","setSelections","selections","arguments","undefined","saveCursorState","restoreCursorState","restoreState","_executeCursorEdit","callback","context","readOnly","executeEdits","edits","cursorStateComputer","startComposition","setIsDoingComposition","endComposition","text","replacePreviousChar","replaceCharCnt","paste","pasteOnNewLine","multicursorText","cut","executeCommand","command","executeCommands","commands","revealPrimaryCursor","revealHorizontal","revealPrimary","revealTopMostCursor","getTopMostViewPosition","viewRange","ViewRevealRangeRequestEvent","revealBottomMostCursor","getBottomMostViewPosition","revealRange","verticalType","scrollType","viewLineNumber","getScrollTop","setScrollTop","newScrollTop","deltaScrollNow","deltaScrollLeft","deltaScrollTop","changeWhitespace","hadAChange","setMaxLineWidth","maxLineWidth"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Color } from '../../../base/common/color.js';\r\nimport { Disposable } from '../../../base/common/lifecycle.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { TokenizationRegistry } from '../modes.js';\r\nimport { tokenizeLineToHTML } from '../modes/textToHtmlTokenizer.js';\r\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\r\nimport * as viewEvents from '../view/viewEvents.js';\r\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\r\nimport { IdentityLinesCollection, SplitLinesCollection } from './splitLinesCollection.js';\r\nimport { MinimapLinesRenderingData, ViewLineRenderingData } from './viewModel.js';\r\nimport { ViewModelDecorations } from './viewModelDecorations.js';\r\nimport { RunOnceScheduler } from '../../../base/common/async.js';\r\nimport * as platform from '../../../base/common/platform.js';\r\nimport { Cursor } from '../controller/cursor.js';\r\nimport { CursorConfiguration } from '../controller/cursorCommon.js';\r\nimport { ViewModelEventDispatcher, FocusChangedEvent, ScrollChangedEvent, ViewZonesChangedEvent, ReadOnlyEditAttemptEvent } from './viewModelEventDispatcher.js';\r\nconst USE_IDENTITY_LINES_COLLECTION = true;\r\nexport class ViewModel extends Disposable {\r\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame) {\r\n        super();\r\n        this._editorId = editorId;\r\n        this._configuration = configuration;\r\n        this.model = model;\r\n        this._eventDispatcher = new ViewModelEventDispatcher();\r\n        this.onEvent = this._eventDispatcher.onEvent;\r\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\r\n        this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\r\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\r\n        this._hasFocus = false;\r\n        this._viewportStartLine = -1;\r\n        this._viewportStartLineTrackedRange = null;\r\n        this._viewportStartLineDelta = 0;\r\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\r\n            this._lines = new IdentityLinesCollection(this.model);\r\n        }\r\n        else {\r\n            const options = this._configuration.options;\r\n            const fontInfo = options.get(38 /* fontInfo */);\r\n            const wrappingStrategy = options.get(118 /* wrappingStrategy */);\r\n            const wrappingInfo = options.get(125 /* wrappingInfo */);\r\n            const wrappingIndent = options.get(117 /* wrappingIndent */);\r\n            this._lines = new SplitLinesCollection(this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\r\n        }\r\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\r\n        this._cursor = this._register(new Cursor(model, this, this.coordinatesConverter, this.cursorConfig));\r\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\r\n        this._register(this.viewLayout.onDidScroll((e) => {\r\n            if (e.scrollTopChanged) {\r\n                this._tokenizeViewportSoon.schedule();\r\n            }\r\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\r\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\r\n        }));\r\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\r\n            this._eventDispatcher.emitOutgoingEvent(e);\r\n        }));\r\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\r\n        this._registerModelEvents();\r\n        this._register(this._configuration.onDidChangeFast((e) => {\r\n            try {\r\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\r\n                this._onConfigurationChanged(eventsCollector, e);\r\n            }\r\n            finally {\r\n                this._eventDispatcher.endEmitViewEvents();\r\n            }\r\n        }));\r\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\r\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\r\n        }));\r\n        this._updateConfigurationViewLineCountNow();\r\n    }\r\n    dispose() {\r\n        // First remove listeners, as disposing the lines might end up sending\r\n        // model decoration changed events ... and we no longer care about them ...\r\n        super.dispose();\r\n        this._decorations.dispose();\r\n        this._lines.dispose();\r\n        this.invalidateMinimapColorCache();\r\n        this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, null, 1 /* NeverGrowsWhenTypingAtEdges */);\r\n        this._eventDispatcher.dispose();\r\n    }\r\n    createLineBreaksComputer() {\r\n        return this._lines.createLineBreaksComputer();\r\n    }\r\n    addViewEventHandler(eventHandler) {\r\n        this._eventDispatcher.addViewEventHandler(eventHandler);\r\n    }\r\n    removeViewEventHandler(eventHandler) {\r\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\r\n    }\r\n    _updateConfigurationViewLineCountNow() {\r\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\r\n    }\r\n    tokenizeViewport() {\r\n        const linesViewportData = this.viewLayout.getLinesViewportData();\r\n        const startPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(linesViewportData.startLineNumber, 1));\r\n        const endPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(linesViewportData.endLineNumber, 1));\r\n        this.model.tokenizeViewport(startPosition.lineNumber, endPosition.lineNumber);\r\n    }\r\n    setHasFocus(hasFocus) {\r\n        this._hasFocus = hasFocus;\r\n        this._cursor.setHasFocus(hasFocus);\r\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\r\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\r\n    }\r\n    onCompositionStart() {\r\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\r\n    }\r\n    onCompositionEnd() {\r\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\r\n    }\r\n    onDidColorThemeChange() {\r\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent());\r\n    }\r\n    _onConfigurationChanged(eventsCollector, e) {\r\n        // We might need to restore the current centered view range, so save it (if available)\r\n        let previousViewportStartModelPosition = null;\r\n        if (this._viewportStartLine !== -1) {\r\n            let previousViewportStartViewPosition = new Position(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));\r\n            previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\r\n        }\r\n        let restorePreviousViewportStart = false;\r\n        const options = this._configuration.options;\r\n        const fontInfo = options.get(38 /* fontInfo */);\r\n        const wrappingStrategy = options.get(118 /* wrappingStrategy */);\r\n        const wrappingInfo = options.get(125 /* wrappingInfo */);\r\n        const wrappingIndent = options.get(117 /* wrappingIndent */);\r\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\r\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\r\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\r\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\r\n            this._cursor.onLineMappingChanged(eventsCollector);\r\n            this._decorations.onLineMappingChanged();\r\n            this.viewLayout.onFlushed(this.getLineCount());\r\n            if (this.viewLayout.getCurrentScrollTop() !== 0) {\r\n                // Never change the scroll position from 0 to something else...\r\n                restorePreviousViewportStart = true;\r\n            }\r\n            this._updateConfigurationViewLineCount.schedule();\r\n        }\r\n        if (e.hasChanged(75 /* readOnly */)) {\r\n            // Must read again all decorations due to readOnly filtering\r\n            this._decorations.reset();\r\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\r\n        }\r\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\r\n        this.viewLayout.onConfigurationChanged(e);\r\n        if (restorePreviousViewportStart && previousViewportStartModelPosition) {\r\n            const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\r\n            const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\r\n            this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStartLineDelta }, 1 /* Immediate */);\r\n        }\r\n        if (CursorConfiguration.shouldRecreate(e)) {\r\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\r\n            this._cursor.updateConfiguration(this.cursorConfig);\r\n        }\r\n    }\r\n    _registerModelEvents() {\r\n        this._register(this.model.onDidChangeRawContentFast((e) => {\r\n            try {\r\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\r\n                let hadOtherModelChange = false;\r\n                let hadModelLineChangeThatChangedLineMapping = false;\r\n                const changes = e.changes;\r\n                const versionId = e.versionId;\r\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\r\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\r\n                for (const change of changes) {\r\n                    switch (change.changeType) {\r\n                        case 4 /* LinesInserted */: {\r\n                            for (const line of change.detail) {\r\n                                lineBreaksComputer.addRequest(line, null);\r\n                            }\r\n                            break;\r\n                        }\r\n                        case 2 /* LineChanged */: {\r\n                            lineBreaksComputer.addRequest(change.detail, null);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                const lineBreaks = lineBreaksComputer.finalize();\r\n                let lineBreaksOffset = 0;\r\n                for (const change of changes) {\r\n                    switch (change.changeType) {\r\n                        case 1 /* Flush */: {\r\n                            this._lines.onModelFlushed();\r\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\r\n                            this._decorations.reset();\r\n                            this.viewLayout.onFlushed(this.getLineCount());\r\n                            hadOtherModelChange = true;\r\n                            break;\r\n                        }\r\n                        case 3 /* LinesDeleted */: {\r\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\r\n                            if (linesDeletedEvent !== null) {\r\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\r\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\r\n                            }\r\n                            hadOtherModelChange = true;\r\n                            break;\r\n                        }\r\n                        case 4 /* LinesInserted */: {\r\n                            const insertedLineBreaks = lineBreaks.slice(lineBreaksOffset, lineBreaksOffset + change.detail.length);\r\n                            lineBreaksOffset += change.detail.length;\r\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\r\n                            if (linesInsertedEvent !== null) {\r\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\r\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\r\n                            }\r\n                            hadOtherModelChange = true;\r\n                            break;\r\n                        }\r\n                        case 2 /* LineChanged */: {\r\n                            const changedLineBreakData = lineBreaks[lineBreaksOffset];\r\n                            lineBreaksOffset++;\r\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\r\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\r\n                            if (linesChangedEvent) {\r\n                                eventsCollector.emitViewEvent(linesChangedEvent);\r\n                            }\r\n                            if (linesInsertedEvent) {\r\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\r\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\r\n                            }\r\n                            if (linesDeletedEvent) {\r\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\r\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\r\n                            }\r\n                            break;\r\n                        }\r\n                        case 5 /* EOLChanged */: {\r\n                            // Nothing to do. The new version will be accepted below\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                this._lines.acceptVersionId(versionId);\r\n                this.viewLayout.onHeightMaybeChanged();\r\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\r\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\r\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\r\n                    this._cursor.onLineMappingChanged(eventsCollector);\r\n                    this._decorations.onLineMappingChanged();\r\n                }\r\n            }\r\n            finally {\r\n                this._eventDispatcher.endEmitViewEvents();\r\n            }\r\n            // Update the configuration and reset the centered view line\r\n            this._viewportStartLine = -1;\r\n            this._configuration.setMaxLineNumber(this.model.getLineCount());\r\n            this._updateConfigurationViewLineCountNow();\r\n            // Recover viewport\r\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {\r\n                const modelRange = this.model._getTrackedRange(this._viewportStartLineTrackedRange);\r\n                if (modelRange) {\r\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\r\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\r\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStartLineDelta }, 1 /* Immediate */);\r\n                }\r\n            }\r\n            try {\r\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\r\n                this._cursor.onModelContentChanged(eventsCollector, e);\r\n            }\r\n            finally {\r\n                this._eventDispatcher.endEmitViewEvents();\r\n            }\r\n        }));\r\n        this._register(this.model.onDidChangeTokens((e) => {\r\n            let viewRanges = [];\r\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\r\n                const modelRange = e.ranges[j];\r\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\r\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\r\n                viewRanges[j] = {\r\n                    fromLineNumber: viewStartLineNumber,\r\n                    toLineNumber: viewEndLineNumber\r\n                };\r\n            }\r\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\r\n            if (e.tokenizationSupportChanged) {\r\n                this._tokenizeViewportSoon.schedule();\r\n            }\r\n        }));\r\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\r\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\r\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\r\n            this._cursor.updateConfiguration(this.cursorConfig);\r\n        }));\r\n        this._register(this.model.onDidChangeLanguage((e) => {\r\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\r\n            this._cursor.updateConfiguration(this.cursorConfig);\r\n        }));\r\n        this._register(this.model.onDidChangeOptions((e) => {\r\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\r\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\r\n                try {\r\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\r\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\r\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\r\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\r\n                    this._cursor.onLineMappingChanged(eventsCollector);\r\n                    this._decorations.onLineMappingChanged();\r\n                    this.viewLayout.onFlushed(this.getLineCount());\r\n                }\r\n                finally {\r\n                    this._eventDispatcher.endEmitViewEvents();\r\n                }\r\n                this._updateConfigurationViewLineCount.schedule();\r\n            }\r\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageIdentifier(), this.model.getOptions(), this._configuration);\r\n            this._cursor.updateConfiguration(this.cursorConfig);\r\n        }));\r\n        this._register(this.model.onDidChangeDecorations((e) => {\r\n            this._decorations.onModelDecorationsChanged();\r\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\r\n        }));\r\n    }\r\n    setHiddenAreas(ranges) {\r\n        try {\r\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\r\n            let lineMappingChanged = this._lines.setHiddenAreas(ranges);\r\n            if (lineMappingChanged) {\r\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\r\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\r\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\r\n                this._cursor.onLineMappingChanged(eventsCollector);\r\n                this._decorations.onLineMappingChanged();\r\n                this.viewLayout.onFlushed(this.getLineCount());\r\n                this.viewLayout.onHeightMaybeChanged();\r\n            }\r\n        }\r\n        finally {\r\n            this._eventDispatcher.endEmitViewEvents();\r\n        }\r\n        this._updateConfigurationViewLineCount.schedule();\r\n    }\r\n    getVisibleRangesPlusViewportAboveBelow() {\r\n        const layoutInfo = this._configuration.options.get(124 /* layoutInfo */);\r\n        const lineHeight = this._configuration.options.get(53 /* lineHeight */);\r\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\r\n        const partialData = this.viewLayout.getLinesViewportData();\r\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\r\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\r\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\r\n    }\r\n    getVisibleRanges() {\r\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\r\n        return this._toModelVisibleRanges(visibleViewRange);\r\n    }\r\n    _toModelVisibleRanges(visibleViewRange) {\r\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\r\n        const hiddenAreas = this._lines.getHiddenAreas();\r\n        if (hiddenAreas.length === 0) {\r\n            return [visibleRange];\r\n        }\r\n        let result = [], resultLen = 0;\r\n        let startLineNumber = visibleRange.startLineNumber;\r\n        let startColumn = visibleRange.startColumn;\r\n        let endLineNumber = visibleRange.endLineNumber;\r\n        let endColumn = visibleRange.endColumn;\r\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\r\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\r\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\r\n            if (hiddenEndLineNumber < startLineNumber) {\r\n                continue;\r\n            }\r\n            if (hiddenStartLineNumber > endLineNumber) {\r\n                continue;\r\n            }\r\n            if (startLineNumber < hiddenStartLineNumber) {\r\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\r\n            }\r\n            startLineNumber = hiddenEndLineNumber + 1;\r\n            startColumn = 1;\r\n        }\r\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\r\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n        }\r\n        return result;\r\n    }\r\n    getCompletelyVisibleViewRange() {\r\n        const partialData = this.viewLayout.getLinesViewportData();\r\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\r\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\r\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\r\n    }\r\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\r\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\r\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\r\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\r\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\r\n    }\r\n    saveState() {\r\n        const compatViewState = this.viewLayout.saveState();\r\n        const scrollTop = compatViewState.scrollTop;\r\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\r\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\r\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\r\n        return {\r\n            scrollLeft: compatViewState.scrollLeft,\r\n            firstPosition: firstPosition,\r\n            firstPositionDeltaTop: firstPositionDeltaTop\r\n        };\r\n    }\r\n    reduceRestoreState(state) {\r\n        if (typeof state.firstPosition === 'undefined') {\r\n            // This is a view state serialized by an older version\r\n            return this._reduceRestoreStateCompatibility(state);\r\n        }\r\n        const modelPosition = this.model.validatePosition(state.firstPosition);\r\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\r\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\r\n        return {\r\n            scrollLeft: state.scrollLeft,\r\n            scrollTop: scrollTop\r\n        };\r\n    }\r\n    _reduceRestoreStateCompatibility(state) {\r\n        return {\r\n            scrollLeft: state.scrollLeft,\r\n            scrollTop: state.scrollTopWithoutViewZones\r\n        };\r\n    }\r\n    getTabSize() {\r\n        return this.model.getOptions().tabSize;\r\n    }\r\n    getTextModelOptions() {\r\n        return this.model.getOptions();\r\n    }\r\n    getLineCount() {\r\n        return this._lines.getViewLineCount();\r\n    }\r\n    /**\r\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\r\n     */\r\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\r\n        this._viewportStartLine = startLineNumber;\r\n        let position = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, this.getLineMinColumn(startLineNumber)));\r\n        this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* NeverGrowsWhenTypingAtEdges */);\r\n        const viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\r\n        const scrollTop = this.viewLayout.getCurrentScrollTop();\r\n        this._viewportStartLineDelta = scrollTop - viewportStartLineTop;\r\n    }\r\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\r\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\r\n    }\r\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\r\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\r\n    }\r\n    getLineContent(lineNumber) {\r\n        return this._lines.getViewLineContent(lineNumber);\r\n    }\r\n    getLineLength(lineNumber) {\r\n        return this._lines.getViewLineLength(lineNumber);\r\n    }\r\n    getLineMinColumn(lineNumber) {\r\n        return this._lines.getViewLineMinColumn(lineNumber);\r\n    }\r\n    getLineMaxColumn(lineNumber) {\r\n        return this._lines.getViewLineMaxColumn(lineNumber);\r\n    }\r\n    getLineFirstNonWhitespaceColumn(lineNumber) {\r\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\r\n        if (result === -1) {\r\n            return 0;\r\n        }\r\n        return result + 1;\r\n    }\r\n    getLineLastNonWhitespaceColumn(lineNumber) {\r\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\r\n        if (result === -1) {\r\n            return 0;\r\n        }\r\n        return result + 2;\r\n    }\r\n    getDecorationsInViewport(visibleRange) {\r\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\r\n    }\r\n    getViewLineRenderingData(visibleRange, lineNumber) {\r\n        let mightContainRTL = this.model.mightContainRTL();\r\n        let mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\r\n        let tabSize = this.getTabSize();\r\n        let lineData = this._lines.getViewLineData(lineNumber);\r\n        let allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\r\n        let inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\r\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\r\n    }\r\n    getViewLineData(lineNumber) {\r\n        return this._lines.getViewLineData(lineNumber);\r\n    }\r\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\r\n        let result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\r\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\r\n    }\r\n    getAllOverviewRulerDecorations(theme) {\r\n        return this._lines.getAllOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options), theme);\r\n    }\r\n    invalidateOverviewRulerColorCache() {\r\n        const decorations = this.model.getOverviewRulerDecorations();\r\n        for (const decoration of decorations) {\r\n            const opts = decoration.options.overviewRuler;\r\n            if (opts) {\r\n                opts.invalidateCachedColor();\r\n            }\r\n        }\r\n    }\r\n    invalidateMinimapColorCache() {\r\n        const decorations = this.model.getAllDecorations();\r\n        for (const decoration of decorations) {\r\n            const opts = decoration.options.minimap;\r\n            if (opts) {\r\n                opts.invalidateCachedColor();\r\n            }\r\n        }\r\n    }\r\n    getValueInRange(range, eol) {\r\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\r\n        return this.model.getValueInRange(modelRange, eol);\r\n    }\r\n    getModelLineMaxColumn(modelLineNumber) {\r\n        return this.model.getLineMaxColumn(modelLineNumber);\r\n    }\r\n    validateModelPosition(position) {\r\n        return this.model.validatePosition(position);\r\n    }\r\n    validateModelRange(range) {\r\n        return this.model.validateRange(range);\r\n    }\r\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\r\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\r\n        if (this.model.getEOL().length === 2) {\r\n            // This model uses CRLF, so the delta must take that into account\r\n            if (deltaOffset < 0) {\r\n                deltaOffset -= lineFeedCnt;\r\n            }\r\n            else {\r\n                deltaOffset += lineFeedCnt;\r\n            }\r\n        }\r\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\r\n        const resultOffset = modelAnchorOffset + deltaOffset;\r\n        return this.model.getPositionAt(resultOffset);\r\n    }\r\n    getEOL() {\r\n        return this.model.getEOL();\r\n    }\r\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\r\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\r\n        modelRanges = modelRanges.slice(0);\r\n        modelRanges.sort(Range.compareRangesUsingStarts);\r\n        let hasEmptyRange = false;\r\n        let hasNonEmptyRange = false;\r\n        for (const range of modelRanges) {\r\n            if (range.isEmpty()) {\r\n                hasEmptyRange = true;\r\n            }\r\n            else {\r\n                hasNonEmptyRange = true;\r\n            }\r\n        }\r\n        if (!hasNonEmptyRange) {\r\n            // all ranges are empty\r\n            if (!emptySelectionClipboard) {\r\n                return '';\r\n            }\r\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\r\n            let result = '';\r\n            for (let i = 0; i < modelLineNumbers.length; i++) {\r\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\r\n                    continue;\r\n                }\r\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\r\n            }\r\n            return result;\r\n        }\r\n        if (hasEmptyRange && emptySelectionClipboard) {\r\n            // mixed empty selections and non-empty selections\r\n            let result = [];\r\n            let prevModelLineNumber = 0;\r\n            for (const modelRange of modelRanges) {\r\n                const modelLineNumber = modelRange.startLineNumber;\r\n                if (modelRange.isEmpty()) {\r\n                    if (modelLineNumber !== prevModelLineNumber) {\r\n                        result.push(this.model.getLineContent(modelLineNumber));\r\n                    }\r\n                }\r\n                else {\r\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\r\n                }\r\n                prevModelLineNumber = modelLineNumber;\r\n            }\r\n            return result.length === 1 ? result[0] : result;\r\n        }\r\n        let result = [];\r\n        for (const modelRange of modelRanges) {\r\n            if (!modelRange.isEmpty()) {\r\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\r\n            }\r\n        }\r\n        return result.length === 1 ? result[0] : result;\r\n    }\r\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\r\n        const languageId = this.model.getLanguageIdentifier();\r\n        if (languageId.id === 1 /* PlainText */) {\r\n            return null;\r\n        }\r\n        if (modelRanges.length !== 1) {\r\n            // no multiple selection support at this time\r\n            return null;\r\n        }\r\n        let range = modelRanges[0];\r\n        if (range.isEmpty()) {\r\n            if (!emptySelectionClipboard) {\r\n                // nothing to copy\r\n                return null;\r\n            }\r\n            const lineNumber = range.startLineNumber;\r\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\r\n        }\r\n        const fontInfo = this._configuration.options.get(38 /* fontInfo */);\r\n        const colorMap = this._getColorMap();\r\n        const fontFamily = fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily ? fontInfo.fontFamily : `'${fontInfo.fontFamily}', ${EDITOR_FONT_DEFAULTS.fontFamily}`;\r\n        return {\r\n            mode: languageId.language,\r\n            html: (`<div style=\"`\r\n                + `color: ${colorMap[1 /* DefaultForeground */]};`\r\n                + `background-color: ${colorMap[2 /* DefaultBackground */]};`\r\n                + `font-family: ${fontFamily};`\r\n                + `font-weight: ${fontInfo.fontWeight};`\r\n                + `font-size: ${fontInfo.fontSize}px;`\r\n                + `line-height: ${fontInfo.lineHeight}px;`\r\n                + `white-space: pre;`\r\n                + `\">`\r\n                + this._getHTMLToCopy(range, colorMap)\r\n                + '</div>')\r\n        };\r\n    }\r\n    _getHTMLToCopy(modelRange, colorMap) {\r\n        const startLineNumber = modelRange.startLineNumber;\r\n        const startColumn = modelRange.startColumn;\r\n        const endLineNumber = modelRange.endLineNumber;\r\n        const endColumn = modelRange.endColumn;\r\n        const tabSize = this.getTabSize();\r\n        let result = '';\r\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            const lineTokens = this.model.getLineTokens(lineNumber);\r\n            const lineContent = lineTokens.getLineContent();\r\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\r\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\r\n            if (lineContent === '') {\r\n                result += '<br>';\r\n            }\r\n            else {\r\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    _getColorMap() {\r\n        let colorMap = TokenizationRegistry.getColorMap();\r\n        let result = ['#000000'];\r\n        if (colorMap) {\r\n            for (let i = 1, len = colorMap.length; i < len; i++) {\r\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    //#region model\r\n    pushStackElement() {\r\n        this.model.pushStackElement();\r\n    }\r\n    //#endregion\r\n    //#region cursor operations\r\n    getPrimaryCursorState() {\r\n        return this._cursor.getPrimaryCursorState();\r\n    }\r\n    getLastAddedCursorIndex() {\r\n        return this._cursor.getLastAddedCursorIndex();\r\n    }\r\n    getCursorStates() {\r\n        return this._cursor.getCursorStates();\r\n    }\r\n    setCursorStates(source, reason, states) {\r\n        this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\r\n    }\r\n    getCursorColumnSelectData() {\r\n        return this._cursor.getCursorColumnSelectData();\r\n    }\r\n    setCursorColumnSelectData(columnSelectData) {\r\n        this._cursor.setCursorColumnSelectData(columnSelectData);\r\n    }\r\n    getPrevEditOperationType() {\r\n        return this._cursor.getPrevEditOperationType();\r\n    }\r\n    setPrevEditOperationType(type) {\r\n        this._cursor.setPrevEditOperationType(type);\r\n    }\r\n    getSelection() {\r\n        return this._cursor.getSelection();\r\n    }\r\n    getSelections() {\r\n        return this._cursor.getSelections();\r\n    }\r\n    getPosition() {\r\n        return this._cursor.getPrimaryCursorState().modelState.position;\r\n    }\r\n    setSelections(source, selections, reason = 0 /* NotSet */) {\r\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\r\n    }\r\n    saveCursorState() {\r\n        return this._cursor.saveState();\r\n    }\r\n    restoreCursorState(states) {\r\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\r\n    }\r\n    _executeCursorEdit(callback) {\r\n        if (this._cursor.context.cursorConfig.readOnly) {\r\n            // we cannot edit when read only...\r\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\r\n            return;\r\n        }\r\n        this._withViewEventsCollector(callback);\r\n    }\r\n    executeEdits(source, edits, cursorStateComputer) {\r\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\r\n    }\r\n    startComposition() {\r\n        this._cursor.setIsDoingComposition(true);\r\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\r\n    }\r\n    endComposition(source) {\r\n        this._cursor.setIsDoingComposition(false);\r\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\r\n    }\r\n    type(text, source) {\r\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\r\n    }\r\n    replacePreviousChar(text, replaceCharCnt, source) {\r\n        this._executeCursorEdit(eventsCollector => this._cursor.replacePreviousChar(eventsCollector, text, replaceCharCnt, source));\r\n    }\r\n    paste(text, pasteOnNewLine, multicursorText, source) {\r\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\r\n    }\r\n    cut(source) {\r\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\r\n    }\r\n    executeCommand(command, source) {\r\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\r\n    }\r\n    executeCommands(commands, source) {\r\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\r\n    }\r\n    revealPrimaryCursor(source, revealHorizontal) {\r\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, revealHorizontal, 0 /* Smooth */));\r\n    }\r\n    revealTopMostCursor(source) {\r\n        const viewPosition = this._cursor.getTopMostViewPosition();\r\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\r\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\r\n    }\r\n    revealBottomMostCursor(source) {\r\n        const viewPosition = this._cursor.getBottomMostViewPosition();\r\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\r\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\r\n    }\r\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\r\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, viewRange, null, verticalType, revealHorizontal, scrollType)));\r\n    }\r\n    //#endregion\r\n    //#region viewLayout\r\n    getVerticalOffsetForLineNumber(viewLineNumber) {\r\n        return this.viewLayout.getVerticalOffsetForLineNumber(viewLineNumber);\r\n    }\r\n    getScrollTop() {\r\n        return this.viewLayout.getCurrentScrollTop();\r\n    }\r\n    setScrollTop(newScrollTop, scrollType) {\r\n        this.viewLayout.setScrollPosition({ scrollTop: newScrollTop }, scrollType);\r\n    }\r\n    setScrollPosition(position, type) {\r\n        this.viewLayout.setScrollPosition(position, type);\r\n    }\r\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\r\n        this.viewLayout.deltaScrollNow(deltaScrollLeft, deltaScrollTop);\r\n    }\r\n    changeWhitespace(callback) {\r\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\r\n        if (hadAChange) {\r\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\r\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\r\n        }\r\n    }\r\n    setMaxLineWidth(maxLineWidth) {\r\n        this.viewLayout.setMaxLineWidth(maxLineWidth);\r\n    }\r\n    //#endregion\r\n    _withViewEventsCollector(callback) {\r\n        try {\r\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\r\n            callback(eventsCollector);\r\n        }\r\n        finally {\r\n            this._eventDispatcher.endEmitViewEvents();\r\n        }\r\n    }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,KAAK,QAAQ,+BAA+B;AACrD,SAASC,UAAU,QAAQ,mCAAmC;AAC9D,OAAO,KAAKC,OAAO,MAAM,iCAAiC;AAC1D,SAASC,oBAAoB,EAAEC,2BAA2B,QAAQ,4BAA4B;AAC9F,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,oBAAoB,QAAQ,aAAa;AAClD,SAASC,kBAAkB,QAAQ,iCAAiC;AACpE,SAASC,yBAAyB,QAAQ,gCAAgC;AAC1E,OAAO,KAAKC,UAAU,MAAM,uBAAuB;AACnD,SAASC,UAAU,QAAQ,6BAA6B;AACxD,SAASC,uBAAuB,EAAEC,oBAAoB,QAAQ,2BAA2B;AACzF,SAASC,yBAAyB,EAAEC,qBAAqB,QAAQ,gBAAgB;AACjF,SAASC,oBAAoB,QAAQ,2BAA2B;AAChE,SAASC,gBAAgB,QAAQ,+BAA+B;AAChE,OAAO,KAAKC,QAAQ,MAAM,kCAAkC;AAC5D,SAASC,MAAM,QAAQ,yBAAyB;AAChD,SAASC,mBAAmB,QAAQ,+BAA+B;AACnE,SAASC,wBAAwB,EAAEC,iBAAiB,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAEC,wBAAwB,QAAQ,+BAA+B;AAChK,MAAMC,6BAA6B,GAAG,IAAI;AAC1C,OAAO,MAAMC,SAAS,SAAS1B,UAAU,CAAC;EACtC2B,WAAWA,CAACC,QAAQ,EAAEC,aAAa,EAAEC,KAAK,EAAEC,4BAA4B,EAAEC,kCAAkC,EAAEC,4BAA4B,EAAE;IACxI,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,SAAS,GAAGN,QAAQ;IACzB,IAAI,CAACO,cAAc,GAAGN,aAAa;IACnC,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACM,gBAAgB,GAAG,IAAIhB,wBAAwB,CAAC,CAAC;IACtD,IAAI,CAACiB,OAAO,GAAG,IAAI,CAACD,gBAAgB,CAACC,OAAO;IAC5C,IAAI,CAACC,YAAY,GAAG,IAAInB,mBAAmB,CAAC,IAAI,CAACW,KAAK,CAACS,qBAAqB,CAAC,CAAC,EAAE,IAAI,CAACT,KAAK,CAACU,UAAU,CAAC,CAAC,EAAE,IAAI,CAACL,cAAc,CAAC;IAC7H,IAAI,CAACM,qBAAqB,GAAG,IAAI,CAACC,SAAS,CAAC,IAAI1B,gBAAgB,CAAC,MAAM,IAAI,CAAC2B,gBAAgB,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACpG,IAAI,CAACC,iCAAiC,GAAG,IAAI,CAACF,SAAS,CAAC,IAAI1B,gBAAgB,CAAC,MAAM,IAAI,CAAC6B,oCAAoC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnI,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,kBAAkB,GAAG,CAAC,CAAC;IAC5B,IAAI,CAACC,8BAA8B,GAAG,IAAI;IAC1C,IAAI,CAACC,uBAAuB,GAAG,CAAC;IAChC,IAAIxB,6BAA6B,IAAI,IAAI,CAACK,KAAK,CAACoB,yBAAyB,CAAC,CAAC,EAAE;MACzE,IAAI,CAACC,MAAM,GAAG,IAAIxC,uBAAuB,CAAC,IAAI,CAACmB,KAAK,CAAC;IACzD,CAAC,MACI;MACD,MAAMsB,OAAO,GAAG,IAAI,CAACjB,cAAc,CAACiB,OAAO;MAC3C,MAAMC,QAAQ,GAAGD,OAAO,CAACE,GAAG,CAAC,EAAE,CAAC,cAAc,CAAC;MAC/C,MAAMC,gBAAgB,GAAGH,OAAO,CAACE,GAAG,CAAC,GAAG,CAAC,sBAAsB,CAAC;MAChE,MAAME,YAAY,GAAGJ,OAAO,CAACE,GAAG,CAAC,GAAG,CAAC,kBAAkB,CAAC;MACxD,MAAMG,cAAc,GAAGL,OAAO,CAACE,GAAG,CAAC,GAAG,CAAC,oBAAoB,CAAC;MAC5D,IAAI,CAACH,MAAM,GAAG,IAAIvC,oBAAoB,CAAC,IAAI,CAACkB,KAAK,EAAEC,4BAA4B,EAAEC,kCAAkC,EAAEqB,QAAQ,EAAE,IAAI,CAACvB,KAAK,CAACU,UAAU,CAAC,CAAC,CAACkB,OAAO,EAAEH,gBAAgB,EAAEC,YAAY,CAACG,cAAc,EAAEF,cAAc,CAAC;IAClO;IACA,IAAI,CAACG,oBAAoB,GAAG,IAAI,CAACT,MAAM,CAACU,0BAA0B,CAAC,CAAC;IACpE,IAAI,CAACC,OAAO,GAAG,IAAI,CAACpB,SAAS,CAAC,IAAIxB,MAAM,CAACY,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC8B,oBAAoB,EAAE,IAAI,CAACtB,YAAY,CAAC,CAAC;IACpG,IAAI,CAACyB,UAAU,GAAG,IAAI,CAACrB,SAAS,CAAC,IAAIhC,UAAU,CAAC,IAAI,CAACyB,cAAc,EAAE,IAAI,CAAC6B,YAAY,CAAC,CAAC,EAAE/B,4BAA4B,CAAC,CAAC;IACxH,IAAI,CAACS,SAAS,CAAC,IAAI,CAACqB,UAAU,CAACE,WAAW,CAAEC,CAAC,IAAK;MAC9C,IAAIA,CAAC,CAACC,gBAAgB,EAAE;QACpB,IAAI,CAAC1B,qBAAqB,CAAC2B,QAAQ,CAAC,CAAC;MACzC;MACA,IAAI,CAAChC,gBAAgB,CAACiC,mBAAmB,CAAC,IAAI5D,UAAU,CAAC6D,sBAAsB,CAACJ,CAAC,CAAC,CAAC;MACnF,IAAI,CAAC9B,gBAAgB,CAACmC,iBAAiB,CAAC,IAAIjD,kBAAkB,CAAC4C,CAAC,CAACM,cAAc,EAAEN,CAAC,CAACO,aAAa,EAAEP,CAAC,CAACQ,eAAe,EAAER,CAAC,CAACS,YAAY,EAAET,CAAC,CAACU,WAAW,EAAEV,CAAC,CAACW,UAAU,EAAEX,CAAC,CAACY,YAAY,EAAEZ,CAAC,CAACa,SAAS,CAAC,CAAC;IACnM,CAAC,CAAC,CAAC;IACH,IAAI,CAACrC,SAAS,CAAC,IAAI,CAACqB,UAAU,CAACiB,sBAAsB,CAAEd,CAAC,IAAK;MACzD,IAAI,CAAC9B,gBAAgB,CAACmC,iBAAiB,CAACL,CAAC,CAAC;IAC9C,CAAC,CAAC,CAAC;IACH,IAAI,CAACe,YAAY,GAAG,IAAIlE,oBAAoB,CAAC,IAAI,CAACmB,SAAS,EAAE,IAAI,CAACJ,KAAK,EAAE,IAAI,CAACK,cAAc,EAAE,IAAI,CAACgB,MAAM,EAAE,IAAI,CAACS,oBAAoB,CAAC;IACrI,IAAI,CAACsB,oBAAoB,CAAC,CAAC;IAC3B,IAAI,CAACxC,SAAS,CAAC,IAAI,CAACP,cAAc,CAACgD,eAAe,CAAEjB,CAAC,IAAK;MACtD,IAAI;QACA,MAAMkB,eAAe,GAAG,IAAI,CAAChD,gBAAgB,CAACiD,mBAAmB,CAAC,CAAC;QACnE,IAAI,CAACC,uBAAuB,CAACF,eAAe,EAAElB,CAAC,CAAC;MACpD,CAAC,SACO;QACJ,IAAI,CAAC9B,gBAAgB,CAACmD,iBAAiB,CAAC,CAAC;MAC7C;IACJ,CAAC,CAAC,CAAC;IACH,IAAI,CAAC7C,SAAS,CAAClC,yBAAyB,CAACgF,WAAW,CAAC,CAAC,CAACC,WAAW,CAAC,MAAM;MACrE,IAAI,CAACrD,gBAAgB,CAACiC,mBAAmB,CAAC,IAAI5D,UAAU,CAACiF,4BAA4B,CAAC,CAAC,CAAC;IAC5F,CAAC,CAAC,CAAC;IACH,IAAI,CAAC7C,oCAAoC,CAAC,CAAC;EAC/C;EACA8C,OAAOA,CAAA,EAAG;IACN;IACA;IACA,KAAK,CAACA,OAAO,CAAC,CAAC;IACf,IAAI,CAACV,YAAY,CAACU,OAAO,CAAC,CAAC;IAC3B,IAAI,CAACxC,MAAM,CAACwC,OAAO,CAAC,CAAC;IACrB,IAAI,CAACC,2BAA2B,CAAC,CAAC;IAClC,IAAI,CAAC5C,8BAA8B,GAAG,IAAI,CAAClB,KAAK,CAAC+D,gBAAgB,CAAC,IAAI,CAAC7C,8BAA8B,EAAE,IAAI,EAAE,CAAC,CAAC,iCAAiC,CAAC;IACjJ,IAAI,CAACZ,gBAAgB,CAACuD,OAAO,CAAC,CAAC;EACnC;EACAG,wBAAwBA,CAAA,EAAG;IACvB,OAAO,IAAI,CAAC3C,MAAM,CAAC2C,wBAAwB,CAAC,CAAC;EACjD;EACAC,mBAAmBA,CAACC,YAAY,EAAE;IAC9B,IAAI,CAAC5D,gBAAgB,CAAC2D,mBAAmB,CAACC,YAAY,CAAC;EAC3D;EACAC,sBAAsBA,CAACD,YAAY,EAAE;IACjC,IAAI,CAAC5D,gBAAgB,CAAC6D,sBAAsB,CAACD,YAAY,CAAC;EAC9D;EACAnD,oCAAoCA,CAAA,EAAG;IACnC,IAAI,CAACV,cAAc,CAAC+D,gBAAgB,CAAC,IAAI,CAAC/C,MAAM,CAACgD,gBAAgB,CAAC,CAAC,CAAC;EACxE;EACAxD,gBAAgBA,CAAA,EAAG;IACf,MAAMyD,iBAAiB,GAAG,IAAI,CAACrC,UAAU,CAACsC,oBAAoB,CAAC,CAAC;IAChE,MAAMC,aAAa,GAAG,IAAI,CAAC1C,oBAAoB,CAAC2C,kCAAkC,CAAC,IAAInG,QAAQ,CAACgG,iBAAiB,CAACI,eAAe,EAAE,CAAC,CAAC,CAAC;IACtI,MAAMC,WAAW,GAAG,IAAI,CAAC7C,oBAAoB,CAAC2C,kCAAkC,CAAC,IAAInG,QAAQ,CAACgG,iBAAiB,CAACM,aAAa,EAAE,CAAC,CAAC,CAAC;IAClI,IAAI,CAAC5E,KAAK,CAACa,gBAAgB,CAAC2D,aAAa,CAACK,UAAU,EAAEF,WAAW,CAACE,UAAU,CAAC;EACjF;EACAC,WAAWA,CAACC,QAAQ,EAAE;IAClB,IAAI,CAAC/D,SAAS,GAAG+D,QAAQ;IACzB,IAAI,CAAC/C,OAAO,CAAC8C,WAAW,CAACC,QAAQ,CAAC;IAClC,IAAI,CAACzE,gBAAgB,CAACiC,mBAAmB,CAAC,IAAI5D,UAAU,CAACqG,qBAAqB,CAACD,QAAQ,CAAC,CAAC;IACzF,IAAI,CAACzE,gBAAgB,CAACmC,iBAAiB,CAAC,IAAIlD,iBAAiB,CAAC,CAACwF,QAAQ,EAAEA,QAAQ,CAAC,CAAC;EACvF;EACAE,kBAAkBA,CAAA,EAAG;IACjB,IAAI,CAAC3E,gBAAgB,CAACiC,mBAAmB,CAAC,IAAI5D,UAAU,CAACuG,yBAAyB,CAAC,CAAC,CAAC;EACzF;EACAC,gBAAgBA,CAAA,EAAG;IACf,IAAI,CAAC7E,gBAAgB,CAACiC,mBAAmB,CAAC,IAAI5D,UAAU,CAACyG,uBAAuB,CAAC,CAAC,CAAC;EACvF;EACAC,qBAAqBA,CAAA,EAAG;IACpB,IAAI,CAAC/E,gBAAgB,CAACiC,mBAAmB,CAAC,IAAI5D,UAAU,CAAC2G,qBAAqB,CAAC,CAAC,CAAC;EACrF;EACA9B,uBAAuBA,CAACF,eAAe,EAAElB,CAAC,EAAE;IACxC;IACA,IAAImD,kCAAkC,GAAG,IAAI;IAC7C,IAAI,IAAI,CAACtE,kBAAkB,KAAK,CAAC,CAAC,EAAE;MAChC,IAAIuE,iCAAiC,GAAG,IAAIlH,QAAQ,CAAC,IAAI,CAAC2C,kBAAkB,EAAE,IAAI,CAACwE,gBAAgB,CAAC,IAAI,CAACxE,kBAAkB,CAAC,CAAC;MAC7HsE,kCAAkC,GAAG,IAAI,CAACzD,oBAAoB,CAAC2C,kCAAkC,CAACe,iCAAiC,CAAC;IACxI;IACA,IAAIE,4BAA4B,GAAG,KAAK;IACxC,MAAMpE,OAAO,GAAG,IAAI,CAACjB,cAAc,CAACiB,OAAO;IAC3C,MAAMC,QAAQ,GAAGD,OAAO,CAACE,GAAG,CAAC,EAAE,CAAC,cAAc,CAAC;IAC/C,MAAMC,gBAAgB,GAAGH,OAAO,CAACE,GAAG,CAAC,GAAG,CAAC,sBAAsB,CAAC;IAChE,MAAME,YAAY,GAAGJ,OAAO,CAACE,GAAG,CAAC,GAAG,CAAC,kBAAkB,CAAC;IACxD,MAAMG,cAAc,GAAGL,OAAO,CAACE,GAAG,CAAC,GAAG,CAAC,oBAAoB,CAAC;IAC5D,IAAI,IAAI,CAACH,MAAM,CAACsE,mBAAmB,CAACpE,QAAQ,EAAEE,gBAAgB,EAAEC,YAAY,CAACG,cAAc,EAAEF,cAAc,CAAC,EAAE;MAC1G2B,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACkH,gBAAgB,CAAC,CAAC,CAAC;MAChEvC,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACmH,2BAA2B,CAAC,CAAC,CAAC;MAC3ExC,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACoH,2BAA2B,CAAC,IAAI,CAAC,CAAC;MAC/E,IAAI,CAAC/D,OAAO,CAACgE,oBAAoB,CAAC1C,eAAe,CAAC;MAClD,IAAI,CAACH,YAAY,CAAC6C,oBAAoB,CAAC,CAAC;MACxC,IAAI,CAAC/D,UAAU,CAACgE,SAAS,CAAC,IAAI,CAAC/D,YAAY,CAAC,CAAC,CAAC;MAC9C,IAAI,IAAI,CAACD,UAAU,CAACiE,mBAAmB,CAAC,CAAC,KAAK,CAAC,EAAE;QAC7C;QACAR,4BAA4B,GAAG,IAAI;MACvC;MACA,IAAI,CAAC5E,iCAAiC,CAACwB,QAAQ,CAAC,CAAC;IACrD;IACA,IAAIF,CAAC,CAAC+D,UAAU,CAAC,EAAE,CAAC,cAAc,CAAC,EAAE;MACjC;MACA,IAAI,CAAChD,YAAY,CAACiD,KAAK,CAAC,CAAC;MACzB9C,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACoH,2BAA2B,CAAC,IAAI,CAAC,CAAC;IACnF;IACAzC,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAAC0H,6BAA6B,CAACjE,CAAC,CAAC,CAAC;IAC9E,IAAI,CAACH,UAAU,CAACqE,sBAAsB,CAAClE,CAAC,CAAC;IACzC,IAAIsD,4BAA4B,IAAIH,kCAAkC,EAAE;MACpE,MAAMgB,YAAY,GAAG,IAAI,CAACzE,oBAAoB,CAAC0E,kCAAkC,CAACjB,kCAAkC,CAAC;MACrH,MAAMkB,eAAe,GAAG,IAAI,CAACxE,UAAU,CAACyE,8BAA8B,CAACH,YAAY,CAAC1B,UAAU,CAAC;MAC/F,IAAI,CAAC5C,UAAU,CAAC0E,iBAAiB,CAAC;QAAE1D,SAAS,EAAEwD,eAAe,GAAG,IAAI,CAACtF;MAAwB,CAAC,EAAE,CAAC,CAAC,eAAe,CAAC;IACvH;;IACA,IAAI9B,mBAAmB,CAACuH,cAAc,CAACxE,CAAC,CAAC,EAAE;MACvC,IAAI,CAAC5B,YAAY,GAAG,IAAInB,mBAAmB,CAAC,IAAI,CAACW,KAAK,CAACS,qBAAqB,CAAC,CAAC,EAAE,IAAI,CAACT,KAAK,CAACU,UAAU,CAAC,CAAC,EAAE,IAAI,CAACL,cAAc,CAAC;MAC7H,IAAI,CAAC2B,OAAO,CAAC6E,mBAAmB,CAAC,IAAI,CAACrG,YAAY,CAAC;IACvD;EACJ;EACA4C,oBAAoBA,CAAA,EAAG;IACnB,IAAI,CAACxC,SAAS,CAAC,IAAI,CAACZ,KAAK,CAAC8G,yBAAyB,CAAE1E,CAAC,IAAK;MACvD,IAAI;QACA,MAAMkB,eAAe,GAAG,IAAI,CAAChD,gBAAgB,CAACiD,mBAAmB,CAAC,CAAC;QACnE,IAAIwD,mBAAmB,GAAG,KAAK;QAC/B,IAAIC,wCAAwC,GAAG,KAAK;QACpD,MAAMC,OAAO,GAAG7E,CAAC,CAAC6E,OAAO;QACzB,MAAMC,SAAS,GAAG9E,CAAC,CAAC8E,SAAS;QAC7B;QACA,MAAMC,kBAAkB,GAAG,IAAI,CAAC9F,MAAM,CAAC2C,wBAAwB,CAAC,CAAC;QACjE,KAAK,MAAMoD,MAAM,IAAIH,OAAO,EAAE;UAC1B,QAAQG,MAAM,CAACC,UAAU;YACrB,KAAK,CAAC,CAAC;cAAqB;gBACxB,KAAK,MAAMC,IAAI,IAAIF,MAAM,CAACG,MAAM,EAAE;kBAC9BJ,kBAAkB,CAACK,UAAU,CAACF,IAAI,EAAE,IAAI,CAAC;gBAC7C;gBACA;cACJ;YACA,KAAK,CAAC,CAAC;cAAmB;gBACtBH,kBAAkB,CAACK,UAAU,CAACJ,MAAM,CAACG,MAAM,EAAE,IAAI,CAAC;gBAClD;cACJ;UACJ;QACJ;QACA,MAAME,UAAU,GAAGN,kBAAkB,CAACO,QAAQ,CAAC,CAAC;QAChD,IAAIC,gBAAgB,GAAG,CAAC;QACxB,KAAK,MAAMP,MAAM,IAAIH,OAAO,EAAE;UAC1B,QAAQG,MAAM,CAACC,UAAU;YACrB,KAAK,CAAC,CAAC;cAAa;gBAChB,IAAI,CAAChG,MAAM,CAACuG,cAAc,CAAC,CAAC;gBAC5BtE,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACkH,gBAAgB,CAAC,CAAC,CAAC;gBAChE,IAAI,CAAC1C,YAAY,CAACiD,KAAK,CAAC,CAAC;gBACzB,IAAI,CAACnE,UAAU,CAACgE,SAAS,CAAC,IAAI,CAAC/D,YAAY,CAAC,CAAC,CAAC;gBAC9C6E,mBAAmB,GAAG,IAAI;gBAC1B;cACJ;YACA,KAAK,CAAC,CAAC;cAAoB;gBACvB,MAAMc,iBAAiB,GAAG,IAAI,CAACxG,MAAM,CAACyG,mBAAmB,CAACZ,SAAS,EAAEE,MAAM,CAACW,cAAc,EAAEX,MAAM,CAACY,YAAY,CAAC;gBAChH,IAAIH,iBAAiB,KAAK,IAAI,EAAE;kBAC5BvE,eAAe,CAACsC,aAAa,CAACiC,iBAAiB,CAAC;kBAChD,IAAI,CAAC5F,UAAU,CAACgG,cAAc,CAACJ,iBAAiB,CAACE,cAAc,EAAEF,iBAAiB,CAACG,YAAY,CAAC;gBACpG;gBACAjB,mBAAmB,GAAG,IAAI;gBAC1B;cACJ;YACA,KAAK,CAAC,CAAC;cAAqB;gBACxB,MAAMmB,kBAAkB,GAAGT,UAAU,CAACU,KAAK,CAACR,gBAAgB,EAAEA,gBAAgB,GAAGP,MAAM,CAACG,MAAM,CAACa,MAAM,CAAC;gBACtGT,gBAAgB,IAAIP,MAAM,CAACG,MAAM,CAACa,MAAM;gBACxC,MAAMC,kBAAkB,GAAG,IAAI,CAAChH,MAAM,CAACiH,oBAAoB,CAACpB,SAAS,EAAEE,MAAM,CAACW,cAAc,EAAEX,MAAM,CAACY,YAAY,EAAEE,kBAAkB,CAAC;gBACtI,IAAIG,kBAAkB,KAAK,IAAI,EAAE;kBAC7B/E,eAAe,CAACsC,aAAa,CAACyC,kBAAkB,CAAC;kBACjD,IAAI,CAACpG,UAAU,CAACsG,eAAe,CAACF,kBAAkB,CAACN,cAAc,EAAEM,kBAAkB,CAACL,YAAY,CAAC;gBACvG;gBACAjB,mBAAmB,GAAG,IAAI;gBAC1B;cACJ;YACA,KAAK,CAAC,CAAC;cAAmB;gBACtB,MAAMyB,oBAAoB,GAAGf,UAAU,CAACE,gBAAgB,CAAC;gBACzDA,gBAAgB,EAAE;gBAClB,MAAM,CAACc,kBAAkB,EAAEC,iBAAiB,EAAEL,kBAAkB,EAAER,iBAAiB,CAAC,GAAG,IAAI,CAACxG,MAAM,CAACsH,kBAAkB,CAACzB,SAAS,EAAEE,MAAM,CAACvC,UAAU,EAAE2D,oBAAoB,CAAC;gBACzKxB,wCAAwC,GAAGyB,kBAAkB;gBAC7D,IAAIC,iBAAiB,EAAE;kBACnBpF,eAAe,CAACsC,aAAa,CAAC8C,iBAAiB,CAAC;gBACpD;gBACA,IAAIL,kBAAkB,EAAE;kBACpB/E,eAAe,CAACsC,aAAa,CAACyC,kBAAkB,CAAC;kBACjD,IAAI,CAACpG,UAAU,CAACsG,eAAe,CAACF,kBAAkB,CAACN,cAAc,EAAEM,kBAAkB,CAACL,YAAY,CAAC;gBACvG;gBACA,IAAIH,iBAAiB,EAAE;kBACnBvE,eAAe,CAACsC,aAAa,CAACiC,iBAAiB,CAAC;kBAChD,IAAI,CAAC5F,UAAU,CAACgG,cAAc,CAACJ,iBAAiB,CAACE,cAAc,EAAEF,iBAAiB,CAACG,YAAY,CAAC;gBACpG;gBACA;cACJ;YACA,KAAK,CAAC,CAAC;cAAkB;gBACrB;gBACA;cACJ;UACJ;QACJ;QACA,IAAI,CAAC3G,MAAM,CAACuH,eAAe,CAAC1B,SAAS,CAAC;QACtC,IAAI,CAACjF,UAAU,CAAC4G,oBAAoB,CAAC,CAAC;QACtC,IAAI,CAAC9B,mBAAmB,IAAIC,wCAAwC,EAAE;UAClE1D,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACmH,2BAA2B,CAAC,CAAC,CAAC;UAC3ExC,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACoH,2BAA2B,CAAC,IAAI,CAAC,CAAC;UAC/E,IAAI,CAAC/D,OAAO,CAACgE,oBAAoB,CAAC1C,eAAe,CAAC;UAClD,IAAI,CAACH,YAAY,CAAC6C,oBAAoB,CAAC,CAAC;QAC5C;MACJ,CAAC,SACO;QACJ,IAAI,CAAC1F,gBAAgB,CAACmD,iBAAiB,CAAC,CAAC;MAC7C;MACA;MACA,IAAI,CAACxC,kBAAkB,GAAG,CAAC,CAAC;MAC5B,IAAI,CAACZ,cAAc,CAACyI,gBAAgB,CAAC,IAAI,CAAC9I,KAAK,CAACkC,YAAY,CAAC,CAAC,CAAC;MAC/D,IAAI,CAACnB,oCAAoC,CAAC,CAAC;MAC3C;MACA,IAAI,CAAC,IAAI,CAACC,SAAS,IAAI,IAAI,CAAChB,KAAK,CAAC+I,sBAAsB,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC7H,8BAA8B,EAAE;QACpG,MAAM8H,UAAU,GAAG,IAAI,CAAChJ,KAAK,CAACiJ,gBAAgB,CAAC,IAAI,CAAC/H,8BAA8B,CAAC;QACnF,IAAI8H,UAAU,EAAE;UACZ,MAAMzC,YAAY,GAAG,IAAI,CAACzE,oBAAoB,CAAC0E,kCAAkC,CAACwC,UAAU,CAACE,gBAAgB,CAAC,CAAC,CAAC;UAChH,MAAMzC,eAAe,GAAG,IAAI,CAACxE,UAAU,CAACyE,8BAA8B,CAACH,YAAY,CAAC1B,UAAU,CAAC;UAC/F,IAAI,CAAC5C,UAAU,CAAC0E,iBAAiB,CAAC;YAAE1D,SAAS,EAAEwD,eAAe,GAAG,IAAI,CAACtF;UAAwB,CAAC,EAAE,CAAC,CAAC,eAAe,CAAC;QACvH;MACJ;;MACA,IAAI;QACA,MAAMmC,eAAe,GAAG,IAAI,CAAChD,gBAAgB,CAACiD,mBAAmB,CAAC,CAAC;QACnE,IAAI,CAACvB,OAAO,CAACmH,qBAAqB,CAAC7F,eAAe,EAAElB,CAAC,CAAC;MAC1D,CAAC,SACO;QACJ,IAAI,CAAC9B,gBAAgB,CAACmD,iBAAiB,CAAC,CAAC;MAC7C;IACJ,CAAC,CAAC,CAAC;IACH,IAAI,CAAC7C,SAAS,CAAC,IAAI,CAACZ,KAAK,CAACoJ,iBAAiB,CAAEhH,CAAC,IAAK;MAC/C,IAAIiH,UAAU,GAAG,EAAE;MACnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGnH,CAAC,CAACoH,MAAM,CAACpB,MAAM,EAAEkB,CAAC,GAAGC,IAAI,EAAED,CAAC,EAAE,EAAE;QACnD,MAAMN,UAAU,GAAG5G,CAAC,CAACoH,MAAM,CAACF,CAAC,CAAC;QAC9B,MAAMG,mBAAmB,GAAG,IAAI,CAAC3H,oBAAoB,CAAC0E,kCAAkC,CAAC,IAAIlI,QAAQ,CAAC0K,UAAU,CAACjB,cAAc,EAAE,CAAC,CAAC,CAAC,CAAClD,UAAU;QAC/I,MAAM6E,iBAAiB,GAAG,IAAI,CAAC5H,oBAAoB,CAAC0E,kCAAkC,CAAC,IAAIlI,QAAQ,CAAC0K,UAAU,CAAChB,YAAY,EAAE,IAAI,CAAChI,KAAK,CAAC2J,gBAAgB,CAACX,UAAU,CAAChB,YAAY,CAAC,CAAC,CAAC,CAACnD,UAAU;QAC9LwE,UAAU,CAACC,CAAC,CAAC,GAAG;UACZvB,cAAc,EAAE0B,mBAAmB;UACnCzB,YAAY,EAAE0B;QAClB,CAAC;MACL;MACA,IAAI,CAACpJ,gBAAgB,CAACiC,mBAAmB,CAAC,IAAI5D,UAAU,CAACiL,sBAAsB,CAACP,UAAU,CAAC,CAAC;MAC5F,IAAIjH,CAAC,CAACyH,0BAA0B,EAAE;QAC9B,IAAI,CAAClJ,qBAAqB,CAAC2B,QAAQ,CAAC,CAAC;MACzC;IACJ,CAAC,CAAC,CAAC;IACH,IAAI,CAAC1B,SAAS,CAAC,IAAI,CAACZ,KAAK,CAAC8J,gCAAgC,CAAE1H,CAAC,IAAK;MAC9D,IAAI,CAAC9B,gBAAgB,CAACiC,mBAAmB,CAAC,IAAI5D,UAAU,CAACoL,8BAA8B,CAAC,CAAC,CAAC;MAC1F,IAAI,CAACvJ,YAAY,GAAG,IAAInB,mBAAmB,CAAC,IAAI,CAACW,KAAK,CAACS,qBAAqB,CAAC,CAAC,EAAE,IAAI,CAACT,KAAK,CAACU,UAAU,CAAC,CAAC,EAAE,IAAI,CAACL,cAAc,CAAC;MAC7H,IAAI,CAAC2B,OAAO,CAAC6E,mBAAmB,CAAC,IAAI,CAACrG,YAAY,CAAC;IACvD,CAAC,CAAC,CAAC;IACH,IAAI,CAACI,SAAS,CAAC,IAAI,CAACZ,KAAK,CAACgK,mBAAmB,CAAE5H,CAAC,IAAK;MACjD,IAAI,CAAC5B,YAAY,GAAG,IAAInB,mBAAmB,CAAC,IAAI,CAACW,KAAK,CAACS,qBAAqB,CAAC,CAAC,EAAE,IAAI,CAACT,KAAK,CAACU,UAAU,CAAC,CAAC,EAAE,IAAI,CAACL,cAAc,CAAC;MAC7H,IAAI,CAAC2B,OAAO,CAAC6E,mBAAmB,CAAC,IAAI,CAACrG,YAAY,CAAC;IACvD,CAAC,CAAC,CAAC;IACH,IAAI,CAACI,SAAS,CAAC,IAAI,CAACZ,KAAK,CAACiK,kBAAkB,CAAE7H,CAAC,IAAK;MAChD;MACA,IAAI,IAAI,CAACf,MAAM,CAAC6I,UAAU,CAAC,IAAI,CAAClK,KAAK,CAACU,UAAU,CAAC,CAAC,CAACkB,OAAO,CAAC,EAAE;QACzD,IAAI;UACA,MAAM0B,eAAe,GAAG,IAAI,CAAChD,gBAAgB,CAACiD,mBAAmB,CAAC,CAAC;UACnED,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACkH,gBAAgB,CAAC,CAAC,CAAC;UAChEvC,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACmH,2BAA2B,CAAC,CAAC,CAAC;UAC3ExC,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACoH,2BAA2B,CAAC,IAAI,CAAC,CAAC;UAC/E,IAAI,CAAC/D,OAAO,CAACgE,oBAAoB,CAAC1C,eAAe,CAAC;UAClD,IAAI,CAACH,YAAY,CAAC6C,oBAAoB,CAAC,CAAC;UACxC,IAAI,CAAC/D,UAAU,CAACgE,SAAS,CAAC,IAAI,CAAC/D,YAAY,CAAC,CAAC,CAAC;QAClD,CAAC,SACO;UACJ,IAAI,CAAC5B,gBAAgB,CAACmD,iBAAiB,CAAC,CAAC;QAC7C;QACA,IAAI,CAAC3C,iCAAiC,CAACwB,QAAQ,CAAC,CAAC;MACrD;MACA,IAAI,CAAC9B,YAAY,GAAG,IAAInB,mBAAmB,CAAC,IAAI,CAACW,KAAK,CAACS,qBAAqB,CAAC,CAAC,EAAE,IAAI,CAACT,KAAK,CAACU,UAAU,CAAC,CAAC,EAAE,IAAI,CAACL,cAAc,CAAC;MAC7H,IAAI,CAAC2B,OAAO,CAAC6E,mBAAmB,CAAC,IAAI,CAACrG,YAAY,CAAC;IACvD,CAAC,CAAC,CAAC;IACH,IAAI,CAACI,SAAS,CAAC,IAAI,CAACZ,KAAK,CAACmK,sBAAsB,CAAE/H,CAAC,IAAK;MACpD,IAAI,CAACe,YAAY,CAACiH,yBAAyB,CAAC,CAAC;MAC7C,IAAI,CAAC9J,gBAAgB,CAACiC,mBAAmB,CAAC,IAAI5D,UAAU,CAACoH,2BAA2B,CAAC3D,CAAC,CAAC,CAAC;IAC5F,CAAC,CAAC,CAAC;EACP;EACAiI,cAAcA,CAACb,MAAM,EAAE;IACnB,IAAI;MACA,MAAMlG,eAAe,GAAG,IAAI,CAAChD,gBAAgB,CAACiD,mBAAmB,CAAC,CAAC;MACnE,IAAIkF,kBAAkB,GAAG,IAAI,CAACpH,MAAM,CAACgJ,cAAc,CAACb,MAAM,CAAC;MAC3D,IAAIf,kBAAkB,EAAE;QACpBnF,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACkH,gBAAgB,CAAC,CAAC,CAAC;QAChEvC,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACmH,2BAA2B,CAAC,CAAC,CAAC;QAC3ExC,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACoH,2BAA2B,CAAC,IAAI,CAAC,CAAC;QAC/E,IAAI,CAAC/D,OAAO,CAACgE,oBAAoB,CAAC1C,eAAe,CAAC;QAClD,IAAI,CAACH,YAAY,CAAC6C,oBAAoB,CAAC,CAAC;QACxC,IAAI,CAAC/D,UAAU,CAACgE,SAAS,CAAC,IAAI,CAAC/D,YAAY,CAAC,CAAC,CAAC;QAC9C,IAAI,CAACD,UAAU,CAAC4G,oBAAoB,CAAC,CAAC;MAC1C;IACJ,CAAC,SACO;MACJ,IAAI,CAACvI,gBAAgB,CAACmD,iBAAiB,CAAC,CAAC;IAC7C;IACA,IAAI,CAAC3C,iCAAiC,CAACwB,QAAQ,CAAC,CAAC;EACrD;EACAgI,sCAAsCA,CAAA,EAAG;IACrC,MAAMC,UAAU,GAAG,IAAI,CAAClK,cAAc,CAACiB,OAAO,CAACE,GAAG,CAAC,GAAG,CAAC,gBAAgB,CAAC;IACxE,MAAMgJ,UAAU,GAAG,IAAI,CAACnK,cAAc,CAACiB,OAAO,CAACE,GAAG,CAAC,EAAE,CAAC,gBAAgB,CAAC;IACvE,MAAMiJ,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC,EAAE,EAAED,IAAI,CAACE,KAAK,CAACL,UAAU,CAACM,MAAM,GAAGL,UAAU,CAAC,CAAC;IAC5E,MAAMM,WAAW,GAAG,IAAI,CAAC7I,UAAU,CAACsC,oBAAoB,CAAC,CAAC;IAC1D,MAAMwG,mBAAmB,GAAGL,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEG,WAAW,CAACE,gCAAgC,GAAGP,WAAW,CAAC;IACnG,MAAMQ,iBAAiB,GAAGP,IAAI,CAACQ,GAAG,CAAC,IAAI,CAAChJ,YAAY,CAAC,CAAC,EAAE4I,WAAW,CAACK,8BAA8B,GAAGV,WAAW,CAAC;IACjH,OAAO,IAAI,CAACW,qBAAqB,CAAC,IAAI7M,KAAK,CAACwM,mBAAmB,EAAE,IAAI,CAACtF,gBAAgB,CAACsF,mBAAmB,CAAC,EAAEE,iBAAiB,EAAE,IAAI,CAACtB,gBAAgB,CAACsB,iBAAiB,CAAC,CAAC,CAAC;EAC9K;EACAI,gBAAgBA,CAAA,EAAG;IACf,MAAMC,gBAAgB,GAAG,IAAI,CAACC,6BAA6B,CAAC,CAAC;IAC7D,OAAO,IAAI,CAACH,qBAAqB,CAACE,gBAAgB,CAAC;EACvD;EACAF,qBAAqBA,CAACE,gBAAgB,EAAE;IACpC,MAAME,YAAY,GAAG,IAAI,CAAC1J,oBAAoB,CAAC2J,4BAA4B,CAACH,gBAAgB,CAAC;IAC7F,MAAMI,WAAW,GAAG,IAAI,CAACrK,MAAM,CAACsK,cAAc,CAAC,CAAC;IAChD,IAAID,WAAW,CAACtD,MAAM,KAAK,CAAC,EAAE;MAC1B,OAAO,CAACoD,YAAY,CAAC;IACzB;IACA,IAAII,MAAM,GAAG,EAAE;MAAEC,SAAS,GAAG,CAAC;IAC9B,IAAInH,eAAe,GAAG8G,YAAY,CAAC9G,eAAe;IAClD,IAAIoH,WAAW,GAAGN,YAAY,CAACM,WAAW;IAC1C,IAAIlH,aAAa,GAAG4G,YAAY,CAAC5G,aAAa;IAC9C,IAAImH,SAAS,GAAGP,YAAY,CAACO,SAAS;IACtC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGP,WAAW,CAACtD,MAAM,EAAE4D,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACpD,MAAME,qBAAqB,GAAGR,WAAW,CAACM,CAAC,CAAC,CAACtH,eAAe;MAC5D,MAAMyH,mBAAmB,GAAGT,WAAW,CAACM,CAAC,CAAC,CAACpH,aAAa;MACxD,IAAIuH,mBAAmB,GAAGzH,eAAe,EAAE;QACvC;MACJ;MACA,IAAIwH,qBAAqB,GAAGtH,aAAa,EAAE;QACvC;MACJ;MACA,IAAIF,eAAe,GAAGwH,qBAAqB,EAAE;QACzCN,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAItN,KAAK,CAACmG,eAAe,EAAEoH,WAAW,EAAEI,qBAAqB,GAAG,CAAC,EAAE,IAAI,CAAClM,KAAK,CAAC2J,gBAAgB,CAACuC,qBAAqB,GAAG,CAAC,CAAC,CAAC;MACpJ;MACAxH,eAAe,GAAGyH,mBAAmB,GAAG,CAAC;MACzCL,WAAW,GAAG,CAAC;IACnB;IACA,IAAIpH,eAAe,GAAGE,aAAa,IAAKF,eAAe,KAAKE,aAAa,IAAIkH,WAAW,GAAGC,SAAU,EAAE;MACnGH,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAItN,KAAK,CAACmG,eAAe,EAAEoH,WAAW,EAAElH,aAAa,EAAEmH,SAAS,CAAC;IAC3F;IACA,OAAOH,MAAM;EACjB;EACAL,6BAA6BA,CAAA,EAAG;IAC5B,MAAMT,WAAW,GAAG,IAAI,CAAC7I,UAAU,CAACsC,oBAAoB,CAAC,CAAC;IAC1D,MAAMwG,mBAAmB,GAAGD,WAAW,CAACE,gCAAgC;IACxE,MAAMC,iBAAiB,GAAGH,WAAW,CAACK,8BAA8B;IACpE,OAAO,IAAI5M,KAAK,CAACwM,mBAAmB,EAAE,IAAI,CAACtF,gBAAgB,CAACsF,mBAAmB,CAAC,EAAEE,iBAAiB,EAAE,IAAI,CAACtB,gBAAgB,CAACsB,iBAAiB,CAAC,CAAC;EAClJ;EACAmB,wCAAwCA,CAACnJ,SAAS,EAAE;IAChD,MAAM6H,WAAW,GAAG,IAAI,CAAC7I,UAAU,CAACoK,+BAA+B,CAACpJ,SAAS,CAAC;IAC9E,MAAM8H,mBAAmB,GAAGD,WAAW,CAACE,gCAAgC;IACxE,MAAMC,iBAAiB,GAAGH,WAAW,CAACK,8BAA8B;IACpE,OAAO,IAAI5M,KAAK,CAACwM,mBAAmB,EAAE,IAAI,CAACtF,gBAAgB,CAACsF,mBAAmB,CAAC,EAAEE,iBAAiB,EAAE,IAAI,CAACtB,gBAAgB,CAACsB,iBAAiB,CAAC,CAAC;EAClJ;EACAqB,SAASA,CAAA,EAAG;IACR,MAAMC,eAAe,GAAG,IAAI,CAACtK,UAAU,CAACqK,SAAS,CAAC,CAAC;IACnD,MAAMrJ,SAAS,GAAGsJ,eAAe,CAACtJ,SAAS;IAC3C,MAAMuJ,mBAAmB,GAAG,IAAI,CAACvK,UAAU,CAACwK,6BAA6B,CAACxJ,SAAS,CAAC;IACpF,MAAMyJ,aAAa,GAAG,IAAI,CAAC5K,oBAAoB,CAAC2C,kCAAkC,CAAC,IAAInG,QAAQ,CAACkO,mBAAmB,EAAE,IAAI,CAAC/G,gBAAgB,CAAC+G,mBAAmB,CAAC,CAAC,CAAC;IACjK,MAAMG,qBAAqB,GAAG,IAAI,CAAC1K,UAAU,CAACyE,8BAA8B,CAAC8F,mBAAmB,CAAC,GAAGvJ,SAAS;IAC7G,OAAO;MACHF,UAAU,EAAEwJ,eAAe,CAACxJ,UAAU;MACtC2J,aAAa,EAAEA,aAAa;MAC5BC,qBAAqB,EAAEA;IAC3B,CAAC;EACL;EACAC,kBAAkBA,CAACC,KAAK,EAAE;IACtB,IAAI,OAAOA,KAAK,CAACH,aAAa,KAAK,WAAW,EAAE;MAC5C;MACA,OAAO,IAAI,CAACI,gCAAgC,CAACD,KAAK,CAAC;IACvD;IACA,MAAME,aAAa,GAAG,IAAI,CAAC/M,KAAK,CAACgN,gBAAgB,CAACH,KAAK,CAACH,aAAa,CAAC;IACtE,MAAMnG,YAAY,GAAG,IAAI,CAACzE,oBAAoB,CAAC0E,kCAAkC,CAACuG,aAAa,CAAC;IAChG,MAAM9J,SAAS,GAAG,IAAI,CAAChB,UAAU,CAACyE,8BAA8B,CAACH,YAAY,CAAC1B,UAAU,CAAC,GAAGgI,KAAK,CAACF,qBAAqB;IACvH,OAAO;MACH5J,UAAU,EAAE8J,KAAK,CAAC9J,UAAU;MAC5BE,SAAS,EAAEA;IACf,CAAC;EACL;EACA6J,gCAAgCA,CAACD,KAAK,EAAE;IACpC,OAAO;MACH9J,UAAU,EAAE8J,KAAK,CAAC9J,UAAU;MAC5BE,SAAS,EAAE4J,KAAK,CAACI;IACrB,CAAC;EACL;EACAC,UAAUA,CAAA,EAAG;IACT,OAAO,IAAI,CAAClN,KAAK,CAACU,UAAU,CAAC,CAAC,CAACkB,OAAO;EAC1C;EACAuL,mBAAmBA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACnN,KAAK,CAACU,UAAU,CAAC,CAAC;EAClC;EACAwB,YAAYA,CAAA,EAAG;IACX,OAAO,IAAI,CAACb,MAAM,CAACgD,gBAAgB,CAAC,CAAC;EACzC;EACA;AACJ;AACA;EACI+I,WAAWA,CAAC1I,eAAe,EAAEE,aAAa,EAAEyI,kBAAkB,EAAE;IAC5D,IAAI,CAACpM,kBAAkB,GAAGyD,eAAe;IACzC,IAAI4I,QAAQ,GAAG,IAAI,CAACxL,oBAAoB,CAAC2C,kCAAkC,CAAC,IAAInG,QAAQ,CAACoG,eAAe,EAAE,IAAI,CAACe,gBAAgB,CAACf,eAAe,CAAC,CAAC,CAAC;IAClJ,IAAI,CAACxD,8BAA8B,GAAG,IAAI,CAAClB,KAAK,CAAC+D,gBAAgB,CAAC,IAAI,CAAC7C,8BAA8B,EAAE,IAAI3C,KAAK,CAAC+O,QAAQ,CAACzI,UAAU,EAAEyI,QAAQ,CAACC,MAAM,EAAED,QAAQ,CAACzI,UAAU,EAAEyI,QAAQ,CAACC,MAAM,CAAC,EAAE,CAAC,CAAC,iCAAiC,CAAC;IAClO,MAAMC,oBAAoB,GAAG,IAAI,CAACvL,UAAU,CAACyE,8BAA8B,CAAChC,eAAe,CAAC;IAC5F,MAAMzB,SAAS,GAAG,IAAI,CAAChB,UAAU,CAACiE,mBAAmB,CAAC,CAAC;IACvD,IAAI,CAAC/E,uBAAuB,GAAG8B,SAAS,GAAGuK,oBAAoB;EACnE;EACAC,oBAAoBA,CAAC5I,UAAU,EAAE6I,aAAa,EAAEC,aAAa,EAAE;IAC3D,OAAO,IAAI,CAACtM,MAAM,CAACoM,oBAAoB,CAAC5I,UAAU,EAAE6I,aAAa,EAAEC,aAAa,CAAC;EACrF;EACAC,oBAAoBA,CAAClJ,eAAe,EAAEE,aAAa,EAAE;IACjD,OAAO,IAAI,CAACvD,MAAM,CAACwM,wBAAwB,CAACnJ,eAAe,EAAEE,aAAa,CAAC;EAC/E;EACAkJ,cAAcA,CAACjJ,UAAU,EAAE;IACvB,OAAO,IAAI,CAACxD,MAAM,CAAC0M,kBAAkB,CAAClJ,UAAU,CAAC;EACrD;EACAmJ,aAAaA,CAACnJ,UAAU,EAAE;IACtB,OAAO,IAAI,CAACxD,MAAM,CAAC4M,iBAAiB,CAACpJ,UAAU,CAAC;EACpD;EACAY,gBAAgBA,CAACZ,UAAU,EAAE;IACzB,OAAO,IAAI,CAACxD,MAAM,CAAC6M,oBAAoB,CAACrJ,UAAU,CAAC;EACvD;EACA8E,gBAAgBA,CAAC9E,UAAU,EAAE;IACzB,OAAO,IAAI,CAACxD,MAAM,CAAC8M,oBAAoB,CAACtJ,UAAU,CAAC;EACvD;EACAuJ,+BAA+BA,CAACvJ,UAAU,EAAE;IACxC,MAAM+G,MAAM,GAAGzN,OAAO,CAACkQ,uBAAuB,CAAC,IAAI,CAACP,cAAc,CAACjJ,UAAU,CAAC,CAAC;IAC/E,IAAI+G,MAAM,KAAK,CAAC,CAAC,EAAE;MACf,OAAO,CAAC;IACZ;IACA,OAAOA,MAAM,GAAG,CAAC;EACrB;EACA0C,8BAA8BA,CAACzJ,UAAU,EAAE;IACvC,MAAM+G,MAAM,GAAGzN,OAAO,CAACoQ,sBAAsB,CAAC,IAAI,CAACT,cAAc,CAACjJ,UAAU,CAAC,CAAC;IAC9E,IAAI+G,MAAM,KAAK,CAAC,CAAC,EAAE;MACf,OAAO,CAAC;IACZ;IACA,OAAOA,MAAM,GAAG,CAAC;EACrB;EACA4C,wBAAwBA,CAAChD,YAAY,EAAE;IACnC,OAAO,IAAI,CAACrI,YAAY,CAACsL,0BAA0B,CAACjD,YAAY,CAAC,CAACkD,WAAW;EACjF;EACAC,wBAAwBA,CAACnD,YAAY,EAAE3G,UAAU,EAAE;IAC/C,IAAI+J,eAAe,GAAG,IAAI,CAAC5O,KAAK,CAAC4O,eAAe,CAAC,CAAC;IAClD,IAAIC,yBAAyB,GAAG,IAAI,CAAC7O,KAAK,CAAC6O,yBAAyB,CAAC,CAAC;IACtE,IAAIjN,OAAO,GAAG,IAAI,CAACsL,UAAU,CAAC,CAAC;IAC/B,IAAI4B,QAAQ,GAAG,IAAI,CAACzN,MAAM,CAAC0N,eAAe,CAAClK,UAAU,CAAC;IACtD,IAAImK,oBAAoB,GAAG,IAAI,CAAC7L,YAAY,CAACsL,0BAA0B,CAACjD,YAAY,CAAC,CAACyD,iBAAiB;IACvG,IAAIA,iBAAiB,GAAGD,oBAAoB,CAACnK,UAAU,GAAG2G,YAAY,CAAC9G,eAAe,CAAC;IACvF,OAAO,IAAI1F,qBAAqB,CAAC8P,QAAQ,CAACI,SAAS,EAAEJ,QAAQ,CAACK,SAAS,EAAEL,QAAQ,CAACM,OAAO,EAAEN,QAAQ,CAACO,wBAAwB,EAAET,eAAe,EAAEC,yBAAyB,EAAEC,QAAQ,CAACQ,MAAM,EAAEL,iBAAiB,EAAErN,OAAO,EAAEkN,QAAQ,CAACS,kBAAkB,CAAC;EACvP;EACAR,eAAeA,CAAClK,UAAU,EAAE;IACxB,OAAO,IAAI,CAACxD,MAAM,CAAC0N,eAAe,CAAClK,UAAU,CAAC;EAClD;EACA2K,4BAA4BA,CAAC9K,eAAe,EAAEE,aAAa,EAAE6K,MAAM,EAAE;IACjE,IAAI7D,MAAM,GAAG,IAAI,CAACvK,MAAM,CAACqO,gBAAgB,CAAChL,eAAe,EAAEE,aAAa,EAAE6K,MAAM,CAAC;IACjF,OAAO,IAAI1Q,yBAAyB,CAAC,IAAI,CAACmO,UAAU,CAAC,CAAC,EAAEtB,MAAM,CAAC;EACnE;EACA+D,8BAA8BA,CAACC,KAAK,EAAE;IAClC,OAAO,IAAI,CAACvO,MAAM,CAACsO,8BAA8B,CAAC,IAAI,CAACvP,SAAS,EAAE/B,2BAA2B,CAAC,IAAI,CAACgC,cAAc,CAACiB,OAAO,CAAC,EAAEsO,KAAK,CAAC;EACtI;EACAC,iCAAiCA,CAAA,EAAG;IAChC,MAAMnB,WAAW,GAAG,IAAI,CAAC1O,KAAK,CAAC8P,2BAA2B,CAAC,CAAC;IAC5D,KAAK,MAAMC,UAAU,IAAIrB,WAAW,EAAE;MAClC,MAAMsB,IAAI,GAAGD,UAAU,CAACzO,OAAO,CAAC2O,aAAa;MAC7C,IAAID,IAAI,EAAE;QACNA,IAAI,CAACE,qBAAqB,CAAC,CAAC;MAChC;IACJ;EACJ;EACApM,2BAA2BA,CAAA,EAAG;IAC1B,MAAM4K,WAAW,GAAG,IAAI,CAAC1O,KAAK,CAACmQ,iBAAiB,CAAC,CAAC;IAClD,KAAK,MAAMJ,UAAU,IAAIrB,WAAW,EAAE;MAClC,MAAMsB,IAAI,GAAGD,UAAU,CAACzO,OAAO,CAAC8O,OAAO;MACvC,IAAIJ,IAAI,EAAE;QACNA,IAAI,CAACE,qBAAqB,CAAC,CAAC;MAChC;IACJ;EACJ;EACAG,eAAeA,CAACC,KAAK,EAAEC,GAAG,EAAE;IACxB,MAAMvH,UAAU,GAAG,IAAI,CAAClH,oBAAoB,CAAC2J,4BAA4B,CAAC6E,KAAK,CAAC;IAChF,OAAO,IAAI,CAACtQ,KAAK,CAACqQ,eAAe,CAACrH,UAAU,EAAEuH,GAAG,CAAC;EACtD;EACAC,qBAAqBA,CAACC,eAAe,EAAE;IACnC,OAAO,IAAI,CAACzQ,KAAK,CAAC2J,gBAAgB,CAAC8G,eAAe,CAAC;EACvD;EACAC,qBAAqBA,CAACpD,QAAQ,EAAE;IAC5B,OAAO,IAAI,CAACtN,KAAK,CAACgN,gBAAgB,CAACM,QAAQ,CAAC;EAChD;EACAqD,kBAAkBA,CAACL,KAAK,EAAE;IACtB,OAAO,IAAI,CAACtQ,KAAK,CAAC4Q,aAAa,CAACN,KAAK,CAAC;EAC1C;EACAO,yCAAyCA,CAACC,kBAAkB,EAAEC,WAAW,EAAEC,WAAW,EAAE;IACpF,MAAMC,WAAW,GAAG,IAAI,CAACnP,oBAAoB,CAAC2C,kCAAkC,CAACqM,kBAAkB,CAAC;IACpG,IAAI,IAAI,CAAC9Q,KAAK,CAACkR,MAAM,CAAC,CAAC,CAAC9I,MAAM,KAAK,CAAC,EAAE;MAClC;MACA,IAAI2I,WAAW,GAAG,CAAC,EAAE;QACjBA,WAAW,IAAIC,WAAW;MAC9B,CAAC,MACI;QACDD,WAAW,IAAIC,WAAW;MAC9B;IACJ;IACA,MAAMG,iBAAiB,GAAG,IAAI,CAACnR,KAAK,CAACoR,WAAW,CAACH,WAAW,CAAC;IAC7D,MAAMI,YAAY,GAAGF,iBAAiB,GAAGJ,WAAW;IACpD,OAAO,IAAI,CAAC/Q,KAAK,CAACsR,aAAa,CAACD,YAAY,CAAC;EACjD;EACAH,MAAMA,CAAA,EAAG;IACL,OAAO,IAAI,CAAClR,KAAK,CAACkR,MAAM,CAAC,CAAC;EAC9B;EACAK,kBAAkBA,CAACC,WAAW,EAAEC,uBAAuB,EAAEC,SAAS,EAAE;IAChE,MAAMC,gBAAgB,GAAGD,SAAS,GAAG,MAAM,GAAG,IAAI,CAAC1R,KAAK,CAACkR,MAAM,CAAC,CAAC;IACjEM,WAAW,GAAGA,WAAW,CAACrJ,KAAK,CAAC,CAAC,CAAC;IAClCqJ,WAAW,CAACI,IAAI,CAACrT,KAAK,CAACsT,wBAAwB,CAAC;IAChD,IAAIC,aAAa,GAAG,KAAK;IACzB,IAAIC,gBAAgB,GAAG,KAAK;IAC5B,KAAK,MAAMzB,KAAK,IAAIkB,WAAW,EAAE;MAC7B,IAAIlB,KAAK,CAAC0B,OAAO,CAAC,CAAC,EAAE;QACjBF,aAAa,GAAG,IAAI;MACxB,CAAC,MACI;QACDC,gBAAgB,GAAG,IAAI;MAC3B;IACJ;IACA,IAAI,CAACA,gBAAgB,EAAE;MACnB;MACA,IAAI,CAACN,uBAAuB,EAAE;QAC1B,OAAO,EAAE;MACb;MACA,MAAMQ,gBAAgB,GAAGT,WAAW,CAACU,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACzN,eAAe,CAAC;MAClE,IAAIkH,MAAM,GAAG,EAAE;MACf,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiG,gBAAgB,CAAC7J,MAAM,EAAE4D,CAAC,EAAE,EAAE;QAC9C,IAAIA,CAAC,GAAG,CAAC,IAAIiG,gBAAgB,CAACjG,CAAC,GAAG,CAAC,CAAC,KAAKiG,gBAAgB,CAACjG,CAAC,CAAC,EAAE;UAC1D;QACJ;QACAJ,MAAM,IAAI,IAAI,CAAC5L,KAAK,CAAC8N,cAAc,CAACmE,gBAAgB,CAACjG,CAAC,CAAC,CAAC,GAAG2F,gBAAgB;MAC/E;MACA,OAAO/F,MAAM;IACjB;IACA,IAAIkG,aAAa,IAAIL,uBAAuB,EAAE;MAC1C;MACA,IAAI7F,MAAM,GAAG,EAAE;MACf,IAAIwG,mBAAmB,GAAG,CAAC;MAC3B,KAAK,MAAMpJ,UAAU,IAAIwI,WAAW,EAAE;QAClC,MAAMf,eAAe,GAAGzH,UAAU,CAACtE,eAAe;QAClD,IAAIsE,UAAU,CAACgJ,OAAO,CAAC,CAAC,EAAE;UACtB,IAAIvB,eAAe,KAAK2B,mBAAmB,EAAE;YACzCxG,MAAM,CAACyG,IAAI,CAAC,IAAI,CAACrS,KAAK,CAAC8N,cAAc,CAAC2C,eAAe,CAAC,CAAC;UAC3D;QACJ,CAAC,MACI;UACD7E,MAAM,CAACyG,IAAI,CAAC,IAAI,CAACrS,KAAK,CAACqQ,eAAe,CAACrH,UAAU,EAAE0I,SAAS,GAAG,CAAC,CAAC,aAAa,CAAC,CAAC,iBAAiB,CAAC,CAAC;QACvG;;QACAU,mBAAmB,GAAG3B,eAAe;MACzC;MACA,OAAO7E,MAAM,CAACxD,MAAM,KAAK,CAAC,GAAGwD,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM;IACnD;IACA,IAAIA,MAAM,GAAG,EAAE;IACf,KAAK,MAAM5C,UAAU,IAAIwI,WAAW,EAAE;MAClC,IAAI,CAACxI,UAAU,CAACgJ,OAAO,CAAC,CAAC,EAAE;QACvBpG,MAAM,CAACyG,IAAI,CAAC,IAAI,CAACrS,KAAK,CAACqQ,eAAe,CAACrH,UAAU,EAAE0I,SAAS,GAAG,CAAC,CAAC,aAAa,CAAC,CAAC,iBAAiB,CAAC,CAAC;MACvG;IACJ;;IACA,OAAO9F,MAAM,CAACxD,MAAM,KAAK,CAAC,GAAGwD,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM;EACnD;EACA0G,iBAAiBA,CAACd,WAAW,EAAEC,uBAAuB,EAAE;IACpD,MAAMc,UAAU,GAAG,IAAI,CAACvS,KAAK,CAACS,qBAAqB,CAAC,CAAC;IACrD,IAAI8R,UAAU,CAACC,EAAE,KAAK,CAAC,CAAC,iBAAiB;MACrC,OAAO,IAAI;IACf;IACA,IAAIhB,WAAW,CAACpJ,MAAM,KAAK,CAAC,EAAE;MAC1B;MACA,OAAO,IAAI;IACf;IACA,IAAIkI,KAAK,GAAGkB,WAAW,CAAC,CAAC,CAAC;IAC1B,IAAIlB,KAAK,CAAC0B,OAAO,CAAC,CAAC,EAAE;MACjB,IAAI,CAACP,uBAAuB,EAAE;QAC1B;QACA,OAAO,IAAI;MACf;MACA,MAAM5M,UAAU,GAAGyL,KAAK,CAAC5L,eAAe;MACxC4L,KAAK,GAAG,IAAI/R,KAAK,CAACsG,UAAU,EAAE,IAAI,CAAC7E,KAAK,CAACyF,gBAAgB,CAACZ,UAAU,CAAC,EAAEA,UAAU,EAAE,IAAI,CAAC7E,KAAK,CAAC2J,gBAAgB,CAAC9E,UAAU,CAAC,CAAC;IAC/H;IACA,MAAMtD,QAAQ,GAAG,IAAI,CAAClB,cAAc,CAACiB,OAAO,CAACE,GAAG,CAAC,EAAE,CAAC,cAAc,CAAC;IACnE,MAAMiR,QAAQ,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IACpC,MAAMC,UAAU,GAAGpR,QAAQ,CAACoR,UAAU,KAAKvU,oBAAoB,CAACuU,UAAU,GAAGpR,QAAQ,CAACoR,UAAU,OAAAC,MAAA,CAAOrR,QAAQ,CAACoR,UAAU,SAAAC,MAAA,CAAMxU,oBAAoB,CAACuU,UAAU,CAAE;IACjK,OAAO;MACHE,IAAI,EAAEN,UAAU,CAACO,QAAQ;MACzBC,IAAI,EAAG,4BAAAH,MAAA,CACSH,QAAQ,CAAC,CAAC,CAAC,wBAAwB,MAAG,wBAAAG,MAAA,CAC3BH,QAAQ,CAAC,CAAC,CAAC,wBAAwB,MAAG,mBAAAG,MAAA,CAC3CD,UAAU,MAAG,mBAAAC,MAAA,CACbrR,QAAQ,CAACyR,UAAU,MAAG,iBAAAJ,MAAA,CACxBrR,QAAQ,CAAC0R,QAAQ,QAAK,mBAAAL,MAAA,CACpBrR,QAAQ,CAACiJ,UAAU,QAAK,sBACrB,QACf,GACJ,IAAI,CAAC0I,cAAc,CAAC5C,KAAK,EAAEmC,QAAQ,CAAC,GACpC;IACV,CAAC;EACL;EACAS,cAAcA,CAAClK,UAAU,EAAEyJ,QAAQ,EAAE;IACjC,MAAM/N,eAAe,GAAGsE,UAAU,CAACtE,eAAe;IAClD,MAAMoH,WAAW,GAAG9C,UAAU,CAAC8C,WAAW;IAC1C,MAAMlH,aAAa,GAAGoE,UAAU,CAACpE,aAAa;IAC9C,MAAMmH,SAAS,GAAG/C,UAAU,CAAC+C,SAAS;IACtC,MAAMnK,OAAO,GAAG,IAAI,CAACsL,UAAU,CAAC,CAAC;IACjC,IAAItB,MAAM,GAAG,EAAE;IACf,KAAK,IAAI/G,UAAU,GAAGH,eAAe,EAAEG,UAAU,IAAID,aAAa,EAAEC,UAAU,EAAE,EAAE;MAC9E,MAAMsO,UAAU,GAAG,IAAI,CAACnT,KAAK,CAACoT,aAAa,CAACvO,UAAU,CAAC;MACvD,MAAMwO,WAAW,GAAGF,UAAU,CAACrF,cAAc,CAAC,CAAC;MAC/C,MAAMwF,WAAW,GAAIzO,UAAU,KAAKH,eAAe,GAAGoH,WAAW,GAAG,CAAC,GAAG,CAAE;MAC1E,MAAMyH,SAAS,GAAI1O,UAAU,KAAKD,aAAa,GAAGmH,SAAS,GAAG,CAAC,GAAGsH,WAAW,CAACjL,MAAO;MACrF,IAAIiL,WAAW,KAAK,EAAE,EAAE;QACpBzH,MAAM,IAAI,MAAM;MACpB,CAAC,MACI;QACDA,MAAM,IAAInN,kBAAkB,CAAC4U,WAAW,EAAEF,UAAU,CAACK,OAAO,CAAC,CAAC,EAAEf,QAAQ,EAAEa,WAAW,EAAEC,SAAS,EAAE3R,OAAO,EAAEzC,QAAQ,CAACsU,SAAS,CAAC;MAClI;IACJ;IACA,OAAO7H,MAAM;EACjB;EACA8G,YAAYA,CAAA,EAAG;IACX,IAAID,QAAQ,GAAGjU,oBAAoB,CAACkV,WAAW,CAAC,CAAC;IACjD,IAAI9H,MAAM,GAAG,CAAC,SAAS,CAAC;IACxB,IAAI6G,QAAQ,EAAE;MACV,KAAK,IAAIzG,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGwG,QAAQ,CAACrK,MAAM,EAAE4D,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QACjDJ,MAAM,CAACI,CAAC,CAAC,GAAG/N,KAAK,CAAC0V,MAAM,CAACC,GAAG,CAACC,SAAS,CAACpB,QAAQ,CAACzG,CAAC,CAAC,CAAC;MACvD;IACJ;IACA,OAAOJ,MAAM;EACjB;EACA;EACAkI,gBAAgBA,CAAA,EAAG;IACf,IAAI,CAAC9T,KAAK,CAAC8T,gBAAgB,CAAC,CAAC;EACjC;EACA;EACA;EACAC,qBAAqBA,CAAA,EAAG;IACpB,OAAO,IAAI,CAAC/R,OAAO,CAAC+R,qBAAqB,CAAC,CAAC;EAC/C;EACAC,uBAAuBA,CAAA,EAAG;IACtB,OAAO,IAAI,CAAChS,OAAO,CAACgS,uBAAuB,CAAC,CAAC;EACjD;EACAC,eAAeA,CAAA,EAAG;IACd,OAAO,IAAI,CAACjS,OAAO,CAACiS,eAAe,CAAC,CAAC;EACzC;EACAC,eAAeA,CAACC,MAAM,EAAEC,MAAM,EAAEC,MAAM,EAAE;IACpC,IAAI,CAACC,wBAAwB,CAAChR,eAAe,IAAI,IAAI,CAACtB,OAAO,CAACuS,SAAS,CAACjR,eAAe,EAAE6Q,MAAM,EAAEC,MAAM,EAAEC,MAAM,CAAC,CAAC;EACrH;EACAG,yBAAyBA,CAAA,EAAG;IACxB,OAAO,IAAI,CAACxS,OAAO,CAACwS,yBAAyB,CAAC,CAAC;EACnD;EACAC,yBAAyBA,CAACC,gBAAgB,EAAE;IACxC,IAAI,CAAC1S,OAAO,CAACyS,yBAAyB,CAACC,gBAAgB,CAAC;EAC5D;EACAC,wBAAwBA,CAAA,EAAG;IACvB,OAAO,IAAI,CAAC3S,OAAO,CAAC2S,wBAAwB,CAAC,CAAC;EAClD;EACAC,wBAAwBA,CAACC,IAAI,EAAE;IAC3B,IAAI,CAAC7S,OAAO,CAAC4S,wBAAwB,CAACC,IAAI,CAAC;EAC/C;EACAC,YAAYA,CAAA,EAAG;IACX,OAAO,IAAI,CAAC9S,OAAO,CAAC8S,YAAY,CAAC,CAAC;EACtC;EACAC,aAAaA,CAAA,EAAG;IACZ,OAAO,IAAI,CAAC/S,OAAO,CAAC+S,aAAa,CAAC,CAAC;EACvC;EACAC,WAAWA,CAAA,EAAG;IACV,OAAO,IAAI,CAAChT,OAAO,CAAC+R,qBAAqB,CAAC,CAAC,CAACkB,UAAU,CAAC3H,QAAQ;EACnE;EACA4H,aAAaA,CAACf,MAAM,EAAEgB,UAAU,EAA2B;IAAA,IAAzBf,MAAM,GAAAgB,SAAA,CAAAhN,MAAA,QAAAgN,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC;IACxC,IAAI,CAACd,wBAAwB,CAAChR,eAAe,IAAI,IAAI,CAACtB,OAAO,CAACkT,aAAa,CAAC5R,eAAe,EAAE6Q,MAAM,EAAEgB,UAAU,EAAEf,MAAM,CAAC,CAAC;EAC7H;EACAkB,eAAeA,CAAA,EAAG;IACd,OAAO,IAAI,CAACtT,OAAO,CAACsK,SAAS,CAAC,CAAC;EACnC;EACAiJ,kBAAkBA,CAAClB,MAAM,EAAE;IACvB,IAAI,CAACC,wBAAwB,CAAChR,eAAe,IAAI,IAAI,CAACtB,OAAO,CAACwT,YAAY,CAAClS,eAAe,EAAE+Q,MAAM,CAAC,CAAC;EACxG;EACAoB,kBAAkBA,CAACC,QAAQ,EAAE;IACzB,IAAI,IAAI,CAAC1T,OAAO,CAAC2T,OAAO,CAACnV,YAAY,CAACoV,QAAQ,EAAE;MAC5C;MACA,IAAI,CAACtV,gBAAgB,CAACmC,iBAAiB,CAAC,IAAI/C,wBAAwB,CAAC,CAAC,CAAC;MACvE;IACJ;IACA,IAAI,CAAC4U,wBAAwB,CAACoB,QAAQ,CAAC;EAC3C;EACAG,YAAYA,CAAC1B,MAAM,EAAE2B,KAAK,EAAEC,mBAAmB,EAAE;IAC7C,IAAI,CAACN,kBAAkB,CAACnS,eAAe,IAAI,IAAI,CAACtB,OAAO,CAAC6T,YAAY,CAACvS,eAAe,EAAE6Q,MAAM,EAAE2B,KAAK,EAAEC,mBAAmB,CAAC,CAAC;EAC9H;EACAC,gBAAgBA,CAAA,EAAG;IACf,IAAI,CAAChU,OAAO,CAACiU,qBAAqB,CAAC,IAAI,CAAC;IACxC,IAAI,CAACR,kBAAkB,CAACnS,eAAe,IAAI,IAAI,CAACtB,OAAO,CAACgU,gBAAgB,CAAC1S,eAAe,CAAC,CAAC;EAC9F;EACA4S,cAAcA,CAAC/B,MAAM,EAAE;IACnB,IAAI,CAACnS,OAAO,CAACiU,qBAAqB,CAAC,KAAK,CAAC;IACzC,IAAI,CAACR,kBAAkB,CAACnS,eAAe,IAAI,IAAI,CAACtB,OAAO,CAACkU,cAAc,CAAC5S,eAAe,EAAE6Q,MAAM,CAAC,CAAC;EACpG;EACAU,IAAIA,CAACsB,IAAI,EAAEhC,MAAM,EAAE;IACf,IAAI,CAACsB,kBAAkB,CAACnS,eAAe,IAAI,IAAI,CAACtB,OAAO,CAAC6S,IAAI,CAACvR,eAAe,EAAE6S,IAAI,EAAEhC,MAAM,CAAC,CAAC;EAChG;EACAiC,mBAAmBA,CAACD,IAAI,EAAEE,cAAc,EAAElC,MAAM,EAAE;IAC9C,IAAI,CAACsB,kBAAkB,CAACnS,eAAe,IAAI,IAAI,CAACtB,OAAO,CAACoU,mBAAmB,CAAC9S,eAAe,EAAE6S,IAAI,EAAEE,cAAc,EAAElC,MAAM,CAAC,CAAC;EAC/H;EACAmC,KAAKA,CAACH,IAAI,EAAEI,cAAc,EAAEC,eAAe,EAAErC,MAAM,EAAE;IACjD,IAAI,CAACsB,kBAAkB,CAACnS,eAAe,IAAI,IAAI,CAACtB,OAAO,CAACsU,KAAK,CAAChT,eAAe,EAAE6S,IAAI,EAAEI,cAAc,EAAEC,eAAe,EAAErC,MAAM,CAAC,CAAC;EAClI;EACAsC,GAAGA,CAACtC,MAAM,EAAE;IACR,IAAI,CAACsB,kBAAkB,CAACnS,eAAe,IAAI,IAAI,CAACtB,OAAO,CAACyU,GAAG,CAACnT,eAAe,EAAE6Q,MAAM,CAAC,CAAC;EACzF;EACAuC,cAAcA,CAACC,OAAO,EAAExC,MAAM,EAAE;IAC5B,IAAI,CAACsB,kBAAkB,CAACnS,eAAe,IAAI,IAAI,CAACtB,OAAO,CAAC0U,cAAc,CAACpT,eAAe,EAAEqT,OAAO,EAAExC,MAAM,CAAC,CAAC;EAC7G;EACAyC,eAAeA,CAACC,QAAQ,EAAE1C,MAAM,EAAE;IAC9B,IAAI,CAACsB,kBAAkB,CAACnS,eAAe,IAAI,IAAI,CAACtB,OAAO,CAAC4U,eAAe,CAACtT,eAAe,EAAEuT,QAAQ,EAAE1C,MAAM,CAAC,CAAC;EAC/G;EACA2C,mBAAmBA,CAAC3C,MAAM,EAAE4C,gBAAgB,EAAE;IAC1C,IAAI,CAACzC,wBAAwB,CAAChR,eAAe,IAAI,IAAI,CAACtB,OAAO,CAACgV,aAAa,CAAC1T,eAAe,EAAE6Q,MAAM,EAAE4C,gBAAgB,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC;EAC3I;;EACAE,mBAAmBA,CAAC9C,MAAM,EAAE;IACxB,MAAM5N,YAAY,GAAG,IAAI,CAACvE,OAAO,CAACkV,sBAAsB,CAAC,CAAC;IAC1D,MAAMC,SAAS,GAAG,IAAI5Y,KAAK,CAACgI,YAAY,CAAC1B,UAAU,EAAE0B,YAAY,CAACgH,MAAM,EAAEhH,YAAY,CAAC1B,UAAU,EAAE0B,YAAY,CAACgH,MAAM,CAAC;IACvH,IAAI,CAAC+G,wBAAwB,CAAChR,eAAe,IAAIA,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACyY,2BAA2B,CAACjD,MAAM,EAAEgD,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC,cAAc,IAAI,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;EAC9L;;EACAE,sBAAsBA,CAAClD,MAAM,EAAE;IAC3B,MAAM5N,YAAY,GAAG,IAAI,CAACvE,OAAO,CAACsV,yBAAyB,CAAC,CAAC;IAC7D,MAAMH,SAAS,GAAG,IAAI5Y,KAAK,CAACgI,YAAY,CAAC1B,UAAU,EAAE0B,YAAY,CAACgH,MAAM,EAAEhH,YAAY,CAAC1B,UAAU,EAAE0B,YAAY,CAACgH,MAAM,CAAC;IACvH,IAAI,CAAC+G,wBAAwB,CAAChR,eAAe,IAAIA,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACyY,2BAA2B,CAACjD,MAAM,EAAEgD,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC,cAAc,IAAI,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;EAC9L;;EACAI,WAAWA,CAACpD,MAAM,EAAE4C,gBAAgB,EAAEI,SAAS,EAAEK,YAAY,EAAEC,UAAU,EAAE;IACvE,IAAI,CAACnD,wBAAwB,CAAChR,eAAe,IAAIA,eAAe,CAACsC,aAAa,CAAC,IAAIjH,UAAU,CAACyY,2BAA2B,CAACjD,MAAM,EAAEgD,SAAS,EAAE,IAAI,EAAEK,YAAY,EAAET,gBAAgB,EAAEU,UAAU,CAAC,CAAC,CAAC;EACpM;EACA;EACA;EACA/Q,8BAA8BA,CAACgR,cAAc,EAAE;IAC3C,OAAO,IAAI,CAACzV,UAAU,CAACyE,8BAA8B,CAACgR,cAAc,CAAC;EACzE;EACAC,YAAYA,CAAA,EAAG;IACX,OAAO,IAAI,CAAC1V,UAAU,CAACiE,mBAAmB,CAAC,CAAC;EAChD;EACA0R,YAAYA,CAACC,YAAY,EAAEJ,UAAU,EAAE;IACnC,IAAI,CAACxV,UAAU,CAAC0E,iBAAiB,CAAC;MAAE1D,SAAS,EAAE4U;IAAa,CAAC,EAAEJ,UAAU,CAAC;EAC9E;EACA9Q,iBAAiBA,CAAC2G,QAAQ,EAAEuH,IAAI,EAAE;IAC9B,IAAI,CAAC5S,UAAU,CAAC0E,iBAAiB,CAAC2G,QAAQ,EAAEuH,IAAI,CAAC;EACrD;EACAiD,cAAcA,CAACC,eAAe,EAAEC,cAAc,EAAE;IAC5C,IAAI,CAAC/V,UAAU,CAAC6V,cAAc,CAACC,eAAe,EAAEC,cAAc,CAAC;EACnE;EACAC,gBAAgBA,CAACvC,QAAQ,EAAE;IACvB,MAAMwC,UAAU,GAAG,IAAI,CAACjW,UAAU,CAACgW,gBAAgB,CAACvC,QAAQ,CAAC;IAC7D,IAAIwC,UAAU,EAAE;MACZ,IAAI,CAAC5X,gBAAgB,CAACiC,mBAAmB,CAAC,IAAI5D,UAAU,CAACc,qBAAqB,CAAC,CAAC,CAAC;MACjF,IAAI,CAACa,gBAAgB,CAACmC,iBAAiB,CAAC,IAAIhD,qBAAqB,CAAC,CAAC,CAAC;IACxE;EACJ;EACA0Y,eAAeA,CAACC,YAAY,EAAE;IAC1B,IAAI,CAACnW,UAAU,CAACkW,eAAe,CAACC,YAAY,CAAC;EACjD;EACA;EACA9D,wBAAwBA,CAACoB,QAAQ,EAAE;IAC/B,IAAI;MACA,MAAMpS,eAAe,GAAG,IAAI,CAAChD,gBAAgB,CAACiD,mBAAmB,CAAC,CAAC;MACnEmS,QAAQ,CAACpS,eAAe,CAAC;IAC7B,CAAC,SACO;MACJ,IAAI,CAAChD,gBAAgB,CAACmD,iBAAiB,CAAC,CAAC;IAC7C;EACJ;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}