{"ast":null,"code":"import { IdleValue } from './async.js';\n// When comparing large numbers of strings, such as in sorting large arrays, is better for\n// performance to create an Intl.Collator object and use the function provided by its compare\n// property than it is to use String.prototype.localeCompare()\n// A collator with numeric sorting enabled, and no sensitivity to case or to accents\nconst intlFileNameCollatorBaseNumeric = new IdleValue(() => {\n  const collator = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: 'base'\n  });\n  return {\n    collator: collator,\n    collatorIsNumeric: collator.resolvedOptions().numeric\n  };\n}); /** Compares filenames without distinguishing the name from the extension. Disambiguates by unicode comparison. */\nexport function compareFileNames(one, other) {\n  let caseSensitive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const a = one || '';\n  const b = other || '';\n  const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);\n  // Using the numeric option in the collator will\n  // make compare(`foo1`, `foo01`) === 0. We must disambiguate.\n  if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {\n    return a < b ? -1 : 1;\n  }\n  return result;\n}\nexport function compareAnything(one, other, lookFor) {\n  const elementAName = one.toLowerCase();\n  const elementBName = other.toLowerCase();\n  // Sort prefix matches over non prefix matches\n  const prefixCompare = compareByPrefix(one, other, lookFor);\n  if (prefixCompare) {\n    return prefixCompare;\n  }\n  // Sort suffix matches over non suffix matches\n  const elementASuffixMatch = elementAName.endsWith(lookFor);\n  const elementBSuffixMatch = elementBName.endsWith(lookFor);\n  if (elementASuffixMatch !== elementBSuffixMatch) {\n    return elementASuffixMatch ? -1 : 1;\n  }\n  // Understand file names\n  const r = compareFileNames(elementAName, elementBName);\n  if (r !== 0) {\n    return r;\n  }\n  // Compare by name\n  return elementAName.localeCompare(elementBName);\n}\nexport function compareByPrefix(one, other, lookFor) {\n  const elementAName = one.toLowerCase();\n  const elementBName = other.toLowerCase();\n  // Sort prefix matches over non prefix matches\n  const elementAPrefixMatch = elementAName.startsWith(lookFor);\n  const elementBPrefixMatch = elementBName.startsWith(lookFor);\n  if (elementAPrefixMatch !== elementBPrefixMatch) {\n    return elementAPrefixMatch ? -1 : 1;\n  }\n  // Same prefix: Sort shorter matches to the top to have those on top that match more precisely\n  else if (elementAPrefixMatch && elementBPrefixMatch) {\n    if (elementAName.length < elementBName.length) {\n      return -1;\n    }\n    if (elementAName.length > elementBName.length) {\n      return 1;\n    }\n  }\n  return 0;\n}","map":{"version":3,"names":["IdleValue","intlFileNameCollatorBaseNumeric","collator","Intl","Collator","undefined","numeric","sensitivity","collatorIsNumeric","resolvedOptions","compareFileNames","one","other","caseSensitive","arguments","length","a","b","result","value","compare","compareAnything","lookFor","elementAName","toLowerCase","elementBName","prefixCompare","compareByPrefix","elementASuffixMatch","endsWith","elementBSuffixMatch","r","localeCompare","elementAPrefixMatch","startsWith","elementBPrefixMatch"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/comparers.js"],"sourcesContent":["import { IdleValue } from './async.js';\r\n// When comparing large numbers of strings, such as in sorting large arrays, is better for\r\n// performance to create an Intl.Collator object and use the function provided by its compare\r\n// property than it is to use String.prototype.localeCompare()\r\n// A collator with numeric sorting enabled, and no sensitivity to case or to accents\r\nconst intlFileNameCollatorBaseNumeric = new IdleValue(() => {\r\n    const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });\r\n    return {\r\n        collator: collator,\r\n        collatorIsNumeric: collator.resolvedOptions().numeric\r\n    };\r\n}); /** Compares filenames without distinguishing the name from the extension. Disambiguates by unicode comparison. */\r\nexport function compareFileNames(one, other, caseSensitive = false) {\r\n    const a = one || '';\r\n    const b = other || '';\r\n    const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);\r\n    // Using the numeric option in the collator will\r\n    // make compare(`foo1`, `foo01`) === 0. We must disambiguate.\r\n    if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {\r\n        return a < b ? -1 : 1;\r\n    }\r\n    return result;\r\n}\r\nexport function compareAnything(one, other, lookFor) {\r\n    const elementAName = one.toLowerCase();\r\n    const elementBName = other.toLowerCase();\r\n    // Sort prefix matches over non prefix matches\r\n    const prefixCompare = compareByPrefix(one, other, lookFor);\r\n    if (prefixCompare) {\r\n        return prefixCompare;\r\n    }\r\n    // Sort suffix matches over non suffix matches\r\n    const elementASuffixMatch = elementAName.endsWith(lookFor);\r\n    const elementBSuffixMatch = elementBName.endsWith(lookFor);\r\n    if (elementASuffixMatch !== elementBSuffixMatch) {\r\n        return elementASuffixMatch ? -1 : 1;\r\n    }\r\n    // Understand file names\r\n    const r = compareFileNames(elementAName, elementBName);\r\n    if (r !== 0) {\r\n        return r;\r\n    }\r\n    // Compare by name\r\n    return elementAName.localeCompare(elementBName);\r\n}\r\nexport function compareByPrefix(one, other, lookFor) {\r\n    const elementAName = one.toLowerCase();\r\n    const elementBName = other.toLowerCase();\r\n    // Sort prefix matches over non prefix matches\r\n    const elementAPrefixMatch = elementAName.startsWith(lookFor);\r\n    const elementBPrefixMatch = elementBName.startsWith(lookFor);\r\n    if (elementAPrefixMatch !== elementBPrefixMatch) {\r\n        return elementAPrefixMatch ? -1 : 1;\r\n    }\r\n    // Same prefix: Sort shorter matches to the top to have those on top that match more precisely\r\n    else if (elementAPrefixMatch && elementBPrefixMatch) {\r\n        if (elementAName.length < elementBName.length) {\r\n            return -1;\r\n        }\r\n        if (elementAName.length > elementBName.length) {\r\n            return 1;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}