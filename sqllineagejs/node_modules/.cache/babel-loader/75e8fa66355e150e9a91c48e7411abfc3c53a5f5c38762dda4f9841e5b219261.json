{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n  static _createWord(lineContent, wordType, nextCharClass, start, end) {\n    // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n    return {\n      start: start,\n      end: end,\n      wordType: wordType,\n      nextCharClass: nextCharClass\n    };\n  }\n  static _findPreviousWordOnLine(wordSeparators, model, position) {\n    let lineContent = model.getLineContent(position.lineNumber);\n    return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n  }\n  static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n    let wordType = 0 /* None */;\n    for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n      let chCode = lineContent.charCodeAt(chIndex);\n      let chClass = wordSeparators.get(chCode);\n      if (chClass === 0 /* Regular */) {\n        if (wordType === 2 /* Separator */) {\n          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n        }\n        wordType = 1 /* Regular */;\n      } else if (chClass === 2 /* WordSeparator */) {\n        if (wordType === 1 /* Regular */) {\n          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n        }\n        wordType = 2 /* Separator */;\n      } else if (chClass === 1 /* Whitespace */) {\n        if (wordType !== 0 /* None */) {\n          return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n        }\n      }\n    }\n    if (wordType !== 0 /* None */) {\n      return this._createWord(lineContent, wordType, 1 /* Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n    }\n    return null;\n  }\n  static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n    let len = lineContent.length;\n    for (let chIndex = startIndex; chIndex < len; chIndex++) {\n      let chCode = lineContent.charCodeAt(chIndex);\n      let chClass = wordSeparators.get(chCode);\n      if (chClass === 1 /* Whitespace */) {\n        return chIndex;\n      }\n      if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {\n        return chIndex;\n      }\n      if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {\n        return chIndex;\n      }\n    }\n    return len;\n  }\n  static _findNextWordOnLine(wordSeparators, model, position) {\n    let lineContent = model.getLineContent(position.lineNumber);\n    return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n  }\n  static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n    let wordType = 0 /* None */;\n    let len = lineContent.length;\n    for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n      let chCode = lineContent.charCodeAt(chIndex);\n      let chClass = wordSeparators.get(chCode);\n      if (chClass === 0 /* Regular */) {\n        if (wordType === 2 /* Separator */) {\n          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n        }\n        wordType = 1 /* Regular */;\n      } else if (chClass === 2 /* WordSeparator */) {\n        if (wordType === 1 /* Regular */) {\n          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n        }\n        wordType = 2 /* Separator */;\n      } else if (chClass === 1 /* Whitespace */) {\n        if (wordType !== 0 /* None */) {\n          return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n        }\n      }\n    }\n    if (wordType !== 0 /* None */) {\n      return this._createWord(lineContent, wordType, 1 /* Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n    }\n    return null;\n  }\n  static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n    for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n      let chCode = lineContent.charCodeAt(chIndex);\n      let chClass = wordSeparators.get(chCode);\n      if (chClass === 1 /* Whitespace */) {\n        return chIndex + 1;\n      }\n      if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {\n        return chIndex + 1;\n      }\n      if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {\n        return chIndex + 1;\n      }\n    }\n    return 0;\n  }\n  static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    if (column === 1) {\n      if (lineNumber > 1) {\n        lineNumber = lineNumber - 1;\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    }\n    let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n    if (wordNavigationType === 0 /* WordStart */) {\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n    }\n    if (wordNavigationType === 1 /* WordStartFast */) {\n      if (prevWordOnLine && prevWordOnLine.wordType === 2 /* Separator */ && prevWordOnLine.end - prevWordOnLine.start === 1 && prevWordOnLine.nextCharClass === 0 /* Regular */) {\n        // Skip over a word made up of one single separator and followed by a regular character\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n    }\n    if (wordNavigationType === 3 /* WordAccessibility */) {\n      while (prevWordOnLine && prevWordOnLine.wordType === 2 /* Separator */) {\n        // Skip over words made up of only separators\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n    }\n    // We are stopping at the ending of words\n    if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n      prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n    }\n    return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n  }\n  static _moveWordPartLeft(model, position) {\n    const lineNumber = position.lineNumber;\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n    if (position.column === 1) {\n      return lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position;\n    }\n    const lineContent = model.getLineContent(lineNumber);\n    for (let column = position.column - 1; column > 1; column--) {\n      const left = lineContent.charCodeAt(column - 2);\n      const right = lineContent.charCodeAt(column - 1);\n      if (left === 95 /* Underline */ && right !== 95 /* Underline */) {\n        // snake_case_variables\n        return new Position(lineNumber, column);\n      }\n      if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // camelCaseVariables\n        return new Position(lineNumber, column);\n      }\n      if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // thisIsACamelCaseWithOneLetterWords\n        if (column + 1 < maxColumn) {\n          const rightRight = lineContent.charCodeAt(column);\n          if (strings.isLowerAsciiLetter(rightRight)) {\n            return new Position(lineNumber, column);\n          }\n        }\n      }\n    }\n    return new Position(lineNumber, 1);\n  }\n  static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    let movedDown = false;\n    if (column === model.getLineMaxColumn(lineNumber)) {\n      if (lineNumber < model.getLineCount()) {\n        movedDown = true;\n        lineNumber = lineNumber + 1;\n        column = 1;\n      }\n    }\n    let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n    if (wordNavigationType === 2 /* WordEnd */) {\n      if (nextWordOnLine && nextWordOnLine.wordType === 2 /* Separator */) {\n        if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* Regular */) {\n          // Skip over a word made up of one single separator and followed by a regular character\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n        }\n      }\n      if (nextWordOnLine) {\n        column = nextWordOnLine.end + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    } else if (wordNavigationType === 3 /* WordAccessibility */) {\n      if (movedDown) {\n        // If we move to the next line, pretend that the cursor is right before the first character.\n        // This is needed when the first word starts right at the first character - and in order not to miss it,\n        // we need to start before.\n        column = 0;\n      }\n      while (nextWordOnLine && (nextWordOnLine.wordType === 2 /* Separator */ || nextWordOnLine.start + 1 <= column)) {\n        // Skip over a word made up of one single separator\n        // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    } else {\n      if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        column = model.getLineMaxColumn(lineNumber);\n      }\n    }\n    return new Position(lineNumber, column);\n  }\n  static _moveWordPartRight(model, position) {\n    const lineNumber = position.lineNumber;\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n    if (position.column === maxColumn) {\n      return lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position;\n    }\n    const lineContent = model.getLineContent(lineNumber);\n    for (let column = position.column + 1; column < maxColumn; column++) {\n      const left = lineContent.charCodeAt(column - 2);\n      const right = lineContent.charCodeAt(column - 1);\n      if (left !== 95 /* Underline */ && right === 95 /* Underline */) {\n        // snake_case_variables\n        return new Position(lineNumber, column);\n      }\n      if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // camelCaseVariables\n        return new Position(lineNumber, column);\n      }\n      if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n        // thisIsACamelCaseWithOneLetterWords\n        if (column + 1 < maxColumn) {\n          const rightRight = lineContent.charCodeAt(column);\n          if (strings.isLowerAsciiLetter(rightRight)) {\n            return new Position(lineNumber, column);\n          }\n        }\n      }\n    }\n    return new Position(lineNumber, maxColumn);\n  }\n  static _deleteWordLeftWhitespace(model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const startIndex = position.column - 2;\n    const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n    if (lastNonWhitespace + 1 < startIndex) {\n      return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n    }\n    return null;\n  }\n  static deleteWordLeft(ctx, wordNavigationType) {\n    const wordSeparators = ctx.wordSeparators;\n    const model = ctx.model;\n    const selection = ctx.selection;\n    const whitespaceHeuristics = ctx.whitespaceHeuristics;\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection])) {\n      const position = ctx.selection.getPosition();\n      return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n    }\n    const position = new Position(selection.positionLineNumber, selection.positionColumn);\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    if (lineNumber === 1 && column === 1) {\n      // Ignore deleting at beginning of file\n      return null;\n    }\n    if (whitespaceHeuristics) {\n      let r = this._deleteWordLeftWhitespace(model, position);\n      if (r) {\n        return r;\n      }\n    }\n    let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n    if (wordNavigationType === 0 /* WordStart */) {\n      if (prevWordOnLine) {\n        column = prevWordOnLine.start + 1;\n      } else {\n        if (column > 1) {\n          column = 1;\n        } else {\n          lineNumber--;\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n    } else {\n      if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n      if (prevWordOnLine) {\n        column = prevWordOnLine.end + 1;\n      } else {\n        if (column > 1) {\n          column = 1;\n        } else {\n          lineNumber--;\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n    }\n    return new Range(lineNumber, column, position.lineNumber, position.column);\n  }\n  static deleteInsideWord(wordSeparators, model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const position = new Position(selection.positionLineNumber, selection.positionColumn);\n    let r = this._deleteInsideWordWhitespace(model, position);\n    if (r) {\n      return r;\n    }\n    return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n  }\n  static _charAtIsWhitespace(str, index) {\n    const charCode = str.charCodeAt(index);\n    return charCode === 32 /* Space */ || charCode === 9 /* Tab */;\n  }\n\n  static _deleteInsideWordWhitespace(model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const lineContentLength = lineContent.length;\n    if (lineContentLength === 0) {\n      // empty line\n      return null;\n    }\n    let leftIndex = Math.max(position.column - 2, 0);\n    if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n      // touches a non-whitespace character to the left\n      return null;\n    }\n    let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n    if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n      // touches a non-whitespace character to the right\n      return null;\n    }\n    // walk over whitespace to the left\n    while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n      leftIndex--;\n    }\n    // walk over whitespace to the right\n    while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n      rightIndex++;\n    }\n    return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n  }\n  static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const lineLength = lineContent.length;\n    if (lineLength === 0) {\n      // empty line\n      if (position.lineNumber > 1) {\n        return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n      } else {\n        if (position.lineNumber < model.getLineCount()) {\n          return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n        } else {\n          // empty model\n          return new Range(position.lineNumber, 1, position.lineNumber, 1);\n        }\n      }\n    }\n    const touchesWord = word => {\n      return word.start + 1 <= position.column && position.column <= word.end + 1;\n    };\n    const createRangeWithPosition = (startColumn, endColumn) => {\n      startColumn = Math.min(startColumn, position.column);\n      endColumn = Math.max(endColumn, position.column);\n      return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n    };\n    const deleteWordAndAdjacentWhitespace = word => {\n      let startColumn = word.start + 1;\n      let endColumn = word.end + 1;\n      let expandedToTheRight = false;\n      while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n        expandedToTheRight = true;\n        endColumn++;\n      }\n      if (!expandedToTheRight) {\n        while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n          startColumn--;\n        }\n      }\n      return createRangeWithPosition(startColumn, endColumn);\n    };\n    const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n    if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n      return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n    }\n    const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n    if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n      return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n    }\n    if (prevWordOnLine && nextWordOnLine) {\n      return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n    }\n    if (prevWordOnLine) {\n      return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n    }\n    if (nextWordOnLine) {\n      return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n    }\n    return createRangeWithPosition(1, lineLength + 1);\n  }\n  static _deleteWordPartLeft(model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const pos = selection.getPosition();\n    const toPosition = WordOperations._moveWordPartLeft(model, pos);\n    return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n  }\n  static _findFirstNonWhitespaceChar(str, startIndex) {\n    let len = str.length;\n    for (let chIndex = startIndex; chIndex < len; chIndex++) {\n      let ch = str.charAt(chIndex);\n      if (ch !== ' ' && ch !== '\\t') {\n        return chIndex;\n      }\n    }\n    return len;\n  }\n  static _deleteWordRightWhitespace(model, position) {\n    const lineContent = model.getLineContent(position.lineNumber);\n    const startIndex = position.column - 1;\n    const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n    if (startIndex + 1 < firstNonWhitespace) {\n      // bingo\n      return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n    }\n    return null;\n  }\n  static deleteWordRight(ctx, wordNavigationType) {\n    const wordSeparators = ctx.wordSeparators;\n    const model = ctx.model;\n    const selection = ctx.selection;\n    const whitespaceHeuristics = ctx.whitespaceHeuristics;\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const position = new Position(selection.positionLineNumber, selection.positionColumn);\n    let lineNumber = position.lineNumber;\n    let column = position.column;\n    const lineCount = model.getLineCount();\n    const maxColumn = model.getLineMaxColumn(lineNumber);\n    if (lineNumber === lineCount && column === maxColumn) {\n      // Ignore deleting at end of file\n      return null;\n    }\n    if (whitespaceHeuristics) {\n      let r = this._deleteWordRightWhitespace(model, position);\n      if (r) {\n        return r;\n      }\n    }\n    let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n    if (wordNavigationType === 2 /* WordEnd */) {\n      if (nextWordOnLine) {\n        column = nextWordOnLine.end + 1;\n      } else {\n        if (column < maxColumn || lineNumber === lineCount) {\n          column = maxColumn;\n        } else {\n          lineNumber++;\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n          if (nextWordOnLine) {\n            column = nextWordOnLine.start + 1;\n          } else {\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      }\n    } else {\n      if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n      }\n      if (nextWordOnLine) {\n        column = nextWordOnLine.start + 1;\n      } else {\n        if (column < maxColumn || lineNumber === lineCount) {\n          column = maxColumn;\n        } else {\n          lineNumber++;\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n          if (nextWordOnLine) {\n            column = nextWordOnLine.start + 1;\n          } else {\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      }\n    }\n    return new Range(lineNumber, column, position.lineNumber, position.column);\n  }\n  static _deleteWordPartRight(model, selection) {\n    if (!selection.isEmpty()) {\n      return selection;\n    }\n    const pos = selection.getPosition();\n    const toPosition = WordOperations._moveWordPartRight(model, pos);\n    return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n  }\n  static _createWordAtPosition(model, lineNumber, word) {\n    const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n    return {\n      word: model.getValueInRange(range),\n      startColumn: range.startColumn,\n      endColumn: range.endColumn\n    };\n  }\n  static getWordAtPosition(model, _wordSeparators, position) {\n    const wordSeparators = getMapForWordSeparators(_wordSeparators);\n    const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n    if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n      return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n    }\n    const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n    if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n      return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n    }\n    return null;\n  }\n  static word(config, model, cursor, inSelectionMode, position) {\n    const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n    let prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n    let nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n    if (!inSelectionMode) {\n      // Entering word selection for the first time\n      let startColumn;\n      let endColumn;\n      if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n        // isTouchingPrevWord\n        startColumn = prevWord.start + 1;\n        endColumn = prevWord.end + 1;\n      } else if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n        // isTouchingNextWord\n        startColumn = nextWord.start + 1;\n        endColumn = nextWord.end + 1;\n      } else {\n        if (prevWord) {\n          startColumn = prevWord.end + 1;\n        } else {\n          startColumn = 1;\n        }\n        if (nextWord) {\n          endColumn = nextWord.start + 1;\n        } else {\n          endColumn = model.getLineMaxColumn(position.lineNumber);\n        }\n      }\n      return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 0, new Position(position.lineNumber, endColumn), 0);\n    }\n    let startColumn;\n    let endColumn;\n    if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n      // isInsidePrevWord\n      startColumn = prevWord.start + 1;\n      endColumn = prevWord.end + 1;\n    } else if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n      // isInsideNextWord\n      startColumn = nextWord.start + 1;\n      endColumn = nextWord.end + 1;\n    } else {\n      startColumn = position.column;\n      endColumn = position.column;\n    }\n    let lineNumber = position.lineNumber;\n    let column;\n    if (cursor.selectionStart.containsPosition(position)) {\n      column = cursor.selectionStart.endColumn;\n    } else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n      column = startColumn;\n      let possiblePosition = new Position(lineNumber, column);\n      if (cursor.selectionStart.containsPosition(possiblePosition)) {\n        column = cursor.selectionStart.endColumn;\n      }\n    } else {\n      column = endColumn;\n      let possiblePosition = new Position(lineNumber, column);\n      if (cursor.selectionStart.containsPosition(possiblePosition)) {\n        column = cursor.selectionStart.startColumn;\n      }\n    }\n    return cursor.move(true, lineNumber, column, 0);\n  }\n}\nexport class WordPartOperations extends WordOperations {\n  static deleteWordPartLeft(ctx) {\n    const candidates = enforceDefined([WordOperations.deleteWordLeft(ctx, 0 /* WordStart */), WordOperations.deleteWordLeft(ctx, 2 /* WordEnd */), WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)]);\n    candidates.sort(Range.compareRangesUsingEnds);\n    return candidates[2];\n  }\n  static deleteWordPartRight(ctx) {\n    const candidates = enforceDefined([WordOperations.deleteWordRight(ctx, 0 /* WordStart */), WordOperations.deleteWordRight(ctx, 2 /* WordEnd */), WordOperations._deleteWordPartRight(ctx.model, ctx.selection)]);\n    candidates.sort(Range.compareRangesUsingStarts);\n    return candidates[0];\n  }\n  static moveWordPartLeft(wordSeparators, model, position) {\n    const candidates = enforceDefined([WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordStart */), WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordEnd */), WordOperations._moveWordPartLeft(model, position)]);\n    candidates.sort(Position.compare);\n    return candidates[2];\n  }\n  static moveWordPartRight(wordSeparators, model, position) {\n    const candidates = enforceDefined([WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordStart */), WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordEnd */), WordOperations._moveWordPartRight(model, position)]);\n    candidates.sort(Position.compare);\n    return candidates[0];\n  }\n}\nfunction enforceDefined(arr) {\n  return arr.filter(el => Boolean(el));\n}","map":{"version":3,"names":["strings","SingleCursorState","DeleteOperations","getMapForWordSeparators","Position","Range","WordOperations","_createWord","lineContent","wordType","nextCharClass","start","end","_findPreviousWordOnLine","wordSeparators","model","position","getLineContent","lineNumber","_doFindPreviousWordOnLine","chIndex","column","chCode","charCodeAt","chClass","get","_findEndOfWord","startIndex","len","length","_findNextWordOnLine","_doFindNextWordOnLine","_findStartOfWord","moveWordLeft","wordNavigationType","getLineMaxColumn","prevWordOnLine","_moveWordPartLeft","maxColumn","left","right","isLowerAsciiLetter","isUpperAsciiLetter","rightRight","moveWordRight","movedDown","getLineCount","nextWordOnLine","_moveWordPartRight","_deleteWordLeftWhitespace","lastNonWhitespace","lastNonWhitespaceIndex","deleteWordLeft","ctx","selection","whitespaceHeuristics","isEmpty","isAutoClosingPairDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairs","autoClosingPairsOpenByEnd","getPosition","positionLineNumber","positionColumn","r","deleteInsideWord","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","_charAtIsWhitespace","str","index","charCode","lineContentLength","leftIndex","Math","max","rightIndex","min","lineLength","touchesWord","word","createRangeWithPosition","startColumn","endColumn","deleteWordAndAdjacentWhitespace","expandedToTheRight","_deleteWordPartLeft","pos","toPosition","_findFirstNonWhitespaceChar","ch","charAt","_deleteWordRightWhitespace","firstNonWhitespace","deleteWordRight","lineCount","_deleteWordPartRight","_createWordAtPosition","range","getValueInRange","getWordAtPosition","_wordSeparators","prevWord","nextWord","config","cursor","inSelectionMode","selectionStart","containsPosition","isBeforeOrEqual","getStartPosition","possiblePosition","move","WordPartOperations","deleteWordPartLeft","candidates","enforceDefined","sort","compareRangesUsingEnds","deleteWordPartRight","compareRangesUsingStarts","moveWordPartLeft","compare","moveWordPartRight","arr","filter","el","Boolean"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/controller/cursorWordOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { SingleCursorState } from './cursorCommon.js';\r\nimport { DeleteOperations } from './cursorDeleteOperations.js';\r\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nexport class WordOperations {\r\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\r\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\r\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\r\n    }\r\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\r\n        let lineContent = model.getLineContent(position.lineNumber);\r\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\r\n    }\r\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\r\n        let wordType = 0 /* None */;\r\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\r\n            let chCode = lineContent.charCodeAt(chIndex);\r\n            let chClass = wordSeparators.get(chCode);\r\n            if (chClass === 0 /* Regular */) {\r\n                if (wordType === 2 /* Separator */) {\r\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\r\n                }\r\n                wordType = 1 /* Regular */;\r\n            }\r\n            else if (chClass === 2 /* WordSeparator */) {\r\n                if (wordType === 1 /* Regular */) {\r\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\r\n                }\r\n                wordType = 2 /* Separator */;\r\n            }\r\n            else if (chClass === 1 /* Whitespace */) {\r\n                if (wordType !== 0 /* None */) {\r\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\r\n                }\r\n            }\r\n        }\r\n        if (wordType !== 0 /* None */) {\r\n            return this._createWord(lineContent, wordType, 1 /* Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\r\n        }\r\n        return null;\r\n    }\r\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\r\n        let len = lineContent.length;\r\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\r\n            let chCode = lineContent.charCodeAt(chIndex);\r\n            let chClass = wordSeparators.get(chCode);\r\n            if (chClass === 1 /* Whitespace */) {\r\n                return chIndex;\r\n            }\r\n            if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {\r\n                return chIndex;\r\n            }\r\n            if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {\r\n                return chIndex;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n    static _findNextWordOnLine(wordSeparators, model, position) {\r\n        let lineContent = model.getLineContent(position.lineNumber);\r\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\r\n    }\r\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\r\n        let wordType = 0 /* None */;\r\n        let len = lineContent.length;\r\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\r\n            let chCode = lineContent.charCodeAt(chIndex);\r\n            let chClass = wordSeparators.get(chCode);\r\n            if (chClass === 0 /* Regular */) {\r\n                if (wordType === 2 /* Separator */) {\r\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\r\n                }\r\n                wordType = 1 /* Regular */;\r\n            }\r\n            else if (chClass === 2 /* WordSeparator */) {\r\n                if (wordType === 1 /* Regular */) {\r\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\r\n                }\r\n                wordType = 2 /* Separator */;\r\n            }\r\n            else if (chClass === 1 /* Whitespace */) {\r\n                if (wordType !== 0 /* None */) {\r\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\r\n                }\r\n            }\r\n        }\r\n        if (wordType !== 0 /* None */) {\r\n            return this._createWord(lineContent, wordType, 1 /* Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\r\n        }\r\n        return null;\r\n    }\r\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\r\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\r\n            let chCode = lineContent.charCodeAt(chIndex);\r\n            let chClass = wordSeparators.get(chCode);\r\n            if (chClass === 1 /* Whitespace */) {\r\n                return chIndex + 1;\r\n            }\r\n            if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {\r\n                return chIndex + 1;\r\n            }\r\n            if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {\r\n                return chIndex + 1;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\r\n        let lineNumber = position.lineNumber;\r\n        let column = position.column;\r\n        if (column === 1) {\r\n            if (lineNumber > 1) {\r\n                lineNumber = lineNumber - 1;\r\n                column = model.getLineMaxColumn(lineNumber);\r\n            }\r\n        }\r\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\r\n        if (wordNavigationType === 0 /* WordStart */) {\r\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\r\n        }\r\n        if (wordNavigationType === 1 /* WordStartFast */) {\r\n            if (prevWordOnLine\r\n                && prevWordOnLine.wordType === 2 /* Separator */\r\n                && prevWordOnLine.end - prevWordOnLine.start === 1\r\n                && prevWordOnLine.nextCharClass === 0 /* Regular */) {\r\n                // Skip over a word made up of one single separator and followed by a regular character\r\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\r\n            }\r\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\r\n        }\r\n        if (wordNavigationType === 3 /* WordAccessibility */) {\r\n            while (prevWordOnLine\r\n                && prevWordOnLine.wordType === 2 /* Separator */) {\r\n                // Skip over words made up of only separators\r\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\r\n            }\r\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\r\n        }\r\n        // We are stopping at the ending of words\r\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\r\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\r\n        }\r\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\r\n    }\r\n    static _moveWordPartLeft(model, position) {\r\n        const lineNumber = position.lineNumber;\r\n        const maxColumn = model.getLineMaxColumn(lineNumber);\r\n        if (position.column === 1) {\r\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\r\n        }\r\n        const lineContent = model.getLineContent(lineNumber);\r\n        for (let column = position.column - 1; column > 1; column--) {\r\n            const left = lineContent.charCodeAt(column - 2);\r\n            const right = lineContent.charCodeAt(column - 1);\r\n            if (left === 95 /* Underline */ && right !== 95 /* Underline */) {\r\n                // snake_case_variables\r\n                return new Position(lineNumber, column);\r\n            }\r\n            if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\r\n                // camelCaseVariables\r\n                return new Position(lineNumber, column);\r\n            }\r\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\r\n                // thisIsACamelCaseWithOneLetterWords\r\n                if (column + 1 < maxColumn) {\r\n                    const rightRight = lineContent.charCodeAt(column);\r\n                    if (strings.isLowerAsciiLetter(rightRight)) {\r\n                        return new Position(lineNumber, column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Position(lineNumber, 1);\r\n    }\r\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\r\n        let lineNumber = position.lineNumber;\r\n        let column = position.column;\r\n        let movedDown = false;\r\n        if (column === model.getLineMaxColumn(lineNumber)) {\r\n            if (lineNumber < model.getLineCount()) {\r\n                movedDown = true;\r\n                lineNumber = lineNumber + 1;\r\n                column = 1;\r\n            }\r\n        }\r\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\r\n        if (wordNavigationType === 2 /* WordEnd */) {\r\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* Separator */) {\r\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* Regular */) {\r\n                    // Skip over a word made up of one single separator and followed by a regular character\r\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\r\n                }\r\n            }\r\n            if (nextWordOnLine) {\r\n                column = nextWordOnLine.end + 1;\r\n            }\r\n            else {\r\n                column = model.getLineMaxColumn(lineNumber);\r\n            }\r\n        }\r\n        else if (wordNavigationType === 3 /* WordAccessibility */) {\r\n            if (movedDown) {\r\n                // If we move to the next line, pretend that the cursor is right before the first character.\r\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\r\n                // we need to start before.\r\n                column = 0;\r\n            }\r\n            while (nextWordOnLine\r\n                && (nextWordOnLine.wordType === 2 /* Separator */\r\n                    || nextWordOnLine.start + 1 <= column)) {\r\n                // Skip over a word made up of one single separator\r\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\r\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\r\n            }\r\n            if (nextWordOnLine) {\r\n                column = nextWordOnLine.start + 1;\r\n            }\r\n            else {\r\n                column = model.getLineMaxColumn(lineNumber);\r\n            }\r\n        }\r\n        else {\r\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\r\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\r\n            }\r\n            if (nextWordOnLine) {\r\n                column = nextWordOnLine.start + 1;\r\n            }\r\n            else {\r\n                column = model.getLineMaxColumn(lineNumber);\r\n            }\r\n        }\r\n        return new Position(lineNumber, column);\r\n    }\r\n    static _moveWordPartRight(model, position) {\r\n        const lineNumber = position.lineNumber;\r\n        const maxColumn = model.getLineMaxColumn(lineNumber);\r\n        if (position.column === maxColumn) {\r\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\r\n        }\r\n        const lineContent = model.getLineContent(lineNumber);\r\n        for (let column = position.column + 1; column < maxColumn; column++) {\r\n            const left = lineContent.charCodeAt(column - 2);\r\n            const right = lineContent.charCodeAt(column - 1);\r\n            if (left !== 95 /* Underline */ && right === 95 /* Underline */) {\r\n                // snake_case_variables\r\n                return new Position(lineNumber, column);\r\n            }\r\n            if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\r\n                // camelCaseVariables\r\n                return new Position(lineNumber, column);\r\n            }\r\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\r\n                // thisIsACamelCaseWithOneLetterWords\r\n                if (column + 1 < maxColumn) {\r\n                    const rightRight = lineContent.charCodeAt(column);\r\n                    if (strings.isLowerAsciiLetter(rightRight)) {\r\n                        return new Position(lineNumber, column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Position(lineNumber, maxColumn);\r\n    }\r\n    static _deleteWordLeftWhitespace(model, position) {\r\n        const lineContent = model.getLineContent(position.lineNumber);\r\n        const startIndex = position.column - 2;\r\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\r\n        if (lastNonWhitespace + 1 < startIndex) {\r\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\r\n        }\r\n        return null;\r\n    }\r\n    static deleteWordLeft(ctx, wordNavigationType) {\r\n        const wordSeparators = ctx.wordSeparators;\r\n        const model = ctx.model;\r\n        const selection = ctx.selection;\r\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\r\n        if (!selection.isEmpty()) {\r\n            return selection;\r\n        }\r\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection])) {\r\n            const position = ctx.selection.getPosition();\r\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\r\n        }\r\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\r\n        let lineNumber = position.lineNumber;\r\n        let column = position.column;\r\n        if (lineNumber === 1 && column === 1) {\r\n            // Ignore deleting at beginning of file\r\n            return null;\r\n        }\r\n        if (whitespaceHeuristics) {\r\n            let r = this._deleteWordLeftWhitespace(model, position);\r\n            if (r) {\r\n                return r;\r\n            }\r\n        }\r\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\r\n        if (wordNavigationType === 0 /* WordStart */) {\r\n            if (prevWordOnLine) {\r\n                column = prevWordOnLine.start + 1;\r\n            }\r\n            else {\r\n                if (column > 1) {\r\n                    column = 1;\r\n                }\r\n                else {\r\n                    lineNumber--;\r\n                    column = model.getLineMaxColumn(lineNumber);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\r\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\r\n            }\r\n            if (prevWordOnLine) {\r\n                column = prevWordOnLine.end + 1;\r\n            }\r\n            else {\r\n                if (column > 1) {\r\n                    column = 1;\r\n                }\r\n                else {\r\n                    lineNumber--;\r\n                    column = model.getLineMaxColumn(lineNumber);\r\n                }\r\n            }\r\n        }\r\n        return new Range(lineNumber, column, position.lineNumber, position.column);\r\n    }\r\n    static deleteInsideWord(wordSeparators, model, selection) {\r\n        if (!selection.isEmpty()) {\r\n            return selection;\r\n        }\r\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\r\n        let r = this._deleteInsideWordWhitespace(model, position);\r\n        if (r) {\r\n            return r;\r\n        }\r\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\r\n    }\r\n    static _charAtIsWhitespace(str, index) {\r\n        const charCode = str.charCodeAt(index);\r\n        return (charCode === 32 /* Space */ || charCode === 9 /* Tab */);\r\n    }\r\n    static _deleteInsideWordWhitespace(model, position) {\r\n        const lineContent = model.getLineContent(position.lineNumber);\r\n        const lineContentLength = lineContent.length;\r\n        if (lineContentLength === 0) {\r\n            // empty line\r\n            return null;\r\n        }\r\n        let leftIndex = Math.max(position.column - 2, 0);\r\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\r\n            // touches a non-whitespace character to the left\r\n            return null;\r\n        }\r\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\r\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\r\n            // touches a non-whitespace character to the right\r\n            return null;\r\n        }\r\n        // walk over whitespace to the left\r\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\r\n            leftIndex--;\r\n        }\r\n        // walk over whitespace to the right\r\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\r\n            rightIndex++;\r\n        }\r\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\r\n    }\r\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\r\n        const lineContent = model.getLineContent(position.lineNumber);\r\n        const lineLength = lineContent.length;\r\n        if (lineLength === 0) {\r\n            // empty line\r\n            if (position.lineNumber > 1) {\r\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\r\n            }\r\n            else {\r\n                if (position.lineNumber < model.getLineCount()) {\r\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\r\n                }\r\n                else {\r\n                    // empty model\r\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\r\n                }\r\n            }\r\n        }\r\n        const touchesWord = (word) => {\r\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\r\n        };\r\n        const createRangeWithPosition = (startColumn, endColumn) => {\r\n            startColumn = Math.min(startColumn, position.column);\r\n            endColumn = Math.max(endColumn, position.column);\r\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\r\n        };\r\n        const deleteWordAndAdjacentWhitespace = (word) => {\r\n            let startColumn = word.start + 1;\r\n            let endColumn = word.end + 1;\r\n            let expandedToTheRight = false;\r\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\r\n                expandedToTheRight = true;\r\n                endColumn++;\r\n            }\r\n            if (!expandedToTheRight) {\r\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\r\n                    startColumn--;\r\n                }\r\n            }\r\n            return createRangeWithPosition(startColumn, endColumn);\r\n        };\r\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\r\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\r\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\r\n        }\r\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\r\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\r\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\r\n        }\r\n        if (prevWordOnLine && nextWordOnLine) {\r\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\r\n        }\r\n        if (prevWordOnLine) {\r\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\r\n        }\r\n        if (nextWordOnLine) {\r\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\r\n        }\r\n        return createRangeWithPosition(1, lineLength + 1);\r\n    }\r\n    static _deleteWordPartLeft(model, selection) {\r\n        if (!selection.isEmpty()) {\r\n            return selection;\r\n        }\r\n        const pos = selection.getPosition();\r\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\r\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\r\n    }\r\n    static _findFirstNonWhitespaceChar(str, startIndex) {\r\n        let len = str.length;\r\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\r\n            let ch = str.charAt(chIndex);\r\n            if (ch !== ' ' && ch !== '\\t') {\r\n                return chIndex;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n    static _deleteWordRightWhitespace(model, position) {\r\n        const lineContent = model.getLineContent(position.lineNumber);\r\n        const startIndex = position.column - 1;\r\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\r\n        if (startIndex + 1 < firstNonWhitespace) {\r\n            // bingo\r\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\r\n        }\r\n        return null;\r\n    }\r\n    static deleteWordRight(ctx, wordNavigationType) {\r\n        const wordSeparators = ctx.wordSeparators;\r\n        const model = ctx.model;\r\n        const selection = ctx.selection;\r\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\r\n        if (!selection.isEmpty()) {\r\n            return selection;\r\n        }\r\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\r\n        let lineNumber = position.lineNumber;\r\n        let column = position.column;\r\n        const lineCount = model.getLineCount();\r\n        const maxColumn = model.getLineMaxColumn(lineNumber);\r\n        if (lineNumber === lineCount && column === maxColumn) {\r\n            // Ignore deleting at end of file\r\n            return null;\r\n        }\r\n        if (whitespaceHeuristics) {\r\n            let r = this._deleteWordRightWhitespace(model, position);\r\n            if (r) {\r\n                return r;\r\n            }\r\n        }\r\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\r\n        if (wordNavigationType === 2 /* WordEnd */) {\r\n            if (nextWordOnLine) {\r\n                column = nextWordOnLine.end + 1;\r\n            }\r\n            else {\r\n                if (column < maxColumn || lineNumber === lineCount) {\r\n                    column = maxColumn;\r\n                }\r\n                else {\r\n                    lineNumber++;\r\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\r\n                    if (nextWordOnLine) {\r\n                        column = nextWordOnLine.start + 1;\r\n                    }\r\n                    else {\r\n                        column = model.getLineMaxColumn(lineNumber);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\r\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\r\n            }\r\n            if (nextWordOnLine) {\r\n                column = nextWordOnLine.start + 1;\r\n            }\r\n            else {\r\n                if (column < maxColumn || lineNumber === lineCount) {\r\n                    column = maxColumn;\r\n                }\r\n                else {\r\n                    lineNumber++;\r\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\r\n                    if (nextWordOnLine) {\r\n                        column = nextWordOnLine.start + 1;\r\n                    }\r\n                    else {\r\n                        column = model.getLineMaxColumn(lineNumber);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Range(lineNumber, column, position.lineNumber, position.column);\r\n    }\r\n    static _deleteWordPartRight(model, selection) {\r\n        if (!selection.isEmpty()) {\r\n            return selection;\r\n        }\r\n        const pos = selection.getPosition();\r\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\r\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\r\n    }\r\n    static _createWordAtPosition(model, lineNumber, word) {\r\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\r\n        return {\r\n            word: model.getValueInRange(range),\r\n            startColumn: range.startColumn,\r\n            endColumn: range.endColumn\r\n        };\r\n    }\r\n    static getWordAtPosition(model, _wordSeparators, position) {\r\n        const wordSeparators = getMapForWordSeparators(_wordSeparators);\r\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\r\n        if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\r\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\r\n        }\r\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\r\n        if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\r\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\r\n        }\r\n        return null;\r\n    }\r\n    static word(config, model, cursor, inSelectionMode, position) {\r\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\r\n        let prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\r\n        let nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\r\n        if (!inSelectionMode) {\r\n            // Entering word selection for the first time\r\n            let startColumn;\r\n            let endColumn;\r\n            if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\r\n                // isTouchingPrevWord\r\n                startColumn = prevWord.start + 1;\r\n                endColumn = prevWord.end + 1;\r\n            }\r\n            else if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\r\n                // isTouchingNextWord\r\n                startColumn = nextWord.start + 1;\r\n                endColumn = nextWord.end + 1;\r\n            }\r\n            else {\r\n                if (prevWord) {\r\n                    startColumn = prevWord.end + 1;\r\n                }\r\n                else {\r\n                    startColumn = 1;\r\n                }\r\n                if (nextWord) {\r\n                    endColumn = nextWord.start + 1;\r\n                }\r\n                else {\r\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\r\n                }\r\n            }\r\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 0, new Position(position.lineNumber, endColumn), 0);\r\n        }\r\n        let startColumn;\r\n        let endColumn;\r\n        if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\r\n            // isInsidePrevWord\r\n            startColumn = prevWord.start + 1;\r\n            endColumn = prevWord.end + 1;\r\n        }\r\n        else if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\r\n            // isInsideNextWord\r\n            startColumn = nextWord.start + 1;\r\n            endColumn = nextWord.end + 1;\r\n        }\r\n        else {\r\n            startColumn = position.column;\r\n            endColumn = position.column;\r\n        }\r\n        let lineNumber = position.lineNumber;\r\n        let column;\r\n        if (cursor.selectionStart.containsPosition(position)) {\r\n            column = cursor.selectionStart.endColumn;\r\n        }\r\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\r\n            column = startColumn;\r\n            let possiblePosition = new Position(lineNumber, column);\r\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\r\n                column = cursor.selectionStart.endColumn;\r\n            }\r\n        }\r\n        else {\r\n            column = endColumn;\r\n            let possiblePosition = new Position(lineNumber, column);\r\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\r\n                column = cursor.selectionStart.startColumn;\r\n            }\r\n        }\r\n        return cursor.move(true, lineNumber, column, 0);\r\n    }\r\n}\r\nexport class WordPartOperations extends WordOperations {\r\n    static deleteWordPartLeft(ctx) {\r\n        const candidates = enforceDefined([\r\n            WordOperations.deleteWordLeft(ctx, 0 /* WordStart */),\r\n            WordOperations.deleteWordLeft(ctx, 2 /* WordEnd */),\r\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\r\n        ]);\r\n        candidates.sort(Range.compareRangesUsingEnds);\r\n        return candidates[2];\r\n    }\r\n    static deleteWordPartRight(ctx) {\r\n        const candidates = enforceDefined([\r\n            WordOperations.deleteWordRight(ctx, 0 /* WordStart */),\r\n            WordOperations.deleteWordRight(ctx, 2 /* WordEnd */),\r\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\r\n        ]);\r\n        candidates.sort(Range.compareRangesUsingStarts);\r\n        return candidates[0];\r\n    }\r\n    static moveWordPartLeft(wordSeparators, model, position) {\r\n        const candidates = enforceDefined([\r\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordStart */),\r\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordEnd */),\r\n            WordOperations._moveWordPartLeft(model, position)\r\n        ]);\r\n        candidates.sort(Position.compare);\r\n        return candidates[2];\r\n    }\r\n    static moveWordPartRight(wordSeparators, model, position) {\r\n        const candidates = enforceDefined([\r\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordStart */),\r\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordEnd */),\r\n            WordOperations._moveWordPartRight(model, position)\r\n        ]);\r\n        candidates.sort(Position.compare);\r\n        return candidates[0];\r\n    }\r\n}\r\nfunction enforceDefined(arr) {\r\n    return arr.filter(el => Boolean(el));\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}