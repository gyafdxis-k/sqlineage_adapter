{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { MinimapCharRenderer } from './minimapCharRenderer.js';\nimport { allCharCodes } from './minimapCharSheet.js';\nimport { prebakedMiniMaps } from './minimapPreBaked.js';\nimport { toUint8 } from '../../../../base/common/uint.js';\n/**\r\n * Creates character renderers. It takes a 'scale' that determines how large\r\n * characters should be drawn. Using this, it draws data into a canvas and\r\n * then downsamples the characters as necessary for the current display.\r\n * This makes rendering more efficient, rather than drawing a full (tiny)\r\n * font, or downsampling in real-time.\r\n */\nexport class MinimapCharRendererFactory {\n  /**\r\n   * Creates a new character renderer factory with the given scale.\r\n   */\n  static create(scale, fontFamily) {\n    // renderers are immutable. By default we'll 'create' a new minimap\n    // character renderer whenever we switch editors, no need to do extra work.\n    if (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {\n      return this.lastCreated;\n    }\n    let factory;\n    if (prebakedMiniMaps[scale]) {\n      factory = new MinimapCharRenderer(prebakedMiniMaps[scale](), scale);\n    } else {\n      factory = MinimapCharRendererFactory.createFromSampleData(MinimapCharRendererFactory.createSampleData(fontFamily).data, scale);\n    }\n    this.lastFontFamily = fontFamily;\n    this.lastCreated = factory;\n    return factory;\n  }\n  /**\r\n   * Creates the font sample data, writing to a canvas.\r\n   */\n  static createSampleData(fontFamily) {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    canvas.style.height = \"\".concat(16 /* SAMPLED_CHAR_HEIGHT */, \"px\");\n    canvas.height = 16 /* SAMPLED_CHAR_HEIGHT */;\n    canvas.width = 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */;\n    canvas.style.width = 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */ + 'px';\n    ctx.fillStyle = '#ffffff';\n    ctx.font = \"bold \".concat(16 /* SAMPLED_CHAR_HEIGHT */, \"px \", fontFamily);\n    ctx.textBaseline = 'middle';\n    let x = 0;\n    for (const code of allCharCodes) {\n      ctx.fillText(String.fromCharCode(code), x, 16 /* SAMPLED_CHAR_HEIGHT */ / 2);\n      x += 10 /* SAMPLED_CHAR_WIDTH */;\n    }\n\n    return ctx.getImageData(0, 0, 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */, 16 /* SAMPLED_CHAR_HEIGHT */);\n  }\n  /**\r\n   * Creates a character renderer from the canvas sample data.\r\n   */\n  static createFromSampleData(source, scale) {\n    const expectedLength = 16 /* SAMPLED_CHAR_HEIGHT */ * 10 /* SAMPLED_CHAR_WIDTH */ * 4 /* RGBA_CHANNELS_CNT */ * 96 /* CHAR_COUNT */;\n    if (source.length !== expectedLength) {\n      throw new Error('Unexpected source in MinimapCharRenderer');\n    }\n    let charData = MinimapCharRendererFactory._downsample(source, scale);\n    return new MinimapCharRenderer(charData, scale);\n  }\n  static _downsampleChar(source, sourceOffset, dest, destOffset, scale) {\n    const width = 1 /* BASE_CHAR_WIDTH */ * scale;\n    const height = 2 /* BASE_CHAR_HEIGHT */ * scale;\n    let targetIndex = destOffset;\n    let brightest = 0;\n    // This is essentially an ad-hoc rescaling algorithm. Standard approaches\n    // like bicubic interpolation are awesome for scaling between image sizes,\n    // but don't work so well when scaling to very small pixel values, we end\n    // up with blurry, indistinct forms.\n    //\n    // The approach taken here is simply mapping each source pixel to the target\n    // pixels, and taking the weighted values for all pixels in each, and then\n    // averaging them out. Finally we apply an intensity boost in _downsample,\n    // since when scaling to the smallest pixel sizes there's more black space\n    // which causes characters to be much less distinct.\n    for (let y = 0; y < height; y++) {\n      // 1. For this destination pixel, get the source pixels we're sampling\n      // from (x1, y1) to the next pixel (x2, y2)\n      const sourceY1 = y / height * 16 /* SAMPLED_CHAR_HEIGHT */;\n      const sourceY2 = (y + 1) / height * 16 /* SAMPLED_CHAR_HEIGHT */;\n      for (let x = 0; x < width; x++) {\n        const sourceX1 = x / width * 10 /* SAMPLED_CHAR_WIDTH */;\n        const sourceX2 = (x + 1) / width * 10 /* SAMPLED_CHAR_WIDTH */;\n        // 2. Sample all of them, summing them up and weighting them. Similar\n        // to bilinear interpolation.\n        let value = 0;\n        let samples = 0;\n        for (let sy = sourceY1; sy < sourceY2; sy++) {\n          const sourceRow = sourceOffset + Math.floor(sy) * 3840 /* RGBA_SAMPLED_ROW_WIDTH */;\n          const yBalance = 1 - (sy - Math.floor(sy));\n          for (let sx = sourceX1; sx < sourceX2; sx++) {\n            const xBalance = 1 - (sx - Math.floor(sx));\n            const sourceIndex = sourceRow + Math.floor(sx) * 4 /* RGBA_CHANNELS_CNT */;\n            const weight = xBalance * yBalance;\n            samples += weight;\n            value += source[sourceIndex] * source[sourceIndex + 3] / 255 * weight;\n          }\n        }\n        const final = value / samples;\n        brightest = Math.max(brightest, final);\n        dest[targetIndex++] = toUint8(final);\n      }\n    }\n    return brightest;\n  }\n  static _downsample(data, scale) {\n    const pixelsPerCharacter = 2 /* BASE_CHAR_HEIGHT */ * scale * 1 /* BASE_CHAR_WIDTH */ * scale;\n    const resultLen = pixelsPerCharacter * 96 /* CHAR_COUNT */;\n    const result = new Uint8ClampedArray(resultLen);\n    let resultOffset = 0;\n    let sourceOffset = 0;\n    let brightest = 0;\n    for (let charIndex = 0; charIndex < 96 /* CHAR_COUNT */; charIndex++) {\n      brightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale));\n      resultOffset += pixelsPerCharacter;\n      sourceOffset += 10 /* SAMPLED_CHAR_WIDTH */ * 4 /* RGBA_CHANNELS_CNT */;\n    }\n\n    if (brightest > 0) {\n      const adjust = 255 / brightest;\n      for (let i = 0; i < resultLen; i++) {\n        result[i] *= adjust;\n      }\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["MinimapCharRenderer","allCharCodes","prebakedMiniMaps","toUint8","MinimapCharRendererFactory","create","scale","fontFamily","lastCreated","lastFontFamily","factory","createFromSampleData","createSampleData","data","canvas","document","createElement","ctx","getContext","style","height","concat","width","fillStyle","font","textBaseline","x","code","fillText","String","fromCharCode","getImageData","source","expectedLength","length","Error","charData","_downsample","_downsampleChar","sourceOffset","dest","destOffset","targetIndex","brightest","y","sourceY1","sourceY2","sourceX1","sourceX2","value","samples","sy","sourceRow","Math","floor","yBalance","sx","xBalance","sourceIndex","weight","final","max","pixelsPerCharacter","resultLen","result","Uint8ClampedArray","resultOffset","charIndex","adjust","i"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimapCharRendererFactory.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { MinimapCharRenderer } from './minimapCharRenderer.js';\r\nimport { allCharCodes } from './minimapCharSheet.js';\r\nimport { prebakedMiniMaps } from './minimapPreBaked.js';\r\nimport { toUint8 } from '../../../../base/common/uint.js';\r\n/**\r\n * Creates character renderers. It takes a 'scale' that determines how large\r\n * characters should be drawn. Using this, it draws data into a canvas and\r\n * then downsamples the characters as necessary for the current display.\r\n * This makes rendering more efficient, rather than drawing a full (tiny)\r\n * font, or downsampling in real-time.\r\n */\r\nexport class MinimapCharRendererFactory {\r\n    /**\r\n     * Creates a new character renderer factory with the given scale.\r\n     */\r\n    static create(scale, fontFamily) {\r\n        // renderers are immutable. By default we'll 'create' a new minimap\r\n        // character renderer whenever we switch editors, no need to do extra work.\r\n        if (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {\r\n            return this.lastCreated;\r\n        }\r\n        let factory;\r\n        if (prebakedMiniMaps[scale]) {\r\n            factory = new MinimapCharRenderer(prebakedMiniMaps[scale](), scale);\r\n        }\r\n        else {\r\n            factory = MinimapCharRendererFactory.createFromSampleData(MinimapCharRendererFactory.createSampleData(fontFamily).data, scale);\r\n        }\r\n        this.lastFontFamily = fontFamily;\r\n        this.lastCreated = factory;\r\n        return factory;\r\n    }\r\n    /**\r\n     * Creates the font sample data, writing to a canvas.\r\n     */\r\n    static createSampleData(fontFamily) {\r\n        const canvas = document.createElement('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n        canvas.style.height = `${16 /* SAMPLED_CHAR_HEIGHT */}px`;\r\n        canvas.height = 16 /* SAMPLED_CHAR_HEIGHT */;\r\n        canvas.width = 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */;\r\n        canvas.style.width = 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */ + 'px';\r\n        ctx.fillStyle = '#ffffff';\r\n        ctx.font = `bold ${16 /* SAMPLED_CHAR_HEIGHT */}px ${fontFamily}`;\r\n        ctx.textBaseline = 'middle';\r\n        let x = 0;\r\n        for (const code of allCharCodes) {\r\n            ctx.fillText(String.fromCharCode(code), x, 16 /* SAMPLED_CHAR_HEIGHT */ / 2);\r\n            x += 10 /* SAMPLED_CHAR_WIDTH */;\r\n        }\r\n        return ctx.getImageData(0, 0, 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */, 16 /* SAMPLED_CHAR_HEIGHT */);\r\n    }\r\n    /**\r\n     * Creates a character renderer from the canvas sample data.\r\n     */\r\n    static createFromSampleData(source, scale) {\r\n        const expectedLength = 16 /* SAMPLED_CHAR_HEIGHT */ * 10 /* SAMPLED_CHAR_WIDTH */ * 4 /* RGBA_CHANNELS_CNT */ * 96 /* CHAR_COUNT */;\r\n        if (source.length !== expectedLength) {\r\n            throw new Error('Unexpected source in MinimapCharRenderer');\r\n        }\r\n        let charData = MinimapCharRendererFactory._downsample(source, scale);\r\n        return new MinimapCharRenderer(charData, scale);\r\n    }\r\n    static _downsampleChar(source, sourceOffset, dest, destOffset, scale) {\r\n        const width = 1 /* BASE_CHAR_WIDTH */ * scale;\r\n        const height = 2 /* BASE_CHAR_HEIGHT */ * scale;\r\n        let targetIndex = destOffset;\r\n        let brightest = 0;\r\n        // This is essentially an ad-hoc rescaling algorithm. Standard approaches\r\n        // like bicubic interpolation are awesome for scaling between image sizes,\r\n        // but don't work so well when scaling to very small pixel values, we end\r\n        // up with blurry, indistinct forms.\r\n        //\r\n        // The approach taken here is simply mapping each source pixel to the target\r\n        // pixels, and taking the weighted values for all pixels in each, and then\r\n        // averaging them out. Finally we apply an intensity boost in _downsample,\r\n        // since when scaling to the smallest pixel sizes there's more black space\r\n        // which causes characters to be much less distinct.\r\n        for (let y = 0; y < height; y++) {\r\n            // 1. For this destination pixel, get the source pixels we're sampling\r\n            // from (x1, y1) to the next pixel (x2, y2)\r\n            const sourceY1 = (y / height) * 16 /* SAMPLED_CHAR_HEIGHT */;\r\n            const sourceY2 = ((y + 1) / height) * 16 /* SAMPLED_CHAR_HEIGHT */;\r\n            for (let x = 0; x < width; x++) {\r\n                const sourceX1 = (x / width) * 10 /* SAMPLED_CHAR_WIDTH */;\r\n                const sourceX2 = ((x + 1) / width) * 10 /* SAMPLED_CHAR_WIDTH */;\r\n                // 2. Sample all of them, summing them up and weighting them. Similar\r\n                // to bilinear interpolation.\r\n                let value = 0;\r\n                let samples = 0;\r\n                for (let sy = sourceY1; sy < sourceY2; sy++) {\r\n                    const sourceRow = sourceOffset + Math.floor(sy) * 3840 /* RGBA_SAMPLED_ROW_WIDTH */;\r\n                    const yBalance = 1 - (sy - Math.floor(sy));\r\n                    for (let sx = sourceX1; sx < sourceX2; sx++) {\r\n                        const xBalance = 1 - (sx - Math.floor(sx));\r\n                        const sourceIndex = sourceRow + Math.floor(sx) * 4 /* RGBA_CHANNELS_CNT */;\r\n                        const weight = xBalance * yBalance;\r\n                        samples += weight;\r\n                        value += ((source[sourceIndex] * source[sourceIndex + 3]) / 255) * weight;\r\n                    }\r\n                }\r\n                const final = value / samples;\r\n                brightest = Math.max(brightest, final);\r\n                dest[targetIndex++] = toUint8(final);\r\n            }\r\n        }\r\n        return brightest;\r\n    }\r\n    static _downsample(data, scale) {\r\n        const pixelsPerCharacter = 2 /* BASE_CHAR_HEIGHT */ * scale * 1 /* BASE_CHAR_WIDTH */ * scale;\r\n        const resultLen = pixelsPerCharacter * 96 /* CHAR_COUNT */;\r\n        const result = new Uint8ClampedArray(resultLen);\r\n        let resultOffset = 0;\r\n        let sourceOffset = 0;\r\n        let brightest = 0;\r\n        for (let charIndex = 0; charIndex < 96 /* CHAR_COUNT */; charIndex++) {\r\n            brightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale));\r\n            resultOffset += pixelsPerCharacter;\r\n            sourceOffset += 10 /* SAMPLED_CHAR_WIDTH */ * 4 /* RGBA_CHANNELS_CNT */;\r\n        }\r\n        if (brightest > 0) {\r\n            const adjust = 255 / brightest;\r\n            for (let i = 0; i < resultLen; i++) {\r\n                result[i] *= adjust;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}