{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { TokenizationRegistry } from '../modes.js';\nimport { nullTokenize2 } from '../modes/nullMode.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { MultilineTokensBuilder, countEOL } from './tokensStore.js';\nimport * as platform from '../../../base/common/platform.js';\nexport class TokenizationStateStore {\n  constructor() {\n    this._beginState = [];\n    this._valid = [];\n    this._len = 0;\n    this._invalidLineStartIndex = 0;\n  }\n  _reset(initialState) {\n    this._beginState = [];\n    this._valid = [];\n    this._len = 0;\n    this._invalidLineStartIndex = 0;\n    if (initialState) {\n      this._setBeginState(0, initialState);\n    }\n  }\n  flush(initialState) {\n    this._reset(initialState);\n  }\n  get invalidLineStartIndex() {\n    return this._invalidLineStartIndex;\n  }\n  _invalidateLine(lineIndex) {\n    if (lineIndex < this._len) {\n      this._valid[lineIndex] = false;\n    }\n    if (lineIndex < this._invalidLineStartIndex) {\n      this._invalidLineStartIndex = lineIndex;\n    }\n  }\n  _isValid(lineIndex) {\n    if (lineIndex < this._len) {\n      return this._valid[lineIndex];\n    }\n    return false;\n  }\n  getBeginState(lineIndex) {\n    if (lineIndex < this._len) {\n      return this._beginState[lineIndex];\n    }\n    return null;\n  }\n  _ensureLine(lineIndex) {\n    while (lineIndex >= this._len) {\n      this._beginState[this._len] = null;\n      this._valid[this._len] = false;\n      this._len++;\n    }\n  }\n  _deleteLines(start, deleteCount) {\n    if (deleteCount === 0) {\n      return;\n    }\n    if (start + deleteCount > this._len) {\n      deleteCount = this._len - start;\n    }\n    this._beginState.splice(start, deleteCount);\n    this._valid.splice(start, deleteCount);\n    this._len -= deleteCount;\n  }\n  _insertLines(insertIndex, insertCount) {\n    if (insertCount === 0) {\n      return;\n    }\n    let beginState = [];\n    let valid = [];\n    for (let i = 0; i < insertCount; i++) {\n      beginState[i] = null;\n      valid[i] = false;\n    }\n    this._beginState = arrays.arrayInsert(this._beginState, insertIndex, beginState);\n    this._valid = arrays.arrayInsert(this._valid, insertIndex, valid);\n    this._len += insertCount;\n  }\n  _setValid(lineIndex, valid) {\n    this._ensureLine(lineIndex);\n    this._valid[lineIndex] = valid;\n  }\n  _setBeginState(lineIndex, beginState) {\n    this._ensureLine(lineIndex);\n    this._beginState[lineIndex] = beginState;\n  }\n  setEndState(linesLength, lineIndex, endState) {\n    this._setValid(lineIndex, true);\n    this._invalidLineStartIndex = lineIndex + 1;\n    // Check if this was the last line\n    if (lineIndex === linesLength - 1) {\n      return;\n    }\n    // Check if the end state has changed\n    const previousEndState = this.getBeginState(lineIndex + 1);\n    if (previousEndState === null || !endState.equals(previousEndState)) {\n      this._setBeginState(lineIndex + 1, endState);\n      this._invalidateLine(lineIndex + 1);\n      return;\n    }\n    // Perhaps we can skip tokenizing some lines...\n    let i = lineIndex + 1;\n    while (i < linesLength) {\n      if (!this._isValid(i)) {\n        break;\n      }\n      i++;\n    }\n    this._invalidLineStartIndex = i;\n  }\n  setFakeTokens(lineIndex) {\n    this._setValid(lineIndex, false);\n  }\n  //#region Editing\n  applyEdits(range, eolCount) {\n    const deletingLinesCnt = range.endLineNumber - range.startLineNumber;\n    const insertingLinesCnt = eolCount;\n    const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n    for (let j = editingLinesCnt; j >= 0; j--) {\n      this._invalidateLine(range.startLineNumber + j - 1);\n    }\n    this._acceptDeleteRange(range);\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount);\n  }\n  _acceptDeleteRange(range) {\n    const firstLineIndex = range.startLineNumber - 1;\n    if (firstLineIndex >= this._len) {\n      return;\n    }\n    this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n  }\n  _acceptInsertText(position, eolCount) {\n    const lineIndex = position.lineNumber - 1;\n    if (lineIndex >= this._len) {\n      return;\n    }\n    this._insertLines(position.lineNumber, eolCount);\n  }\n}\nexport class TextModelTokenization extends Disposable {\n  constructor(textModel) {\n    super();\n    this._isDisposed = false;\n    this._textModel = textModel;\n    this._tokenizationStateStore = new TokenizationStateStore();\n    this._tokenizationSupport = null;\n    this._register(TokenizationRegistry.onDidChange(e => {\n      const languageIdentifier = this._textModel.getLanguageIdentifier();\n      if (e.changedLanguages.indexOf(languageIdentifier.language) === -1) {\n        return;\n      }\n      this._resetTokenizationState();\n      this._textModel.clearTokens();\n    }));\n    this._register(this._textModel.onDidChangeRawContentFast(e => {\n      if (e.containsEvent(1 /* Flush */)) {\n        this._resetTokenizationState();\n        return;\n      }\n    }));\n    this._register(this._textModel.onDidChangeContentFast(e => {\n      for (let i = 0, len = e.changes.length; i < len; i++) {\n        const change = e.changes[i];\n        const [eolCount] = countEOL(change.text);\n        this._tokenizationStateStore.applyEdits(change.range, eolCount);\n      }\n      this._beginBackgroundTokenization();\n    }));\n    this._register(this._textModel.onDidChangeAttached(() => {\n      this._beginBackgroundTokenization();\n    }));\n    this._register(this._textModel.onDidChangeLanguage(() => {\n      this._resetTokenizationState();\n      this._textModel.clearTokens();\n    }));\n    this._resetTokenizationState();\n  }\n  dispose() {\n    this._isDisposed = true;\n    super.dispose();\n  }\n  _resetTokenizationState() {\n    const [tokenizationSupport, initialState] = initializeTokenization(this._textModel);\n    this._tokenizationSupport = tokenizationSupport;\n    this._tokenizationStateStore.flush(initialState);\n    this._beginBackgroundTokenization();\n  }\n  _beginBackgroundTokenization() {\n    if (this._textModel.isAttachedToEditor() && this._hasLinesToTokenize()) {\n      platform.setImmediate(() => {\n        if (this._isDisposed) {\n          // disposed in the meantime\n          return;\n        }\n        this._revalidateTokensNow();\n      });\n    }\n  }\n  _revalidateTokensNow() {\n    let toLineNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._textModel.getLineCount();\n    const MAX_ALLOWED_TIME = 1;\n    const builder = new MultilineTokensBuilder();\n    const sw = StopWatch.create(false);\n    while (this._hasLinesToTokenize()) {\n      if (sw.elapsed() > MAX_ALLOWED_TIME) {\n        // Stop if MAX_ALLOWED_TIME is reached\n        break;\n      }\n      const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n      if (tokenizedLineNumber >= toLineNumber) {\n        break;\n      }\n    }\n    this._beginBackgroundTokenization();\n    this._textModel.setTokens(builder.tokens);\n  }\n  tokenizeViewport(startLineNumber, endLineNumber) {\n    const builder = new MultilineTokensBuilder();\n    this._tokenizeViewport(builder, startLineNumber, endLineNumber);\n    this._textModel.setTokens(builder.tokens);\n  }\n  reset() {\n    this._resetTokenizationState();\n    this._textModel.clearTokens();\n  }\n  forceTokenization(lineNumber) {\n    const builder = new MultilineTokensBuilder();\n    this._updateTokensUntilLine(builder, lineNumber);\n    this._textModel.setTokens(builder.tokens);\n  }\n  isCheapToTokenize(lineNumber) {\n    if (!this._tokenizationSupport) {\n      return true;\n    }\n    const firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n    if (lineNumber > firstInvalidLineNumber) {\n      return false;\n    }\n    if (lineNumber < firstInvalidLineNumber) {\n      return true;\n    }\n    if (this._textModel.getLineLength(lineNumber) < 2048 /* CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n      return true;\n    }\n    return false;\n  }\n  _hasLinesToTokenize() {\n    if (!this._tokenizationSupport) {\n      return false;\n    }\n    return this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount();\n  }\n  _tokenizeOneInvalidLine(builder) {\n    if (!this._hasLinesToTokenize()) {\n      return this._textModel.getLineCount() + 1;\n    }\n    const lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n    this._updateTokensUntilLine(builder, lineNumber);\n    return lineNumber;\n  }\n  _updateTokensUntilLine(builder, lineNumber) {\n    if (!this._tokenizationSupport) {\n      return;\n    }\n    const languageIdentifier = this._textModel.getLanguageIdentifier();\n    const linesLength = this._textModel.getLineCount();\n    const endLineIndex = lineNumber - 1;\n    // Validate all states up to and including endLineIndex\n    for (let lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n      const text = this._textModel.getLineContent(lineIndex + 1);\n      const lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\n      const r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, true, lineStartState);\n      builder.add(lineIndex + 1, r.tokens);\n      this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\n      lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\n    }\n  }\n\n  _tokenizeViewport(builder, startLineNumber, endLineNumber) {\n    if (!this._tokenizationSupport) {\n      // nothing to do\n      return;\n    }\n    if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n      // nothing to do\n      return;\n    }\n    if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n      // tokenization has reached the viewport start...\n      this._updateTokensUntilLine(builder, endLineNumber);\n      return;\n    }\n    let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\n    let fakeLines = [];\n    let initialState = null;\n    for (let i = startLineNumber - 1; nonWhitespaceColumn > 0 && i >= 1; i--) {\n      let newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n      if (newNonWhitespaceIndex === 0) {\n        continue;\n      }\n      if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n        initialState = this._tokenizationStateStore.getBeginState(i - 1);\n        if (initialState) {\n          break;\n        }\n        fakeLines.push(this._textModel.getLineContent(i));\n        nonWhitespaceColumn = newNonWhitespaceIndex;\n      }\n    }\n    if (!initialState) {\n      initialState = this._tokenizationSupport.getInitialState();\n    }\n    const languageIdentifier = this._textModel.getLanguageIdentifier();\n    let state = initialState;\n    for (let i = fakeLines.length - 1; i >= 0; i--) {\n      let r = safeTokenize(languageIdentifier, this._tokenizationSupport, fakeLines[i], false, state);\n      state = r.endState;\n    }\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      let text = this._textModel.getLineContent(lineNumber);\n      let r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, true, state);\n      builder.add(lineNumber, r.tokens);\n      this._tokenizationStateStore.setFakeTokens(lineNumber - 1);\n      state = r.endState;\n    }\n  }\n}\nfunction initializeTokenization(textModel) {\n  const languageIdentifier = textModel.getLanguageIdentifier();\n  let tokenizationSupport = textModel.isTooLargeForTokenization() ? null : TokenizationRegistry.get(languageIdentifier.language);\n  let initialState = null;\n  if (tokenizationSupport) {\n    try {\n      initialState = tokenizationSupport.getInitialState();\n    } catch (e) {\n      onUnexpectedError(e);\n      tokenizationSupport = null;\n    }\n  }\n  return [tokenizationSupport, initialState];\n}\nfunction safeTokenize(languageIdentifier, tokenizationSupport, text, hasEOL, state) {\n  let r = null;\n  if (tokenizationSupport) {\n    try {\n      r = tokenizationSupport.tokenize2(text, hasEOL, state.clone(), 0);\n    } catch (e) {\n      onUnexpectedError(e);\n    }\n  }\n  if (!r) {\n    r = nullTokenize2(languageIdentifier.id, text, state, 0);\n  }\n  LineTokens.convertToEndOffset(r.tokens, text.length);\n  return r;\n}","map":{"version":3,"names":["arrays","onUnexpectedError","LineTokens","Position","TokenizationRegistry","nullTokenize2","Disposable","StopWatch","MultilineTokensBuilder","countEOL","platform","TokenizationStateStore","constructor","_beginState","_valid","_len","_invalidLineStartIndex","_reset","initialState","_setBeginState","flush","invalidLineStartIndex","_invalidateLine","lineIndex","_isValid","getBeginState","_ensureLine","_deleteLines","start","deleteCount","splice","_insertLines","insertIndex","insertCount","beginState","valid","i","arrayInsert","_setValid","setEndState","linesLength","endState","previousEndState","equals","setFakeTokens","applyEdits","range","eolCount","deletingLinesCnt","endLineNumber","startLineNumber","insertingLinesCnt","editingLinesCnt","Math","min","j","_acceptDeleteRange","_acceptInsertText","startColumn","firstLineIndex","position","lineNumber","TextModelTokenization","textModel","_isDisposed","_textModel","_tokenizationStateStore","_tokenizationSupport","_register","onDidChange","e","languageIdentifier","getLanguageIdentifier","changedLanguages","indexOf","language","_resetTokenizationState","clearTokens","onDidChangeRawContentFast","containsEvent","onDidChangeContentFast","len","changes","length","change","text","_beginBackgroundTokenization","onDidChangeAttached","onDidChangeLanguage","dispose","tokenizationSupport","initializeTokenization","isAttachedToEditor","_hasLinesToTokenize","setImmediate","_revalidateTokensNow","toLineNumber","arguments","undefined","getLineCount","MAX_ALLOWED_TIME","builder","sw","create","elapsed","tokenizedLineNumber","_tokenizeOneInvalidLine","setTokens","tokens","tokenizeViewport","_tokenizeViewport","reset","forceTokenization","_updateTokensUntilLine","isCheapToTokenize","firstInvalidLineNumber","getLineLength","endLineIndex","getLineContent","lineStartState","r","safeTokenize","add","nonWhitespaceColumn","getLineFirstNonWhitespaceColumn","fakeLines","newNonWhitespaceIndex","push","getInitialState","state","isTooLargeForTokenization","get","hasEOL","tokenize2","clone","id","convertToEndOffset"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as arrays from '../../../base/common/arrays.js';\r\nimport { onUnexpectedError } from '../../../base/common/errors.js';\r\nimport { LineTokens } from '../core/lineTokens.js';\r\nimport { Position } from '../core/position.js';\r\nimport { TokenizationRegistry } from '../modes.js';\r\nimport { nullTokenize2 } from '../modes/nullMode.js';\r\nimport { Disposable } from '../../../base/common/lifecycle.js';\r\nimport { StopWatch } from '../../../base/common/stopwatch.js';\r\nimport { MultilineTokensBuilder, countEOL } from './tokensStore.js';\r\nimport * as platform from '../../../base/common/platform.js';\r\nexport class TokenizationStateStore {\r\n    constructor() {\r\n        this._beginState = [];\r\n        this._valid = [];\r\n        this._len = 0;\r\n        this._invalidLineStartIndex = 0;\r\n    }\r\n    _reset(initialState) {\r\n        this._beginState = [];\r\n        this._valid = [];\r\n        this._len = 0;\r\n        this._invalidLineStartIndex = 0;\r\n        if (initialState) {\r\n            this._setBeginState(0, initialState);\r\n        }\r\n    }\r\n    flush(initialState) {\r\n        this._reset(initialState);\r\n    }\r\n    get invalidLineStartIndex() {\r\n        return this._invalidLineStartIndex;\r\n    }\r\n    _invalidateLine(lineIndex) {\r\n        if (lineIndex < this._len) {\r\n            this._valid[lineIndex] = false;\r\n        }\r\n        if (lineIndex < this._invalidLineStartIndex) {\r\n            this._invalidLineStartIndex = lineIndex;\r\n        }\r\n    }\r\n    _isValid(lineIndex) {\r\n        if (lineIndex < this._len) {\r\n            return this._valid[lineIndex];\r\n        }\r\n        return false;\r\n    }\r\n    getBeginState(lineIndex) {\r\n        if (lineIndex < this._len) {\r\n            return this._beginState[lineIndex];\r\n        }\r\n        return null;\r\n    }\r\n    _ensureLine(lineIndex) {\r\n        while (lineIndex >= this._len) {\r\n            this._beginState[this._len] = null;\r\n            this._valid[this._len] = false;\r\n            this._len++;\r\n        }\r\n    }\r\n    _deleteLines(start, deleteCount) {\r\n        if (deleteCount === 0) {\r\n            return;\r\n        }\r\n        if (start + deleteCount > this._len) {\r\n            deleteCount = this._len - start;\r\n        }\r\n        this._beginState.splice(start, deleteCount);\r\n        this._valid.splice(start, deleteCount);\r\n        this._len -= deleteCount;\r\n    }\r\n    _insertLines(insertIndex, insertCount) {\r\n        if (insertCount === 0) {\r\n            return;\r\n        }\r\n        let beginState = [];\r\n        let valid = [];\r\n        for (let i = 0; i < insertCount; i++) {\r\n            beginState[i] = null;\r\n            valid[i] = false;\r\n        }\r\n        this._beginState = arrays.arrayInsert(this._beginState, insertIndex, beginState);\r\n        this._valid = arrays.arrayInsert(this._valid, insertIndex, valid);\r\n        this._len += insertCount;\r\n    }\r\n    _setValid(lineIndex, valid) {\r\n        this._ensureLine(lineIndex);\r\n        this._valid[lineIndex] = valid;\r\n    }\r\n    _setBeginState(lineIndex, beginState) {\r\n        this._ensureLine(lineIndex);\r\n        this._beginState[lineIndex] = beginState;\r\n    }\r\n    setEndState(linesLength, lineIndex, endState) {\r\n        this._setValid(lineIndex, true);\r\n        this._invalidLineStartIndex = lineIndex + 1;\r\n        // Check if this was the last line\r\n        if (lineIndex === linesLength - 1) {\r\n            return;\r\n        }\r\n        // Check if the end state has changed\r\n        const previousEndState = this.getBeginState(lineIndex + 1);\r\n        if (previousEndState === null || !endState.equals(previousEndState)) {\r\n            this._setBeginState(lineIndex + 1, endState);\r\n            this._invalidateLine(lineIndex + 1);\r\n            return;\r\n        }\r\n        // Perhaps we can skip tokenizing some lines...\r\n        let i = lineIndex + 1;\r\n        while (i < linesLength) {\r\n            if (!this._isValid(i)) {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        this._invalidLineStartIndex = i;\r\n    }\r\n    setFakeTokens(lineIndex) {\r\n        this._setValid(lineIndex, false);\r\n    }\r\n    //#region Editing\r\n    applyEdits(range, eolCount) {\r\n        const deletingLinesCnt = range.endLineNumber - range.startLineNumber;\r\n        const insertingLinesCnt = eolCount;\r\n        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\r\n        for (let j = editingLinesCnt; j >= 0; j--) {\r\n            this._invalidateLine(range.startLineNumber + j - 1);\r\n        }\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount);\r\n    }\r\n    _acceptDeleteRange(range) {\r\n        const firstLineIndex = range.startLineNumber - 1;\r\n        if (firstLineIndex >= this._len) {\r\n            return;\r\n        }\r\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n    }\r\n    _acceptInsertText(position, eolCount) {\r\n        const lineIndex = position.lineNumber - 1;\r\n        if (lineIndex >= this._len) {\r\n            return;\r\n        }\r\n        this._insertLines(position.lineNumber, eolCount);\r\n    }\r\n}\r\nexport class TextModelTokenization extends Disposable {\r\n    constructor(textModel) {\r\n        super();\r\n        this._isDisposed = false;\r\n        this._textModel = textModel;\r\n        this._tokenizationStateStore = new TokenizationStateStore();\r\n        this._tokenizationSupport = null;\r\n        this._register(TokenizationRegistry.onDidChange((e) => {\r\n            const languageIdentifier = this._textModel.getLanguageIdentifier();\r\n            if (e.changedLanguages.indexOf(languageIdentifier.language) === -1) {\r\n                return;\r\n            }\r\n            this._resetTokenizationState();\r\n            this._textModel.clearTokens();\r\n        }));\r\n        this._register(this._textModel.onDidChangeRawContentFast((e) => {\r\n            if (e.containsEvent(1 /* Flush */)) {\r\n                this._resetTokenizationState();\r\n                return;\r\n            }\r\n        }));\r\n        this._register(this._textModel.onDidChangeContentFast((e) => {\r\n            for (let i = 0, len = e.changes.length; i < len; i++) {\r\n                const change = e.changes[i];\r\n                const [eolCount] = countEOL(change.text);\r\n                this._tokenizationStateStore.applyEdits(change.range, eolCount);\r\n            }\r\n            this._beginBackgroundTokenization();\r\n        }));\r\n        this._register(this._textModel.onDidChangeAttached(() => {\r\n            this._beginBackgroundTokenization();\r\n        }));\r\n        this._register(this._textModel.onDidChangeLanguage(() => {\r\n            this._resetTokenizationState();\r\n            this._textModel.clearTokens();\r\n        }));\r\n        this._resetTokenizationState();\r\n    }\r\n    dispose() {\r\n        this._isDisposed = true;\r\n        super.dispose();\r\n    }\r\n    _resetTokenizationState() {\r\n        const [tokenizationSupport, initialState] = initializeTokenization(this._textModel);\r\n        this._tokenizationSupport = tokenizationSupport;\r\n        this._tokenizationStateStore.flush(initialState);\r\n        this._beginBackgroundTokenization();\r\n    }\r\n    _beginBackgroundTokenization() {\r\n        if (this._textModel.isAttachedToEditor() && this._hasLinesToTokenize()) {\r\n            platform.setImmediate(() => {\r\n                if (this._isDisposed) {\r\n                    // disposed in the meantime\r\n                    return;\r\n                }\r\n                this._revalidateTokensNow();\r\n            });\r\n        }\r\n    }\r\n    _revalidateTokensNow(toLineNumber = this._textModel.getLineCount()) {\r\n        const MAX_ALLOWED_TIME = 1;\r\n        const builder = new MultilineTokensBuilder();\r\n        const sw = StopWatch.create(false);\r\n        while (this._hasLinesToTokenize()) {\r\n            if (sw.elapsed() > MAX_ALLOWED_TIME) {\r\n                // Stop if MAX_ALLOWED_TIME is reached\r\n                break;\r\n            }\r\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\r\n            if (tokenizedLineNumber >= toLineNumber) {\r\n                break;\r\n            }\r\n        }\r\n        this._beginBackgroundTokenization();\r\n        this._textModel.setTokens(builder.tokens);\r\n    }\r\n    tokenizeViewport(startLineNumber, endLineNumber) {\r\n        const builder = new MultilineTokensBuilder();\r\n        this._tokenizeViewport(builder, startLineNumber, endLineNumber);\r\n        this._textModel.setTokens(builder.tokens);\r\n    }\r\n    reset() {\r\n        this._resetTokenizationState();\r\n        this._textModel.clearTokens();\r\n    }\r\n    forceTokenization(lineNumber) {\r\n        const builder = new MultilineTokensBuilder();\r\n        this._updateTokensUntilLine(builder, lineNumber);\r\n        this._textModel.setTokens(builder.tokens);\r\n    }\r\n    isCheapToTokenize(lineNumber) {\r\n        if (!this._tokenizationSupport) {\r\n            return true;\r\n        }\r\n        const firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\r\n        if (lineNumber > firstInvalidLineNumber) {\r\n            return false;\r\n        }\r\n        if (lineNumber < firstInvalidLineNumber) {\r\n            return true;\r\n        }\r\n        if (this._textModel.getLineLength(lineNumber) < 2048 /* CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    _hasLinesToTokenize() {\r\n        if (!this._tokenizationSupport) {\r\n            return false;\r\n        }\r\n        return (this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount());\r\n    }\r\n    _tokenizeOneInvalidLine(builder) {\r\n        if (!this._hasLinesToTokenize()) {\r\n            return this._textModel.getLineCount() + 1;\r\n        }\r\n        const lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\r\n        this._updateTokensUntilLine(builder, lineNumber);\r\n        return lineNumber;\r\n    }\r\n    _updateTokensUntilLine(builder, lineNumber) {\r\n        if (!this._tokenizationSupport) {\r\n            return;\r\n        }\r\n        const languageIdentifier = this._textModel.getLanguageIdentifier();\r\n        const linesLength = this._textModel.getLineCount();\r\n        const endLineIndex = lineNumber - 1;\r\n        // Validate all states up to and including endLineIndex\r\n        for (let lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\r\n            const text = this._textModel.getLineContent(lineIndex + 1);\r\n            const lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\r\n            const r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, true, lineStartState);\r\n            builder.add(lineIndex + 1, r.tokens);\r\n            this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\r\n            lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\r\n        }\r\n    }\r\n    _tokenizeViewport(builder, startLineNumber, endLineNumber) {\r\n        if (!this._tokenizationSupport) {\r\n            // nothing to do\r\n            return;\r\n        }\r\n        if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\r\n            // nothing to do\r\n            return;\r\n        }\r\n        if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\r\n            // tokenization has reached the viewport start...\r\n            this._updateTokensUntilLine(builder, endLineNumber);\r\n            return;\r\n        }\r\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\r\n        let fakeLines = [];\r\n        let initialState = null;\r\n        for (let i = startLineNumber - 1; nonWhitespaceColumn > 0 && i >= 1; i--) {\r\n            let newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\r\n            if (newNonWhitespaceIndex === 0) {\r\n                continue;\r\n            }\r\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\r\n                initialState = this._tokenizationStateStore.getBeginState(i - 1);\r\n                if (initialState) {\r\n                    break;\r\n                }\r\n                fakeLines.push(this._textModel.getLineContent(i));\r\n                nonWhitespaceColumn = newNonWhitespaceIndex;\r\n            }\r\n        }\r\n        if (!initialState) {\r\n            initialState = this._tokenizationSupport.getInitialState();\r\n        }\r\n        const languageIdentifier = this._textModel.getLanguageIdentifier();\r\n        let state = initialState;\r\n        for (let i = fakeLines.length - 1; i >= 0; i--) {\r\n            let r = safeTokenize(languageIdentifier, this._tokenizationSupport, fakeLines[i], false, state);\r\n            state = r.endState;\r\n        }\r\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            let text = this._textModel.getLineContent(lineNumber);\r\n            let r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, true, state);\r\n            builder.add(lineNumber, r.tokens);\r\n            this._tokenizationStateStore.setFakeTokens(lineNumber - 1);\r\n            state = r.endState;\r\n        }\r\n    }\r\n}\r\nfunction initializeTokenization(textModel) {\r\n    const languageIdentifier = textModel.getLanguageIdentifier();\r\n    let tokenizationSupport = (textModel.isTooLargeForTokenization()\r\n        ? null\r\n        : TokenizationRegistry.get(languageIdentifier.language));\r\n    let initialState = null;\r\n    if (tokenizationSupport) {\r\n        try {\r\n            initialState = tokenizationSupport.getInitialState();\r\n        }\r\n        catch (e) {\r\n            onUnexpectedError(e);\r\n            tokenizationSupport = null;\r\n        }\r\n    }\r\n    return [tokenizationSupport, initialState];\r\n}\r\nfunction safeTokenize(languageIdentifier, tokenizationSupport, text, hasEOL, state) {\r\n    let r = null;\r\n    if (tokenizationSupport) {\r\n        try {\r\n            r = tokenizationSupport.tokenize2(text, hasEOL, state.clone(), 0);\r\n        }\r\n        catch (e) {\r\n            onUnexpectedError(e);\r\n        }\r\n    }\r\n    if (!r) {\r\n        r = nullTokenize2(languageIdentifier.id, text, state, 0);\r\n    }\r\n    LineTokens.convertToEndOffset(r.tokens, text.length);\r\n    return r;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}