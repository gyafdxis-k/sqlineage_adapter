{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n/**\r\n * Copyright Joyent, Inc. and other Node contributors.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to permit\r\n * persons to whom the Software is furnished to do so, subject to the\r\n * following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\nimport * as process from './process.js';\nconst CHAR_UPPERCASE_A = 65; /* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\nclass ErrorInvalidArgType extends Error {\n  constructor(name, expected, actual) {\n    // determiner: 'must be' or 'must not be'\n    let determiner;\n    if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n    const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n    let msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" of type \").concat(expected);\n    msg += \". Received type \".concat(typeof actual);\n    super(msg);\n    this.code = 'ERR_INVALID_ARG_TYPE';\n  }\n}\nfunction validateString(value, name) {\n  if (typeof value !== 'string') {\n    throw new ErrorInvalidArgType(name, 'string', value);\n  }\n}\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\nfunction isWindowsDeviceRoot(code) {\n  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? \"\".concat(separator, \"..\") : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += \"\".concat(separator).concat(path.slice(lastSlash + 1, i));\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nfunction _format(sep, pathObject) {\n  if (pathObject === null || typeof pathObject !== 'object') {\n    throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n  }\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base || \"\".concat(pathObject.name || '').concat(pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? \"\".concat(dir).concat(base) : \"\".concat(dir).concat(sep).concat(base);\n}\nexport const win32 = {\n  // path.resolve([from ...], to)\n  resolve() {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n    for (let i = arguments.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = i < 0 || arguments.length <= i ? undefined : arguments[i];\n        validateString(path, 'path');\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive, or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points, because UNC paths are always absolute.\n        path = process.env[\"=\".concat(resolvedDevice)] || process.cwd();\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n        if (path === undefined || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n          path = \"\".concat(resolvedDevice, \"\\\\\");\n        }\n      }\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = path.charCodeAt(0);\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n        // If we started with a separator, we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = path.slice(last, j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len && isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device = \"\\\\\\\\\".concat(firstPart, \"\\\\\").concat(path.slice(last, j));\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n        // Possible device root\n        device = path.slice(0, 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n            // This path points to another device so it is not applicable\n            continue;\n          }\n        } else {\n          resolvedDevice = device;\n        }\n      }\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0) {\n          break;\n        }\n      } else {\n        resolvedTail = \"\".concat(path.slice(rootEnd), \"\\\\\").concat(resolvedTail);\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n    // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\n    return resolvedAbsolute ? \"\".concat(resolvedDevice, \"\\\\\").concat(resolvedTail) : \"\".concat(resolvedDevice).concat(resolvedTail) || '.';\n  },\n  normalize(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0) {\n      return '.';\n    }\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = path.charCodeAt(0);\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char, exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n      // If we started with a separator, we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = path.slice(last, j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len && isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return \"\\\\\\\\\".concat(firstPart, \"\\\\\").concat(path.slice(last), \"\\\\\");\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device = \"\\\\\\\\\".concat(firstPart, \"\\\\\").concat(path.slice(last, j));\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      // Possible device root\n      device = path.slice(0, 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n    let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) : '';\n    if (tail.length === 0 && !isAbsolute) {\n      tail = '.';\n    }\n    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n      tail += '\\\\';\n    }\n    if (device === undefined) {\n      return isAbsolute ? \"\\\\\".concat(tail) : tail;\n    }\n    return isAbsolute ? \"\".concat(device, \"\\\\\").concat(tail) : \"\".concat(device).concat(tail);\n  },\n  isAbsolute(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0) {\n      return false;\n    }\n    const code = path.charCodeAt(0);\n    return isPathSeparator(code) ||\n    // Possible device root\n    len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));\n  },\n  join() {\n    if (arguments.length === 0) {\n      return '.';\n    }\n    let joined;\n    let firstPart;\n    for (let i = 0; i < arguments.length; ++i) {\n      const arg = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = firstPart = arg;\n        } else {\n          joined += \"\\\\\".concat(arg);\n        }\n      }\n    }\n    if (joined === undefined) {\n      return '.';\n    }\n    // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for an UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at an UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as an UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(firstPart.charCodeAt(2))) {\n            ++slashCount;\n          } else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {\n        slashCount++;\n      }\n      // Replace the slashes if needed\n      if (slashCount >= 2) {\n        joined = \"\\\\\".concat(joined.slice(slashCount));\n      }\n    }\n    return win32.normalize(joined);\n  },\n  // It will solve the relative path from `from` to `to`, for instance:\n  //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n  //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n    if (from === to) {\n      return '';\n    }\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n    if (fromOrig === toOrig) {\n      return '';\n    }\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n    if (from === to) {\n      return '';\n    }\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_BACKWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    // We found a mismatch before the first common path separator was seen, so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1) {\n        return toOrig;\n      }\n    } else {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return toOrig.slice(toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return toOrig.slice(toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1) {\n        lastCommonSep = 0;\n      }\n    }\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n    toStart += lastCommonSep;\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0) {\n      return \"\".concat(out).concat(toOrig.slice(toStart, toEnd));\n    }\n    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n      ++toStart;\n    }\n    return toOrig.slice(toStart, toEnd);\n  },\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string') {\n      return path;\n    }\n    if (path.length === 0) {\n      return '';\n    }\n    const resolvedPath = win32.resolve(path);\n    if (resolvedPath.length <= 2) {\n      return path;\n    }\n    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n        const code = resolvedPath.charCodeAt(2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root, convert the path to a long UNC path\n          return \"\\\\\\\\?\\\\UNC\\\\\".concat(resolvedPath.slice(2));\n        }\n      }\n    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n      // Matched device root, convert the path to a long UNC path\n      return \"\\\\\\\\?\\\\\".concat(resolvedPath);\n    }\n    return path;\n  },\n  dirname(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0) {\n      return '.';\n    }\n    let rootEnd = -1;\n    let offset = 0;\n    const code = path.charCodeAt(0);\n    if (len === 1) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n      rootEnd = offset = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len && isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a \"normal root\" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n      // Possible device root\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) {\n      if (rootEnd === -1) {\n        return '.';\n      }\n      end = rootEnd;\n    }\n    return path.slice(0, end);\n  },\n  basename(path, ext) {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n    validateString(path, 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {\n      start = 2;\n    }\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path) {\n        return '';\n      }\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= start; --i) {\n        const code = path.charCodeAt(i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1) {\n      return '';\n    }\n    return path.slice(start, end);\n  },\n  extname(path) {\n    validateString(path, 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {\n      start = startPart = 2;\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n  format: _format.bind(null, '\\\\'),\n  parse(path) {\n    validateString(path, 'path');\n    const ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n    if (path.length === 0) {\n      return ret;\n    }\n    const len = path.length;\n    let rootEnd = 0;\n    let code = path.charCodeAt(0);\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator, exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n      rootEnd = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len && isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root, exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(path.charCodeAt(2))) {\n        if (len === 3) {\n          // `path` contains just a drive root, exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0) {\n      ret.root = path.slice(0, rootEnd);\n    }\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (end !== -1) {\n      if (startDot === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n        ret.base = ret.name = path.slice(startPart, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n    // If the directory is the root, use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else {\n      ret.dir = ret.root;\n    }\n    return ret;\n  },\n  sep: '\\\\',\n  delimiter: ';',\n  win32: null,\n  posix: null\n};\nexport const posix = {\n  // path.resolve([from ...], to)\n  resolve() {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n    for (let i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? i < 0 || arguments.length <= i ? undefined : arguments[i] : process.cwd();\n      validateString(path, 'path');\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n      resolvedPath = \"\".concat(path, \"/\").concat(resolvedPath);\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    }\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n    if (resolvedAbsolute) {\n      return \"/\".concat(resolvedPath);\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  },\n  normalize(path) {\n    validateString(path, 'path');\n    if (path.length === 0) {\n      return '.';\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n    if (path.length === 0) {\n      if (isAbsolute) {\n        return '/';\n      }\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator) {\n      path += '/';\n    }\n    return isAbsolute ? \"/\".concat(path) : path;\n  },\n  isAbsolute(path) {\n    validateString(path, 'path');\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n  join() {\n    if (arguments.length === 0) {\n      return '.';\n    }\n    let joined;\n    for (let i = 0; i < arguments.length; ++i) {\n      const arg = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg;\n        } else {\n          joined += \"/\".concat(arg);\n        }\n      }\n    }\n    if (joined === undefined) {\n      return '.';\n    }\n    return posix.normalize(joined);\n  },\n  relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n    if (from === to) {\n      return '';\n    }\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n    if (from === to) {\n      return '';\n    }\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return \"\".concat(out).concat(to.slice(toStart + lastCommonSep));\n  },\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  },\n  dirname(path) {\n    validateString(path, 'path');\n    if (path.length === 0) {\n      return '.';\n    }\n    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) {\n      return hasRoot ? '/' : '.';\n    }\n    if (hasRoot && end === 1) {\n      return '//';\n    }\n    return path.slice(0, end);\n  },\n  basename(path, ext) {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n    validateString(path, 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path) {\n        return '';\n      }\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1) {\n      return '';\n    }\n    return path.slice(start, end);\n  },\n  extname(path) {\n    validateString(path, 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n  format: _format.bind(null, '/'),\n  parse(path) {\n    validateString(path, 'path');\n    const ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n    if (path.length === 0) {\n      return ret;\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n        ret.base = ret.name = path.slice(start, end);\n      } else {\n        ret.name = path.slice(start, startDot);\n        ret.base = path.slice(start, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n    if (startPart > 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = '/';\n    }\n    return ret;\n  },\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nexport const normalize = process.platform === 'win32' ? win32.normalize : posix.normalize;\nexport const resolve = process.platform === 'win32' ? win32.resolve : posix.resolve;\nexport const relative = process.platform === 'win32' ? win32.relative : posix.relative;\nexport const dirname = process.platform === 'win32' ? win32.dirname : posix.dirname;\nexport const basename = process.platform === 'win32' ? win32.basename : posix.basename;\nexport const extname = process.platform === 'win32' ? win32.extname : posix.extname;\nexport const sep = process.platform === 'win32' ? win32.sep : posix.sep;","map":{"version":3,"names":["process","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_DOT","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","CHAR_COLON","CHAR_QUESTION_MARK","ErrorInvalidArgType","Error","constructor","name","expected","actual","determiner","indexOf","replace","type","msg","concat","code","validateString","value","isPathSeparator","isPosixPathSeparator","isWindowsDeviceRoot","normalizeString","path","allowAboveRoot","separator","res","lastSegmentLength","lastSlash","dots","i","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","_format","sep","pathObject","dir","root","base","ext","win32","resolve","resolvedDevice","resolvedTail","resolvedAbsolute","arguments","undefined","cwd","env","toLowerCase","len","rootEnd","device","isAbsolute","j","last","firstPart","normalize","tail","join","joined","arg","needsReplace","slashCount","firstLen","relative","from","to","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","out","toNamespacedPath","resolvedPath","dirname","offset","end","matchedSlash","basename","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","bind","parse","ret","delimiter","posix","trailingSeparator","hasRoot","platform"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/base/common/path.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\r\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\r\n/**\r\n * Copyright Joyent, Inc. and other Node contributors.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to permit\r\n * persons to whom the Software is furnished to do so, subject to the\r\n * following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\nimport * as process from './process.js';\r\nconst CHAR_UPPERCASE_A = 65; /* A */\r\nconst CHAR_LOWERCASE_A = 97; /* a */\r\nconst CHAR_UPPERCASE_Z = 90; /* Z */\r\nconst CHAR_LOWERCASE_Z = 122; /* z */\r\nconst CHAR_DOT = 46; /* . */\r\nconst CHAR_FORWARD_SLASH = 47; /* / */\r\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\r\nconst CHAR_COLON = 58; /* : */\r\nconst CHAR_QUESTION_MARK = 63; /* ? */\r\nclass ErrorInvalidArgType extends Error {\r\n    constructor(name, expected, actual) {\r\n        // determiner: 'must be' or 'must not be'\r\n        let determiner;\r\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\r\n            determiner = 'must not be';\r\n            expected = expected.replace(/^not /, '');\r\n        }\r\n        else {\r\n            determiner = 'must be';\r\n        }\r\n        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\r\n        let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\r\n        msg += `. Received type ${typeof actual}`;\r\n        super(msg);\r\n        this.code = 'ERR_INVALID_ARG_TYPE';\r\n    }\r\n}\r\nfunction validateString(value, name) {\r\n    if (typeof value !== 'string') {\r\n        throw new ErrorInvalidArgType(name, 'string', value);\r\n    }\r\n}\r\nfunction isPathSeparator(code) {\r\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\r\n}\r\nfunction isPosixPathSeparator(code) {\r\n    return code === CHAR_FORWARD_SLASH;\r\n}\r\nfunction isWindowsDeviceRoot(code) {\r\n    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\r\n        code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\r\n}\r\n// Resolves . and .. elements in a path with directory names\r\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\r\n    let res = '';\r\n    let lastSegmentLength = 0;\r\n    let lastSlash = -1;\r\n    let dots = 0;\r\n    let code = 0;\r\n    for (let i = 0; i <= path.length; ++i) {\r\n        if (i < path.length) {\r\n            code = path.charCodeAt(i);\r\n        }\r\n        else if (isPathSeparator(code)) {\r\n            break;\r\n        }\r\n        else {\r\n            code = CHAR_FORWARD_SLASH;\r\n        }\r\n        if (isPathSeparator(code)) {\r\n            if (lastSlash === i - 1 || dots === 1) {\r\n                // NOOP\r\n            }\r\n            else if (dots === 2) {\r\n                if (res.length < 2 || lastSegmentLength !== 2 ||\r\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\r\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\r\n                    if (res.length > 2) {\r\n                        const lastSlashIndex = res.lastIndexOf(separator);\r\n                        if (lastSlashIndex === -1) {\r\n                            res = '';\r\n                            lastSegmentLength = 0;\r\n                        }\r\n                        else {\r\n                            res = res.slice(0, lastSlashIndex);\r\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\r\n                        }\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                    else if (res.length !== 0) {\r\n                        res = '';\r\n                        lastSegmentLength = 0;\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                }\r\n                if (allowAboveRoot) {\r\n                    res += res.length > 0 ? `${separator}..` : '..';\r\n                    lastSegmentLength = 2;\r\n                }\r\n            }\r\n            else {\r\n                if (res.length > 0) {\r\n                    res += `${separator}${path.slice(lastSlash + 1, i)}`;\r\n                }\r\n                else {\r\n                    res = path.slice(lastSlash + 1, i);\r\n                }\r\n                lastSegmentLength = i - lastSlash - 1;\r\n            }\r\n            lastSlash = i;\r\n            dots = 0;\r\n        }\r\n        else if (code === CHAR_DOT && dots !== -1) {\r\n            ++dots;\r\n        }\r\n        else {\r\n            dots = -1;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction _format(sep, pathObject) {\r\n    if (pathObject === null || typeof pathObject !== 'object') {\r\n        throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\r\n    }\r\n    const dir = pathObject.dir || pathObject.root;\r\n    const base = pathObject.base ||\r\n        `${pathObject.name || ''}${pathObject.ext || ''}`;\r\n    if (!dir) {\r\n        return base;\r\n    }\r\n    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\r\n}\r\nexport const win32 = {\r\n    // path.resolve([from ...], to)\r\n    resolve(...pathSegments) {\r\n        let resolvedDevice = '';\r\n        let resolvedTail = '';\r\n        let resolvedAbsolute = false;\r\n        for (let i = pathSegments.length - 1; i >= -1; i--) {\r\n            let path;\r\n            if (i >= 0) {\r\n                path = pathSegments[i];\r\n                validateString(path, 'path');\r\n                // Skip empty entries\r\n                if (path.length === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n            else if (resolvedDevice.length === 0) {\r\n                path = process.cwd();\r\n            }\r\n            else {\r\n                // Windows has the concept of drive-specific current working\r\n                // directories. If we've resolved a drive letter but not yet an\r\n                // absolute path, get cwd for that drive, or the process cwd if\r\n                // the drive cwd is not available. We're sure the device is not\r\n                // a UNC path at this points, because UNC paths are always absolute.\r\n                path = process.env[`=${resolvedDevice}`] || process.cwd();\r\n                // Verify that a cwd was found and that it actually points\r\n                // to our drive. If not, default to the drive's root.\r\n                if (path === undefined ||\r\n                    path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\r\n                        path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\r\n                    path = `${resolvedDevice}\\\\`;\r\n                }\r\n            }\r\n            const len = path.length;\r\n            let rootEnd = 0;\r\n            let device = '';\r\n            let isAbsolute = false;\r\n            const code = path.charCodeAt(0);\r\n            // Try to match a root\r\n            if (len === 1) {\r\n                if (isPathSeparator(code)) {\r\n                    // `path` contains just a path separator\r\n                    rootEnd = 1;\r\n                    isAbsolute = true;\r\n                }\r\n            }\r\n            else if (isPathSeparator(code)) {\r\n                // Possible UNC root\r\n                // If we started with a separator, we know we at least have an\r\n                // absolute path of some kind (UNC or otherwise)\r\n                isAbsolute = true;\r\n                if (isPathSeparator(path.charCodeAt(1))) {\r\n                    // Matched double path separator at beginning\r\n                    let j = 2;\r\n                    let last = j;\r\n                    // Match 1 or more non-path separators\r\n                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        const firstPart = path.slice(last, j);\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more path separators\r\n                        while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            // Matched!\r\n                            last = j;\r\n                            // Match 1 or more non-path separators\r\n                            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                                j++;\r\n                            }\r\n                            if (j === len || j !== last) {\r\n                                // We matched a UNC root\r\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\r\n                                rootEnd = j;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    rootEnd = 1;\r\n                }\r\n            }\r\n            else if (isWindowsDeviceRoot(code) &&\r\n                path.charCodeAt(1) === CHAR_COLON) {\r\n                // Possible device root\r\n                device = path.slice(0, 2);\r\n                rootEnd = 2;\r\n                if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\r\n                    // Treat separator following drive name as an absolute path\r\n                    // indicator\r\n                    isAbsolute = true;\r\n                    rootEnd = 3;\r\n                }\r\n            }\r\n            if (device.length > 0) {\r\n                if (resolvedDevice.length > 0) {\r\n                    if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n                        // This path points to another device so it is not applicable\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    resolvedDevice = device;\r\n                }\r\n            }\r\n            if (resolvedAbsolute) {\r\n                if (resolvedDevice.length > 0) {\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\r\n                resolvedAbsolute = isAbsolute;\r\n                if (isAbsolute && resolvedDevice.length > 0) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // At this point the path should be resolved to a full absolute path,\r\n        // but handle relative paths to be safe (might happen when process.cwd()\r\n        // fails)\r\n        // Normalize the tail path\r\n        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\r\n        return resolvedAbsolute ?\r\n            `${resolvedDevice}\\\\${resolvedTail}` :\r\n            `${resolvedDevice}${resolvedTail}` || '.';\r\n    },\r\n    normalize(path) {\r\n        validateString(path, 'path');\r\n        const len = path.length;\r\n        if (len === 0) {\r\n            return '.';\r\n        }\r\n        let rootEnd = 0;\r\n        let device;\r\n        let isAbsolute = false;\r\n        const code = path.charCodeAt(0);\r\n        // Try to match a root\r\n        if (len === 1) {\r\n            // `path` contains just a single char, exit early to avoid\r\n            // unnecessary work\r\n            return isPosixPathSeparator(code) ? '\\\\' : path;\r\n        }\r\n        if (isPathSeparator(code)) {\r\n            // Possible UNC root\r\n            // If we started with a separator, we know we at least have an absolute\r\n            // path of some kind (UNC or otherwise)\r\n            isAbsolute = true;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                // Matched double path separator at beginning\r\n                let j = 2;\r\n                let last = j;\r\n                // Match 1 or more non-path separators\r\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                    j++;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    const firstPart = path.slice(last, j);\r\n                    // Matched!\r\n                    last = j;\r\n                    // Match 1 or more path separators\r\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more non-path separators\r\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j === len) {\r\n                            // We matched a UNC root only\r\n                            // Return the normalized version of the UNC root since there\r\n                            // is nothing left to process\r\n                            return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\r\n                        }\r\n                        if (j !== last) {\r\n                            // We matched a UNC root with leftovers\r\n                            device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\r\n                            rootEnd = j;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                rootEnd = 1;\r\n            }\r\n        }\r\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\r\n            // Possible device root\r\n            device = path.slice(0, 2);\r\n            rootEnd = 2;\r\n            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\r\n                // Treat separator following drive name as an absolute path\r\n                // indicator\r\n                isAbsolute = true;\r\n                rootEnd = 3;\r\n            }\r\n        }\r\n        let tail = rootEnd < len ?\r\n            normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\r\n            '';\r\n        if (tail.length === 0 && !isAbsolute) {\r\n            tail = '.';\r\n        }\r\n        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\r\n            tail += '\\\\';\r\n        }\r\n        if (device === undefined) {\r\n            return isAbsolute ? `\\\\${tail}` : tail;\r\n        }\r\n        return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\r\n    },\r\n    isAbsolute(path) {\r\n        validateString(path, 'path');\r\n        const len = path.length;\r\n        if (len === 0) {\r\n            return false;\r\n        }\r\n        const code = path.charCodeAt(0);\r\n        return isPathSeparator(code) ||\r\n            // Possible device root\r\n            len > 2 &&\r\n                isWindowsDeviceRoot(code) &&\r\n                path.charCodeAt(1) === CHAR_COLON &&\r\n                isPathSeparator(path.charCodeAt(2));\r\n    },\r\n    join(...paths) {\r\n        if (paths.length === 0) {\r\n            return '.';\r\n        }\r\n        let joined;\r\n        let firstPart;\r\n        for (let i = 0; i < paths.length; ++i) {\r\n            const arg = paths[i];\r\n            validateString(arg, 'path');\r\n            if (arg.length > 0) {\r\n                if (joined === undefined) {\r\n                    joined = firstPart = arg;\r\n                }\r\n                else {\r\n                    joined += `\\\\${arg}`;\r\n                }\r\n            }\r\n        }\r\n        if (joined === undefined) {\r\n            return '.';\r\n        }\r\n        // Make sure that the joined path doesn't start with two slashes, because\r\n        // normalize() will mistake it for an UNC path then.\r\n        //\r\n        // This step is skipped when it is very clear that the user actually\r\n        // intended to point at an UNC path. This is assumed when the first\r\n        // non-empty string arguments starts with exactly two slashes followed by\r\n        // at least one more non-slash character.\r\n        //\r\n        // Note that for normalize() to treat a path as an UNC path it needs to\r\n        // have at least 2 components, so we don't filter for that here.\r\n        // This means that the user can use join to construct UNC paths from\r\n        // a server name and a share name; for example:\r\n        //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\r\n        let needsReplace = true;\r\n        let slashCount = 0;\r\n        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\r\n            ++slashCount;\r\n            const firstLen = firstPart.length;\r\n            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\r\n                ++slashCount;\r\n                if (firstLen > 2) {\r\n                    if (isPathSeparator(firstPart.charCodeAt(2))) {\r\n                        ++slashCount;\r\n                    }\r\n                    else {\r\n                        // We matched a UNC path in the first part\r\n                        needsReplace = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (needsReplace) {\r\n            // Find any more consecutive slashes we need to replace\r\n            while (slashCount < joined.length &&\r\n                isPathSeparator(joined.charCodeAt(slashCount))) {\r\n                slashCount++;\r\n            }\r\n            // Replace the slashes if needed\r\n            if (slashCount >= 2) {\r\n                joined = `\\\\${joined.slice(slashCount)}`;\r\n            }\r\n        }\r\n        return win32.normalize(joined);\r\n    },\r\n    // It will solve the relative path from `from` to `to`, for instance:\r\n    //  from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n    //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n    // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\n    relative(from, to) {\r\n        validateString(from, 'from');\r\n        validateString(to, 'to');\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        const fromOrig = win32.resolve(from);\r\n        const toOrig = win32.resolve(to);\r\n        if (fromOrig === toOrig) {\r\n            return '';\r\n        }\r\n        from = fromOrig.toLowerCase();\r\n        to = toOrig.toLowerCase();\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        // Trim any leading backslashes\r\n        let fromStart = 0;\r\n        while (fromStart < from.length &&\r\n            from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\r\n            fromStart++;\r\n        }\r\n        // Trim trailing backslashes (applicable to UNC paths only)\r\n        let fromEnd = from.length;\r\n        while (fromEnd - 1 > fromStart &&\r\n            from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\r\n            fromEnd--;\r\n        }\r\n        const fromLen = fromEnd - fromStart;\r\n        // Trim any leading backslashes\r\n        let toStart = 0;\r\n        while (toStart < to.length &&\r\n            to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\r\n            toStart++;\r\n        }\r\n        // Trim trailing backslashes (applicable to UNC paths only)\r\n        let toEnd = to.length;\r\n        while (toEnd - 1 > toStart &&\r\n            to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\r\n            toEnd--;\r\n        }\r\n        const toLen = toEnd - toStart;\r\n        // Compare paths to find the longest common path from root\r\n        const length = fromLen < toLen ? fromLen : toLen;\r\n        let lastCommonSep = -1;\r\n        let i = 0;\r\n        for (; i < length; i++) {\r\n            const fromCode = from.charCodeAt(fromStart + i);\r\n            if (fromCode !== to.charCodeAt(toStart + i)) {\r\n                break;\r\n            }\r\n            else if (fromCode === CHAR_BACKWARD_SLASH) {\r\n                lastCommonSep = i;\r\n            }\r\n        }\r\n        // We found a mismatch before the first common path separator was seen, so\r\n        // return the original `to`.\r\n        if (i !== length) {\r\n            if (lastCommonSep === -1) {\r\n                return toOrig;\r\n            }\r\n        }\r\n        else {\r\n            if (toLen > length) {\r\n                if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\r\n                    // We get here if `from` is the exact base path for `to`.\r\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\r\n                    return toOrig.slice(toStart + i + 1);\r\n                }\r\n                if (i === 2) {\r\n                    // We get here if `from` is the device root.\r\n                    // For example: from='C:\\\\'; to='C:\\\\foo'\r\n                    return toOrig.slice(toStart + i);\r\n                }\r\n            }\r\n            if (fromLen > length) {\r\n                if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\r\n                    // We get here if `to` is the exact base path for `from`.\r\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\r\n                    lastCommonSep = i;\r\n                }\r\n                else if (i === 2) {\r\n                    // We get here if `to` is the device root.\r\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\r\n                    lastCommonSep = 3;\r\n                }\r\n            }\r\n            if (lastCommonSep === -1) {\r\n                lastCommonSep = 0;\r\n            }\r\n        }\r\n        let out = '';\r\n        // Generate the relative path based on the path difference between `to` and\r\n        // `from`\r\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\r\n                out += out.length === 0 ? '..' : '\\\\..';\r\n            }\r\n        }\r\n        toStart += lastCommonSep;\r\n        // Lastly, append the rest of the destination (`to`) path that comes after\r\n        // the common path parts\r\n        if (out.length > 0) {\r\n            return `${out}${toOrig.slice(toStart, toEnd)}`;\r\n        }\r\n        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\r\n            ++toStart;\r\n        }\r\n        return toOrig.slice(toStart, toEnd);\r\n    },\r\n    toNamespacedPath(path) {\r\n        // Note: this will *probably* throw somewhere.\r\n        if (typeof path !== 'string') {\r\n            return path;\r\n        }\r\n        if (path.length === 0) {\r\n            return '';\r\n        }\r\n        const resolvedPath = win32.resolve(path);\r\n        if (resolvedPath.length <= 2) {\r\n            return path;\r\n        }\r\n        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\r\n            // Possible UNC root\r\n            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\r\n                const code = resolvedPath.charCodeAt(2);\r\n                if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\r\n                    // Matched non-long UNC root, convert the path to a long UNC path\r\n                    return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\r\n                }\r\n            }\r\n        }\r\n        else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\r\n            resolvedPath.charCodeAt(1) === CHAR_COLON &&\r\n            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\r\n            // Matched device root, convert the path to a long UNC path\r\n            return `\\\\\\\\?\\\\${resolvedPath}`;\r\n        }\r\n        return path;\r\n    },\r\n    dirname(path) {\r\n        validateString(path, 'path');\r\n        const len = path.length;\r\n        if (len === 0) {\r\n            return '.';\r\n        }\r\n        let rootEnd = -1;\r\n        let offset = 0;\r\n        const code = path.charCodeAt(0);\r\n        if (len === 1) {\r\n            // `path` contains just a path separator, exit early to avoid\r\n            // unnecessary work or a dot.\r\n            return isPathSeparator(code) ? path : '.';\r\n        }\r\n        // Try to match a root\r\n        if (isPathSeparator(code)) {\r\n            // Possible UNC root\r\n            rootEnd = offset = 1;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                // Matched double path separator at beginning\r\n                let j = 2;\r\n                let last = j;\r\n                // Match 1 or more non-path separators\r\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                    j++;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    // Matched!\r\n                    last = j;\r\n                    // Match 1 or more path separators\r\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more non-path separators\r\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j === len) {\r\n                            // We matched a UNC root only\r\n                            return path;\r\n                        }\r\n                        if (j !== last) {\r\n                            // We matched a UNC root with leftovers\r\n                            // Offset by 1 to include the separator after the UNC root to\r\n                            // treat it as a \"normal root\" on top of a (UNC) root\r\n                            rootEnd = offset = j + 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Possible device root\r\n        }\r\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\r\n            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\r\n            offset = rootEnd;\r\n        }\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        for (let i = len - 1; i >= offset; --i) {\r\n            if (isPathSeparator(path.charCodeAt(i))) {\r\n                if (!matchedSlash) {\r\n                    end = i;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                // We saw the first non-path separator\r\n                matchedSlash = false;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            if (rootEnd === -1) {\r\n                return '.';\r\n            }\r\n            end = rootEnd;\r\n        }\r\n        return path.slice(0, end);\r\n    },\r\n    basename(path, ext) {\r\n        if (ext !== undefined) {\r\n            validateString(ext, 'ext');\r\n        }\r\n        validateString(path, 'path');\r\n        let start = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i;\r\n        // Check for a drive letter prefix so as not to mistake the following\r\n        // path separator as an extra separator at the end of the path that can be\r\n        // disregarded\r\n        if (path.length >= 2 &&\r\n            isWindowsDeviceRoot(path.charCodeAt(0)) &&\r\n            path.charCodeAt(1) === CHAR_COLON) {\r\n            start = 2;\r\n        }\r\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n            if (ext === path) {\r\n                return '';\r\n            }\r\n            let extIdx = ext.length - 1;\r\n            let firstNonSlashEnd = -1;\r\n            for (i = path.length - 1; i >= start; --i) {\r\n                const code = path.charCodeAt(i);\r\n                if (isPathSeparator(code)) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (firstNonSlashEnd === -1) {\r\n                        // We saw the first non-path separator, remember this index in case\r\n                        // we need it if the extension ends up not matching\r\n                        matchedSlash = false;\r\n                        firstNonSlashEnd = i + 1;\r\n                    }\r\n                    if (extIdx >= 0) {\r\n                        // Try to match the explicit extension\r\n                        if (code === ext.charCodeAt(extIdx)) {\r\n                            if (--extIdx === -1) {\r\n                                // We matched the extension, so mark this as the end of our path\r\n                                // component\r\n                                end = i;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Extension does not match, so our result is the entire path\r\n                            // component\r\n                            extIdx = -1;\r\n                            end = firstNonSlashEnd;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (start === end) {\r\n                end = firstNonSlashEnd;\r\n            }\r\n            else if (end === -1) {\r\n                end = path.length;\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n        for (i = path.length - 1; i >= start; --i) {\r\n            if (isPathSeparator(path.charCodeAt(i))) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    start = i + 1;\r\n                    break;\r\n                }\r\n            }\r\n            else if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // path component\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return '';\r\n        }\r\n        return path.slice(start, end);\r\n    },\r\n    extname(path) {\r\n        validateString(path, 'path');\r\n        let start = 0;\r\n        let startDot = -1;\r\n        let startPart = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        // Check for a drive letter prefix so as not to mistake the following\r\n        // path separator as an extra separator at the end of the path that can be\r\n        // disregarded\r\n        if (path.length >= 2 &&\r\n            path.charCodeAt(1) === CHAR_COLON &&\r\n            isWindowsDeviceRoot(path.charCodeAt(0))) {\r\n            start = startPart = 2;\r\n        }\r\n        for (let i = path.length - 1; i >= start; --i) {\r\n            const code = path.charCodeAt(i);\r\n            if (isPathSeparator(code)) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            return '';\r\n        }\r\n        return path.slice(startDot, end);\r\n    },\r\n    format: _format.bind(null, '\\\\'),\r\n    parse(path) {\r\n        validateString(path, 'path');\r\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n        if (path.length === 0) {\r\n            return ret;\r\n        }\r\n        const len = path.length;\r\n        let rootEnd = 0;\r\n        let code = path.charCodeAt(0);\r\n        if (len === 1) {\r\n            if (isPathSeparator(code)) {\r\n                // `path` contains just a path separator, exit early to avoid\r\n                // unnecessary work\r\n                ret.root = ret.dir = path;\r\n                return ret;\r\n            }\r\n            ret.base = ret.name = path;\r\n            return ret;\r\n        }\r\n        // Try to match a root\r\n        if (isPathSeparator(code)) {\r\n            // Possible UNC root\r\n            rootEnd = 1;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                // Matched double path separator at beginning\r\n                let j = 2;\r\n                let last = j;\r\n                // Match 1 or more non-path separators\r\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                    j++;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    // Matched!\r\n                    last = j;\r\n                    // Match 1 or more path separators\r\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more non-path separators\r\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j === len) {\r\n                            // We matched a UNC root only\r\n                            rootEnd = j;\r\n                        }\r\n                        else if (j !== last) {\r\n                            // We matched a UNC root with leftovers\r\n                            rootEnd = j + 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\r\n            // Possible device root\r\n            if (len <= 2) {\r\n                // `path` contains just a drive root, exit early to avoid\r\n                // unnecessary work\r\n                ret.root = ret.dir = path;\r\n                return ret;\r\n            }\r\n            rootEnd = 2;\r\n            if (isPathSeparator(path.charCodeAt(2))) {\r\n                if (len === 3) {\r\n                    // `path` contains just a drive root, exit early to avoid\r\n                    // unnecessary work\r\n                    ret.root = ret.dir = path;\r\n                    return ret;\r\n                }\r\n                rootEnd = 3;\r\n            }\r\n        }\r\n        if (rootEnd > 0) {\r\n            ret.root = path.slice(0, rootEnd);\r\n        }\r\n        let startDot = -1;\r\n        let startPart = rootEnd;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i = path.length - 1;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        // Get non-dir info\r\n        for (; i >= rootEnd; --i) {\r\n            code = path.charCodeAt(i);\r\n            if (isPathSeparator(code)) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (end !== -1) {\r\n            if (startDot === -1 ||\r\n                // We saw a non-dot character immediately before the dot\r\n                preDotState === 0 ||\r\n                // The (right-most) trimmed path component is exactly '..'\r\n                (preDotState === 1 &&\r\n                    startDot === end - 1 &&\r\n                    startDot === startPart + 1)) {\r\n                ret.base = ret.name = path.slice(startPart, end);\r\n            }\r\n            else {\r\n                ret.name = path.slice(startPart, startDot);\r\n                ret.base = path.slice(startPart, end);\r\n                ret.ext = path.slice(startDot, end);\r\n            }\r\n        }\r\n        // If the directory is the root, use the entire root as the `dir` including\r\n        // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\r\n        // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\r\n        if (startPart > 0 && startPart !== rootEnd) {\r\n            ret.dir = path.slice(0, startPart - 1);\r\n        }\r\n        else {\r\n            ret.dir = ret.root;\r\n        }\r\n        return ret;\r\n    },\r\n    sep: '\\\\',\r\n    delimiter: ';',\r\n    win32: null,\r\n    posix: null\r\n};\r\nexport const posix = {\r\n    // path.resolve([from ...], to)\r\n    resolve(...pathSegments) {\r\n        let resolvedPath = '';\r\n        let resolvedAbsolute = false;\r\n        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n            const path = i >= 0 ? pathSegments[i] : process.cwd();\r\n            validateString(path, 'path');\r\n            // Skip empty entries\r\n            if (path.length === 0) {\r\n                continue;\r\n            }\r\n            resolvedPath = `${path}/${resolvedPath}`;\r\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        }\r\n        // At this point the path should be resolved to a full absolute path, but\r\n        // handle relative paths to be safe (might happen when process.cwd() fails)\r\n        // Normalize the path\r\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\r\n        if (resolvedAbsolute) {\r\n            return `/${resolvedPath}`;\r\n        }\r\n        return resolvedPath.length > 0 ? resolvedPath : '.';\r\n    },\r\n    normalize(path) {\r\n        validateString(path, 'path');\r\n        if (path.length === 0) {\r\n            return '.';\r\n        }\r\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\r\n        // Normalize the path\r\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\r\n        if (path.length === 0) {\r\n            if (isAbsolute) {\r\n                return '/';\r\n            }\r\n            return trailingSeparator ? './' : '.';\r\n        }\r\n        if (trailingSeparator) {\r\n            path += '/';\r\n        }\r\n        return isAbsolute ? `/${path}` : path;\r\n    },\r\n    isAbsolute(path) {\r\n        validateString(path, 'path');\r\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n    },\r\n    join(...paths) {\r\n        if (paths.length === 0) {\r\n            return '.';\r\n        }\r\n        let joined;\r\n        for (let i = 0; i < paths.length; ++i) {\r\n            const arg = paths[i];\r\n            validateString(arg, 'path');\r\n            if (arg.length > 0) {\r\n                if (joined === undefined) {\r\n                    joined = arg;\r\n                }\r\n                else {\r\n                    joined += `/${arg}`;\r\n                }\r\n            }\r\n        }\r\n        if (joined === undefined) {\r\n            return '.';\r\n        }\r\n        return posix.normalize(joined);\r\n    },\r\n    relative(from, to) {\r\n        validateString(from, 'from');\r\n        validateString(to, 'to');\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        // Trim leading forward slashes.\r\n        from = posix.resolve(from);\r\n        to = posix.resolve(to);\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        const fromStart = 1;\r\n        const fromEnd = from.length;\r\n        const fromLen = fromEnd - fromStart;\r\n        const toStart = 1;\r\n        const toLen = to.length - toStart;\r\n        // Compare paths to find the longest common path from root\r\n        const length = (fromLen < toLen ? fromLen : toLen);\r\n        let lastCommonSep = -1;\r\n        let i = 0;\r\n        for (; i < length; i++) {\r\n            const fromCode = from.charCodeAt(fromStart + i);\r\n            if (fromCode !== to.charCodeAt(toStart + i)) {\r\n                break;\r\n            }\r\n            else if (fromCode === CHAR_FORWARD_SLASH) {\r\n                lastCommonSep = i;\r\n            }\r\n        }\r\n        if (i === length) {\r\n            if (toLen > length) {\r\n                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\r\n                    // We get here if `from` is the exact base path for `to`.\r\n                    // For example: from='/foo/bar'; to='/foo/bar/baz'\r\n                    return to.slice(toStart + i + 1);\r\n                }\r\n                if (i === 0) {\r\n                    // We get here if `from` is the root\r\n                    // For example: from='/'; to='/foo'\r\n                    return to.slice(toStart + i);\r\n                }\r\n            }\r\n            else if (fromLen > length) {\r\n                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\r\n                    // We get here if `to` is the exact base path for `from`.\r\n                    // For example: from='/foo/bar/baz'; to='/foo/bar'\r\n                    lastCommonSep = i;\r\n                }\r\n                else if (i === 0) {\r\n                    // We get here if `to` is the root.\r\n                    // For example: from='/foo/bar'; to='/'\r\n                    lastCommonSep = 0;\r\n                }\r\n            }\r\n        }\r\n        let out = '';\r\n        // Generate the relative path based on the path difference between `to`\r\n        // and `from`.\r\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                out += out.length === 0 ? '..' : '/..';\r\n            }\r\n        }\r\n        // Lastly, append the rest of the destination (`to`) path that comes after\r\n        // the common path parts.\r\n        return `${out}${to.slice(toStart + lastCommonSep)}`;\r\n    },\r\n    toNamespacedPath(path) {\r\n        // Non-op on posix systems\r\n        return path;\r\n    },\r\n    dirname(path) {\r\n        validateString(path, 'path');\r\n        if (path.length === 0) {\r\n            return '.';\r\n        }\r\n        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        for (let i = path.length - 1; i >= 1; --i) {\r\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                if (!matchedSlash) {\r\n                    end = i;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                // We saw the first non-path separator\r\n                matchedSlash = false;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return hasRoot ? '/' : '.';\r\n        }\r\n        if (hasRoot && end === 1) {\r\n            return '//';\r\n        }\r\n        return path.slice(0, end);\r\n    },\r\n    basename(path, ext) {\r\n        if (ext !== undefined) {\r\n            validateString(ext, 'ext');\r\n        }\r\n        validateString(path, 'path');\r\n        let start = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i;\r\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n            if (ext === path) {\r\n                return '';\r\n            }\r\n            let extIdx = ext.length - 1;\r\n            let firstNonSlashEnd = -1;\r\n            for (i = path.length - 1; i >= 0; --i) {\r\n                const code = path.charCodeAt(i);\r\n                if (code === CHAR_FORWARD_SLASH) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (firstNonSlashEnd === -1) {\r\n                        // We saw the first non-path separator, remember this index in case\r\n                        // we need it if the extension ends up not matching\r\n                        matchedSlash = false;\r\n                        firstNonSlashEnd = i + 1;\r\n                    }\r\n                    if (extIdx >= 0) {\r\n                        // Try to match the explicit extension\r\n                        if (code === ext.charCodeAt(extIdx)) {\r\n                            if (--extIdx === -1) {\r\n                                // We matched the extension, so mark this as the end of our path\r\n                                // component\r\n                                end = i;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Extension does not match, so our result is the entire path\r\n                            // component\r\n                            extIdx = -1;\r\n                            end = firstNonSlashEnd;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (start === end) {\r\n                end = firstNonSlashEnd;\r\n            }\r\n            else if (end === -1) {\r\n                end = path.length;\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n        for (i = path.length - 1; i >= 0; --i) {\r\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    start = i + 1;\r\n                    break;\r\n                }\r\n            }\r\n            else if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // path component\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return '';\r\n        }\r\n        return path.slice(start, end);\r\n    },\r\n    extname(path) {\r\n        validateString(path, 'path');\r\n        let startDot = -1;\r\n        let startPart = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        for (let i = path.length - 1; i >= 0; --i) {\r\n            const code = path.charCodeAt(i);\r\n            if (code === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            return '';\r\n        }\r\n        return path.slice(startDot, end);\r\n    },\r\n    format: _format.bind(null, '/'),\r\n    parse(path) {\r\n        validateString(path, 'path');\r\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n        if (path.length === 0) {\r\n            return ret;\r\n        }\r\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        let start;\r\n        if (isAbsolute) {\r\n            ret.root = '/';\r\n            start = 1;\r\n        }\r\n        else {\r\n            start = 0;\r\n        }\r\n        let startDot = -1;\r\n        let startPart = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i = path.length - 1;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        // Get non-dir info\r\n        for (; i >= start; --i) {\r\n            const code = path.charCodeAt(i);\r\n            if (code === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (end !== -1) {\r\n            const start = startPart === 0 && isAbsolute ? 1 : startPart;\r\n            if (startDot === -1 ||\r\n                // We saw a non-dot character immediately before the dot\r\n                preDotState === 0 ||\r\n                // The (right-most) trimmed path component is exactly '..'\r\n                (preDotState === 1 &&\r\n                    startDot === end - 1 &&\r\n                    startDot === startPart + 1)) {\r\n                ret.base = ret.name = path.slice(start, end);\r\n            }\r\n            else {\r\n                ret.name = path.slice(start, startDot);\r\n                ret.base = path.slice(start, end);\r\n                ret.ext = path.slice(startDot, end);\r\n            }\r\n        }\r\n        if (startPart > 0) {\r\n            ret.dir = path.slice(0, startPart - 1);\r\n        }\r\n        else if (isAbsolute) {\r\n            ret.dir = '/';\r\n        }\r\n        return ret;\r\n    },\r\n    sep: '/',\r\n    delimiter: ':',\r\n    win32: null,\r\n    posix: null\r\n};\r\nposix.win32 = win32.win32 = win32;\r\nposix.posix = win32.posix = posix;\r\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\r\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\r\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\r\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\r\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\r\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\r\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}