{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { userAgent, isMacintosh, isLinux, isWindows, isWeb } from '../../../base/common/platform.js';\nlet _userAgent = userAgent || '';\nconst STATIC_VALUES = new Map();\nSTATIC_VALUES.set('false', false);\nSTATIC_VALUES.set('true', true);\nSTATIC_VALUES.set('isMac', isMacintosh);\nSTATIC_VALUES.set('isLinux', isLinux);\nSTATIC_VALUES.set('isWindows', isWindows);\nSTATIC_VALUES.set('isWeb', isWeb);\nSTATIC_VALUES.set('isMacNative', isMacintosh && !isWeb);\nSTATIC_VALUES.set('isEdge', _userAgent.indexOf('Edg/') >= 0);\nSTATIC_VALUES.set('isFirefox', _userAgent.indexOf('Firefox') >= 0);\nSTATIC_VALUES.set('isChrome', _userAgent.indexOf('Chrome') >= 0);\nSTATIC_VALUES.set('isSafari', _userAgent.indexOf('Safari') >= 0);\nSTATIC_VALUES.set('isIPad', _userAgent.indexOf('iPad') >= 0);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport class ContextKeyExpr {\n  static has(key) {\n    return ContextKeyDefinedExpr.create(key);\n  }\n  static equals(key, value) {\n    return ContextKeyEqualsExpr.create(key, value);\n  }\n  static regex(key, value) {\n    return ContextKeyRegexExpr.create(key, value);\n  }\n  static not(key) {\n    return ContextKeyNotExpr.create(key);\n  }\n  static and() {\n    for (var _len = arguments.length, expr = new Array(_len), _key = 0; _key < _len; _key++) {\n      expr[_key] = arguments[_key];\n    }\n    return ContextKeyAndExpr.create(expr);\n  }\n  static or() {\n    for (var _len2 = arguments.length, expr = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      expr[_key2] = arguments[_key2];\n    }\n    return ContextKeyOrExpr.create(expr);\n  }\n  static deserialize(serialized) {\n    let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!serialized) {\n      return undefined;\n    }\n    return this._deserializeOrExpression(serialized, strict);\n  }\n  static _deserializeOrExpression(serialized, strict) {\n    let pieces = serialized.split('||');\n    return ContextKeyOrExpr.create(pieces.map(p => this._deserializeAndExpression(p, strict)));\n  }\n  static _deserializeAndExpression(serialized, strict) {\n    let pieces = serialized.split('&&');\n    return ContextKeyAndExpr.create(pieces.map(p => this._deserializeOne(p, strict)));\n  }\n  static _deserializeOne(serializedOne, strict) {\n    serializedOne = serializedOne.trim();\n    if (serializedOne.indexOf('!=') >= 0) {\n      let pieces = serializedOne.split('!=');\n      return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n    }\n    if (serializedOne.indexOf('==') >= 0) {\n      let pieces = serializedOne.split('==');\n      return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\n    }\n    if (serializedOne.indexOf('=~') >= 0) {\n      let pieces = serializedOne.split('=~');\n      return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\n    }\n    if (serializedOne.indexOf(' in ') >= 0) {\n      let pieces = serializedOne.split(' in ');\n      return ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n    if (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('>=');\n      return ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n    if (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('>');\n      return ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n    if (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('<=');\n      return ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n    if (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {\n      const pieces = serializedOne.split('<');\n      return ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());\n    }\n    if (/^\\!\\s*/.test(serializedOne)) {\n      return ContextKeyNotExpr.create(serializedOne.substr(1).trim());\n    }\n    return ContextKeyDefinedExpr.create(serializedOne);\n  }\n  static _deserializeValue(serializedValue, strict) {\n    serializedValue = serializedValue.trim();\n    if (serializedValue === 'true') {\n      return true;\n    }\n    if (serializedValue === 'false') {\n      return false;\n    }\n    let m = /^'([^']*)'$/.exec(serializedValue);\n    if (m) {\n      return m[1].trim();\n    }\n    return serializedValue;\n  }\n  static _deserializeRegexValue(serializedValue, strict) {\n    if (isFalsyOrWhitespace(serializedValue)) {\n      if (strict) {\n        throw new Error('missing regexp-value for =~-expression');\n      } else {\n        console.warn('missing regexp-value for =~-expression');\n      }\n      return null;\n    }\n    let start = serializedValue.indexOf('/');\n    let end = serializedValue.lastIndexOf('/');\n    if (start === end || start < 0 /* || to < 0 */) {\n      if (strict) {\n        throw new Error(\"bad regexp-value '\".concat(serializedValue, \"', missing /-enclosure\"));\n      } else {\n        console.warn(\"bad regexp-value '\".concat(serializedValue, \"', missing /-enclosure\"));\n      }\n      return null;\n    }\n    let value = serializedValue.slice(start + 1, end);\n    let caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n    try {\n      return new RegExp(value, caseIgnoreFlag);\n    } catch (e) {\n      if (strict) {\n        throw new Error(\"bad regexp-value '\".concat(serializedValue, \"', parse error: \").concat(e));\n      } else {\n        console.warn(\"bad regexp-value '\".concat(serializedValue, \"', parse error: \").concat(e));\n      }\n      return null;\n    }\n  }\n}\nfunction cmp(a, b) {\n  return a.cmp(b);\n}\nexport class ContextKeyFalseExpr {\n  constructor() {\n    this.type = 0 /* False */;\n  }\n\n  cmp(other) {\n    return this.type - other.type;\n  }\n  equals(other) {\n    return other.type === this.type;\n  }\n  evaluate(context) {\n    return false;\n  }\n  serialize() {\n    return 'false';\n  }\n  keys() {\n    return [];\n  }\n  negate() {\n    return ContextKeyTrueExpr.INSTANCE;\n  }\n}\nContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();\nexport class ContextKeyTrueExpr {\n  constructor() {\n    this.type = 1 /* True */;\n  }\n\n  cmp(other) {\n    return this.type - other.type;\n  }\n  equals(other) {\n    return other.type === this.type;\n  }\n  evaluate(context) {\n    return true;\n  }\n  serialize() {\n    return 'true';\n  }\n  keys() {\n    return [];\n  }\n  negate() {\n    return ContextKeyFalseExpr.INSTANCE;\n  }\n}\nContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();\nexport class ContextKeyDefinedExpr {\n  constructor(key) {\n    this.key = key;\n    this.type = 2 /* Defined */;\n  }\n\n  static create(key) {\n    const staticValue = STATIC_VALUES.get(key);\n    if (typeof staticValue === 'boolean') {\n      return staticValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return new ContextKeyDefinedExpr(key);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp1(this.key, other.key);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key;\n    }\n    return false;\n  }\n  evaluate(context) {\n    return !!context.getValue(this.key);\n  }\n  serialize() {\n    return this.key;\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    return ContextKeyNotExpr.create(this.key);\n  }\n}\nexport class ContextKeyEqualsExpr {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.type = 4 /* Equals */;\n  }\n\n  static create(key, value) {\n    if (typeof value === 'boolean') {\n      return value ? ContextKeyDefinedExpr.create(key) : ContextKeyNotExpr.create(key);\n    }\n    const staticValue = STATIC_VALUES.get(key);\n    if (typeof staticValue === 'boolean') {\n      const trueValue = staticValue ? 'true' : 'false';\n      return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return new ContextKeyEqualsExpr(key, value);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  evaluate(context) {\n    // Intentional ==\n    // eslint-disable-next-line eqeqeq\n    return context.getValue(this.key) == this.value;\n  }\n  serialize() {\n    return \"\".concat(this.key, \" == '\").concat(this.value, \"'\");\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    return ContextKeyNotEqualsExpr.create(this.key, this.value);\n  }\n}\nexport class ContextKeyInExpr {\n  constructor(key, valueKey) {\n    this.key = key;\n    this.valueKey = valueKey;\n    this.type = 10 /* In */;\n  }\n\n  static create(key, valueKey) {\n    return new ContextKeyInExpr(key, valueKey);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.valueKey === other.valueKey;\n    }\n    return false;\n  }\n  evaluate(context) {\n    const source = context.getValue(this.valueKey);\n    const item = context.getValue(this.key);\n    if (Array.isArray(source)) {\n      return source.indexOf(item) >= 0;\n    }\n    if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n      return hasOwnProperty.call(source, item);\n    }\n    return false;\n  }\n  serialize() {\n    return \"\".concat(this.key, \" in '\").concat(this.valueKey, \"'\");\n  }\n  keys() {\n    return [this.key, this.valueKey];\n  }\n  negate() {\n    return ContextKeyNotInExpr.create(this);\n  }\n}\nexport class ContextKeyNotInExpr {\n  constructor(_actual) {\n    this._actual = _actual;\n    this.type = 11 /* NotIn */;\n    //\n  }\n\n  static create(actual) {\n    return new ContextKeyNotInExpr(actual);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return this._actual.cmp(other._actual);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this._actual.equals(other._actual);\n    }\n    return false;\n  }\n  evaluate(context) {\n    return !this._actual.evaluate(context);\n  }\n  serialize() {\n    throw new Error('Method not implemented.');\n  }\n  keys() {\n    return this._actual.keys();\n  }\n  negate() {\n    return this._actual;\n  }\n}\nexport class ContextKeyNotEqualsExpr {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.type = 5 /* NotEquals */;\n  }\n\n  static create(key, value) {\n    if (typeof value === 'boolean') {\n      if (value) {\n        return ContextKeyNotExpr.create(key);\n      }\n      return ContextKeyDefinedExpr.create(key);\n    }\n    const staticValue = STATIC_VALUES.get(key);\n    if (typeof staticValue === 'boolean') {\n      const falseValue = staticValue ? 'true' : 'false';\n      return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return new ContextKeyNotEqualsExpr(key, value);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  evaluate(context) {\n    // Intentional !=\n    // eslint-disable-next-line eqeqeq\n    return context.getValue(this.key) != this.value;\n  }\n  serialize() {\n    return \"\".concat(this.key, \" != '\").concat(this.value, \"'\");\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    return ContextKeyEqualsExpr.create(this.key, this.value);\n  }\n}\nexport class ContextKeyNotExpr {\n  constructor(key) {\n    this.key = key;\n    this.type = 3 /* Not */;\n  }\n\n  static create(key) {\n    const staticValue = STATIC_VALUES.get(key);\n    if (typeof staticValue === 'boolean') {\n      return staticValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return new ContextKeyNotExpr(key);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp1(this.key, other.key);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key;\n    }\n    return false;\n  }\n  evaluate(context) {\n    return !context.getValue(this.key);\n  }\n  serialize() {\n    return \"!\".concat(this.key);\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    return ContextKeyDefinedExpr.create(this.key);\n  }\n}\nexport class ContextKeyGreaterExpr {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.type = 12 /* Greater */;\n  }\n\n  static create(key, value) {\n    return new ContextKeyGreaterExpr(key, value);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  evaluate(context) {\n    return parseFloat(context.getValue(this.key)) > parseFloat(this.value);\n  }\n  serialize() {\n    return \"\".concat(this.key, \" > \").concat(this.value);\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    return ContextKeySmallerEqualsExpr.create(this.key, this.value);\n  }\n}\nexport class ContextKeyGreaterEqualsExpr {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.type = 13 /* GreaterEquals */;\n  }\n\n  static create(key, value) {\n    return new ContextKeyGreaterEqualsExpr(key, value);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  evaluate(context) {\n    return parseFloat(context.getValue(this.key)) >= parseFloat(this.value);\n  }\n  serialize() {\n    return \"\".concat(this.key, \" >= \").concat(this.value);\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    return ContextKeySmallerExpr.create(this.key, this.value);\n  }\n}\nexport class ContextKeySmallerExpr {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.type = 14 /* Smaller */;\n  }\n\n  static create(key, value) {\n    return new ContextKeySmallerExpr(key, value);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  evaluate(context) {\n    return parseFloat(context.getValue(this.key)) < parseFloat(this.value);\n  }\n  serialize() {\n    return \"\".concat(this.key, \" < \").concat(this.value);\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    return ContextKeyGreaterEqualsExpr.create(this.key, this.value);\n  }\n}\nexport class ContextKeySmallerEqualsExpr {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.type = 15 /* SmallerEquals */;\n  }\n\n  static create(key, value) {\n    return new ContextKeySmallerEqualsExpr(key, value);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  evaluate(context) {\n    return parseFloat(context.getValue(this.key)) <= parseFloat(this.value);\n  }\n  serialize() {\n    return \"\".concat(this.key, \" <= \").concat(this.value);\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    return ContextKeyGreaterExpr.create(this.key, this.value);\n  }\n}\nexport class ContextKeyRegexExpr {\n  constructor(key, regexp) {\n    this.key = key;\n    this.regexp = regexp;\n    this.type = 7 /* Regex */;\n    //\n  }\n\n  static create(key, regexp) {\n    return new ContextKeyRegexExpr(key, regexp);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    if (this.key < other.key) {\n      return -1;\n    }\n    if (this.key > other.key) {\n      return 1;\n    }\n    const thisSource = this.regexp ? this.regexp.source : '';\n    const otherSource = other.regexp ? other.regexp.source : '';\n    if (thisSource < otherSource) {\n      return -1;\n    }\n    if (thisSource > otherSource) {\n      return 1;\n    }\n    return 0;\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      const thisSource = this.regexp ? this.regexp.source : '';\n      const otherSource = other.regexp ? other.regexp.source : '';\n      return this.key === other.key && thisSource === otherSource;\n    }\n    return false;\n  }\n  evaluate(context) {\n    let value = context.getValue(this.key);\n    return this.regexp ? this.regexp.test(value) : false;\n  }\n  serialize() {\n    const value = this.regexp ? \"/\".concat(this.regexp.source, \"/\").concat(this.regexp.ignoreCase ? 'i' : '') : '/invalid/';\n    return \"\".concat(this.key, \" =~ \").concat(value);\n  }\n  keys() {\n    return [this.key];\n  }\n  negate() {\n    return ContextKeyNotRegexExpr.create(this);\n  }\n}\nexport class ContextKeyNotRegexExpr {\n  constructor(_actual) {\n    this._actual = _actual;\n    this.type = 8 /* NotRegex */;\n    //\n  }\n\n  static create(actual) {\n    return new ContextKeyNotRegexExpr(actual);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return this._actual.cmp(other._actual);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this._actual.equals(other._actual);\n    }\n    return false;\n  }\n  evaluate(context) {\n    return !this._actual.evaluate(context);\n  }\n  serialize() {\n    throw new Error('Method not implemented.');\n  }\n  keys() {\n    return this._actual.keys();\n  }\n  negate() {\n    return this._actual;\n  }\n}\nexport class ContextKeyAndExpr {\n  constructor(expr) {\n    this.expr = expr;\n    this.type = 6 /* And */;\n  }\n\n  static create(_expr) {\n    return ContextKeyAndExpr._normalizeArr(_expr);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      const r = cmp(this.expr[i], other.expr[i]);\n      if (r !== 0) {\n        return r;\n      }\n    }\n    return 0;\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n      for (let i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  evaluate(context) {\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      if (!this.expr[i].evaluate(context)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static _normalizeArr(arr) {\n    const expr = [];\n    let hasTrue = false;\n    for (const e of arr) {\n      if (!e) {\n        continue;\n      }\n      if (e.type === 1 /* True */) {\n        // anything && true ==> anything\n        hasTrue = true;\n        continue;\n      }\n      if (e.type === 0 /* False */) {\n        // anything && false ==> false\n        return ContextKeyFalseExpr.INSTANCE;\n      }\n      if (e.type === 6 /* And */) {\n        expr.push(...e.expr);\n        continue;\n      }\n      expr.push(e);\n    }\n    if (expr.length === 0 && hasTrue) {\n      return ContextKeyTrueExpr.INSTANCE;\n    }\n    if (expr.length === 0) {\n      return undefined;\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    expr.sort(cmp);\n    // We must distribute any OR expression because we don't support parens\n    // OR extensions will be at the end (due to sorting rules)\n    while (expr.length > 1) {\n      const lastElement = expr[expr.length - 1];\n      if (lastElement.type !== 9 /* Or */) {\n        break;\n      }\n      // pop the last element\n      expr.pop();\n      // pop the second to last element\n      const secondToLastElement = expr.pop();\n      // distribute `lastElement` over `secondToLastElement`\n      const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement])));\n      if (resultElement) {\n        expr.push(resultElement);\n        expr.sort(cmp);\n      }\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    return new ContextKeyAndExpr(expr);\n  }\n  serialize() {\n    return this.expr.map(e => e.serialize()).join(' && ');\n  }\n  keys() {\n    const result = [];\n    for (let expr of this.expr) {\n      result.push(...expr.keys());\n    }\n    return result;\n  }\n  negate() {\n    let result = [];\n    for (let expr of this.expr) {\n      result.push(expr.negate());\n    }\n    return ContextKeyOrExpr.create(result);\n  }\n}\nexport class ContextKeyOrExpr {\n  constructor(expr) {\n    this.expr = expr;\n    this.type = 9 /* Or */;\n  }\n\n  static create(_expr) {\n    const expr = ContextKeyOrExpr._normalizeArr(_expr);\n    if (expr.length === 0) {\n      return undefined;\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    return new ContextKeyOrExpr(expr);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      const r = cmp(this.expr[i], other.expr[i]);\n      if (r !== 0) {\n        return r;\n      }\n    }\n    return 0;\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n      for (let i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  evaluate(context) {\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      if (this.expr[i].evaluate(context)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static _normalizeArr(arr) {\n    let expr = [];\n    let hasFalse = false;\n    if (arr) {\n      for (let i = 0, len = arr.length; i < len; i++) {\n        const e = arr[i];\n        if (!e) {\n          continue;\n        }\n        if (e.type === 0 /* False */) {\n          // anything || false ==> anything\n          hasFalse = true;\n          continue;\n        }\n        if (e.type === 1 /* True */) {\n          // anything || true ==> true\n          return [ContextKeyTrueExpr.INSTANCE];\n        }\n        if (e.type === 9 /* Or */) {\n          expr = expr.concat(e.expr);\n          continue;\n        }\n        expr.push(e);\n      }\n      if (expr.length === 0 && hasFalse) {\n        return [ContextKeyFalseExpr.INSTANCE];\n      }\n      expr.sort(cmp);\n    }\n    return expr;\n  }\n  serialize() {\n    return this.expr.map(e => e.serialize()).join(' || ');\n  }\n  keys() {\n    const result = [];\n    for (let expr of this.expr) {\n      result.push(...expr.keys());\n    }\n    return result;\n  }\n  negate() {\n    let result = [];\n    for (let expr of this.expr) {\n      result.push(expr.negate());\n    }\n    const terminals = node => {\n      if (node.type === 9 /* Or */) {\n        return node.expr;\n      }\n      return [node];\n    };\n    // We don't support parens, so here we distribute the AND over the OR terminals\n    // We always take the first 2 AND pairs and distribute them\n    while (result.length > 1) {\n      const LEFT = result.shift();\n      const RIGHT = result.shift();\n      const all = [];\n      for (const left of terminals(LEFT)) {\n        for (const right of terminals(RIGHT)) {\n          all.push(ContextKeyExpr.and(left, right));\n        }\n      }\n      result.unshift(ContextKeyExpr.or(...all));\n    }\n    return result[0];\n  }\n}\nexport class RawContextKey extends ContextKeyDefinedExpr {\n  constructor(key, defaultValue) {\n    super(key);\n    this._defaultValue = defaultValue;\n  }\n  bindTo(target) {\n    return target.createKey(this.key, this._defaultValue);\n  }\n  getValue(target) {\n    return target.getContextKeyValue(this.key);\n  }\n  toNegated() {\n    return ContextKeyExpr.not(this.key);\n  }\n  isEqualTo(value) {\n    return ContextKeyExpr.equals(this.key, value);\n  }\n}\nexport const IContextKeyService = createDecorator('contextKeyService');\nexport const SET_CONTEXT_COMMAND_ID = 'setContext';\nfunction cmp1(key1, key2) {\n  if (key1 < key2) {\n    return -1;\n  }\n  if (key1 > key2) {\n    return 1;\n  }\n  return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n  if (key1 < key2) {\n    return -1;\n  }\n  if (key1 > key2) {\n    return 1;\n  }\n  if (value1 < value2) {\n    return -1;\n  }\n  if (value1 > value2) {\n    return 1;\n  }\n  return 0;\n}","map":{"version":3,"names":["isFalsyOrWhitespace","createDecorator","userAgent","isMacintosh","isLinux","isWindows","isWeb","_userAgent","STATIC_VALUES","Map","set","indexOf","hasOwnProperty","Object","prototype","ContextKeyExpr","has","key","ContextKeyDefinedExpr","create","equals","value","ContextKeyEqualsExpr","regex","ContextKeyRegexExpr","not","ContextKeyNotExpr","and","_len","arguments","length","expr","Array","_key","ContextKeyAndExpr","or","_len2","_key2","ContextKeyOrExpr","deserialize","serialized","strict","undefined","_deserializeOrExpression","pieces","split","map","p","_deserializeAndExpression","_deserializeOne","serializedOne","trim","ContextKeyNotEqualsExpr","_deserializeValue","_deserializeRegexValue","ContextKeyInExpr","test","ContextKeyGreaterEqualsExpr","ContextKeyGreaterExpr","ContextKeySmallerEqualsExpr","ContextKeySmallerExpr","substr","serializedValue","m","exec","Error","console","warn","start","end","lastIndexOf","concat","slice","caseIgnoreFlag","RegExp","e","cmp","a","b","ContextKeyFalseExpr","constructor","type","other","evaluate","context","serialize","keys","negate","ContextKeyTrueExpr","INSTANCE","staticValue","get","cmp1","getValue","trueValue","cmp2","valueKey","source","item","isArray","call","ContextKeyNotInExpr","_actual","actual","falseValue","parseFloat","regexp","thisSource","otherSource","ignoreCase","ContextKeyNotRegexExpr","_expr","_normalizeArr","i","len","r","arr","hasTrue","push","sort","lastElement","pop","secondToLastElement","resultElement","el","join","result","hasFalse","terminals","node","LEFT","shift","RIGHT","all","left","right","unshift","RawContextKey","defaultValue","_defaultValue","bindTo","target","createKey","getContextKeyValue","toNegated","isEqualTo","IContextKeyService","SET_CONTEXT_COMMAND_ID","key1","key2","value1","value2"],"sources":["C:/Users/Administrator/Desktop/sqllineage-master/sqllineagejs/node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\r\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\r\nimport { userAgent, isMacintosh, isLinux, isWindows, isWeb } from '../../../base/common/platform.js';\r\nlet _userAgent = userAgent || '';\r\nconst STATIC_VALUES = new Map();\r\nSTATIC_VALUES.set('false', false);\r\nSTATIC_VALUES.set('true', true);\r\nSTATIC_VALUES.set('isMac', isMacintosh);\r\nSTATIC_VALUES.set('isLinux', isLinux);\r\nSTATIC_VALUES.set('isWindows', isWindows);\r\nSTATIC_VALUES.set('isWeb', isWeb);\r\nSTATIC_VALUES.set('isMacNative', isMacintosh && !isWeb);\r\nSTATIC_VALUES.set('isEdge', _userAgent.indexOf('Edg/') >= 0);\r\nSTATIC_VALUES.set('isFirefox', _userAgent.indexOf('Firefox') >= 0);\r\nSTATIC_VALUES.set('isChrome', _userAgent.indexOf('Chrome') >= 0);\r\nSTATIC_VALUES.set('isSafari', _userAgent.indexOf('Safari') >= 0);\r\nSTATIC_VALUES.set('isIPad', _userAgent.indexOf('iPad') >= 0);\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nexport class ContextKeyExpr {\r\n    static has(key) {\r\n        return ContextKeyDefinedExpr.create(key);\r\n    }\r\n    static equals(key, value) {\r\n        return ContextKeyEqualsExpr.create(key, value);\r\n    }\r\n    static regex(key, value) {\r\n        return ContextKeyRegexExpr.create(key, value);\r\n    }\r\n    static not(key) {\r\n        return ContextKeyNotExpr.create(key);\r\n    }\r\n    static and(...expr) {\r\n        return ContextKeyAndExpr.create(expr);\r\n    }\r\n    static or(...expr) {\r\n        return ContextKeyOrExpr.create(expr);\r\n    }\r\n    static deserialize(serialized, strict = false) {\r\n        if (!serialized) {\r\n            return undefined;\r\n        }\r\n        return this._deserializeOrExpression(serialized, strict);\r\n    }\r\n    static _deserializeOrExpression(serialized, strict) {\r\n        let pieces = serialized.split('||');\r\n        return ContextKeyOrExpr.create(pieces.map(p => this._deserializeAndExpression(p, strict)));\r\n    }\r\n    static _deserializeAndExpression(serialized, strict) {\r\n        let pieces = serialized.split('&&');\r\n        return ContextKeyAndExpr.create(pieces.map(p => this._deserializeOne(p, strict)));\r\n    }\r\n    static _deserializeOne(serializedOne, strict) {\r\n        serializedOne = serializedOne.trim();\r\n        if (serializedOne.indexOf('!=') >= 0) {\r\n            let pieces = serializedOne.split('!=');\r\n            return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\r\n        }\r\n        if (serializedOne.indexOf('==') >= 0) {\r\n            let pieces = serializedOne.split('==');\r\n            return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1], strict));\r\n        }\r\n        if (serializedOne.indexOf('=~') >= 0) {\r\n            let pieces = serializedOne.split('=~');\r\n            return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1], strict));\r\n        }\r\n        if (serializedOne.indexOf(' in ') >= 0) {\r\n            let pieces = serializedOne.split(' in ');\r\n            return ContextKeyInExpr.create(pieces[0].trim(), pieces[1].trim());\r\n        }\r\n        if (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {\r\n            const pieces = serializedOne.split('>=');\r\n            return ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\r\n        }\r\n        if (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {\r\n            const pieces = serializedOne.split('>');\r\n            return ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());\r\n        }\r\n        if (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {\r\n            const pieces = serializedOne.split('<=');\r\n            return ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());\r\n        }\r\n        if (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {\r\n            const pieces = serializedOne.split('<');\r\n            return ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());\r\n        }\r\n        if (/^\\!\\s*/.test(serializedOne)) {\r\n            return ContextKeyNotExpr.create(serializedOne.substr(1).trim());\r\n        }\r\n        return ContextKeyDefinedExpr.create(serializedOne);\r\n    }\r\n    static _deserializeValue(serializedValue, strict) {\r\n        serializedValue = serializedValue.trim();\r\n        if (serializedValue === 'true') {\r\n            return true;\r\n        }\r\n        if (serializedValue === 'false') {\r\n            return false;\r\n        }\r\n        let m = /^'([^']*)'$/.exec(serializedValue);\r\n        if (m) {\r\n            return m[1].trim();\r\n        }\r\n        return serializedValue;\r\n    }\r\n    static _deserializeRegexValue(serializedValue, strict) {\r\n        if (isFalsyOrWhitespace(serializedValue)) {\r\n            if (strict) {\r\n                throw new Error('missing regexp-value for =~-expression');\r\n            }\r\n            else {\r\n                console.warn('missing regexp-value for =~-expression');\r\n            }\r\n            return null;\r\n        }\r\n        let start = serializedValue.indexOf('/');\r\n        let end = serializedValue.lastIndexOf('/');\r\n        if (start === end || start < 0 /* || to < 0 */) {\r\n            if (strict) {\r\n                throw new Error(`bad regexp-value '${serializedValue}', missing /-enclosure`);\r\n            }\r\n            else {\r\n                console.warn(`bad regexp-value '${serializedValue}', missing /-enclosure`);\r\n            }\r\n            return null;\r\n        }\r\n        let value = serializedValue.slice(start + 1, end);\r\n        let caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\r\n        try {\r\n            return new RegExp(value, caseIgnoreFlag);\r\n        }\r\n        catch (e) {\r\n            if (strict) {\r\n                throw new Error(`bad regexp-value '${serializedValue}', parse error: ${e}`);\r\n            }\r\n            else {\r\n                console.warn(`bad regexp-value '${serializedValue}', parse error: ${e}`);\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n}\r\nfunction cmp(a, b) {\r\n    return a.cmp(b);\r\n}\r\nexport class ContextKeyFalseExpr {\r\n    constructor() {\r\n        this.type = 0 /* False */;\r\n    }\r\n    cmp(other) {\r\n        return this.type - other.type;\r\n    }\r\n    equals(other) {\r\n        return (other.type === this.type);\r\n    }\r\n    evaluate(context) {\r\n        return false;\r\n    }\r\n    serialize() {\r\n        return 'false';\r\n    }\r\n    keys() {\r\n        return [];\r\n    }\r\n    negate() {\r\n        return ContextKeyTrueExpr.INSTANCE;\r\n    }\r\n}\r\nContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();\r\nexport class ContextKeyTrueExpr {\r\n    constructor() {\r\n        this.type = 1 /* True */;\r\n    }\r\n    cmp(other) {\r\n        return this.type - other.type;\r\n    }\r\n    equals(other) {\r\n        return (other.type === this.type);\r\n    }\r\n    evaluate(context) {\r\n        return true;\r\n    }\r\n    serialize() {\r\n        return 'true';\r\n    }\r\n    keys() {\r\n        return [];\r\n    }\r\n    negate() {\r\n        return ContextKeyFalseExpr.INSTANCE;\r\n    }\r\n}\r\nContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();\r\nexport class ContextKeyDefinedExpr {\r\n    constructor(key) {\r\n        this.key = key;\r\n        this.type = 2 /* Defined */;\r\n    }\r\n    static create(key) {\r\n        const staticValue = STATIC_VALUES.get(key);\r\n        if (typeof staticValue === 'boolean') {\r\n            return staticValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\r\n        }\r\n        return new ContextKeyDefinedExpr(key);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        return cmp1(this.key, other.key);\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            return (this.key === other.key);\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        return (!!context.getValue(this.key));\r\n    }\r\n    serialize() {\r\n        return this.key;\r\n    }\r\n    keys() {\r\n        return [this.key];\r\n    }\r\n    negate() {\r\n        return ContextKeyNotExpr.create(this.key);\r\n    }\r\n}\r\nexport class ContextKeyEqualsExpr {\r\n    constructor(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.type = 4 /* Equals */;\r\n    }\r\n    static create(key, value) {\r\n        if (typeof value === 'boolean') {\r\n            return (value ? ContextKeyDefinedExpr.create(key) : ContextKeyNotExpr.create(key));\r\n        }\r\n        const staticValue = STATIC_VALUES.get(key);\r\n        if (typeof staticValue === 'boolean') {\r\n            const trueValue = staticValue ? 'true' : 'false';\r\n            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\r\n        }\r\n        return new ContextKeyEqualsExpr(key, value);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        return cmp2(this.key, this.value, other.key, other.value);\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            return (this.key === other.key && this.value === other.value);\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        // Intentional ==\r\n        // eslint-disable-next-line eqeqeq\r\n        return (context.getValue(this.key) == this.value);\r\n    }\r\n    serialize() {\r\n        return `${this.key} == '${this.value}'`;\r\n    }\r\n    keys() {\r\n        return [this.key];\r\n    }\r\n    negate() {\r\n        return ContextKeyNotEqualsExpr.create(this.key, this.value);\r\n    }\r\n}\r\nexport class ContextKeyInExpr {\r\n    constructor(key, valueKey) {\r\n        this.key = key;\r\n        this.valueKey = valueKey;\r\n        this.type = 10 /* In */;\r\n    }\r\n    static create(key, valueKey) {\r\n        return new ContextKeyInExpr(key, valueKey);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        return cmp2(this.key, this.valueKey, other.key, other.valueKey);\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            return (this.key === other.key && this.valueKey === other.valueKey);\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        const source = context.getValue(this.valueKey);\r\n        const item = context.getValue(this.key);\r\n        if (Array.isArray(source)) {\r\n            return (source.indexOf(item) >= 0);\r\n        }\r\n        if (typeof item === 'string' && typeof source === 'object' && source !== null) {\r\n            return hasOwnProperty.call(source, item);\r\n        }\r\n        return false;\r\n    }\r\n    serialize() {\r\n        return `${this.key} in '${this.valueKey}'`;\r\n    }\r\n    keys() {\r\n        return [this.key, this.valueKey];\r\n    }\r\n    negate() {\r\n        return ContextKeyNotInExpr.create(this);\r\n    }\r\n}\r\nexport class ContextKeyNotInExpr {\r\n    constructor(_actual) {\r\n        this._actual = _actual;\r\n        this.type = 11 /* NotIn */;\r\n        //\r\n    }\r\n    static create(actual) {\r\n        return new ContextKeyNotInExpr(actual);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        return this._actual.cmp(other._actual);\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            return this._actual.equals(other._actual);\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        return !this._actual.evaluate(context);\r\n    }\r\n    serialize() {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    keys() {\r\n        return this._actual.keys();\r\n    }\r\n    negate() {\r\n        return this._actual;\r\n    }\r\n}\r\nexport class ContextKeyNotEqualsExpr {\r\n    constructor(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.type = 5 /* NotEquals */;\r\n    }\r\n    static create(key, value) {\r\n        if (typeof value === 'boolean') {\r\n            if (value) {\r\n                return ContextKeyNotExpr.create(key);\r\n            }\r\n            return ContextKeyDefinedExpr.create(key);\r\n        }\r\n        const staticValue = STATIC_VALUES.get(key);\r\n        if (typeof staticValue === 'boolean') {\r\n            const falseValue = staticValue ? 'true' : 'false';\r\n            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\r\n        }\r\n        return new ContextKeyNotEqualsExpr(key, value);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        return cmp2(this.key, this.value, other.key, other.value);\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            return (this.key === other.key && this.value === other.value);\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        // Intentional !=\r\n        // eslint-disable-next-line eqeqeq\r\n        return (context.getValue(this.key) != this.value);\r\n    }\r\n    serialize() {\r\n        return `${this.key} != '${this.value}'`;\r\n    }\r\n    keys() {\r\n        return [this.key];\r\n    }\r\n    negate() {\r\n        return ContextKeyEqualsExpr.create(this.key, this.value);\r\n    }\r\n}\r\nexport class ContextKeyNotExpr {\r\n    constructor(key) {\r\n        this.key = key;\r\n        this.type = 3 /* Not */;\r\n    }\r\n    static create(key) {\r\n        const staticValue = STATIC_VALUES.get(key);\r\n        if (typeof staticValue === 'boolean') {\r\n            return (staticValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\r\n        }\r\n        return new ContextKeyNotExpr(key);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        return cmp1(this.key, other.key);\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            return (this.key === other.key);\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        return (!context.getValue(this.key));\r\n    }\r\n    serialize() {\r\n        return `!${this.key}`;\r\n    }\r\n    keys() {\r\n        return [this.key];\r\n    }\r\n    negate() {\r\n        return ContextKeyDefinedExpr.create(this.key);\r\n    }\r\n}\r\nexport class ContextKeyGreaterExpr {\r\n    constructor(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.type = 12 /* Greater */;\r\n    }\r\n    static create(key, value) {\r\n        return new ContextKeyGreaterExpr(key, value);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        return cmp2(this.key, this.value, other.key, other.value);\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            return (this.key === other.key && this.value === other.value);\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        return (parseFloat(context.getValue(this.key)) > parseFloat(this.value));\r\n    }\r\n    serialize() {\r\n        return `${this.key} > ${this.value}`;\r\n    }\r\n    keys() {\r\n        return [this.key];\r\n    }\r\n    negate() {\r\n        return ContextKeySmallerEqualsExpr.create(this.key, this.value);\r\n    }\r\n}\r\nexport class ContextKeyGreaterEqualsExpr {\r\n    constructor(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.type = 13 /* GreaterEquals */;\r\n    }\r\n    static create(key, value) {\r\n        return new ContextKeyGreaterEqualsExpr(key, value);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        return cmp2(this.key, this.value, other.key, other.value);\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            return (this.key === other.key && this.value === other.value);\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        return (parseFloat(context.getValue(this.key)) >= parseFloat(this.value));\r\n    }\r\n    serialize() {\r\n        return `${this.key} >= ${this.value}`;\r\n    }\r\n    keys() {\r\n        return [this.key];\r\n    }\r\n    negate() {\r\n        return ContextKeySmallerExpr.create(this.key, this.value);\r\n    }\r\n}\r\nexport class ContextKeySmallerExpr {\r\n    constructor(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.type = 14 /* Smaller */;\r\n    }\r\n    static create(key, value) {\r\n        return new ContextKeySmallerExpr(key, value);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        return cmp2(this.key, this.value, other.key, other.value);\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            return (this.key === other.key && this.value === other.value);\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        return (parseFloat(context.getValue(this.key)) < parseFloat(this.value));\r\n    }\r\n    serialize() {\r\n        return `${this.key} < ${this.value}`;\r\n    }\r\n    keys() {\r\n        return [this.key];\r\n    }\r\n    negate() {\r\n        return ContextKeyGreaterEqualsExpr.create(this.key, this.value);\r\n    }\r\n}\r\nexport class ContextKeySmallerEqualsExpr {\r\n    constructor(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.type = 15 /* SmallerEquals */;\r\n    }\r\n    static create(key, value) {\r\n        return new ContextKeySmallerEqualsExpr(key, value);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        return cmp2(this.key, this.value, other.key, other.value);\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            return (this.key === other.key && this.value === other.value);\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        return (parseFloat(context.getValue(this.key)) <= parseFloat(this.value));\r\n    }\r\n    serialize() {\r\n        return `${this.key} <= ${this.value}`;\r\n    }\r\n    keys() {\r\n        return [this.key];\r\n    }\r\n    negate() {\r\n        return ContextKeyGreaterExpr.create(this.key, this.value);\r\n    }\r\n}\r\nexport class ContextKeyRegexExpr {\r\n    constructor(key, regexp) {\r\n        this.key = key;\r\n        this.regexp = regexp;\r\n        this.type = 7 /* Regex */;\r\n        //\r\n    }\r\n    static create(key, regexp) {\r\n        return new ContextKeyRegexExpr(key, regexp);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        if (this.key < other.key) {\r\n            return -1;\r\n        }\r\n        if (this.key > other.key) {\r\n            return 1;\r\n        }\r\n        const thisSource = this.regexp ? this.regexp.source : '';\r\n        const otherSource = other.regexp ? other.regexp.source : '';\r\n        if (thisSource < otherSource) {\r\n            return -1;\r\n        }\r\n        if (thisSource > otherSource) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            const thisSource = this.regexp ? this.regexp.source : '';\r\n            const otherSource = other.regexp ? other.regexp.source : '';\r\n            return (this.key === other.key && thisSource === otherSource);\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        let value = context.getValue(this.key);\r\n        return this.regexp ? this.regexp.test(value) : false;\r\n    }\r\n    serialize() {\r\n        const value = this.regexp\r\n            ? `/${this.regexp.source}/${this.regexp.ignoreCase ? 'i' : ''}`\r\n            : '/invalid/';\r\n        return `${this.key} =~ ${value}`;\r\n    }\r\n    keys() {\r\n        return [this.key];\r\n    }\r\n    negate() {\r\n        return ContextKeyNotRegexExpr.create(this);\r\n    }\r\n}\r\nexport class ContextKeyNotRegexExpr {\r\n    constructor(_actual) {\r\n        this._actual = _actual;\r\n        this.type = 8 /* NotRegex */;\r\n        //\r\n    }\r\n    static create(actual) {\r\n        return new ContextKeyNotRegexExpr(actual);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        return this._actual.cmp(other._actual);\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            return this._actual.equals(other._actual);\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        return !this._actual.evaluate(context);\r\n    }\r\n    serialize() {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    keys() {\r\n        return this._actual.keys();\r\n    }\r\n    negate() {\r\n        return this._actual;\r\n    }\r\n}\r\nexport class ContextKeyAndExpr {\r\n    constructor(expr) {\r\n        this.expr = expr;\r\n        this.type = 6 /* And */;\r\n    }\r\n    static create(_expr) {\r\n        return ContextKeyAndExpr._normalizeArr(_expr);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        if (this.expr.length < other.expr.length) {\r\n            return -1;\r\n        }\r\n        if (this.expr.length > other.expr.length) {\r\n            return 1;\r\n        }\r\n        for (let i = 0, len = this.expr.length; i < len; i++) {\r\n            const r = cmp(this.expr[i], other.expr[i]);\r\n            if (r !== 0) {\r\n                return r;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            if (this.expr.length !== other.expr.length) {\r\n                return false;\r\n            }\r\n            for (let i = 0, len = this.expr.length; i < len; i++) {\r\n                if (!this.expr[i].equals(other.expr[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        for (let i = 0, len = this.expr.length; i < len; i++) {\r\n            if (!this.expr[i].evaluate(context)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static _normalizeArr(arr) {\r\n        const expr = [];\r\n        let hasTrue = false;\r\n        for (const e of arr) {\r\n            if (!e) {\r\n                continue;\r\n            }\r\n            if (e.type === 1 /* True */) {\r\n                // anything && true ==> anything\r\n                hasTrue = true;\r\n                continue;\r\n            }\r\n            if (e.type === 0 /* False */) {\r\n                // anything && false ==> false\r\n                return ContextKeyFalseExpr.INSTANCE;\r\n            }\r\n            if (e.type === 6 /* And */) {\r\n                expr.push(...e.expr);\r\n                continue;\r\n            }\r\n            expr.push(e);\r\n        }\r\n        if (expr.length === 0 && hasTrue) {\r\n            return ContextKeyTrueExpr.INSTANCE;\r\n        }\r\n        if (expr.length === 0) {\r\n            return undefined;\r\n        }\r\n        if (expr.length === 1) {\r\n            return expr[0];\r\n        }\r\n        expr.sort(cmp);\r\n        // We must distribute any OR expression because we don't support parens\r\n        // OR extensions will be at the end (due to sorting rules)\r\n        while (expr.length > 1) {\r\n            const lastElement = expr[expr.length - 1];\r\n            if (lastElement.type !== 9 /* Or */) {\r\n                break;\r\n            }\r\n            // pop the last element\r\n            expr.pop();\r\n            // pop the second to last element\r\n            const secondToLastElement = expr.pop();\r\n            // distribute `lastElement` over `secondToLastElement`\r\n            const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement])));\r\n            if (resultElement) {\r\n                expr.push(resultElement);\r\n                expr.sort(cmp);\r\n            }\r\n        }\r\n        if (expr.length === 1) {\r\n            return expr[0];\r\n        }\r\n        return new ContextKeyAndExpr(expr);\r\n    }\r\n    serialize() {\r\n        return this.expr.map(e => e.serialize()).join(' && ');\r\n    }\r\n    keys() {\r\n        const result = [];\r\n        for (let expr of this.expr) {\r\n            result.push(...expr.keys());\r\n        }\r\n        return result;\r\n    }\r\n    negate() {\r\n        let result = [];\r\n        for (let expr of this.expr) {\r\n            result.push(expr.negate());\r\n        }\r\n        return ContextKeyOrExpr.create(result);\r\n    }\r\n}\r\nexport class ContextKeyOrExpr {\r\n    constructor(expr) {\r\n        this.expr = expr;\r\n        this.type = 9 /* Or */;\r\n    }\r\n    static create(_expr) {\r\n        const expr = ContextKeyOrExpr._normalizeArr(_expr);\r\n        if (expr.length === 0) {\r\n            return undefined;\r\n        }\r\n        if (expr.length === 1) {\r\n            return expr[0];\r\n        }\r\n        return new ContextKeyOrExpr(expr);\r\n    }\r\n    cmp(other) {\r\n        if (other.type !== this.type) {\r\n            return this.type - other.type;\r\n        }\r\n        if (this.expr.length < other.expr.length) {\r\n            return -1;\r\n        }\r\n        if (this.expr.length > other.expr.length) {\r\n            return 1;\r\n        }\r\n        for (let i = 0, len = this.expr.length; i < len; i++) {\r\n            const r = cmp(this.expr[i], other.expr[i]);\r\n            if (r !== 0) {\r\n                return r;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    equals(other) {\r\n        if (other.type === this.type) {\r\n            if (this.expr.length !== other.expr.length) {\r\n                return false;\r\n            }\r\n            for (let i = 0, len = this.expr.length; i < len; i++) {\r\n                if (!this.expr[i].equals(other.expr[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    evaluate(context) {\r\n        for (let i = 0, len = this.expr.length; i < len; i++) {\r\n            if (this.expr[i].evaluate(context)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    static _normalizeArr(arr) {\r\n        let expr = [];\r\n        let hasFalse = false;\r\n        if (arr) {\r\n            for (let i = 0, len = arr.length; i < len; i++) {\r\n                const e = arr[i];\r\n                if (!e) {\r\n                    continue;\r\n                }\r\n                if (e.type === 0 /* False */) {\r\n                    // anything || false ==> anything\r\n                    hasFalse = true;\r\n                    continue;\r\n                }\r\n                if (e.type === 1 /* True */) {\r\n                    // anything || true ==> true\r\n                    return [ContextKeyTrueExpr.INSTANCE];\r\n                }\r\n                if (e.type === 9 /* Or */) {\r\n                    expr = expr.concat(e.expr);\r\n                    continue;\r\n                }\r\n                expr.push(e);\r\n            }\r\n            if (expr.length === 0 && hasFalse) {\r\n                return [ContextKeyFalseExpr.INSTANCE];\r\n            }\r\n            expr.sort(cmp);\r\n        }\r\n        return expr;\r\n    }\r\n    serialize() {\r\n        return this.expr.map(e => e.serialize()).join(' || ');\r\n    }\r\n    keys() {\r\n        const result = [];\r\n        for (let expr of this.expr) {\r\n            result.push(...expr.keys());\r\n        }\r\n        return result;\r\n    }\r\n    negate() {\r\n        let result = [];\r\n        for (let expr of this.expr) {\r\n            result.push(expr.negate());\r\n        }\r\n        const terminals = (node) => {\r\n            if (node.type === 9 /* Or */) {\r\n                return node.expr;\r\n            }\r\n            return [node];\r\n        };\r\n        // We don't support parens, so here we distribute the AND over the OR terminals\r\n        // We always take the first 2 AND pairs and distribute them\r\n        while (result.length > 1) {\r\n            const LEFT = result.shift();\r\n            const RIGHT = result.shift();\r\n            const all = [];\r\n            for (const left of terminals(LEFT)) {\r\n                for (const right of terminals(RIGHT)) {\r\n                    all.push(ContextKeyExpr.and(left, right));\r\n                }\r\n            }\r\n            result.unshift(ContextKeyExpr.or(...all));\r\n        }\r\n        return result[0];\r\n    }\r\n}\r\nexport class RawContextKey extends ContextKeyDefinedExpr {\r\n    constructor(key, defaultValue) {\r\n        super(key);\r\n        this._defaultValue = defaultValue;\r\n    }\r\n    bindTo(target) {\r\n        return target.createKey(this.key, this._defaultValue);\r\n    }\r\n    getValue(target) {\r\n        return target.getContextKeyValue(this.key);\r\n    }\r\n    toNegated() {\r\n        return ContextKeyExpr.not(this.key);\r\n    }\r\n    isEqualTo(value) {\r\n        return ContextKeyExpr.equals(this.key, value);\r\n    }\r\n}\r\nexport const IContextKeyService = createDecorator('contextKeyService');\r\nexport const SET_CONTEXT_COMMAND_ID = 'setContext';\r\nfunction cmp1(key1, key2) {\r\n    if (key1 < key2) {\r\n        return -1;\r\n    }\r\n    if (key1 > key2) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nfunction cmp2(key1, value1, key2, value2) {\r\n    if (key1 < key2) {\r\n        return -1;\r\n    }\r\n    if (key1 > key2) {\r\n        return 1;\r\n    }\r\n    if (value1 < value2) {\r\n        return -1;\r\n    }\r\n    if (value1 > value2) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}